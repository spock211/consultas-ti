Marca tipo placa mae rede bluetooth debian
lspci -knn | grep Net -A2; lsusb

-------------------------------------------------------------------------------------------
Projetor Epson wifi

Aplicativo Epson iProjection para Chromebook
chromebook https://epson.com.br/Support/wa00813

EasyMP Network Projection v2.84
https://epson.com.br/Support/wa00682a

-------------------------------------------------------------------------------------------

chaveiro google chrome senha password
apt install seahorse

-------------------------------------------------------------------------------------------
Problemas do windows 10

Comandos windows 10 pelo cmd terminal
Painel de controle %Windir%\System32\control.exe

cmd como adm:

sfc /scannow
dism /online /cleanup-image /restorehealth
chkdsk /f /r /b

shutdown -s -t 0


Reiniciar
shutdown /r

Iniciar e configurar o Servidor OpenSSH
Para iniciar e configurar o servidor OpenSSH para uso inicial, abra o PowerShell como administrador e execute os seguintes comandos para iniciar o sshd service:

PowerShell

Copiar
# Start the sshd service
Start-Service sshd

# OPTIONAL but recommended:
Set-Service -Name sshd -StartupType 'Automatic'

# Confirm the Firewall rule is configured. It should be created automatically by setup. Run the following to verify
if (!(Get-NetFirewallRule -Name "OpenSSH-Server-In-TCP" -ErrorAction SilentlyContinue | Select-Object Name, Enabled)) {
    Write-Output "Firewall Rule 'OpenSSH-Server-In-TCP' does not exist, creating it..."
    New-NetFirewallRule -Name 'OpenSSH-Server-In-TCP' -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22
} else {
    Write-Output "Firewall rule 'OpenSSH-Server-In-TCP' has been created and exists."
}


Comando DISM.exe /Online /Cleanup-image /RestorehealthRestorehealth
Recentemente, eu usei o comando DISM.exe /Online /Cleanup-image /Restorehealth no Windows 10 e reiniciei. Logo após, não consigo mais acessar as configurações, nem mesmo desligar ou reiniciar pelo "iniciar". O que eu deveria fazer?

 Esta conversa está bloqueada. Você pode acompanhar a pergunta ou votar, mas não pode responder a esta conversa.
 Tenho a mesma pergunta (5) Relatar abuso
Respostas (1) 
Simone Borges CCO
Simone Borges CCO
Agente da Microsoft | Moderador
Respondido em maio 16, 2021
Relatar abuso
Olá Liliane.#, tudo bem?

Seja bem-vinda à Comunidade Microsoft.

Sinto muito por estar enfrentando esse problema, imagino o quanto deve estar lhe impactando, mas fique tranquila, pois darei o meu melhor para tentar resolver este cenário.


Para ser mais assertiva na solução desta questão, preciso saber:


Qual a versão e edição do Windows 10? (Para localizar estas informações, pressione as teclas do Windows + R, digite Winver e clique em Ok);

Qual o modelo e fabricante do seu computador? (Para localizar, pressione as teclas do Windows + R e digite: Msinfo32 e clique em Ok).


Mesmo sem essas informações, eu quero te ajudar!

O comando Dism /Online /Cleanup-Image /RestoreHealth irá verificar quais os arquivos que estão corrompidos e substituí-los por versões em bom estado, ou seja, não deveria apresentar este comportamento que você relatou. Neste caso, pode ter ocorrido outro problema.

Execute os procedimentos abaixo e me informe dos resultados, por favor.

1º Passo - Inicialização limpa.

A inicialização limpa serve para que possa determinar se um programa em segundo plano está interferindo no sistema.

1. Pressione as teclas Windows + R, digite MSconfig e clique em Ok;

2. Na janela Configuração do Sistema clique na aba Serviços (1);

3. Na parte inferior da tela marque a caixa Ocultar todos os Serviços Microsoft (2) e clique Desativar tudo (3);

4. Agora clique na aba Inicialização de Programas e clique em Abrir Gerenciador de tarefas;

5. Na janela gerenciadora de tarefas na aba Inicializar, desabilite todos os programas que não são Microsoft, feche o Gerenciador de tarefas e clique Ok em Configuração do sistema e reinicie o computador se solicitado.

Imagem

NOTA: Este procedimento desabilita todos serviços e programas de terceiros. Você pode posteriormente, se o problema for solucionado desta forma, habilitar os programas e serviços que serão inicializados com o Windows, seletivamente, ao invés de manter todos desativados. Se o problema voltar após ativação da inicialização de um serviço ou programa em especifico, o problema está exatamente na inicialização deste software e é recomendável removê-lo.

Caso exista algum firewall ou antivírus de terceiros, tente desativar ou até mesmo remover o software para testar se pode ou não estar interferindo e se mesmo assim o comportamento continuar, execute o próximo passo.

2º Passo - Powershell.

1. Pressione as teclas Ctrl + Shift + ESC, clique em Arquivo;

2. Clique em Executar nova tarefa;

3. Marque a opção Criar essa tarefa com privilégios administrativos;

4. No campo abrir digite powershell, em seguida clique em OK;

5. Execute o seguinte comando:

Get-AppXPackage -AllUsers |Where-Object {$_.InstallLocation -like "*SystemApps*"} | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register "$($_.InstallLocation)\AppXManifest.xml"}

6. Ao concluir reinicie o computador.

3º Passo - Crie um novo usuário.

1. Pressione as teclas Windows + Q;
2. Digite CMD e clique com o botão direito do mouse em Executar como Administrador;

3. No Prompt de Comando digite ou copie e cole os comandos e pressione ENTER ao final de cada linha:

net user teste /add

net localgroup administrators teste /add

4. Pressione as teclas Windows + L, efetue o login no novo usuário. Verifique se nesse novo perfil o mesmo acontece.

Observação: Se o comportamento não ocorrer neste usuário você poderá migrar os seus dados do outro usuário para este. Para migrar seus dados ao novo usuário, pressione as teclas Windows + R, digite %systemdrive%\users, procure seu usuário anterior e cole seus documentos no novo perfil.

4º Passo - Reinstalar o Windows 10.

Este seria para o caso que nenhuma das opções acima surtirem efeito.

Acesse o link a seguir e Reinstale o Windows 10 mantendo mantendo os dados pessoais na pasta Windows. old.

Nota importante: Como você tem acesso ao sistema, pule para a etapa 11 do link informado.

Caso enfrente alguma dificuldade, antes de clicar em Não, por favor, poste com as informações solicitadas e logo criarei um plano de ação com base no seu retorno.

Segue um link que poderá lhe auxiliar Usar a Ferramenta de Captura para obter capturas de tela.

Ou, se as informações são suficientes, por favor, mantenha-se logado(a) com sua conta e clique em Sim e marque-a como Resposta, para ajudar outras pessoas com a mesma dificuldade.


Estou torcendo para que tudo se resolva logo!

Aguardo novidades e até breve!

: D

Simone Borges
Moderadora da Comunidade
 


------------------------------------------------------------------------------------------------------------------------------------------------------
Primeira Revolução Industrial (1760-1840) – foi quando a Inglaterra desenvolveu a máquina a vapor, que deu impulso ao início da industrialização.
Segunda Revolução Industrial (1806 a 1945) – foi uma época de progresso nas industrias: química, de petróleo, elétrica e de aço.
Terceira Revolução Industrial (1950 a 2000) – foi o período após a segunda guerra mundial; surge a Internet.
Quarta Revolução Industrial (hoje) – indústria 4.0.
------------------------------------------------------------------------------------------------------------------------------------------------------
Uninter Aula - 2 - ANÁLISE DE SISTEMAS
      Profª Adriana Bastos da Costa

https://univirtus.uninter.com/ava/web/roa/           1/13
-----------------------Page 1 End-----------------------

13/10/2022 14:20                            UNINTER

CONVERSA INICIAL

Os estudos em análise de sistemas são fundamentais para todo profissional que deseja desenvolver um
software, pois é a disciplina que permite ao aluno traduzir, por meio de modelos e
documentação específica, as necessidades de negócio do cliente em um projeto
técnico de software. É a disciplina que apresenta a necessidade de planejar
tecnicamente um software antes de sua codificação, para que os objetivos de
negócio do cliente sejam atendidos.

Analisar, projetar e desenvolver um software são atividades complexas que envolvem as necessidades
dos clientes, regras de negócios e tecnologia, por isso, precisam ser muito bem planejadas e
estrategicamente pensadas para que sejam o mais eficientes possível na solução do problema
pretendido. Não basta atender aos requisitos de negócio, é preciso ter um processamento rápido
e eficiente.

Nesta aula, vamos conhecer o que é a análise estruturada, como ela surgiu e como um software pode
ser projetado seguindo seus preceitos. Também vamos conhecer o que é um Diagrama de Fluxo de Dados
(DFD) e descobrir como ele ajuda a analisar o funcionamento de um software.

Esta aula está organizada em cinco grandes temas, sendo eles: 

1 – Análise de Sistemas – a história;
2 – Análise Estruturada; 
3 – Diagrama de Fluxo de Dados (DFD);
4 – Níveis de um DFD;
5 – Analisando um exemplo de DFD.

TEMA 1 – ANÁLISE DE SISTEMAS – A HISTÓRIA

      No século XX, vivemos o que se
chamou de Era da Informação. Mas esse movimento ainda não parou, pois continuamos
vivendo nessa era, e cada
vez mais a informação está presente em todos os
pontos da nossa vida. A informação flui com velocidade cada vez maior e em
volumes espantosos.

      Estamos cercados por informações,
fazendo uso delas o tempo todo nos nossos estudos, no nosso trabalho e até
mesmo na vida social. É preciso
criar mecanismos para processar o grande volume
de informações que recebemos diariamente, separando o que é útil do que não nos
ajuda em nada.

      O mesmo ocorre nas
organizações. Há informações sobre clientes, sobre o mercado e sobre os
concorrentes que estão o tempo todo influenciando a
nossa tomada de decisão. As
 melhores decisões são tomadas baseadas em informações, mas como separar as
 informações úteis das informações
irrelevantes para o negócio? As informações
corretas e relevantes são fontes de poder, uma vez que permitem analisar fatores
do passado, compreender
o presente e, principalmente, prever o futuro.

Os sistemas de informação computacionais surgiram com o objetivo de ajudar as empresas a 
organizarem suas informações. Eles surgiram de maneira simples, atendendo a poucas áreas da
empresa, e evoluíram bastante, chegando até a incorporar BI (Business Intelligence) e inteligência
artificial como forma de aprimorar o processamento do grande volume de informações que as empresas
utilizam diariamente no seu processo de  tomada de decisão, aumentando o desempenho financeiro e 
participação no mercado, que são alguns dos principais objetivos de toda empresa com fins 
lucrativos.

      A Tecnologia da Informação
(TI) é composta por um conjunto de recursos de hardware e de software dedicados
ao armazenamento, processamento e
utilização da informação. Além disso, a TI
define a maneira como os recursos de hardware e software estão organizados num
sistema capaz de executar
um conjunto de tarefas para manter e evoluir o
negócio.

      Com o uso cada vez mais
intenso dos sistemas computacionais e com a evolução constante da tecnologia,
foi necessário estruturar a construção de
software, definindo padrões e
metodologias que pudessem organizar e atender à complexidade crescente dos
softwares solicitados pelos clientes. É fato
que indivíduos, empresas e
sociedade com um todo dependem dos sistemas de software avançados.

      Dessa forma, a análise de
sistemas surgiu e foi definindo formas mais efetivas de desenvolver softwares.
É necessário criar sistemas confiáveis, com
custo adequado e de forma a atender
à velocidade das demandas dos indivíduos e das empresas.

1.1 ANÁLISE DE SISTEMAS

      A análise de sistemas tem
como finalidade a realização de estudos de processos a fim de encontrar o
melhor caminho lógico para que a informação
possa ser processada. Segundo

*************************************************************************************************
Pressman (2016), a análise de sistemas é uma prática baseada em modelos, com o objetivo de obter
um melhor entendimento da entidade real a ser construída.
*************************************************************************************************

https://univirtus.uninter.com/ava/web/roa/           2/13
-----------------------Page 2 End-----------------------

13/10/2022 14:20                            UNINTER

O modelo precisa representar a entidade física, como aluno, cliente e venda, bem como representar
a informação referente às entidades físicas que o software precisa processar. O modelo também
precisa representar a arquitetura e as funcionalidades que o software precisa entregar.

A modelagem do software precisa mostrar a solução a ser construída em diferentes níveis de
abstração. 

Ou seja, é preciso mostrar o software:

1. do ponto de vista dos clientes
2. do ponto de vista técnico, de forma a permitir a análise da viabilidade de implementação dos
requisitos de negócio.

Para representar os dois níveis de abstração, são usadas duas classes de modelos. Os modelos
de análise representam os requisitos do software, mostrando três domínios diferentes,
sendo eles: 

1. o domínio das informações que precisam ser tratadas; 
2. o domínio das funcionalidades a serem atendidas;
3. o domínio comportamental que deve ser seguido. 

Os modelos de projetos representam as características que ajudam tecnicamente a entender o
funcionamento do software, sendo elas: a arquitetura; a interface do usuário ou camada visual do
software; e os detalhes no nível de componentes, que é a camada física relacionada com a construção
efetiva do software.

Ao longo do tempo, um grande número de métodos de modelagem de análise foi definido e utilizado.
Cada um dos métodos de análise possui um ponto de vista único, com foco e objetivospróprios. 
Mas todos os métodos encontrados na literatura possuem princípios claros e relacionados, 
sendo eles:

O domínio de informação relacionado com o software a ser construído precisa ser representado
e entendido. Esse domínio envolve os dados que transitam dentro do sistema e para fora do sistema
como resultado do que é processado pelo software.

Os dados usados dentro do sistema podem vir de usuários finais, de outros sistemas ou de
dispositivos externos. Os dados que são repassados para fora do sistema podem fluir por meio de
interface do usuário, de interfaces de rede, de relatórios gerados, gráficos ou outros meios
que mostrem o produto ou serviço final, objeto do software;

As funcionalidades a serem desenvolvidas pelo software devem ser detalhadamente definidas.
As funções podem ser descritas em diferentes níveis de abstração, que podem ser uma simples
declaração geral de objetivos ou um documento com o detalhamento dos elementos de processamento
que precisam ser utilizados;

O comportamento do software precisa ser representado e deve ser guiado pelas
interações com o ambiente externo, pelo contexto de negócio no qual o cliente
está inserido e pelo uso que o usuário dará para o software. O comportamento
esperado para o software em termos de tempo de resposta e usabilidade, bem como
seus critérios de qualidade, devem estar claros e documentados;

Os modelos que mostram informações, funcionalidade e comportamento devem ser
particionados de modo que revelem os detalhes em forma de camadas. Isso é
importante porque problemas complexos são difíceis de serem analisados e
resolvidos como um todo. Um problema complexo ou grande é dividido em partes
menores de forma que seja mais fácil de ser entendido e solucionado. Esse
conceito é chamado de **particionamento** e consiste em uma estratégia-chave na
modelagem de análise. Os modelos se integram até mostrar a solução completa do
problema como um todo;

A tarefa de análise deve ir da informação essencial para o software até os
detalhes de implementação do mesmo. A modelagem de análise começa
descrevendo o problema na perspectiva do usuário final, que é quem realmente
vai usar o software. O ponto principal do problema é descrito ainda sem se preocupar
com a solução de software que será implementada. O foco aqui ainda é entender o problema
do cliente. 

**Essa é a essência pura e simples do problema.**

Já o modelo de projeto foca nos detalhes de implementação da solução que vai resolver o
problema, ou seja, o modelo de projeto indica como a essência, que foi modelada
no modelo de análise, será implementada.

A evolução da análise de sistemas propôs três grandes métodos de modelagem de sistemas,
sendo eles:

1. Modelagem estruturada.
2. Modelagem essencial.
3. Modelagem orientada a objetos.

A análise estruturada está fundamentada na decomposição funcional do problema, ou seja,
foca de forma principal nas funcionalidades que o softwaredeve entregar. 
A modelagem estruturada utiliza um conjunto de ferramentas para organizar a visão de análise
do problema, sendo o Diagrama de Fluxo de Dados (DFD) e o Dicionário de Dados (DD) 
as principais ferramentas.

A análise essencial é considerada uma evolução da análise estruturada, mas com diferenças
essenciais da decomposição do problema. Ela se utiliza das mesmas ferramentas de modelagem da
análise estruturada, mas, em vez de uma decomposição do mais geral para o mais
específico (top-down), o método prevê que sejam identificados, inicialmente, os eventos externos
que acionam o software, sendo derivadas, então, as ações (ou funções) em resposta a esses eventos
e, posteriormente, os eventos gerados internamente e também as respectivas ações.

A análise orientada a objetos procura compreender o problema a ser resolvido por meio de
simples objetos do mundo real. Objeto é uma entidade real ou abstrata que modela
um conceito presente na  realidade humana, ocupando espaço físico ou lógico. Por exemplo,
um produto é um objeto com informações e características próprias. Um produto pode ter um
código que o identifique, um nome, um peso, dimensões e outras características que
façam sentido para o foco que o sistema quer dar ao objeto. Um objeto pode também ser algo
não físico, como uma venda ou mesmo uma data de realização,produtos comprados, valor de venda,
identificação do cliente, e outras características que estejam relacionadas ao objetivo dos requisitos.

https://univirtus.uninter.com/ava/web/roa/                                                                                           3/13
-----------------------Page 3 End-----------------------

13/10/2022 14:20                            UNINTER

1.2 O ANALISTA DE SISTEMAS

TI é uma área muito ampla, com  oportunidade para profissionais se especializarem em 
vários assuntos diferentes. É possível atuar no desenvolvimento de software como desenvolvedor,
como analista de requisitos, como arquiteto de softwares, como DBA, como engenheiro de software,
como cientista de dados, como analista de sistemas e muitas outras especializações.

Um dos objetivos desta aula é discutirmos um pouco sobre o papel e as responsabilidades de
um analista de sistemas.

Os analistas de sistemas estudam como o comportamento e as funcionalidades do software serão
desenvolvidos por meio dos requisitos,transformando-se em soluções que serão padronizadas
e transcritas da forma que o computador possa executar.

Os analistas de sistemas projetam softwares, que são executados em hardwares e são operados 
por usuários.

Portanto, eles precisam traduzir a linguagem dos negócios em linguagem técnica,
que vai se transformar em linhas de código pelas mãos dos programadores. Dessa
forma, o analista de sistemas é o profissional que, por meio do trabalho do
analista de requisitos, projeta uma solução, baseada na arquitetura definida
pelo arquiteto de software, gerando modelos e documentos que serão utilizados
pelos programadores na construção do software.

Os analistas precisam estar preparados e treinados em procedimentos operacionais padronizados
e dotados de conhecimentos necessários para executar seu trabalho. A análise de sistemas é
uma profissão cujas responsabilidades concentram-se na análise dos sistemas a serem desenvolvidos
e na administração de sistemas computacionais já em uso.

TEMA 2 – ANÁLISE ESTRUTURADA

A análise estruturada de sistemas é composta por um conjunto de técnicas e ferramentas que
continuam em constante evolução, apesar de ser um método mais antigo de se fazer análise de
sistemas.

O objetivo principal da análise estruturada é a construção de um modelo lógico e não de um
modelo físico de sistema. Ou seja, a análise estruturada busca compreender a lógica
por trás de cada funcionalidade que precisa ser desenvolvida no software. Como toda modelagem,
a análise estruturada também utiliza técnicas gráficas. Os modelos produzidos precisam ser
capazes de levar usuários, analistas e projetistas a formarem um quadro claro e geral do
sistema e de como suas partes se encaixam para atender às necessidades do cliente.

A análise estruturada tem como objetivo fornecer uma abordagem sistemática, etapa por etapa,
para desenvolver a análise e produzir uma especificação de sistema adequada para resolver o
problema do cliente. Para conseguir esse objetivo, a análise estruturada busca
uma comunicação clara, direta e concisa. A especificação do sistema é o elo entre a análise e
o projeto, e fornece uma descrição dos requisitos do sistema a ser construído.

O principal objetivo da análise é produzir uma especificação do sistema que defina a estrutura
do problema a ser resolvido de acordo com a visão do usuário e em uma linguagem que possa ser
entendida pela equipe técnica. O objetivo do projeto é definir a estrutura do problema com os
requisitos do usuário, estruturando a implementação que será dada para a solução.

Os defensores da análise estruturada afirmam que o uso do mesmo método de construção para a
especificação e para o projeto obriga os dois a ficarem mais coesos e a, provavelmente, 
representarem um sistema que satisfará às necessidades e expectativas do usuário. Por isso,
mesmo sendo um método mais antigo, a análise estruturada ainda é encontrada, principalmente
em empresas que possuem sistemas legados, que precisam ser mantidos e evoluídos.

A especificação baseada na análise estruturada é composta de diagrama de fluxo de dados (DFD),
de dicionário de dados (DD) e de especificações dos processos.

Antes do desenvolvimento dessas ferramentas de Análise Estruturada de Sistemas, todos os
detalhes da implementação física eram perdidos ou não eram pensados antecipadamente, o que
gerava uma grande falha de entendimento.

2.1 A EVOLUÇÃO DA ANÁLISE ESTRUTURADA

Até o final da década de 1970, os requisitos de um software eram documentados apenas por meio
de uma narrativa em português, gerando, muitas vezes, um entendimento equivocado da real
necessidade do usuário. A linguagem usada em conversas normais de dia a dia não é adequada
para o detalhamento de requisitos, pois pode não ser clara e gerar inconsistência de entendimento.
Por isso, é importante agregar diagramas ou qualquer outra ferramenta que mostre, de maneira
gráfica e visual, o entendimento sobre o funcionamento dos requisitos.

https://univirtus.uninter.com/ava/web/roa/                                                                           4/13
-----------------------Page 4 End-----------------------

13/10/2022 14:20                            UNINTER

Desde os primeiros autores que discutiram sobre análise estruturada, o método continuou evoluindo.
Após a aplicação do método em alguns projetos de software, foram identificadas algumas
alterações necessárias para a melhoria das técnicas e ferramentas. A seguir, algumas 
das principais melhorias:

Evitar a construção de modelos "físicos" e "lógicos" do sistema atual, pois o foco é a 
construção do novo sistema. Logo, se gasta muito tempo, vai ser descontinuado. 
Essa prática deveria ser trocada pela prática de modelagemde processos de negócio, 
e por meio desse fluxo de processos, trabalhar na análise lógica do novo sistema;

A distinção vaga entre os modelos lógico e físico é dependente da tecnologia. É
preciso entender completamente a diferença entre os dois modelos. 

**O modelo lógico é o modelo essencial que ajuda a entender a essência do sistema.

**O modelo físico é o modelo que se preocupa com a implementação, pois considera os aspectos
tecnológicos do software;

Carência de técnicas de modelos para construir sistemas de tempo real, ou seja, sistemas
que mostrem o funcionamento do software no momento em que o processamento
ocorre. 

Para resolver essa falha, foi definido e passou a ser utilizado na análise de software
o Diagrama de Transição de Estado (DTE);

Percebeu-se também a necessidade de modelar as estruturas de dados dos sistemas, como forma
de compreender o relacionamento entre elas. Com isso, começou-se a utilizar Diagramas
de Entidades-Relacionamentos (DER), que focam no relacionamento entre as diferentes
entidades que compõem um sistema e em como os dados fluem por meio delas;

Com a introdução de vários diagramas, além dos diagramas já utilizados na análise
de sistema, era necessário buscar uma forma de melhor integrar
todas essas ferramentas.

É importante ressaltar que cada diagrama tem um objetivo a cumprir, e a junção
coerente e integrada de todos geram umanvisão mais completa do software que se
quer construir.

2.2 BENEFÍCIOS E PROBLEMAS

Como todo método, a análise estruturada foi pensada para atender a um conjunto de necessidades,
mas não poderá ser aplicada a toda situação de software por ter uma visão focada no fluxo de
dados que transitam do software e para o software.

Por isso, é preciso conhecer diferentes métodos para aplicar o que melhor agrega valor ao 
contexto de software em questão. O importante é que o problema a ser resolvido fique claro
para a equipe de desenvolvimento.

Vários benefícios podem ser identificados quando a análise estruturada é utilizada, tais como:

Os usuários conseguem ter uma ideia mais clara do sistema proposto com o uso do diagrama
de fluxo de dados em comparação ao obtido por meio apenas de narrativa e de fluxograma
de sistemas físicos;
       
A apresentação dos requisitos em termos de fluxo lógico consegue mostrar mal-entendidos
e pontos controversos, minimizando problemas em estágios mais avançados da construção do
software;

As interfaces entre o novo sistema e outros sistemas já existentes são mostrados de modo bem
mais claro, facilitando a compreensão da comunicação entre eles;
       
O uso de dicionário de dados para guardar os itens do glossário do projeto economiza tempo ao
resolver rapidamente os casos em que pessoas chamam as mesmas coisas por diferentes nomes,
além de criar um padrão de nomenclatura que ajuda na qualidade de construção do software.

Alguns problemas também podem ser encontrados ao se utilizar análise de estrutura para modelar
um software, principalmente quando o software é complexo e precisa de outras visões para ser
mais bem compreendido e projetado. Vamos discutir alguns dos problemas que podem ser
identificados, tais como:

O esforço, a formalidade e o grau de detalhe necessários, especialmente na
construção do dicionário de dados, muitas vezes, geram resistência por parte
dos analistas de sistemas. Mas é importante reforçar que toda documentação de
software deve agregar valor ao entendimento do problema, por isso deve ser focada
no que é principal e essencial para o correto entendimento. E toda documentação 
deve ser mantida, ou seja, deve evoluir junto com as modificações
nos requisitos do software. Uma documentação desatualizada pode ser fonte de
confusão e desinformação em um projeto;

Tem havido uma certa preocupação por parte dos programadores de que ao obterem
especificações detalhadas da lógica no português estruturado, acabarão 
“retirando todo o prazer da programação, tornando-os meros codificadores”, mas
é preciso lembrar que existem programadores inexperientes que precisam de maior
ajuda para desenvolver seu trabalho com maior qualidade;


Orientação dos usuários e treinamento dos analistas são necessários, pois, com a
introdução da análise estruturada, foram mudadas as “regras do jogo”, e todos
devem ser bem esclarecidos quanto às novas regras e à maneira como elas
melhoram o jogo. Como a análise era feita anteriormente apenas com uma
descrição dos requisitos, agora é preciso “aprender” a ler o diagrama. Mas a
linguagem usada no DFD é tão simples que esse aprendizado não é um problema
para a utilização do método.

TEMA 3 – DIAGRAMA DE FLUXO DE DADOS (DFD)

O DFD é uma das ferramentas mais utilizadas na análise estruturada como forma de compreender e analisar o
fluxo de dados dentro do próprio sistema e o fluxo entre o mundo exterior com osistema. Quando falamos do 
fluxo exterior, precisamos detalhar tanto os dados que entram no sistema quanto os que saem do sistema.

O DFD possui uma representação em rede que mostra as funcionalidades que o sistema deve entregar e os dados
que interligam essas funcionalidades. O objetivo principal do diagrama de fluxo de dados é mostrar o que o
sistema faz e não como será feita a solução em desenvolvimento. Isso ocorre porque é o momento de análise,
e não de projeto, no ciclo de vida do desenvolvimento.

**Outro ponto interessante a ressaltar é que o DFD mostra a lógica das funcionalidades e não a parte física
da sua implementação, exatamente porque foca na análise, e não no projeto.**

A criação de um DFD envolve os seguintes pontos:

1. Escolha de nomes significativos para os seus componentes, de forma a facilitar o
entendimento sobre o DFD e o que ele faz;

2. Numerar os processos, para facilitar a referência a eles em uma documentação escrita;
       
3. Criar o diagrama e ajustá-lo visando uma boa estética e comunicação adequada. Evitar
DFD muito complexo. Um diagrama é uma ferramenta gráfica, portanto, o visual bem organizado
é fundamental para a compreensão do todo;
   
4. Caso necessário, utilizar o particionamento em níveis, ou seja, quebrar o detalhamento em níveis
de aprofundamento maiores. É mais fácil entender o todo por meio de partes menores. Mas é
importante se certificar de que os diferentes níveis de entendimento gerados são consistentes
internamente e também consistentes com os demais níveis relacionados.

O diagrama é composto por vários elementos ou componentes, chamados de processos, fluxos de dados, depósitos
de dados e entidades. Arepresentação gráfica de cada componente pode sofrer pequenas diferenças, dependendo
do autor e do livro que se estiver seguindo. Os principais estudiosos sobre o método são Chris Gane, Trish Sarson,
Tom DeMarco e Edward Yourdon.

Vamos analisar cada componente e entender a função de cada um no diagrama.

3.1 PROCESSOS

O primeiro componente a ser analisado é o processo, pois ele é o coração do DFD. Ele mostra as
funcionalidades ou processos que o software deve executar. Processos também são conhecidos como
bolha, função ou transformação, pois representam as transformações de fluxos de dados de entrada
em fluxos de dados de saída. Por proporcionar uma  transformação, geralmente, o processo provoca
mudanças de estrutura, conteúdo ou estado dos dados.

Para ficar intuitivo e mais fácil de ser compreendido, o nome do processo deve descrever o que ele faz.
Quando o nome de um processo é claro e direto, todos os envolvidos no desenvolvimento do software
conseguem compreender a que o DFD se refere e o que o software deve fazer.

Fazendo uma analogia: andar, caminhar e comer são processos ou ações, assim como “cadastrar cliente”,
“registrar o pedido do cliente” ou “emitir nota fiscal para o cliente”. Os processos ou ações são também 
entendidos como as funcionalidades que o software deve entregar para o cliente. Portanto, entender como
o fluxo de dados ocorre nesses processos é fundamental para entender o que o software deve fazer.

Em um DFD, os processos modelados podem ser manuais, como “arquivar uma pasta do cliente em um armário”,
ou automatizados, como “arquivar os dados do cliente”.

Como boa prática de análise de  sistemas, para representar processos, é interessante utilizar verbos, como
extrair, produzir, criar, armazenar, recuperar, calcular, verificar, classificar, entre outros, a fim de
demonstrar exatamente o que o processo irá executar.

Especificando ainda mais um processo, podemos nomear a que o processo se refere no contexto do software,
por exemplo, a um cliente, a um aluno, a um produto, ou qualquer outro objeto. Dessa forma, o nome de um
processo pode ser “Armazenar dados do cliente”, “Calcular média bimestral do aluno”, “Consultar dados do aluno” etc.

Um processo pode ter as seguintes representações gráficas:

Representações gráficas de processos

3.2 FLUXOS DE DADOS

Os fluxos de dados são os componentes capazes de interligar os processos. Eles representam caminhos pelos
quais passam os dados, sendo representados por meio de setas que indicam a origem e o destino do dado.

Podemos entender os fluxos de dados também como um “tubo” hipotético, mas não necessariamente físico, pelo
qual passam pacotes de dados.

É importante que o nome do fluxo de dado seja documentado no dicionário de dados sempre que essa documentação
facilitar o entendimento e o aprofundamento da análise. Tudo o que for documentado pode evitar mal-entendidos
e facilitar a evolução do processo de análise.

Quando um cliente faz um pedido, por exemplo, envia um fluxo de dados. Podemos chamar esse fluxo de Pedido,
que pode ser composto por: nome, CPF, nome do produto, código identificador do produto, descrição do produto,
valor do produto, entre tantas outras informações necessárias para processar as funcionalidades do software
relacionadas com Pedido. Cada fluxo deve ter um único nome, o qual deve identificar os dados transportados
pelo fluxo.

É preciso entender que, muitas vezes, um mesmo fragmento de dados pode ter significados diferentes em pontos
distintos de um DFD. É possível ter CPF-Válido e CPF-Inválido, Aluno-Aprovado e Aluno-Reprovado, por exemplo.
Perceba que o fluxo do dado mostra também o estado em que o dado se encontra, baseado no processo executado,
mas ele não modifica o dado durante o transporte, apenas movimenta o dado de um ponto para outro.

Os fluxos de dados transportam dados entre os componentes do DFD, ou seja, é possível encontrar fluxos de
dados movimentando dados: de processo processo, de entidade ⇔ processo e de depósito de dados ⇔ processo.

O DFD mostra todos os movimentos dos dados dentro e fora do software.

Os fluxos de dados podem ser classificados da seguinte forma:

1. Fluxo externo: entre entidade e processo. São chamados de externos, pois
envolvem não apenas processos, mas também outro componente do DFD;

2. Fluxo interno: entre dois processos;
       
3. Fluxo de acesso à memória: entre processo e depósito de dados;
       
4. Fluxo de erro ou rejeição: para fora de um Processo.

Um fluxo de dados pode ser representado por meio de setas, as quais podem estar direcionadas para a direita
e para a esquerda, ou, ainda, para cima e para baixo. A ponta da seta indica o destino, portanto, no diagrama,
deve-se observar a lógica da origem para o destino de cada fluxo de dado.

Um processo pode ter as seguintes representações gráficas:

                                                                                         Figura 2 –
Fluxo de dados

3.3 DEPÓSITO DE DADOS

Um depósito de dados representa uma coleção de pacotes de dados, mas não deve ser confundido com banco de dados,
pois possuem objetivos diferentes. Utilizar depósito de dados em um DFD é um
meio de se reter os dados que serão utilizados em outro momento pela mesma funcionalidade
ou por outras. Os depósitos de dados são simples meios de armazenamento de dados estocados, sem maiores preocupações
com suas características físicas, por isso, não podem ser confundidos com o banco de dados.

13/10/2022 14:20                                                   UNINTER

O depósito de dados representado em um DFD mostra a lógica e não a parte física do dado em si. Um
banco de dados seria exatamente a parte física, ou seja, representa o dado  fisicamente armazenado. 
O depósito de dados destina-se a informar aquilo que precisamos movimentar,
independentemente de ser um bando de dados em si. É possível representar em um DFD a movimentação
de dados partindo de um arquivo, por exemplo.

Seguindo o mesmo raciocínio, quando se tem um conjunto de clientes, os quais compram os produtos do nosso cliente,
precisamos guardar em algum lugar os dados de cada cliente para processá-lo. No âmbito do DFD, esse lugar é um
depósito de dados, que chamaremos de Clientes, por exemplo.

Se iremos guardar esses dados em um banco de dados físico ou apenas utilizá-los para um processamento e
descartá-los, isso é a implementação física do software, representada nos modelos de projeto.

O nome de um depósito de dados, como boa prática, deve sempre estar no plural, representando que, no
depósito, existem vários dados do mesmo contexto. Um depósito de cliente, por exemplo, deve se chamar
Clientes, pois o software vai processar dados de vários clientes.

As possíveis representações gráficas de um depósito de dados são:

Figura 3 – Depósito de dados

3.4 ENTIDADES

A entidades são categorias lógicas de “coisas” ou “pessoas”, as quais representam uma origem ou destino de
transações. Se compararmos com a orientação a objetos, as entidades funcionam de modo similar ao dos objetos,
pois representam parte do mundo real.
      
Também podem ser chamadas de Terminadores, por serem o ponto de partida ou de chegada de qualquer transação.
As entidades são as fontes ou os destinatários das informações que entram e saem
do sistema. As entidades também podem, além de representar “coisas” ou “pessoas”, representar um outro sistema,
se este outro sistema tiver interface com o sistema que está sendo modelado.

Seguindo as boas práticas de análise de sistemas, a nomenclatura utilizada nas entidades deve estar no
plural, devido ao mesmo motivo pelo qual é utilizado plural nos depósitos de dados, ou seja, para
representar um grupo de pessoas ou coisas. Normalmente, as entidades têm, intencionalmente, seu
nome escrito em maiúsculo, para diferenciá-las de possíveis depósitos de dados com o mesmo nome.

Quando a entidade representar um sistema externo, deve ser incluída a palavra sistema ao seu nome,
como sistema de contabilidade. Isso nos ajuda a entender com qual sistema o DFD está interagindo.

A representação gráfica de umaentidade é:

Figura 4 – Representação gráfica de entidade

TEMA 4 – NÍVEIS DE UM DFD

O DFD deve ser modelado em uma série de níveis, de modo que, a cada nível, ofereça sucessivamente mais
detalhes sobre uma parte do nível que lhe seja superior.

Muitas vezes, o DFD de um sistemamé algo não trivial, pois reflete a complexidade do problema que vai ser resolvido
por meio de um software. Como o objetivo é ajudar a analisar e a compreender o funcionamento dos requisitos
e das funcionalidades que devem ser implementas, é preciso montar diagramas com níveis diferentes do processo. 
Dessa forma, para evitar que tudo seja definido num único diagrama, que geralmente é difícil de ser entendido e mantido,
criam-se DFDs que detalham um processo de um nível mais alto para o mais baixo.

O principal objetivo de organizar o DFD em níveis é mostrar o diagrama de fluxo de dados do nível mais
macro até o nível mais detalhado. E qual é o limite de criação de níveis em um DFD? O limite é o correto
e o completo entendimento do problema. Ou seja, enquanto for necessário detalhar algum processo para ajudar
no desenvolvimento do software, deve ser criado mais um nível de DFD. Vamos entender cada um nos
principais níveis conhecidos e definidos em um DFD.

4.1 DFD DE CONTEXTO

Este é o DFD de nível mais alto, sendo o que dá a visão das principais funções do sistema. Ele é macro,
contendo um processo que representa o sistema como um todo, os principais fluxos  de dados e os agentes
externos, ou seja, os sistemas com os quais o sistema modelado faz interface, ou mesmo os diversos setores
da empresa que terão algum tipo de acesso ao sistema.

Ele é simples, porque não detalha nenhum dos processos do sistema, mas dá uma visão do todo e dos
principais relacionamentos.

Vamos analisar um exemplo de DFD de contexto.

Figura 5 – Sistema de vendas – exemplo de DFD de contexto

                                                                                             Crédito:
Costa, 2021.

O DFD do exemplo apresentado modela o sistema de vendas que é acionado pelo setor de vendas quando um pedido
é feito por um cliente. Quando o pedido é processado e faturado, o setor de  logística é acionado com a fatura,
para que separe e entregue os produtos comprados pelo cliente. O pagamento do pedido feito pelo cliente é feito
por outro sistema, o sistema financeiro, que recebe os dados de cobrança. E, por último, o setor de pós-
vendas recebe os dados do Pedido para fazer o atendimento ao cliente e verificar a satisfação com a compra, após ele ter
recebido os produtos comprados.

Veja que é uma visão de alto nível, mas que explica o objetivo do software, os principais dados trafegados e
as entidades mais importantes. Porém, esse nível de diagrama não permite entender os detalhes do funcionamento. Por isso, é preciso criar outros diagramas, nos níveis maiores de detalhe.

4.2 DFD DE NÍVEL ZERO

Após ter a visão macro do sistema, é preciso analisar os principais processos do software e colocar uma
lupa nos fluxos e nas entidades envolvidas nesses processos. Nesse nível de DFD, é possível encontrar detalhes
sobre as principais funcionalidades do software.

O DFD imediatamente abaixo do diagrama de contexto é conhecido como DFD de nível zero. Ele representa a visão
de mais alto nível das principais funções do sistema, bem como das principais interfaces entre essas funcionalidades.


Cada uma dessas bolhas, que representam os principais processos ou funcionalidades, deve ser numerada para
 fácil identificação e referência. Explicando com outras palavras, o DFD de nível zero contém as macrofunções do sistema.

Vamos analisar um exemplo de DFD de nível zero:

Figura 6 – Sistema de vendas – exemplo de DFD de nível zero

https://univirtus.uninter.com/ava/web/roa/           9/13
-----------------------Page 9 End-----------------------

13/10/2022 14:20                            UNINTER

                                                                                             Crédito:
Costa, 2021.

Como o exemplo ilustra um sistema de vendas, as principais funcionalidade são a criação e o processamento
de um pedido feito por um cliente. Dessa forma, os depósitos de dados  principais envolvidos com as
funcionalidades apresentadas são clientes e pedidos. Cliente é o que inicia todo o sistema com uma compra,
e pedido é o que é processado e faturado, pois é a razão de o sistema existir.

As entidades apresentadas neste nível de DFD mostram quais são os relacionamentos das principais
funcionalidades. Com esse nível de DFD, é possível criar um entendimento, mesmo que primário, sobre o
funcionamento do software. Por meio desse nível, ou dos níveis intermediários de DFD, é
possível detalhar ainda mais os fluxos dos dados, com base nas principais funcionalidades do sistema.

Para que seja possível realmente compreender toda a complexidade do software, é preciso evoluir no
detalhamento dos níveis do DFD.

4.3 DFD DE NÍVEIS INTERMEDIÁRIOS

Os DFDs de níveis intermediários são os diagramas que mostram a decomposição, ou seja, o
detalhamento ou explosão de cada processo de nível mais alto. Portanto, cada nível detalha
mais o nível imediatamente anterior.

A quantidade de níveis depende de fatores como complexidade e porte do sistema. Em geral, a decomposição em
níveis menores deve terminar quando for possível especificar o processo em uma página, ou quando o detalhamento
estiver suficiente para compreender toda a análise do sistema.

Vamos analisar um exemplo de
DFD de nível intermediário:

                                                                   Figura
7 – Sistema de vendas – DFD de nível intermediário

                                                                                             Crédito:
Costa, 2021.

No DFD de nível intermediário, é possível analisar o desdobramento da funcionalidade 2 – Processar Pedido, ou
seja, essa funcionalidade tem duas responsabilidades centrais: 2.1. Gerar Cobrança e 2.2. Gerar Fatura.

É importante perceber como a numeração dos processos ajuda na identificação do detalhamento. Nesse nível de
detalhamento, é possível entender logicamente como é o relacionamento do processo de Processar Pedido e seus subprocessos com as entidades e depósitos de dados principais.

TEMA 5 – ANALISANDO UM EXEMPLO DE DFD

Estamos chegando ao último tema desta aula e, como foi feito em outro momento de nossos estudos, vamos
analisar o que aprendemos por meio de um estudo de caso. Vamos analisar a construção
de um DFD na prática. O objetivo é apresentar como um DFD pode ser criado por
meio da descrição de
https://univirtus.uninter.com/ava/web/roa/           10/13
-----------------------Page 10 End-----------------------

13/10/2022 14:20                                                          UNINTER
um problema de um cliente. Atente-se aos detalhes e lembre-se de que vamos utilizar este estudo de caso em
todas as aulas da disciplina. Conforme explicado anteriormente, vamos evoluir com esse estudo de caso por todas as
etapas da análise de sistemas de um ciclo de desenvolvimento, construindo vários modelos que ajudem a projetar a
construção completa do software.

Relembrando o nosso estudo de caso:

Fomos contratados pelo nosso cliente para modelar o processo de vendas on-line de livros. O nosso
cliente tem uma livraria virtual, que vende produtos diretamente em um site próprio. O diferencial
desta livraria é ter um estoque próprio, o que garante uma entrega mais rápida a seus clientes, e
aceitar vários tipos de pagamento, como cartão de crédito, cartão de débito e boleto bancário.
A livraria possui um programa de fidelidade, que permite desconto de 10% aos clientes que comprarem
R$ 500,00 ou mais em 1 ano.

Vamos ao nosso estudo de caso, aplicando os conceitos de DFD aprendidos:

Figura 8 – Sistema da Livraria On-line – DFD de Contexto

Crédito: Costa, 2021.

Este DFD é o de mais alto nível, refletindo o sistema com uma visão macro e geral, mostrando as
principais entidades envolvidas e os dados que alimentam o sistema também de  forma macro. Dessa forma,
trata-se de uma visão lógica e de alto nível do que foi representado na modelagem de processos de
negócio, estudada anteriormente.

Vamos, agora, analisar o DFD de nível zero das principais funcionalidades.

                                                                     Figura 9 – Sistema da livraria on-line –
DFD de nível zero

                                                                                             Crédito: Costa, 2021.

O DFD de nível zero deste estudo de caso mostrou a principais funcionalidades do software, que, para o
contexto em questão, são: 1 – Carregar carrinho de compras (porque é o momento em que o cliente seleciona
os produtos e faz sua compra); e 2 – Processar Pagamento (pois é o momento em que o cliente realmente realiza
sua compra,fazendo o pagamento da mesma).

A principais entidades foram representadas, assim como os depósitos de dados que fazem o recebimento ou
entrega dos dados trafegados. Os fluxos de dados mostram logicamente a principal informação que é trafegada,
não dando detalhes de quais são essas informações. Esse detalhamento deve ocorrer em DFDs de níveis intermediários.

https://univirtus.uninter.com/ava/web/roa/                                                            11/13
-----------------------Page 11 End-----------------------

13/10/2022 14:20                            UNINTER

Lembrando que essa não é a única forma de criar o DFD para este estudo de caso. O DFD foi criado de acordo
com a visão do analista que o está construindo. Portanto, outras soluções podem ser dadas para o mesmo estudo de caso.
O importante é que o DFD seja completo e coerente com a visão lógica que se espera do software.

FINALIZANDO

Chegamos ao final desta aula. Esperamos  que os conceitos vistos tenham ficado claros. O mais importante é entender que uma
boa análise dos requisitos – com o objetivo de entender o que as funcionalidades do software realmente precisam fazer e como devem fazer – é fundamental para o sucesso do projeto.

A análise de estrutura utiliza ferramentas como o DFD (Diagrama de Fluxo de Dados) e o DD (Dicionário de Dados)
para detalhar a visão lógica das funcionalidades e mostrar como os dados fluem ao longo do processamento esperado para cada requisito.

É importante relembrar que objetivo de um DFD é mostrar de onde os dados surgem, para onde vão, quando são
armazenados e qual processo os transforma. Também é importante conhecer as interações entre armazenamento de dados
e processos. Essa visão é fundamental para se compreender o funcionamento e comportamento do software.

O grande benefício de se utilizar DFD na modelagem de um software é que a ferramenta é simples, permitindo a
avaliação do modelo junto aos usuários, o que permite identificar as falhas o mais cedo possível. Embora a análise
orientada a objetos seja a forma mais moderna de se modelar projetos de software, a análise estruturada ainda é
utilizada em alguns projetos, principalmente nos que usam programação estruturada, pois a visão é simples,
mas permite garantir o entendimento necessário dos requisitos de forma a construir uma boa solução para o cliente.

Nas próximas aulas, vamos estudar como documentar e gerenciar os requisitos do software, aprendendo o que
é um caso de uso e como descrevê-lo a fim de compará-lo às estórias de usuários.

REFERÊNCIAS

      BECKER, J.; ROSEMANN, M.; VON UTHMANN, C.
Guidelines of business process modeling. In: VAN DER
AALST, W.; DESEL, J.; OBERWEIS, A.
(Eds.). Business
Process Management. New York: Springer Berlin
Heidelberg, 2000. p. 30-49.

      COHN, M. User Stories Applied for Agile
Software Development. Assison-Wesley Professional. 2004.
      GANE, C.; SARSON, T. Análise Estruturada de Sistemas.
LTC. 1983.
      YOURDON, E. Análise Estruturada Moderna. Rio de Janeiro: Campus, 1990.
      LAPLANTE, P. A. Requirements engineering
for software and systems. Boca Raton: CRC Press, 2013.
      MALL, R. Fundamentals of software
engineering. New Delhi: PHI Learning, 2014.
      OGUNNAIKE, B. A.; RAY, W. H. Process
dynamics, modeling, and control. Oxford: Oxford University Press,
1994.
      PAIM, R. et al. Gestão de Processos: pensar, agir e aprender.
Porto Alegre: Bookman. 2009.
      PIZZA, W. R. A metodologia Business Process Management
 (BPM) e sua importância para as organizações. 36 f. Monografia (Curso de
Tecnologia em Processamento de Dados) – Faculdade de Tecnologia de São Paulo –
FATEC SP, São Paulo, 2012.
      PRESSMAN, R. S.; MAXIM, B. R. Engenharia de Software:
Uma Abordagem Profissional. Nova Iorque: Mc Graw Hill Educattion. 8. ed. 2016.
      ROSEMANN, M.; BROCKE, J. V.; HONORATO, B. Manual de BPM:
gestão de processos de negócio. Porto Alegre: Bookman, 2013.
      SILVER, B.; RICHARD, B. BPMN method and
style. v. 2. Aptos: Cody-Cassidy Press, 2009.
      WIEGERS, K.; BEATTY, J. Software
requirements. 3. ed. London: Pearson Education, 2013.

https://univirtus.uninter.com/ava/web/roa/           12/13
-----------------------Page 12 End-----------------------

13/10/2022 14:20                            UNINTER

https://univirtus.uninter.com/ava/web/roa/           13/13
-----------------------Page 13 End-----------------------


-------------------------------------------------------------------------------------

Abstração: a abstração consiste em se concentrar nos aspectos essenciais, próprios de uma entidade, e em se ignorar suas propriedades
acidentais, ou seja, dar foco a aspectos relevantes para um determinado propósito. Esse conceito é muito importante para simplificar os conceitos complexos.
--------------------------------------------------------------------------------------

winetricks
Update winetricks to the latest version by running

sudo winetricks --self-update
--------------------------------------------------------------------------------------

Banco de dados

MariaDB [sistema]> ALTER TABLE alunos MODIFY cod_aluno int PRIMARY KEY;
ALTER TABLE alunos MODIFY cod_aluno int AUTO_INCREMENT;

---------------------------------------------------------------------------------------
Mudar editor padrao do cron crontab
select-editor
-----------------------------------------------------------------------------------------------------------------------
Como testar memória RAM com o CMD? memoria teste
Para executar o Diagnóstico de Memória do Windows, você pode simplesmente pesquisar por memória no menu Iniciar do Windows ou então, digite CMD, na janela que abrir digite mdsched na caixa Executar e clique em “OK”
-----------------------------------------------------------------------------------------------------------------------
instalar modulos python
apt install pip
pip install "nome_do_modulo"

from pdf2docx import Converter
pdf_file = 'Line.pdf'
docx_file = 'Line.docx'
cv = Converter(pdf_file)
cv.convert(docx_file)
cv.close()

-----------------------------------------------------------------------------------------------------------------------
Modo seguro windows 10
Modo de segurança windows 10

Antes de entrar no modo de segurança, você precisa inserir o winRE (ambiente Windows de recuperação). Para fazer isso, você desativará repetidamente o dispositivo e, em seguida, ativará:

Mantenha pressionado o botão de energia por 10 segundos para desligar o dispositivo.

Pressione o botão de energia novamente para ligar o dispositivo.

Ao primeiro sinal de que o Windows foi iniciado (por exemplo, alguns dispositivos exibem o logotipo do fabricante ao reiniciar), mantenha o botão de energia pressionado por 10 segundos até desligar o dispositivo.

Pressione o botão de energia novamente para ligar o dispositivo.

Quando o Windows reiniciar, mantenha pressionado o botão de energia por 10 segundos para desligar o dispositivo.

Pressione o botão de energia novamente para ligar o dispositivo.

Permitir que o dispositivo reinicie completamente. Você entrará no winRE.

Agora que está no winRE, você seguirá estas etapas para entrar no modo de segurança:

Fonte: https://support.microsoft.com/pt-br/windows/inicie-o-computador-no-modo-de-seguran%C3%A7a-windows-92c27cff-db89-8644-1ce4-b3e5e56fe234
---------------------------------------------------
desativar reparo automatico windows 10
cmd como adm:

bcdedit /set recoveryenabled NO "ENTER" 
------------------------------------------------------
caminho de dados

O caminho de dados é a parte da CPU que contém a ULA, suas entradas e suas saídas. O coração de todo computador é o caminho
de dados. Pois ele contém alguns registradores, um, dois ou três barramentos e uma ou mais unidades funcionais como ULAs e
deslocadores – que tem como função principal buscar alguns operandos em registradores e enviá-los pelos barramentos à ULA e a
outras unidades funcionais para execução. Então os resultados são armazenados de volta nos registradores.
------------------------------------------------------
blau araujo

#processos
#Processos não são programas


#processo pai

#comandos e utilitarios para verificar os processos: 
less /proc/$PPID/status

fork

execute

Primeira forma:
ps -e | grep Xorg
1099 tty7     00:01:16 Xorg

Segunda forma:
pidof Xorg
1099
pstree 1099
Xorg───9*[{Xorg}]

pstree -p 1099

ps
top
htop

ps -ely | grep 'Ẑ' #Z de zumbi

-----------------------------------------
reiniciar rede restart rede 
systemctl restart networking
-------------------------------------
esqueci esqueceu comando linux
apropos

--------------------------------------------------------------------------------------------
python

Operadores de atalho

Chegou a hora do próximo conjunto de operadores que facilitam a vida de um programador.

Muito frequentemente, queremos utilizar uma e a mesma variável tanto para o lado direito como para o esquerdo do = operador.

Por exemplo, se precisarmos de calcular uma série de valores sucessivos de potências de 2, podemos utilizar uma peça como esta:

x = x * 2

Pode usar uma expressão como esta se não conseguir adormecer e estiver a tentar lidar com ela usando alguns métodos bons e antiquados:

sheep = sheep + 1

O Python oferece-lhe uma forma abreviada de escrever operações como estas, que podem ser codificadas como se segue:

x *= 2
sheep += 1

Vamos tentar apresentar uma descrição geral para estas operações.

Se op é um operador de dois argumentos (esta é uma condição muito importante) e o operador é utilizado no seguinte contexto:

variable = variable op expression

Pode ser simplificado e mostrado da seguinte forma:

variable op= expression

Dê uma vista de olhos nos exemplos abaixo. Certifique-se de que os compreende a todos.

i = i + 2 * j ⇒ i += 2 * j

var = var / 2 ⇒ var /= 2

rem = rem % 10 ⇒ rem %= 10

j = j - (i + var + rem) ⇒ j -= (i + var + rem)

x = x ** 2 ⇒ x **= 2




----------------------------------------------------------------
senha de app google	hcyzywuemjxoeovc
-----------------------------------------------------------------
editor vi como procurar e trocar 
search and replace

The search pattern has to be a complete word or else we will be dealing with the error below.

 :%s/\<lin\>/linear/gc 
 
 link "https://www.linuxshelltips.com/search-replace-text-vim-editor/
----------------------------------------------------------------
Gabarito 1 redes de computadores uninter

1)Na camada 2 do TCP/IP – camada inter-redes, são definidos os protocolos responsáveis por tratar da comunicação entre as redes, a saber:

IP, que trata o endereço lógico e faz o encaminhamento dos pacotes entre as redes.

2)Sobre os endereços IP utilizados para identificação da origem e destino das comunicações em rede com o protocolo TCP/IP, assinale a única alternativa correta:

O IPv6 é a versão mais atual do protocolo IP, e pode endereçar até 4.294.967.296 hosts.

3)As camadas são o resultado da divisão da complexa tarefa de comunicação de dados entre computadores através da aplicação de regras – os protocolos – ao hardware, firmware, software, sinais elétricos, óticos e eletromagnéticos. Cada camada trata de aspectos específicos do processo de comunicação, especializando-se em receber a informação da camada anterior, decodificar, tratar e em seguida repassar para a camada seguinte. Este processo funciona tanto na origem da comunicação como no seu destino, e cada camada trata as informações para executar suas tarefas e entregas às outras camadas um resultado. Considerando esta definição, é correto afirmar que:

A camada física define os padrões de potência do sinal, frequência de operação e a forma de codificar os dígitos binários

Os meios de transmissão são os canais, as vias ou condutores pelos quais os computadores e os dispositivos de rede enviam e recebem os dados. Eles são capazes de transportar sinais elétricos e eletromagnéticos (ondas de rádio) e a luz, que por sua vez carregam as informações em sua menor unidade, o BIT. Assinale a alternativa correta quanto às características dos meios de transmissão:

Uma desvantagem da comunicação sem fio por sinal de rádio é que o espectro de frequências disponíveis é limitado e disputado com outros usuários, como as emissoras de rádio e televisão, os sistemas de telecomunicações e radares, etc.

As redes de computadores podem ser diferenciadas em função da sua abrangência geográfica, ou seja, o espaço territorial que ocupam e no qual atuam. Sob este aspecto as redes podem ser denominadas como:

LAN: é uma rede que interliga os equipamentos de uma instalação ou edificação – casa, escritório, escola, prédio, planta de fábrica, etc.

Comparando os modelos ISO/OSI e TCP/IP é possível constatar que:

A camada 2 (ou inter-rede) do TCP/IP é equivalente à camada de rede (camada 3) do modelo ISO/OSI, e trata do roteamento ou encaminhamento de pacotes entre os nós das redes.

As redes de computadores são sistemas de computadores e dispositivos de comunicação computadorizados que estão interconectados entre si, possibilitando a troca de informações no formato digital. As redes estão presentes em praticamente todas as atividades exercidas pelos seres humanos na atualidade, provendo os serviços de comunicação de dados tais como:

O acesso remoto à informação, à dispositivos e a serviços os mais diversos, desde uma compra de passagem aérea em outro continente até o controle das comportas de uma usina hidroelétrica.

Os emissores e os receptores das informações que são conduzidas pela comunicação através de uma rede possuem dois tipos de identificação: uma física, o MAC Address, e outra lógica. Estas identificações estão relacionadas com determinadas camadas de rede, como segue:

A camada de Enlace trata do endereço físico e a camada de Rede trata do endereço lógico

Uma das camadas do modelo ISO/OSI trata da interação entre o hardware e os mecanismos de sinalização. Esta camada fornece seus serviços para a camada superior e estabelece a ligação entre os nós da rede, com ou sem fio, através de um meio de transmissão. Esta camada é:

Física

Quanto às limitações das tecnologias empregadas para a comunicação de dados nas redes de computador é correto afirmar que:

A Ethernet consegue atingir até 100 m com cabos condutores padrões 10 Base-T, com cabos CAT-5 e conector RJ-45.

----------------------------------------------------------------------------
uninter redes de computadores

Rota de Aprendizagem
Redes de Computadores
Aula 01

Aula 01 - Parte 1 – Redes de Computadores
Introdução
Nesta primeira aula vamos abordar os conceitos gerais de Redes de Computadores,
apresentando uma visão geral sobre o tema, abordando os principais tipos e as tecnologias
utilizadas na composição das redes de computadores. Nosso objetivo é identificar e classificar
as redes de computadores dos mais diversos tipos, constituições e abrangência, os serviços
prestados por estas redes e as suas principais características.
Leituras recomendadas:
 Tanenbaum, 2011 – Seções 1.1 e 1.2 (pag. 2 a 17) e 1.5 (pag. 33 a 45).
 Kurose, 2003 – Seções 1.8 e 1.9 (pag. 41 a 48).
Contextualizando
O que são as redes de computadores?
As redes de computadores são sistemas de computadores e dispositivos de
comunicação computadorizados que estão interconectados entre si, possibilitando a troca de
informações no formato digital, isto é, de bits e bytes. Em uma rede, os computadores são
interligados através de um meio de comunicação, formando uma estrutura composta de
computadores e outros dispositivos, dos meios de transmissão, do software de rede e dos
equipamentos de comunicação. Uma rede, network ou simplesmente net também é conhecida
pelo acrônimo (sigla) em Inglês DCN – Data Communication Network.
Simplificando ao máximo, podemos dizer que uma rede de computadores é a utilização
de computadores integrada aos sistemas de comunicação:
Computador + Comunicação = DCN
(Data Communications and Computer Network)
Para ajudar a entender mais um pouco, assista o vídeo disponível em
https://www.youtube.com/watch?v=_axG2fUpUCs.
Qual é a finalidade das redes de computadores?
As redes de computadores estão presentes em praticamente todas as atividades
exercidas pelos seres humanos na atualidade, provendo os serviços de comunicação de
dados, através do qual possibilitam:

1

Rota de Aprendizagem
Redes de Computadores
Aula 01

- A interoperabilidade, ou seja a capacidade de diferentes sistemas computacionais
trocaram informações entre si para a realização de tarefas ou atividades – como um ERP e um
sistema bancário possibilitando a troca de informações sobre cobrança e pagamento bancário,
por exemplo. Ou um portal de comércio eletrônico que realiza vendas e aceita o pagamento
através de cartões de crédito. Sobre este assunto, faça uma pesquisa sobre os temas
“Comércio Eletrônico, Banco Eletrônico e Governo Eletrônico” na internet e comente no
FORUM “Interoperabilidade”.
- A interconectividade, isto é, a capacidade de diferentes tipos de dispositivos
conectarem-se para a troca de informações ou a realização de operações e atividades. Como
por exemplo um smartphone conectado à internet, um leitor de cartão de crédito ou débito
conectado ao sistema bancário através da rede de telefonia celular, um dispositivo de
rastreamento que permite seguir o trajeto de um veículo ou de uma encomenda através da
internet, etc.
- Os serviços de mensagem, ou troca de texto, sejam instantâneas ou não, como o email em geral, o Whatsapp, o Skype, Twitter, Messenger e muitos outros.
- Os serviços de telefonia, como o VoIP, ou seja, o tráfego de voz e imagem integrado
ao uso dos computadores, como o Skype, por exemplo.
- O acesso remoto à informação, à dispositivos e a serviços os mais diversos, desde
uma compra de passagem aérea em outro continente até o controle das comportas de uma
usina hidroelétrica.
As redes de computadores também possibilitam o compartilhamento de recursos
como impressoras, dispositivos de armazenamento, de obtenção e tratamento de imagem e
som, e até mesmo de processamento. Com isso, as redes possibilitam a otimização do uso
destes dispositivos, permitindo que mais pessoas possam fazer uso dos mesmos em um maior
período de tempo e a partir de regiões geográficas distintas. Com isto é possível obter uma
redução de custos, seja na aquisição – dispensando a compra de vários desses dispositivos
para cada local onde são necessários – ou na manutenção de vários equipamentos espalhados
por diversas áreas. Além disso as redes também possibilitam a distribuição da carga de
trabalho entre diversos computadores, que podem repartir uma tarefa pesada e complexa,

2

Rota de Aprendizagem
Redes de Computadores
Aula 01

fazendo com que cada um execute uma parte e assim obtenham o resultado mais
rapidamente.
Pesquisa
Procure descobrir como funcionam os buscadores na Internet, - também chamados
de motores de pesquisa ou ferramentas de busca, em inglês search engine - como por exemplo
o Google, o Bing, o Yahoo, o Baidoo e muitos outros.
As redes de computadores também reforçam a confiabilidade e segurança dos
sistemas, uma vez que permitem a estruturação de sistemas com tolerância a falhas, nos
quais, havendo problemas em um computador ou em um local específico, outro computador
ou outro local pode assumir a atividade em execução e dar sequência às operações. Aliás, foi
este aspecto levou às pesquisas que resultaram no desenvolvimento da Internet, você sabia?
Para saber mais sobre isto, faça uma pesquisa sobre ARPA / DARPA na Internet.
Outra finalidade das redes é o gerenciamento ou gestão de recursos, sejam estes
recursos computacionais ou não. Através da sua capilaridade – isto é, da capacidade de
chegar a diversos pontos – e da sua abrangência, as redes de computadores possibilitam a
disseminação ordenada das informações, além de possibilitar a administração do conteúdo e
da circulação de informações entre os pontos interligados.
A classificação das redes de computadores
As redes de computadores podem ser diferenciadas em função da sua abrangência
geográfica, ou seja, o espaço territorial que ocupam e no qual atuam. Sob este aspecto as
redes podem ser denominadas como:
 PAN, do Inglês Personal Area Network ou rede de área pessoal;
 LAN, de Local Area Network ou rede de área local, ou simplesmente Rede Local;
 MAN, de Metropolitan Area Network ou rede de área metropolitana
 WAN, de Wide Area Network ou rede de grande área;
 E a Internet, isto é, a interconexão de redes, a rede das redes, ou rede de alcance
mundial.

3

Rota de Aprendizagem
Redes de Computadores
Aula 01

Quanto à conectividade as redes podem ser classificadas em redes lógicas, na qual a
configuração é definida por um arranjo de software, ou redes físicas, que resultam da
combinação de meios de comunicação e hardware específico em arranjos físicos e com
distribuição geográfica conhecida. Uma rede também pode ser composta pelos combinação
destes dois tipos. O melhor exemplo para isto é a famosa Computação na Nuvem, ou seja, o
Cloud Computing. Para saber mais sobre o assunto, faça uma pesquisa sobre a computação na
nuvem (ou cloud computing) e exponha suas descobertas no FORUM “Computação na Nuvem”.
Em função da forma de gerenciamento as redes podem ser públicas, com seus
endereços e computadores conhecidos e possíveis de serem acessados por todos –
respeitadas as regras de segurança, ou privadas, com o acesso restrito à um grupo ou
organização que seleciona e condiciona à determinadas regras aqueles que podem fazer uso
da rede.
Quanto à arquitetura uma rede pode ser identificada como Cliente/Servidor, com
um computador provendo informações e gerindo a comunicação de outros, pode ser uma rede
ponto a ponto na qual os computadores em comunicação trocam informações entre si e
gerenciam a comunicação em conjunto. E é possível a combinação de ambos os modelos,
formando assim uma rede híbrida.
As aplicações das redes de computadores
Como já mencionado, as redes são utilizadas para o compartilhamento de recursos,
como os de impressão e armazenamento, captura, armazenagem e tratamento de voz, sons e
imagens. Também são utilizadas para a troca de informações como no caso do e-mail, a troca
de arquivos (FTP), as mensagens instantâneas, a TV e os vídeos sob demanda. Através das
redes é possível fazer o compartilhamento de informações pessoais (blogs e redes sociais),
profissionais, educacionais e governamentais (você pesquisou sobre Governo Eletrônico?).
As redes também podem suportar serviços de telefonia, como o VoIP, por exemplo, e
as teleconferências de áudio e vídeo. Além disso podem ser estabelecidas redes de
computadores com o propósito de utilizar a computação paralela ou distribuída, como no
projeto SETI (Já ouviu falar ou leu a respeito? Que tal pesquisar?), na operação de redes de
radiotelescópios, sensores e radares com uso em astronomia, climatologia, energia, etc.

4

Rota de Aprendizagem
Redes de Computadores
Aula 01

Tipos de redes
Personal Área Network é uma pequena rede no ambiente pessoal que abrange alguns
poucos metros (<=10 m) em uma mesa, casa ou escritório, permitindo a interligação de
computadores, smart phones, mouse, teclado, fones de ouvido, câmeras, relógios, televisores,
eletrodomésticos e diversos outros tipos de dispositivos, normalmente através de tecnologia
Bluetooth ou raios infravermelhos. Um exemplo deste tipo de rede é a Piconet - uma rede
Bluetooth que conecta até oito dispositivos móveis no formato Master-Slave.
A Rede de Área Local ou simplesmente Rede Local é uma rede que interliga os
equipamentos de uma instalação ou edificação – casa, escritório, escola, prédio, planta de
fábrica, etc. – através de cabos ou ondas de rádio – as redes chamadas redes wireless ou sem
fio. Normalmente a área de abrangência fica em torno de poucas centenas de metros, e
conecta de dois até milhares de computadores. Em geral é a rede local que nos possibilita,
entre outras coisas, o compartilhamento de impressoras, scanners, o acesso aos servidores
(de dados, de aplicações, de comunicação) e à Internet, entre outros, e por isso é a rede típica
das organizações em geral.
Os equipamentos de rede utilizados em uma LAN são mais simples e de baixo custo, e é
comum encontrar nestas redes equipamentos com funções de Proxy, Firewall, Switch,
Roteador (Você sabe o que é isto? Que tal pesquisar?). Os endereços dos computadores desta
rede são privativos, isto é, de conhecimento apenas de quem faz parte da rede ou a
administra. As conexões são feitas por cabo (Ethernet ou Fibra Ótica) ou sem fio (WiFi ou
Wireless), e há um domínio próprio que não requer registro e tampouco é publicado na
Internet.
MAN ou rede metropolitana é um tipo de rede que abrange uma cidade ou uma área
metropolitana, interconectando diversas construções e diferentes organizações, cujos
endereços são públicos e a interconexão (enlaced ou links) é feita por cabo, fibra ótica, laser
ou rádio. Estas redes incorporam um serviço de domínio e de nomes, e formam um Backbone
que conecta outras redes – LANs – entre si. São típicas de serviços como os dos provedores de
Internet (ISP), Metro Ethernet, TV a Cabo, Telefonia fixa e interligação das estações rádio base
(ERBs) – as “torres” da telefonia celular.

5

Rota de Aprendizagem
Redes de Computadores
Aula 01

Uma WAN ou rede de grande abrangência é uma rede que atende a áreas enormes,
normalmente superando as fronteiras entre estados, países e até continentes, fazendo uso de
links compostos por cabo, fibra ótica ou satélite. É uma rede típica de provedores de serviços
de telecomunicações e grandes corporações, e que tem por finalidade conectar LANs e MANs
entre si através de um Backbone de grande extensão e altíssimo volume de tráfego de dados.
Normalmente é operada por corporações de alcance global e fornece serviços para
provedores de Internet (ISP), sistemas de telefonia fixa, transmissões de áudio e vídeo para
emissoras de televisão e corporações globais.
A Internetwork ou a rede das redes, ou simplesmente Internet é uma rede de alcance
global (World Wide Web) que contempla desde as conexões locais até as intercontinentais
por fibra óptica e satélite, tornando-se uma rede com uma enorme quantidade de
computadores conectados. Sua principal característica é o grande volume de informações
disponível, que contempla e-mails, texto e Imagens, áudio e vídeo, mídias sociais, comércio,
serviços e governo eletrônico. Uma pergunta que sempre é feita é: quem controla a Internet?
A resposta: a Internet não tem dono! Mas tem organismos de controle que zelam pela sua
operação e evolução.
Pesquisa
Para saber mais sobre os organismos que regulam a Internet, pesquise sobre ICANN,
IANA e IETF e compartilhe com os colegas de curso no FORUM “A Internet”. E assista o vídeo
“Guerreiros da Internet” disponível em https://www.youtube.com/watch?v=Iqcp3k8DgGw. E
então, você já sabe como surgiu a internet? E quem administra a Internet no mundo? E no
Brasil? Que tal pesquisar?
Tecnologias
Para que as redes funcionem e ofereçam os serviços com a qualidade esperada existem
diversos elementos e padrões que definem as características necessárias, possibilitando assim
a construção física e também a configuração lógica mais adequada. Neste aspecto as
tecnologias empregadas para a comunicação de dados nas redes de computador são cruciais,
tendo sido determinantes na evolução e na disseminação do uso das redes.
Uma dessas tecnologias é a Ethernet, um modelo e padrão desenvolvido em conjunto
pela DEC (Digital Equipment Corporation), Intel e Xerox no início da década de 70, e tornado

6

Rota de Aprendizagem
Redes de Computadores
Aula 01

padrão pelo IEEE (Institute of Electrical and Electronics Engineers) na década de 80. É típica de
topologia do tipo Estrela, e faz uso de prevenção e detecção de colisões com o CSMA/CD. As
interfaces (cartões ou placas) de rede física (MAC) possuem endereços de 48 bits, ou seja, é
possível designar até 248 endereços para os dispositivos ou hosts. A ethernet usa como
padrões de mídia o 10 Base-T, com cabos CAT-5 e conector RJ-45. Com estes padrões
consegue atingir distâncias de até 100 metros mantendo uma velocidade de comunicação de
10 Mbps (dez megabits por segundo). Com o passar do tempo e a evolução tecnológica, a
ethernet também foi evoluindo, passando a apresentar novos padrões, tais como:
 FAST ETHERNET, padrão IEEE 802.2, mídia 100 Base-T, cabo CAT-5 e conector RJ-45,
que atinge até 100 Mbps em distâncias de até 100m;
 FAST ETHERNET em fibra ótica, mídia 100 Base-Fx, que atinge até 100 Mbps em até
2.000 m (ou 2 Km, dois quilômetros);
 GIGABIT ETHERNET, padrão IEEE 802.3ab, cabos CAT-5, CAT-5e e CAT-6, com
velocidades até 1 Gbps (Gigabits por segundo);
 GIGABIT ETHERNET em fibra óptica, padrão IEEE 802.ah;
Uma outra tecnologia é a Token Ring, criado pela IBM nos anos 80. Esta tecnologia foi
padronizada pela norma IEEE 802.5, e é utilizada principalmente em redes de topologia ANEL
em ambientes de altíssimo volume de tráfego de dados, exigência de alta disponibilidade e
baixíssima taxa de erros. Geralmente é empregada para a comunicação de computadores de
grande porte, os Mainframes, dispositivos de armazenamento de grande capacidade, os
Storages ou dispositivos voltados para a cópia de segurança dos dados destes sistemas, o
Backup. Esta rede é eficiente para ambientes que trocam grandes volumes de dados pois evita
a colisão – a tentativa de comunicação simultânea entre mais de dois dispositivos. Isto porque
existe um TOKEN, isto é, um sinalizador que fica de posse de apenas um host a cada momento,
e somente o host que tiver a posse do token poderá transmitir seus dados através da rede.
Uma tecnologia que se tornou popular e é massivamente utilizada atualmente é o
WiFi® – Wireless Fidelity, marca registrada da WiFi Alliance. É definida pelos padrões IEEE
802.11a para a velocidade de até 2 Mbps, IEEE 802.11b para 11 Mbps, IEEE 802.11g para 54
Mbps e IEEE 802.11n de 150 até 600 Mbps. Esta tecnologia permite a conexão a redes sem o

7

Rota de Aprendizagem
Redes de Computadores
Aula 01

uso de condutores (fios), e também por isso é conhecida como Wireless, ou seja, sem fio. É
importante não confundir comunicação sem fio com a comunicação móvel (mobile) dos
celulares e tablets, pois tratam-se de tecnologias bastante distintas entre si, embora ambas
utilizem a atmosfera (através dos sinais de rádio) como meio de transmissão. Duas questões
críticas para esta tecnologia é a limitação de frequências disponíveis no espectro
eletromagnético e a segurança da informação. A limitação de frequências decorre da
utilização da faixa de rádio frequências para o uso de outros serviços, como transmissões por
micro-ondas, satélite, comunicação militar, radares, radiotelescópios e outros. A segurança
tem evoluído desde os primeiros mecanismos, como o WEP – Wired Equivalent Privacy – ou
privacidade equivalente à rede com fios, uma iniciativa que buscou a segurança durante os
processos de autenticação para a proteção e a confiabilidade no tráfego de dados entre os
dispositivos wireless e que se tornou parte do padrão IEEE 802.11. Por sua fragilidade e
constante quebra de segurança foi praticamente abandonado, sendo mantido apenas por
razões de compatibilidade com disposiivos mais antigos, tendo sido substituído pelo WPA –
Wi-fi Protected Access ou acesso Wi-Fi protegido, e posteriormente WPA2, que usa
criptografia AES, e pela sua versão simplificada para usuários domésticos, o WPS - Wi-Fi
Protected Setup, inicialmente chamado de Wi-Fi Simple Config.
O Bluetooth é outra tecnologia de rede sem fio, criada pela ERICSSON na década de 90,
e transformada no padrão IEEE 802.15.x, é uma tecnologia voltada para a comunicação à
curta distância, basicamente para as redes pessoais (PAN ou WPAN), e também associada à
mobilidade e à IOT – Internet of Things – internet das coisas, modelo que possibilita a conexão
à internet através de diversos dispositivos, incluindo os telefones celulares, impressoras,
scanners, videogames, GPS, mouse , teclado e também os eletrodomésticos, como televisores,
geladeiras e DVDs.
A comunicação móvel ou Mobile é composta de outras tecnologias que permitem o
tráfego de dados, denominadas 2G, 3G, 4G, etc. Estas tecnologias foram originalmente
desenvolvidas para o tráfego de voz e posteriormente aprimoradas para o tráfego de dados.
Por isto tratam-se de tecnologias mais vinculadas às redes de telefonia do que as redes de
computadores propriamente ditas, embora o seu uso crescente para acesso à internet venha
transformando rapidamente este cenário.

8

Rota de Aprendizagem
Redes de Computadores
Aula 01

Além destas tecnologias existem inúmeras outras, mais específicas e menos utilizadas,
mas não por isto menos importantes, tais como Frame Relay, xDSL, HDLC, FDDI, PPP, DLNA,
MHL e NFC.
Pesquisa
Você se interessa por infraestrutura de TI, Segurança da Informação ou
Telecomunicações? Que tal então pesquisar sobre as demais tecnologias citadas? O que as
diferencia entre si? Onde são usadas? Quais são as vantagens e desvantagens de cada uma?
Trocando Ideias
Acesse o FORUM “Tecnologias das Redes de Computadores” e exponha os resultados
de seu aprendizado e de suas pesquisas. Use os CHATS durante as aulas interativas.
Compartilhe suas descobertas, suas experiências, exponha suas dúvidas... Faça contato com
seus colegas de curso ou de turma, com os tutores, e discuta o que aprendeu, e assim reforce
seu conhecimento e esclareça suas dúvidas.
Síntese
Nessa aula conhecemos as redes de computadores, as suas classificações e os suas
finalidades e usos. Também aprendemos sobre os tipos de rede e as tecnologias empregadas
na construção destas redes de computadores, possibilitando a troca de informação desde os
mais pequenos espaços até as distâncias globais, com qualidade e velocidade.
Compartilhando
Que tal colocar à prova o que você aprendeu? Converse com seus colegas de curso, de
trabalho, seus amigos, seus familiares. Busque saber o que conhecem sobre o assunto e leve
até eles o que viu, ouviu e leu até aqui.
Autoavaliação
 O que são as redes de computadores?
 Para que servem as redes de computadores? Onde são usadas?

9

Rota de Aprendizagem
Redes de Computadores
Aula 01

 Quais os principais tipos de redes de computadores?
 Quais as tecnologias empregadas nas redes de computadores?
 O que diferencia estas tecnologias entre si?
 Onde são usadas as tecnologias apresentadas?
 Quais são as vantagens e desvantagens de cada uma destas tecnologias?
 As redes de computadores influenciam as atividades, os negócios e a história da humanidade?
Como? Isto é bom ou é ruim?

10

Rota de Aprendizagem
Redes de Computadores
Aula 01

Aula 01 - Parte 2 – Redes de Computadores
Introdução
Nesta aula vamos conhecer as topologias ou arquiteturas das Redes de Computadores,
os meios de transmissão de dados utilizados para estabelecer uma rede e as características
das principais conexões físicas utilizadas nas redes. Nosso objetivo é poder identificar e
diferenciar as redes de computadores de acordo com sua constituição física e lógica.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.6, pag. (46 a 52), 2.2 a 2.4 (pag. 58 a 76) e 2.6 a 2.9
(pag. 86 a 117).
Contextualizando
Topologia (ou arquitetura)
Topologia de uma rede de computadores é a forma através da qual os computadores e
demais componentes ou dispositivos da rede estão organizados, ligados ou conectados entre
si. Esta ligação pode ocorrer de forma física, através dos meios de comunicação e transmissão,
ou lógica, configurada por software.
A topologia física expressa a aparência ou layout da rede, e a lógica representa o fluxo
dos dados na rede. A topologia física representa como as redes estão conectadas (layout
físico) e o meio de conexão dos dispositivos de redes (nós ou nodos). A forma com que os
meios de transmissão, computadores e os dispositivos de rede estão conectados influencia os
aspectos críticos, como a flexibilidade, velocidade e segurança.
A topologia lógica trata da maneira como os dados trafegam através da rede a partir de
um computador ou dispositivo para o outro, desconsiderando as ligações físicas entre eles. A
topologias lógica é associadas ao controle do meio de acesso (mídia, ou meio de transmissão),
e podem ser reconfiguradas dinamicamente em tipos especiais de equipamentos, como
roteadores e switches.

11

Rota de Aprendizagem
Redes de Computadores
Aula 01

Ponto a ponto
Normalmente encontrada em uma rede simples onde dois computadores (dispositivos
ou hosts) são ligados diretamente entre si. Podem haver outros hosts no caminho entre estes
dois, porém devido às características da rede estes dois hosts ignoram a existência dos
demais, não precisando ter informações ou conhecer detalhes da rede ou dos hosts
intermediários. Um exemplo típico de uma rede ponto a ponto é a VPN – Virtual Privative
Network. Também pode ser a conexão física direta entre dois computadores ou dispositivos,
na qual o canal ou circuito de envio de um é conectado ao canal ou circuito de recebimento do
outro, também conhecida como conexão Cross Over.
Barramento (BUS)
Em uma rede do tipo barramento, todos os hosts compartilham um único meio para a
comunicação. Este tipo de rede é fácil de se construir, pois o meio é único – um único cabo
coaxial ou fibra ótica percorrendo toda a extensão da rede. Para evitar problemas de
transmissão este tipo de rede usa um controle de acesso ao meio e de detecção de colisão do
tipo CSMA/CD - Carrier Sense Multiple Access with Collision Detection ou Bus Master, ou seja,
quando um host vai iniciar uma transmissão, primeiro verifica se o meio está livre. Uma das
vantagens deste tipo de rede é que, em caso de falha de um host os outros não são afetados.
PPorém se o meio de transmissão – cabo ou fibra – sofrer uma falha, toda a rede deixa de
funcionar.
Estrela (Star)
Em uma rede do tipo estrela todos os hosts são conectados a um ponto ou nó central,
normalmente um dispositivo de rede do tipo Hub ou Switch , mas também podem ser do tipo
Repetidor, Bridge, Gateway, Router, etc. De fato existe uma conexão ponto a ponto entre os
hosts e este nó central, pelo qual passa todo o tráfego da rede. Por isso, em caso de falha de um
host os outros não são afetados, porém se o equipamento do nó central falhar, toda a rede fica
inoperante.

12

Rota de Aprendizagem
Redes de Computadores
Aula 01

Anel (Ring)
Na rede configurada em formato de anel cada host é conectado a dois outros, seu
antecessor e seu sucessor, ou o anterior e o seguinte. Desta forma há uma conexão ponto-aponto entre cada um destes dois hosts, e o tráfego da rede passa por cada um deles. Por isso
mesmo, em caso de falha de um host toda a rede falha. Para evitar este tipo de falha
normalmente há um anel backup no qual a informação circula em sentido contrário ao do
principal.
Mesh (Malha)
Nas redes do tipo malha, cada host é conectado a todos os outros hosts (Full Mesh) ou
pelo menos aos mais próximos a ele (Partially Mesh), através de uma conexão ponto a ponto
entre cada host. Esta configuração torna este tipo de rede bastante complexa e cara para a
conexão física, sendo mais usual em redes lógicas ou em conexões sem fio (wireless). Uma
vantagem deste tipo de rede é que, em caso de falha de um ou mais hosts a rede como um
todo não é afetada.
Árvore (Tree)
Também chamada de Hierárquica ou de Hierarquia, este tipo de rede é organizada em
camadas (layers), resultado de uma combinação das redes do tipo Barramento e Estrela. Hosts
vizinhos e dispositivos em nós de transição entre os níveis utilizam uma conexão ponto a
ponto, resultando que, em caso de falha dos nós centrais toda a rede falha. Esta é uma
configuração típica das Redes Locais.
Daisy Chain
Em uma rede do tipo Daisy Chain cada host é conectado a dois outros hosts, exceto os
dois da extremidade da rede. É o resultado de uma combinação de redes do tipo barramento
e anel, também fazendo uso de uma conexão ponto-a-ponto entre hosts vizinhos. Porém cada
nó e cada host representa um ponto de falha que pode segmentar a rede, isto é, impedir a

13

Rota de Aprendizagem
Redes de Computadores
Aula 01

comunicação daquele ponto em diante em caso de falha. De fato, cada host funciona como um
roteador para seus vizinhos, repassando a transmissão deles e para eles.
Híbrida
Uma rede do tipo híbrida é uma combinação das demais, da qual obtém-se as
vantagens e as desvantagens de cada modelo. Normalmente são redes de grande área, e o
melhor exemplo deste tipo de rede é a própria Internet.
Ativos de Rede
Ativos de rede são os equipamentos ou dispositivos que, em síntese, fazem a rede
funcionar. São eles que recebem e enviam as informações através da rede, estabelecidos nos
pontos de interconexão também chamados nós (ou nodos) da rede. Através deles faz-se a
configuração e o gerenciamento do tráfego da rede, e também respondem pelo desempenho,
flexibilidade e segurança da rede.
Concentrador ou Reforçador (Hub): É o dispositivo que centraliza a conexão de
diversos hosts em um mesmo segmento da rede, ligando-os e formando uma rede de topologia
estrela. Ao receber um pacote de dados, o Hub o envia a todos os demais hosts, dispositivos e
nós conectados a ele. Neste caso, quando um host transmite, todos os demais hosts e nós de
rede conectados ao Hub recebem, simultaneamente, a transmissão. Ou seja, escutam... E isso é
muito ruim do ponto de vista da segurança da rede.
Repetidor: É o equipamento que conecta dois segmentos de rede recuperando e
reforçando ou amplificando os sinais da transmissão. Com isso consegue-se aumentar a
distância alcançada - ou área de cobertura – daquele segmento de rede. São utilizados quando
a distância entre hosts ou nós da rede superam a extensão recomendada para o meio de
transmissão utilizado.
Bridge: É um ativo de rede que conecta dois segmentos de rede, tornando-os uma
única rede, ou duas redes distintas entre si. Possui a capacidade de promover a interconexão
de redes com tecnologias diferentes, fazendo a conversão e adequação de padrões e
protocolos.

14

Rota de Aprendizagem
Redes de Computadores
Aula 01

Comutador (Switch): É o equipamento mais comum em redes locais, pois conecta
hosts de diferentes segmentos de rede. Diferentemente do HUB, o Switch retransmite os
pacotes de dados apenas para o host ou nó de destino, fechando um circuito entre este e o host
ou nó de origem dos dados e emulando uma rede ponto a ponto entre ambos. Também
permite as transmissões simultâneas ("conversas em paralelo") e, devido à segregação dos
circuitos comutados, diminui o número de colisões no segmento de rede.
Roteador (Router): é o dispositivo que conecta - ou separa - redes distintas, evitando
que pacotes de uma trafeguem de forma indiscriminada para outra, e encaminhando os
pacotes destinados a hosts da outra rede. Um router é capaz de traçar a melhor rota – ou
caminho - para um determinado pacote de dados, identificar o estado dos segmentos de rede
quando à disponibilidade ou tráfego e ainda impor determinadas regras de segurança.
Normalmente é utilizado para conectar instalações entre si - redes entre si ou a empresa toda
à Internet.
Gateway: É o dispositivo que conecta redes com tecnologias distintas entre si, tal como
as Bridges, porém com capacidade de realizar a tradução de protocolos e a conversão de
dados. Um Gateway é utilizado para conectar sistemas que usam:
 Diferentes protocolos de comunicação;
 Estrutura de formatação dos dados diversa ou variada;
 Idiomas ou linguagem diferentes;
 Arquitetura de rede mista ou complexa, com dispositivos de várias funcionalidades e de
fabricantes distintos.
Um exemplo de uso de gateway é a conexão dos serviços de telefonia à rede de
comunicação de dados, o VoIP – Voice over IP, que possibilita o uso de uma mesma rede para
tráfego de voz e dados, além da interligação entre telefone e computador através da Interne,
como no software Skype, por exemplo. Outro exemplo é a conexão entre redes de PCs e de
computadores de grande porte – Mainframes.
Além desses ativos existem vários outros, dentre os quais podemos citar:
- Proxy
- Firewall

15

Rota de Aprendizagem
Redes de Computadores
Aula 01

- IDS ou Intrusion Detection System
Pesquisa
Você sabe o que é um Proxy? E um Firewall? E o IDS? Sabe onde são usados, e porquê?
Que tal pesquisar na bibliografia e na internet?
Meios de transmissão
Os meios de transmissão são os canais, as vias ou condutores pelos quais os
computadores e os dispositivos de rede enviam e recebem os dados. Eles são capazes de
transportar sinais elétricos e eletromagnéticos (ondas de rádio) e a luz, que por sua vez
carregam as informações em sua menor unidade, o BIT. Ou seja, os meios de transmissão
compõem as vias físicas percorridas pelos sinais que transportam os dados de um nó a outro
da rede.
Um dos mais utilizados são os Cabos Elétricos, condutores metálicos apresentados na
forma de cabos telefônicos, cabos coaxiais, pares de fios trançados e a própria rede elétrica
que leva energia às edificações em geral. Estes cabos apresentam a vantagem de ser de fácil
instalação em curtas distâncias e ambientes urbanos, e também de já existirem em alta
quantidade, em função das instalações de serviços de telefonia e de energia elétrica, por
exemplo. Entretanto, apesar disso apresentam inúmeras desvantagens, tais como o alto custo,
devido ao fato de serem compostos de metais como cobre, alumínio e até mesmo ouro e prata,
em casos especiais. Por serem condutores sofrem a interferência de sinais elétricos e
eletromagnéticos, descargas atmosféricas (raios), tensionamento, variação de temperatura,
radiação ultravioleta (do sol) e oxidação, necessitando de constante manutenção para evitar
problemas de segurança. Outro problema também é a ocupação de espaço e a falta de
flexibilidade. Por isso tem sido cada vez menos utilizado em longas distâncias.
Outro importante meio de transmissão de dados é a fibra ótica ou os Cabos Óticos,
utilizados cada vez mais para as conexões a longa distância e altas velocidades.
Diferentemente dos cabos elétricos, os cabos óticos são isolantes – feitos à base de sílica, o
mesmo produto com o qual se faz o vidro, daí a denominação popular de fibra de vidro.
Os cabos óticos também apresentam inúmeras vantagens, como possibilitar o tráfego
em altíssimas velocidades, a grande imunidade a ruído e interferências elétricas e

16

Rota de Aprendizagem
Redes de Computadores
Aula 01

eletromagnéticas, uma vez que transporta a luz, tem um custo menor e apresenta maior
durabilidade. Além disso oferece menores perdas de qualidade mesmo em longas distâncias.
Por outro lado, requer muitos cuidados durante a instalação e sua manutenção é muito
complexa, resultando em alto custo.
Para os casos de comunicação entre pontos muito distantes, como a interligação entre
continentes através de cabos submarinos, por exemplo, a necessidade de regeneração e
repetição do sinal de luz é algo que requer tecnologias de alto custo e complexidade.
O ar ou o espaço, ou também a atmosfera, é um importante meio de transmissão, no
qual podem transitar sinais luminosos (luz visível, infravermelho ou laser) ou as ondas
eletromagnéticas (sinais de rádio frequência). Este meio é o que suporta as comunicações sem
fio (Bluetooth, Wireless ou Wi-fi, Mobile, Satélite, Microondas, etc).
As vantagens deste meio de transmissão vão desde o fato de ser um isolante – em que
pese que as descargas atmosféricas percorram o ar, permitir a transmissão multidirecional
(omnidirecional ou em todas as direções), e a possibilidade de atingir longas distâncias sem a
necessidade de instalação de dispositivos intermediários.
Por outro lado, a instalação e a manutenção dos transmissores e receptores pode ser
difícil e cara, e o sinal transmitido sofre inúmeras interferências, desde as provocadas por
outros dispositivos, como motores, eletrodomésticos, equipamentos industriais, até a
radiação solar. Além disso o espectro de frequências disponíveis é limitado e disputado com
outros usuários, como as emissoras de rádio e televisão, os sistemas de telecomunicações e
radares, etc. Outro aspecto de grande preocupação para a comunicação por rádio ou através
da atmosfera é a segurança, uma vez que o sinal se espalha e pode ser captado por qualquer
um.
O uso da luz (visível ou invisível, infravermelho ou laser) para a comunicação
atmosférica resolve alguns dos problemas que afetam a radiocomunicação, e tem
características semelhantes, porém com custos menores tanto para instalação ou manutenção.
Ao mesmo tempo, apresenta dificuldades para distâncias maiores e também sofre com a
interferência ou bloqueio do sinal luminoso.
Um fator de grande importância para os meios de comunicação são as conexões
físicas, isto é, a forma de prover o contato elétrico ou mecânico entre condutores ou o meio

17

Rota de Aprendizagem
Redes de Computadores
Aula 01

de comunicação e os diversos dispositivos ou equipamentos. Por ser uma estrutura mecânica
ou necessitar fazer contato, são os principais causadores de perdas e ruídos, e estão entre os
principais itens que requerem manutenção contínua. Há uma vasta gama deste tipo de
componentes, condizente com os diversos tipos de equipamentos, meios e padrões existentes
para a conexão mecânica – elétrica, eletromagnética ou ótica. Saber diferenciá-los e escolher
os mais adequados pode ser a diferença entre ter uma rede confiável, segura e com alto
desempenho ou uma que causa mais problemas do que o tolerável.
Pesquisa
Você sabe por onde passam os dados que você envia ou recebe através de seu
computador? Conhece a estrutura de rede de seu local de trabalho ou estudo? Da sua
provedora de serviços de telefonia, TV ou internet? Já viu um quadro de distribuição em seu
prédio, seu bairro? Que tal se informar sobre isto? Já se perguntou a razão das torres de
celular serem sempre altas ou instaladas em pontos elevados? Pesquise, pergunte para as
pessoas que trabalham com isto... Descubra estas e outras respostas que certamente farão
você prestar mais atenção às redes daqui para a frete.
Trocando Ideias
Acesse os fóruns e use os CHATS durante as aulas interativas e compartilhe suas
descobertas, suas experiências, exponha suas dúvidas. Faça contatos com seus colegas de
curso e de turma e discuta o que aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula conhecemos as formas como são organizados os dispositivos que compõem
as redes de computadores, definindo assim a topologia ou arquitetura. Também aprendemos
sobre os vários meios de transmissão utilizados, suas características, vantagens e
desvantagens, assim como os dispositivos utilizados para prover a conexão física – mecânica,
elétrica e ótica – dos componentes e dos meios de transmissão.

18

Rota de Aprendizagem
Redes de Computadores
Aula 01

Compartilhando
Que tal repartir com os outros os conhecimentos que você adquiriu? Discuta com os
seus colegas de curso e de turma, o pessoal do trabalho, profissionais da área de
telecomunicações, os seus amigos e seus familiares. Pergunte o que eles sabem sobre o
assunto e apresente para eles o que viu e ouviu até aqui.
Autoavaliação
 O que é uma topologia de rede?
 Quais são as principais topologias utilizadas na constituição de uma rede de computadores?
Onde elas são mais utilizadas?
 Quais são as principais vantagens e desvantagens das topologias estudadas?
 O que são e para que servem os meios de transmissão?
 Quais são os principais meios de transmissão utilizados?


Quais são as principais vantagens e desvantagens dos meios de transmissão apresentados
nesta aula?

Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.
Na Internet:


https://pt.wikipedia.org/wiki/Topologia_de_rede



http://tecnologia.hsw.uol.com.br/lan-switch2.htm



http://www.infoescola.com/informatica/topologias-de-redes/



http://paginas.fe.up.pt/~goii2000/M3/redes2.htm



http://www.m8.com.br/antonio/redes/Topologia.htm



http://www.tutorialspoint.com/data_communication_computer_network/index.htm

19



CONVERSA INICIAL
Nesta primeira aula, vamos abordar os conceitos gerais de Redes de Computadores, apresentando uma visão geral sobre o tema,
abordando os principais tipos e as tecnologias utilizadas na composição das redes de computadores.
Vamos conhecer também as suas topologias ou arquiteturas, os meios de transmissão de dados utilizados para estabelecer uma
rede e as características das principais conexões físicas utilizadas nas redes.

CONTEXTUALIZANDO
O que são as redes de computadores?
As redes de computadores são sistemas de computadores e dispositivos de comunicação computadorizados que estão
interconectados entre si, possibilitando a troca de informações no formato digital, isto é, de bits e bytes.

Em uma rede, os computadores são interligados através de um meio de comunicação, formando uma estrutura composta de
computadores e outros dispositivos, dos meios de transmissão, do software de rede e dos equipamentos de comunicação. Uma
rede, network ou simplesmente net também é conhecida pela sigla em inglês: DCN – Data Communication Network.

Simplificando ao máximo essas definições, podemos dizer que uma rede de computadores é a utilização de computadores
integrados aos sistemas de comunicação:
Computador + Comunicação = DCN
(Data Communications and Computer Network)

Para ajudar a entender melhor esse conceito, assista ao vídeo indicado:
https://www.youtube.com/watch?v=_axG2fUpUCs

Finalidade das redes de computadores
As redes de computadores estão presentes em praticamente todas as atividades exercidas pelos seres humanos na atualidade,
provendo a comunicação de dados, através da qual possibilita vários serviços:
 Interoperabilidade
A capacidade de diferentes sistemas computacionais trocarem informações entre si para a realização de tarefas ou atividades –
como um ERP e um sistema bancário, possibilitando a troca de informações sobre cobrança e pagamento bancário, por exemplo.
Ou um portal de comércio eletrônico que realiza vendas e aceita o pagamento através de cartões de crédito.
 Interconectividade
A capacidade de diferentes tipos de dispositivos conectarem-se para trocarem informações ou a realização de operações e
atividades. Como, por exemplo, um smartphone conectado à internet, um leitor de cartão de crédito ou débito conectado ao
sistema bancário através da rede de telefonia celular, um dispositivo de rastreamento que permite seguir o trajeto de um veículo
ou de uma encomenda através da internet etc.

 Serviços de mensagem
Serviços de mensagem, ou troca de texto, sejam instantâneas ou não, como um e-mail, o Whatsapp, o Skype, o Twitter, o
Messenger entre muitos outros.
 Serviços de telefonia
Os serviços de telefonia, ou seja, o tráfego de voz e imagem integrado ao uso dos computadores. Como o Skype ou o VoIP, por
exemplo.
 Acesso remoto à informação
O acesso remoto à informação, aos dispositivos e aos serviços mais diversos, desde uma compra de passagem aérea em outro
continente até o controle das comportas de uma usina hidroelétrica.

As redes de computadores também possibilitam o compartilhamento de recursos como impressoras, dispositivos de
armazenamento, de obtenção e tratamento de imagem e som, e até mesmo de processamento. Desse modo, as redes possibilitam
a otimização do uso destes dispositivos, permitindo que mais pessoas possam fazer uso dos mesmos em um maior período de
tempo e a partir de regiões geográficas distintas.
Além disso as redes também possibilitam a distribuição da carga de trabalho entre diversos computadores, que podem repartir
uma tarefa pesada e complexa, fazendo com que cada um execute uma parte e assim obtenham o resultado mais rapidamente.
Procure descobrir como funcionam os buscadores na Internet, - também chamados de motores de pesquisa ou ferramentas de
busca (search engine) - como por exemplo: o Google, o Bing, o Yahoo, o Baidoo e muitos outros.
As redes também reforçam a confiabilidade e a segurança dos sistemas, uma vez que permitem a estruturação de sistemas com
tolerância às falhas. Havendo problemas em um computador ou em um local específico, outro computador ou outro local podem
assumir a atividade em execução e dar sequência às operações.
Outra finalidade das redes é o gerenciamento ou gestão de recursos, sejam estes recursos computacionais ou não. Através da
sua capilaridade: capacidade de chegar a diversos pontos; e da abrangência: que possibilita a disseminação ordenada das
informações.

Classificação das redes de computadores
As redes de computadores podem ser diferenciadas em função da sua abrangência geográfica, quanto à conectividade, em
função da forma de gerenciamento e quanto à arquitetura.
Aplicações das redes de computadores
Como já mencionado, as redes são utilizadas para o compartilhamento de recursos, como os de impressão e armazenamento,
captura, armazenagem e tratamento de voz, sons e imagens. Também são utilizadas para a troca de informações como no caso do
e-mail, a troca de arquivos (FTP), as mensagens instantâneas, a TV e os vídeos sob demanda. Através das redes é possível fazer o
compartilhamento de informações pessoais (blogs e redes sociais), profissionais, educacionais e governamentais.
As redes também podem suportar serviços de telefonia, além disso podem ser estabelecidas redes de computadores com o
propósito de utilizar a computação paralela ou distribuída, na operação de redes de radiotelescópios, sensores e radares com uso
em astronomia, climatologia, energia, etc.

Assista o vídeo “Guerreiros da Internet”, que vai contar um pouco como funciona a internet.
https://www.youtube.com/watch?v=Iqcp3k8DgGw
PESQUISE
Topologia ou arquitetura de uma rede de computadores
É a forma através da qual os computadores e demais componentes ou dispositivos da rede estão organizados, ligados ou
conectados entre si. Esta ligação pode ocorrer:
De forma física: a topologia física expressa a aparência ou leiaute, e a lógica representa o fluxo dos dados na rede. Representa
ainda, como as redes estão conectadas (leiaute físico) e o meio de conexão dos dispositivos de redes (nós ou nodos). A forma com
que os meios de transmissão, computadores e os dispositivos de rede estão conectados influencia os aspectos críticos, como a
flexibilidade, velocidade e segurança.
De forma lógica: a topologia lógica trata da maneira como os dados trafegam através da rede a partir de um computador ou
dispositivo para o outro, desconsiderando as ligações físicas entre eles; e é associada ao controle do meio de acesso (mídia, ou

meio de transmissão), podendo ser reconfigurada dinamicamente em tipos especiais de equipamentos, como roteadores e

switches.

Meios de transmissão
Os meios de transmissão são os canais, as vias ou condutores pelos quais os computadores e os dispositivos de rede enviam e
recebem os dados. Eles são capazes de transportar sinais elétricos e eletromagnéticos (ondas de rádio) e a luz, que por sua vez
carregam as informações em sua menor unidade, o bit. Ou seja, os meios de transmissão compõem as vias físicas percorridas
pelos sinais que transportam os dados de um nó a outro da rede.
Cabos elétricos: um dos mais utilizados são os cabos elétricos, condutores metálicos apresentados na forma de cabos telefônicos,
cabos coaxiais, pares de fios trançados e a própria rede elétrica que leva energia às edificações em geral.
Estes cabos apresentam a vantagem de ser de fácil instalação em curtas distâncias e ambientes urbanos, e também de já existirem
em alta quantidade, em função das instalações de serviços de telefonia e de energia elétrica, por exemplo. Entretanto, apesar disso
apresentam inúmeras desvantagens, tais como o alto custo, devido ao fato de serem compostos de metais como cobre, alumínio e
até mesmo ouro e prata, em casos especiais.

Por serem condutores sofrem a interferência de sinais elétricos e eletromagnéticos, descargas atmosféricas (raios), tensionamento,
variação de temperatura, radiação ultravioleta (do sol) e oxidação, necessitando de constante manutenção para evitar problemas
de segurança. Outro problema também é a ocupação de espaço e a falta de flexibilidade, por isso tem sido cada vez menos
utilizado em longas distâncias.
Cabos ópticos: outro importante meio de transmissão de dados é a fibra ótica ou os cabos ópticos, utilizados cada vez mais para
as conexões a longa distância e altas velocidades. Diferentemente dos cabos elétricos, os cabos ópticos são isolantes – feitos à
base de sílica, o mesmo produto com o qual se faz o vidro, daí a denominação popular de fibra de vidro.
Os cabos ópticos também apresentam inúmeras vantagens, como possibilitar o tráfego em altíssimas velocidades, a grande
imunidade a ruído e interferências elétricas e eletromagnéticas, uma vez que transporta a luz, tem um custo menor e apresenta
maior durabilidade. Além disso oferece menores perdas de qualidade mesmo em longas distâncias. Por outro lado, requer muitos
cuidados durante a instalação e sua manutenção é muito complexa, resultando em alto custo.
Para os casos de comunicação entre pontos muito distantes, como a interligação entre continentes através de cabos submarinos,
por exemplo, a necessidade de regeneração e repetição do sinal de luz é algo que requer tecnologias de alto custo e complexidade.

Ar ou espaço: o ar ou o espaço, ou também a atmosfera, é um importante meio de transmissão, no qual podem transitar sinais
luminosos (luz visível, infravermelho ou laser) ou as ondas eletromagnéticas (sinais de rádio frequência). Este meio é o que suporta
as comunicações sem fio (Bluetooth, Wireless ou Wi-fi, Mobile, Satélite, Micro-ondas etc.).
As vantagens deste meio de transmissão vão desde o fato de ser um isolante – em que pese que as descargas atmosféricas
percorram o ar, permitir a transmissão multidirecional (omnidirecional ou em todas as direções), e a possibilidade de atingir longas
distâncias sem a necessidade de instalação de dispositivos intermediários.
Por outro lado, a instalação e manutenção dos transmissores e receptores pode ser difícil e cara, e o sinal transmitido sofre
inúmeras interferências, desde as provocadas por outros dispositivos, como motores, eletrodomésticos, equipamentos industriais,
até a radiação solar. Além disso o espectro de frequências disponíveis é limitado e disputado com outros usuários, como as
emissoras de rádio e televisão, os sistemas de telecomunicações e radares, etc. Outro aspecto de grande preocupação para a
comunicação por rádio ou através da atmosfera é a segurança, uma vez que o sinal se espalha e pode ser captado por qualquer
um.
Luz: o uso da luz (visível ou invisível, infravermelho ou laser) para a comunicação atmosférica resolve alguns dos problemas que
afetam a radiocomunicação, e tem características semelhantes, porém com custos menores tanto para instalação ou manutenção.

Ao mesmo tempo, apresenta dificuldades para distâncias maiores e também sofre com a interferência ou bloqueio do sinal
luminoso.
Um fator de grande importância para os meios de comunicação são as conexões físicas, isto é, a forma de prover o contato
elétrico ou mecânico entre condutores ou o meio de comunicação e os diversos dispositivos ou equipamentos.
Por ser uma estrutura mecânica ou por ter necessidade de fazer contato, são os principais causadores de perdas e ruídos, e estão
entre os principais itens que requerem manutenção contínua. Saber diferenciá-los e escolher os mais adequados pode ser a
diferença entre ter uma rede confiável, segura e com alto desempenho ou uma que causa mais problemas do que o tolerável.
Quer complementar seus estudos? Então acesse a Biblioteca Virtual, no portal Único, e confira o livro “Rede de Computadores”!

TROCANDO IDEIAS
Acesse o fórum “Tecnologias das Redes de Computadores” e exponha os resultados de seu aprendizado durante essa aula.
Compartilhe suas descobertas, suas experiências, exponha suas dúvidas, aproveite para fazer contato com seus colegas de curso
ou de turma, com os tutores, e discuta o que aprendeu, e assim reforce seu conhecimento e esclareça suas dúvidas.
NA PRÁTICA
Falamos na aula de hoje sobre vários tipos de conectividade, e um desses tipos é a computação na nuvem ou cloud computing.
Mas você tem ideia de como isso funciona? Para saber mais sobre o assunto, faça uma pesquisa sobre a computação na nuvem.
Tente descobrir como funciona essa conectividade e em que situações é mais utilizada.
Para ajudá-lo na sua pesquisa, selecionamos alguns materiais que podem lhe ajudar. Clique nos ícones a seguir e confira!
https://www.youtube.com/watch?v=FDFejm-ovtI

http://www.infowester.com/cloudcomputing.php

SÍNTESE
Nessa primeira aula conhecemos as redes de computadores, suas classificações, suas finalidades e usos. Também aprendemos
sobre os tipos de rede e as tecnologias empregadas na construção destas redes de computadores, possibilitando a troca de
informação desde os mais pequenos espaços até as distâncias globais, com qualidade e velocidade.
Além disso, abordamos as formas como são organizados os dispositivos que compõem as redes de computadores, definindo assim
a topologia ou arquitetura. Também aprendemos sobre os vários meios de transmissão utilizados, suas características, vantagens e
desvantagens, assim como os dispositivos utilizados para prover a conexão física dos componentes e dos meios de transmissão.
COMPARTILHANDO
Que tal repartir com os outros os conhecimentos que você adquiriu? Discuta com os seus colegas de curso e de turma, o pessoal
do trabalho, profissionais da área de telecomunicações, os seus amigos e seus familiares. Pergunte o que eles sabem sobre o
assunto e apresente para eles o que viu e ouviu até aqui.
Até a próxima!



Rota de Aprendizagem
Redes de Computadores
Aula 02

Aula 02 - Parte 1 – Redes de Computadores
Introdução
Nesta aula vamos tratar dos protocolos de comunicação, da divisão do processo de
comunicação das redes de computadores em camadas especializadas, e dos principais
modelos de organização dos protocolos em camadas: o modelo ISO/OSI e o modelo TCP/IP.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.4, 3.1, 4.3, 5.1 e 6.2.
 Kurose, 2003 – Seções 1.5, 1.7, 2.1 e 3.1.
Contextualizando
O que são os Protocolos?
Protocolos são as regras aplicadas à comunicação de dados nas redes de computadores
– às informações e aos dispositivos da rede – para possibilitar a compatibilidade entre
diferentes tipos de equipamentos, redes e formatos de informação, e principalmente garantir
que a informação trafegue entre origem e destino de modo efetivo, no menor tempo possível e
mantendo suas qualidades.
Qual é a finalidade dos protocolos?
Em síntese os protocolos servem para avaliar, controlar e garantir o fluxo de dados
pela rede. Devido à complexidade do processo de comunicação de dados, existem inúmeros
protocolos. Para tornar mais simples a organização, estes protocolos são divididos em
camadas, as quais são voltadas para tratamentos específicos da informação.
O que são as camadas dos protocolos?
As camadas são o resultado da divisão da complexa tarefa de comunicação de dados
entre computadores através da aplicação de regras – os protocolos – ao hardware, firmware,
software, sinais elétricos, óticos e eletromagnéticos. Cada camada trata de aspectos
específicos do processo de comunicação, especializando-se em receber a informação da
camada anterior, decodificar, tratar e em seguida repassar para a camada seguinte. Este

1

Rota de Aprendizagem
Redes de Computadores
Aula 02

processo funciona tanto na origem da comunicação como no seu destino, e cada camada trata
as informações para executar suas tarefas e entregas às outras camadas um resultado:
 Reconhecer e tratar os protocolos aplicáveis;
 Executar os procedimentos específicos;
 Aplicar os métodos de tratamento de dados.
Uma camada identifica a sua equivalente ou correspondente na origem da informação
através de um rótulo ou cabeçalho anexado aos dados, o qual complementa o pacote de
dados encapsulados que recebe.
O modelo ISO / OSI
O modelo ISO/OSI é um padrão da ISO - International Standard Organization para a
interconexão de sistemas abertos (Open Systems Interconnection). É formado por sete
camadas ou níveis de tratamento da informação:
1 - Física
2 - Enlace
3 - Rede
4 - Transporte
5 - Sessão
6 - Apresentação
7 - Aplicação
Para que serve?
O modelo OSI/ISO tem por finalidade estabelecer um padrão para a comunicação entre
sistemas computacionais, que podem ser de tipos diferentes. Isto é feito pelo tratamento da
informação em cada camada, as quais contemplam protocolos e funções distintas,
apresentadas a seguir.
Camada 1 - Física
A camada física possibilita a ligação física de duas estações diferentes. É esta camada que trata
da interação entre o hardware e os mecanismos de sinalização. Define os padrões de
hardware, do cabeamento, das conexões, a fiação, potência do sinal, frequência de operação e
a forma de codificar os dígitos binários, os BITs. Esta camada fornece seus serviços para a
camada de enlace ou link de dados. Ela estabelece a ligação entre os nós da rede, com ou sem
fio, através de um meio de transmissão.
Camada 2 - Enlace ou link de dados
É a que faz a conversão do fluxo de dados recebido da camada de rede para os sinais a serem
transmitidos pela camada 1, interagindo com o hardware. Do lado do receptor da transmissão
a camada de enlace de dados recebe os dados de hardware, transformados de sinais elétricos

2

Rota de Aprendizagem
Redes de Computadores
Aula 02

em BITs pela camada 1, e os agrupa em um formato de QUADRO reconhecível,
disponibilizando este quadro para a camada de rede.
É dividida em:
 Controle lógico do link: Cuida dos protocolos, controle de fluxo e do controle de erros.
 Controle de acesso ao meio (MAC - Media Access Control): Realiza o controle dos meios
de comunicação. Contém o endereço físico da mídia (“placa” ou “cartão” de rede)
denominado MAC Address.
Camada 3 - Rede
É a camada ou nível que:
 Cuida da atribuição de endereços aos hosts. É nesta camada que o endereço lógico é
configurado, reconhecido e tratado;
 Trata da definição do roteamento, isto é, o caminho pelo qual os pacotes de informação
serão enviados até o destino;
 Faz o controle da transmissão, adequando o fluxo de dados às características do meio
de transmissão (como a velocidade, por exemplo);
 Realiza o tratamento de erros de transmissão, fazendo a detecção e providenciando a
correção dos erros;
 Mantém as tabelas de roteamento ou rotas estáticas;
 Controla a formação dos pacotes de dados de entrada e saída e faz o encaminhamento
de acordo com a qualidade e as restrições do serviço;
 Possibilita a conexão entre redes diferentes;
 Busca a entrega de pacotes para o destino com o menor esforço;
 Fornece os mecanismos para a comunicação através de conexões ou a comunicação
sem conexão.
Além disso, provê os seguintes serviços e recursos:








Gerenciamento da qualidade dos serviços (QoS – Quality of Service);
Balanceamento de carga e gerenciamento de link de dados;
Segurança;
Interação entre diferentes protocolos e a comunicação entre redes diferentes;
Configuração de uma rede lógica sobre a rede física.
Utilização de VPN - Virtual Privative Network ou Rede Privativa Virtual nível L3
Túneis para a conexão dedicada ponto-a-ponto.

É na camada de rede que atuam os roteadores, tratando do encaminhamento (ou roteamento)
dos pacotes e da distribuição da transmissão, que pode ser:
 Unicast: destinado a um único host;
 Multicast: destinado a um grupo de hosts;

3

Rota de Aprendizagem
Redes de Computadores
Aula 02

 Broadcast: destinado a todos os hosts da rede;
 Anycast: destinado aos hosts mais próximos.
É importante destacar que um roteador não encaminha o Broadcast por padrão. Já o tráfego
Multicast recebe um tratamento especial, normalmente por ser um fluxo de vídeo ou de áudio
com maior prioridade. Anycast é semelhante ao Unicast, porém os pacotes são entregues no
destino mais próximo quando vários destinos estão disponíveis.
Camada 4 - Transporte
É a camada que responde pela entrega dos pacotes de dados aos hosts, cuidando da
comunicação de ponta a ponta, entre host que podem nem mesmo pertencer à mesma rede.
Suas principais atribuições são:
 Divide os dados fornecidos pela camada de aplicação em unidades menores, chamadas
segmentos, numerando-os e mantendo o registro de cada segmento.
 Assegura que os dados devem ser recebidos na mesma sequência em que foram
enviados.
 Além dos endereços de rede são associados aos segmentos um número de porta.
 Por sua vez estas portas estão associadas a determinados tipos de serviço e às
aplicações que os utilizam.
 As portas também são numeradas e tem usos definidos.
Camada 5 - Sessão
Nesta camada são estabelecidas as sessões de comunicação entre os hosts. Sessões são
definidas por intervalos de tempo nos quais um serviço é fornecido ou uma atividade é
realizada. Para iniciar uma sessão é necessário realizar uma autenticação, isto é, identificar
quem está solicitando o serviço ou a atividade.
Esta camada também cuida do reconhecimento de nomes e do registro das atividades (log) na
rede.
Camada 6 - Apresentação
Nesta camada é tratado o formato dos dados a serem apresentados pelos aplicativos. Pode-se
considerá-la com ar como o serviço tradutor da rede. Entre outros serviços, fornece a
conversão de códigos de caracteres, conversão, compactação / descompactação e criptografia
de dados;
Camada 7 - Aplicativo
Esta camada é a que interage com os programas de aplicação ou aplicativos do usuário para
que estes possam utilizar os serviços da rede. Entre suas funcionalidades encontram-se:
 O redirecionamento de dispositivo e o compartilhamento de recursos;
 O acesso a arquivos, dados e impressoras remotas;
 A comunicação entre processos, o gerenciamento de rede e os serviços de diretório;

4

Rota de Aprendizagem
Redes de Computadores
Aula 02

 O suporte para as mensagens eletrônicas, como e-mail e instant messengers, por
exemplo;
 Os terminais virtuais de rede;
Para pesquisar:
Links: https://support.microsoft.com/pt-br/help/103884/the-osi-model-s-seven-layersdefined-and-functions-explained
Vídeo: https://youtu.be/QaZwabhBbCw

5

Rota de Aprendizagem
Redes de Computadores
Aula 02

Aula 01 - Parte 2 – Redes de Computadores
Introdução
Nesta aula vamos tratar do protocolo TCP/IP. Nosso objetivo é fazer uma analogia com
o modelo OSI/ISO, conhecer os detalhes de funcionamento e toda a suíte de protocolos que
compõem o modelo TCP/IP.
Contextualizando
O que é o protocolo TCP/IP?
Transmission Control Protocol/Internet Protocol suite é um conjunto de protocolos
utilizado pela Internet. Por isso também é chamado de Internet Model.
De modo análogo ao modelo ISO/OSI, é apresentado em camadas, porém, ao invés das
sete camadas do modelo OSI/ISO, contém quatro camadas interdependentes, a saber:
 Interface de rede
 Inter rede ou internet
 Transporte
 Aplicação
Para que serve?
Cada camada contempla os protocolos específicos e as funções desempenhadas por
estes protocolos.
A camada de rede especifica o tratamento dos bits, isto é, como a informação vai ser
repassada para o meio físico por meio das interfaces eletrônicas. Nesta camada estão as
tecnologias voltadas para o hardware, como o Ethernet e Token Ring.
A camada de internet é a que contempla o IP – Internet Protocol, que trata do
empacotamento dos dados (IP Datagrams) e de seu encaminhamento, isto é, do roteamento
do pacote pela rede. A face mais característica é o endereço IP, um conjunto de números que
representa o endereço de cada host para a rede.

6

Rota de Aprendizagem
Redes de Computadores
Aula 02

A camada de transporte é a responsável pelo nível de serviço e pelo controle da
conexão que provê o transporte das informações pelas rotas da rede. Nela estão definidos os
protocolos TCP e UDP.
A camada de aplicação cuida dos protocolos de aplicação e de como a aplicação realiza
a comunicação com os serviços da camada de transporte. Nesta camada estão os protocolos
como HTTP, SMTP e DHCP.
A camada de rede
Esta camada é responsável pelo envio e recebimento dos dados reais pelos meios
físicos, independentemente da tecnologia, do modelo ou arquitetura de rede. Esta
independência é de grande importância para a Internet, pois trata-se de uma rede bastante
diversificada em termos de arquitetura ou topologia e também de tecnologias.
A camada internet ou Inter redes
Provê o endereçamento e o reconhecimento dos hosts ativos na rede, e também trata
do roteamento dos pacotes pela rede. O Internet Protocolo (IP) atua nesta camada, que
responde pelo endereçamento lógico dos hosts (endereço IP).
A camada de transporte
Esta camada define como os dados devem trafegar entre os hosts, assegurando-se que
tenham sido devidamente encaminhados e entregues em ordem. O principal protocolo desta
camada é o TCP – Transmission Control Protocol ou protocolo de controle de transmissão. E há
também o UDP – User Datagram Protocol, um protocolo mais simples que o TCP, que não
apresenta a garantia da entrega.
A camada de aplicação
Esta camada define o protocolo que permite ao usuário e a aplicação a interagir com a
própria rede. Nesta camada estão os protocolos como o FTP, o HTTP, o SMTP, etc.

7

Rota de Aprendizagem
Redes de Computadores
Aula 02

Características do modelo TCP/IP
Os protocolos do modelo TCP/IP são destinados ao controle do processo de
transmissão e recepção de dados na rede, sem requerer uma topologia ou conjunto específico
de hardware ou software. O TCP/IP permite a conexão entre hosts que não estão fisicamente
conectados, promovendo o roteamento dos pacotes na rede pelos caminhos mais adequados e
cuidando do fluxo de informação de ponto a ponto (da origem ao destino), com a detecção e
correção de falhas se necessário (no caso do TCP).
O endereço IP
É um conjunto de quatro grupos de números binários de oito bits (bytes ou octetos),
podendo variar de 0 (20) a 255 (28 – 1). É o identificador único de um host (ou interface) em
uma rede específica. A composição, a formatação e as características deste número serão
estudadas em um tópico específico da disciplina. Os grupos de números são representados
por dígitos decimais separados por pontos. Como exemplo, veja os seguintes endereços IP:
 192.168.0.1
 172.30.10.1
 10.250.52.15
O processo de comunicação por meio do TCP/IP
O processo de comunicação com o TCP/IP ocorre em etapas bem definidas, como segue:
1. A comunicação pela rede por meio do TCP/IP inicia-se com o empacotamento dos
dados.
2. Os pacotes são numerados sequencialmente para manter a ordem e identificação.
3. Os pacotes numerados são colocados no meio de transmissão pelos protocolos da
suíte, e então enviados individualmente para o IP do destinatário. Cada pacote
segue pela melhor rota possível no momento, até o endereço do host destino.
4. Para cada pacote recebido o destinatário informa o seu recebimento ao remetente.
Caso algum pacote não seja recebido em um determinado tempo, é enviado
novamente.

8

Rota de Aprendizagem
Redes de Computadores
Aula 02

5. Os pacotes recebidos são então colocados na ordem da origem e a informação
completa é reconstruída.
Pesquisa
Você sabe como surgiu a Internet? Quem foi o seu criador? Já ouviu falar em Arpanet?
Que tal pesquisar na bibliografia e na própria internet?
Trocando Ideias
Acesse o fórum sobre PROTOCOLOS e compartilhe suas descobertas, suas experiências,
exponha suas dúvidas... Faça contato com seus colegas de curso e de turma e discuta o que
aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula foram apresentados os protocolos e as camadas às quais as informações
que trafegam pelas redes são submetidas para tratamento, envio, encaminhamento e
recepção. Também foram abordados o modelo ISO/OSI com suas sete camadas de tratamento
das informações na rede e o modelo TCP/IP, com suas quatro camadas.
Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos com seus
colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo
apresentado.
Autoavaliação
 O que são e para que servem os protocolos?
 Porque a comunicação por redes é tratada em camadas?
 No modelo ISO/OSI qual é a camada que acessa os meios de transmissão?
 Qual é a camada do modelo ISO/OSI que faz o tratamento e a correção dos erros?
 Qual é a principal diferença entre as camadas 1, 2 e 3 do modelo ISO/OSI e a camada 1
do modelo TCP/IP?

9

Rota de Aprendizagem
Redes de Computadores
Aula 02

Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova
abordagem. São Paulo. Pearson, 2003.

10



CONVERSA INICIAL
Nesta aula vamos tratar dos protocolos de comunicação, da divisão do processo de comunicação das redes de computadores em
camadas especializadas, e dos principais modelos de organização dos protocolos em camadas: o modelo ISO/OSI e o modelo
TCP/IP.
Nosso objetivo é fazer uma analogia com o modelo OSI/ISO, conhecer os detalhes de funcionamento e toda a suíte de protocolos
que compõem o modelo TCP/IP.
CONTEXTUALIZANDO
Os protocolos são as regras aplicadas à comunicação de dados nas redes de computadores – às informações e aos dispositivos da
rede – para possibilitar a compatibilidade entre diferentes tipos de equipamentos, redes e formatos de informação, e

principalmente garantir que a informação trafegue entre origem e destino de modo efetivo, no menor tempo possível e mantendo
suas qualidades.
Em síntese, os protocolos servem para avaliar, controlar e garantir o fluxo de dados pela rede. Devido à complexidade do processo
de comunicação de dados, existem inúmeros protocolos. Para tornar mais simples a organização, estes protocolos são divididos em
camadas, as quais são voltadas para tratamentos específicos da informação.
As camadas são o resultado da divisão da complexa tarefa de comunicação de dados entre computadores através da aplicação de
regras – os protocolos – ao hardware, firmware, software, sinais elétricos, ópticos e eletromagnéticos. Cada camada trata de
aspectos específicos do processo de comunicação, especializando-se em receber a informação da camada anterior, decodificar,
tratar e em seguida repassar para a camada seguinte. Este processo funciona tanto na origem da comunicação como no seu
destino, e cada camada trata as informações para executar suas tarefas e entregar às outras camadas um resultado:
 Reconhecer e tratar os protocolos aplicáveis;
 Executar os procedimentos específicos;
 Aplicar os métodos de tratamento de dados.

Uma camada identifica a sua equivalente ou correspondente na origem da informação, através de um rótulo ou cabeçalho
anexado aos dados, o qual complementa o pacote de dados encapsulados que recebe.
O modelo ISO / OSI
O modelo ISO/OSI é um padrão da ISO (International Standard Organization) para a interconexão de sistemas abertos (Open

Systems Interconnection).

Esse modelo tem por finalidade estabelecer um padrão para a comunicação entre sistemas computacionais, que podem ser de tipos
diferentes. Isto é feito pelo tratamento da informação em cada uma das sete camadas, as quais contemplam protocolos e funções
distintas. Clique sobre cada uma delas, e conheça suas características:
Camada 1 - Física
A camada física possibilita a ligação física de duas estações diferentes. É esta camada que trata da interação entre o hardware e os
mecanismos de sinalização. Define os padrões de hardware, do cabeamento, das conexões, a fiação, potência do sinal, frequência
de operação e a forma de codificar os dígitos binários, os bits. Esta camada fornece seus serviços para a camada de enlace ou link
de dados. Ela estabelece a ligação entre os nós da rede, com ou sem fio, através de um meio de transmissão.

Camada 2 - Enlace ou link de dados
É a que faz a conversão do fluxo de dados recebido da camada de rede para os sinais a serem transmitidos pela camada 1,
interagindo com o hardware. Do lado do receptor da transmissão a camada de enlace de dados recebe os dados de hardware,
transformados de sinais elétricos em bits pela camada 1, e os agrupa em um formato de QUADRO reconhecível, disponibilizando
este quadro para a camada de rede. É dividida em:


Controle lógico do link: Cuida dos protocolos, controle de fluxo e do controle de erros.



Controle de acesso ao meio (MAC - Media Access Control): Realiza o controle dos meios de comunicação. Contém o endereço
físico da mídia (“placa de rede”) denominado MAC Address.

Camada 3 – Rede
É a camada ou nível que cuida da atribuição de endereços aos hosts. É nesta camada que o endereço lógico é configurado,
reconhecido e tratado:


Trata da definição do roteamento, isto é, o caminho pelo qual os pacotes de informação serão enviados até o destino;



Faz o controle da transmissão, adequando o fluxo de dados às características do meio de transmissão (como a velocidade, por
exemplo);



Realiza o tratamento de erros de transmissão, fazendo a detecção e providenciando a correção dos erros;



Mantém as tabelas de roteamento ou rotas estáticas;



Controla a formação dos pacotes de dados de entrada e saída e faz o encaminhamento de acordo com a qualidade e as
restrições do serviço;



Possibilita a conexão entre redes diferentes;



Busca a entrega de pacotes para o destino com o menor esforço;



Fornece os mecanismos para a comunicação através de conexões ou a comunicação sem conexão.

Além disso, provê os seguintes serviços e recursos:


Gerenciamento da qualidade dos serviços (QoS – Quality of Service);



Balanceamento de carga e gerenciamento de link de dados;



Segurança;



Interação entre diferentes protocolos e a comunicação entre redes diferentes;



Configuração de uma rede lógica sobre a rede física.



Utilização de VPN - Virtual Privative Network ou Rede Privativa Virtual nível L3



Túneis para a conexão dedicada ponto-a-ponto.

É na camada de rede que atuam os roteadores, tratando do encaminhamento (ou roteamento) dos pacotes e da distribuição da
transmissão, que pode ser:


Unicast: destinado a um único host;



Multicast: destinado a um grupo de hosts;



Broadcast: destinado a todos os hosts da rede;



Anycast: destinado aos hosts mais próximos.

É importante destacar que um roteador não encaminha o Broadcast por padrão. Já o tráfego Multicast recebe um tratamento
especial, normalmente por ser um fluxo de vídeo ou de áudio com maior prioridade. Anycast é semelhante ao Unicast, porém os
pacotes são entregues no destino mais próximo quando vários destinos estão disponíveis.

Camada 4 - Transporte
É a camada que responde pela entrega dos pacotes de dados aos hosts, cuidando da comunicação de ponta a ponta, entre host
que podem nem mesmo pertencer à mesma rede. Suas principais atribuições são:


Divide os dados fornecidos pela camada de aplicação em unidades menores, chamadas segmentos, numerando-os e
mantendo o registro de cada segmento.



Assegura que os dados devem ser recebidos na mesma sequência em que foram enviados.



Além dos endereços de rede são associados aos segmentos um número de porta.



Por sua vez estas portas estão associadas a determinados tipos de serviço e às aplicações que os utilizam.



As portas também são numeradas e tem usos definidos.

Camada 5 - Sessão
Nesta camada são estabelecidas as sessões de comunicação entre os hosts. Sessões são definidas por intervalos de tempo nos
quais um serviço é fornecido ou uma atividade é realizada. Para iniciar uma sessão é necessário realizar uma autenticação, isto é,
identificar quem está solicitando o serviço ou a atividade.
Esta camada também cuida do reconhecimento de nomes e do registro das atividades (log) na rede.
Camada 6 - Apresentação
Nesta camada é tratado o formato dos dados a serem apresentados pelos aplicativos. Pode-se considerá-la como o serviço
tradutor da rede. Entre outros serviços, fornece a conversão de códigos de caracteres, conversão, compactação e descompactação
e criptografia de dados.

Camada 7 - Aplicativo
Esta camada é a que interage com os programas de aplicação ou aplicativos do usuário para que estes possam utilizar os serviços
da rede. Entre suas funcionalidades encontram-se:


O redirecionamento de dispositivo e o compartilhamento de recursos;



O acesso a arquivos, dados e impressoras remotas;



A comunicação entre processos, o gerenciamento de rede e os serviços de diretório;



O suporte para as mensagens eletrônicas, como e-mail e instant messengers, por exemplo;



Os terminais virtuais de rede.

Conheça mais algumas características das 7 camadas do modelo ISO/OSI, lendo o texto a seguir e assistindo ao vídeo indicado.
Confira!
https://support.microsoft.com/pt-br/kb/103884/pt-br
https://youtu.be/QaZwabhBbCw

PESQUISE
Vamos conhecer o protocolo TCP/IP?

Transmission Control Protocol/Internet Protocol suite é um conjunto de protocolos utilizado pela Internet, por isso também é
chamado de Internet Model.
De modo análogo ao modelo ISO/OSI, é apresentado em camadas, porém, ao invés das sete camadas do modelo OSI/ISO, contém
quatro camadas interdependentes:
 Interface de rede
 Inter-rede ou internet
 Transporte
 Aplicação
Cada camada contempla os protocolos específicos e as funções desempenhadas por estes protocolos.
Conheça as características específicas de cada uma delas:

Camada de rede
A camada de rede especifica o tratamento dos bits, isto é, como a informação vai ser repassada para o meio físico por meio das
interfaces eletrônicas. Nesta camada estão as tecnologias voltadas para o hardware, como o Ethernet e Token Ring.
Esta camada é responsável pelo envio e recebimento dos dados reais pelos meios físicos, independentemente da tecnologia, do
modelo ou arquitetura de rede. Esta independência é de grande importância para a Internet, pois trata-se de uma rede bastante
diversificada em termos de arquitetura ou topologia e também de tecnologias.
Camada internet ou inter-redes
A camada de internet é a que contempla o IP – Internet Protocol, que trata do empacotamento dos dados (IP Datagrams) e de seu
encaminhamento, isto é, do roteamento do pacote pela rede. A face mais característica é o endereço IP, um conjunto de números
que representa o endereço de cada host para a rede.
Provê o endereçamento e o reconhecimento dos hosts ativos na rede, e também trata do roteamento dos pacotes pela rede. O
Internet Protocolo (IP) atua nesta camada, que responde pelo endereçamento lógico dos hosts (endereço IP).

Camada de transporte
A camada de transporte é a responsável pelo nível de serviço e pelo controle da conexão que provê o transporte das informações
pelas rotas da rede. Nela estão definidos os protocolos TCP e UDP.
Esta camada define como os dados devem trafegar entre os hosts, assegurando-se que tenham sido devidamente encaminhados e
entregues em ordem. O principal protocolo desta camada é o TCP – Transmission Control Protocol ou protocolo de controle de
transmissão. E há também o UDP – User Datagram Protocol, um protocolo mais simples que o TCP, que não apresenta a garantia
da entrega.
Camada de aplicação
A camada de aplicação cuida dos protocolos de aplicação e de como a aplicação realiza a comunicação com os serviços da camada
de transporte. Nesta camada estão os protocolos como HTTP, SMTP e DHCP.
Esta camada define o protocolo que permite ao usuário e a aplicação a interagir com a própria rede. Nesta camada estão os
protocolos como o FTP, o HTTP, o SMTP, etc.

Características do modelo TCP/IP
Os protocolos do modelo TCP/IP são destinados ao controle do processo de transmissão e recepção de dados na rede, sem
requerer uma topologia ou conjunto específico de hardware ou software.
O TCP/IP permite a conexão entre hosts que não estão fisicamente conectados, promovendo o roteamento dos pacotes na rede
pelos caminhos mais adequados e cuidando do fluxo de informação de ponto a ponto (da origem ao destino), com a detecção e
correção de falhas se necessário (no caso do TCP).
Endereço IP
O endereço IP é um conjunto de quatro grupos de números binários de oito bits (bytes ou octetos), podendo variar de 0 (20) a 255
(28 – 1).
Esse endereço é o identificador único de um host (ou interface) em uma rede específica. Os grupos de números são representados
por dígitos decimais separados por pontos, veja os exemplos:
 192.168.0.1
 172.30.10.1

 10.250.52.15

O processo de comunicação por meio do TCP/IP
Esse processo ocorre em cinco etapas bem definidas:
1. A comunicação pela rede por meio do TCP/IP inicia-se com o empacotamento dos dados.
2. Os pacotes são numerados sequencialmente para manter a ordem e identificação.
3. Os pacotes numerados são colocados no meio de transmissão pelos protocolos da suíte, e então enviados
individualmente para o IP do destinatário. Cada pacote segue pela melhor rota possível no momento, até o endereço do
host destino.
4. Para cada pacote recebido o destinatário informa o seu recebimento ao remetente. Caso algum pacote não seja recebido
em um determinado tempo, é enviado novamente.
5. Os pacotes recebidos são então colocados na ordem da origem e a informação completa é reconstruída.

Quer complementar seus estudos? Então acesse a Biblioteca Virtual, no portal Único, e confira o livro “Rede de Computadores”!

TROCANDO IDEIAS
Você sabe como surgiu a Internet? Quem foi o seu criador? Já ouviu falar em Arpanet?
Que tal pesquisar sobre esses assuntos?
Acesse o fórum da nossa disciplina e compartilhe suas descobertas, exponha suas dúvidas. Aproveite e também comente as
postagens dos seus colegas e discuta sobre o que aprendeu. Não deixe de participar!

NA PRÁTICA
Os endereços IP são utilizados para identificar todos os dispositivos conectados à Internet. Sua estrutura precisa estar organizada
de alguma forma para garantir que essa identificação seja eficiente, permitindo separá-los por funções específicas e apontar em
qual localidade determinado endereço está sendo utilizado.
Fique por dentro desse tema tão interessante, assistindo aos vídeos indicados!
https://www.youtube.com/watch?v=jnuHODaLcO8
https://www.youtube.com/watch?v=63M61wttuMk
SÍNTESE
Na aula de hoje, conhecemos os protocolos e as camadas, nos quais as informações que trafegam pelas redes são submetidas para
tratamento, envio, encaminhamento e recepção. Também conhecemos o modelo ISO/OSI, com suas sete camadas de tratamento
das informações na rede; e o modelo TCP/IP, com suas quatro camadas.
Continue pesquisando e aprofundando esses conceitos!

COMPARTILHANDO
Compartilhe seu conhecimento!
Comente com as pessoas e com seus colegas, o que você viu na aula de hoje. Discuta sobre os protocolos de internet e como ele
são usados no nosso dia a dia.
Até a próxima aula!



Rota de Aprendizagem
Redes de Computadores
Aula 03

Aula 03 - Parte 1 – Redes de Computadores
Introdução
Esta aula aborda a conexão entre redes de diversos tipos, o internetworking ou
conexão inter-redes. Para isto vamos apresentar os protocolos da camada 2 do TCP/IP, o
protocolo IP e falar sobre o endereçamento IP.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 5.5 e 5.6.
 Kurose, 2003 – Seções 4.1, 4.4, 4.6 e 4.7.
Contextualizando
O que é o internetworking?
Na atualidade é comum que redes de uma mesma organização estejam dispersas
geograficamente. Também é comum a ligação de duas redes distintas, sejam do mesmo tipo,
ou de diferentes tipos. A conexão ou roteamento entre duas redes é chamada de
internetworking ou conexão inter-redes, e é tratada na camada 2 do protocolo TCP/IP,
principalmente pelo protocolo IP.
As redes podem ser caracterizadas com base em vários parâmetros, tais como os
protocolos empregados, a topologia e a sistemática ou esquema de endereçamento. No
ambiente de internetworking, os roteadores têm conhecimento dos endereços de outros
roteadores e dos endereços de outras redes além da qual eles pertencem. Esta informação
pode ser configurada estaticamente ou os roteadores podem “aprender” os endereços usando
um protocolo de roteamento de internetworking.
Protocolos de roteamento
Os protocolos de roteamento utilizados na rede interna de da organização são
chamados protocolos de gateway interior ou Interior Gateway Protocol (IGP), como por
exemplo os protocolos RIP e OSPF. Roteamento entre diferentes organizações requerem o
Exterior Gateway Protocol (EGP), e há apenas um EGP para cada rede, normalmente o Border
Gateway Protocol (BGP).

1

Rota de Aprendizagem
Redes de Computadores
Aula 03

Pesquisa:
 Existem outros protocolos de roteamento?
 Como funcionam?
 Que tal procurar na bibliografia da disciplina e na internet, entre outros?
Internetworking no TCP/IP e no ISO/OSI
No modelo TCP/IP a camada de Rede combina as camadas de enlace de dados (link) e a
física do modelo ISO/OSI (camadas 1 e 2) para que haja independência da infraestrutura de
rede, lembra-se? A camada superior – camada 2 ou inter-rede, equivalente à camada de rede
(camada 3) do modelo ISO/OSI, trata do roteamento ou encaminhamento de pacotes entre os
nós das redes.
No modelo TCP/IP as camadas de Aplicação, Apresentação e Sessão - camadas 7, 6 e 5
do modelo ISO/OSI - são combinadas e formam a camada de aplicação. Nesta camada estão
presentes os seguintes protocolos ou serviços, entre outros:
 DNS - Domain Name Service ou serviço de nomes do domínio;
 SMTP – Simple Mail Transfer Protocol ou protocolo simples de transferência de correio
 FTP – File Transfer Protocol ou protocolo de transferência de arquivo;
 Ping – serviço / programa de teste de tráfego entre hosts e redes que funciona por
meio de um “eco” de pacotes;
 HTTP – Hyper Text Transfer Protocol ou protocolo de transferência de hipertexto;
 NFS – Network File System ou sistema de arquivo em rede;
 POP – Post Office Protocol ou protocolo de correio;
 Telnet – Terminal Link over Network ou Terminal Virtual da Rede.
As camadas de Enlace e Física – camadas 2 e 1 do modelo ISO/OSI são unificadas na
camada de Rede – camada 1 do TCP/IP. Como já visto, isto se deve à necessidade de preservar,
no TCP/IP, a independência da rede.

2

Rota de Aprendizagem
Redes de Computadores
Aula 03

Pilha de protocolos
Na camada 2 do TCP/IP – camada inter-redes, são definidos os protocolos responsáveis
por tratar da comunicação entre as redes, a saber:
 IP – Internet Protocol ou protocolo internet, é o mais conhecido e mais importante
protocolo

desta

camada,

responsável,

entre

outras

funcionalidades,

pelo

endereçamento dos hosts na Internet, que também chamamos endereço IP. O IP faz o
encaminhamento dos pacotes entre as redes utilizando o endereço IP do host, a máscara de
rede e o gateway padrão. Por exemplo: endereço do host 192.168.1.25, máscara de rede
255.255.255.0 e gateway padrão 192.168.1.1;

 ARP – Address Resolution Protocol, ou protocolo de resolução de endereço, busca o
endereço físico da interface de rede que corresponde a um IP. Este endereço, também
chamado MAC Address, é um número de 48 bits, geralmente representado em
hexadecimal, como por exemplo:
94-eb-cd-26-5d-16
O ARP cria uma tabela em memória com a equivalência entre endereço físico e
endereço IP. É possível acessar esta tabela com o comando ARP –a na linha de
comando do Windows, por exemplo:
Microsoft Windows [versão 6.3.9600]
(c) 2013 Microsoft Corporation. Todos os direitos reservados.
C:\Users\LuisGonzaga>arp -a
Interface: 192.168.25.79 --- 0x3
Endereço IP
Endereço físico
192.168.25.1
06-e0-58-0f-c3-e8
192.168.25.8
2c-e4-12-03-46-4e
192.168.25.11
10-78-d2-49-a1-e1
192.168.25.25
78-e7-d1-55-d3-53
192.168.25.177
88-a7-3c-a6-3e-6f
192.168.25.202
2c-e4-12-00-56-77
192.168.25.255
ff-ff-ff-ff-ff-ff
224.0.0.2
01-00-5e-00-00-02
224.0.0.22
01-00-5e-00-00-16
224.0.0.252
01-00-5e-00-00-fc
224.0.0.253
01-00-5e-00-00-fd
239.255.255.250
01-00-5e-7f-ff-fa

Tipo
dinâmico
dinâmico
dinâmico
dinâmico
dinâmico
dinâmico
estático
estático
estático
estático
estático
estático

Neste exemplo são mostrados todos os endereços IP com os quais o host pode trocar
informações e seus endereços físicos, isto é, os Mac Address.

3

Rota de Aprendizagem
Redes de Computadores
Aula 03

 RARP - Reverse Address Resolution Protocol ou Protocolo de Resolução Reversa de
Endereços associa um endereço físico (MAC Address) conhecido à um endereço IP. É
necessário haver um servidor ou serviço RARP na rede para responder às solicitações
dos hosts, retornando o IP ligado ao MAC Address fornecido. Como o próprio nome diz,
faz o trabalho reverso do ARP.
 ICMP - O Internet Control Message Protocol ou Protocolo Internet de Controle de
Mensagem permite informar os erros ocorridos no processo de comunicação entre
hosts. O protocolo IP não trata os erros, mas os informa às camadas subjacentes que
podem tratar, registrar ou comunicar os erros. Os switches e os routers utilizam o ICMP
para assinalar erros (delivery problem). Um exemplo do uso do ICMP é o comando ping,
que faz uso de mensagens ICMP. O comando solicita um “eco” para um host destino. Se
o host destino devolver o pacote enviado à origem, então pode ser alcançado pela
comunicação.
 IGMP - Internet Group Management Protocol serve para controlar os membros de um
grupo de multicast controlando a entrada e a saída dos hosts deste grupo. Desta forma
o protocolo otimiza os recursos de uma rede, pois os roteadores só enviam multicast
para os hosts de um determinado grupo. Multicast é a transmissão de áudio e/ou vídeo
de um host para um grupo ou conjunto de outros hosts previamente conhecidos. Como
exemplos de uso de multicast estão os jogos em rede, as videoconferências e a
distribuição de vídeo pela rede no formado de Video on Demand - VOD e IP Television
– IPTV.
Exemplos de internetworking
São exemplos típicos de internetworking:
 A comunicação ponto-a-ponto entre dois hosts de redes fisicamente separadas;
 Conexões entre hosts de uma rede local espalhados por locais distintos;
 Uma rede local, podendo ser a de um provedor de conteúdo (ISP), conectada à
internet.

4

Rota de Aprendizagem
Redes de Computadores
Aula 03

Aula 03 - Parte 2 – Redes de Computadores
Introdução
O material na sequência dá continuidade ao estudo da interconexão entre redes, o
internetworking, abordando o endereçamento IP nas duas versões: IPv4 e IPv6.
Endereçamento IP
Todo host conectado à uma rede TCP/IP requer uma identificação exclusiva e universal
perante a rede, de forma que os pacotes endereçados a ele cheguem somente até ele. Para esta
identificação o host é designado por um endereço IP. O endereço é um número binário de 32
bits, que pode endereçar até 4.294.967.296 hosts. Este número, o endereço, pode ser
representado em binário:
01110101 10010101 00011101 00000010
Ou em decimal pontuado, que é a notação mais comum e mais fácil de entender e
memorizar:
117.149.29.2
A notação decimal é resultado da transformação de cada conjunto de oito bits (octetos
ou bytes) em um número decimal, que pode variar de 0 a 255, representando um intervalo de
256 valores (28). Os endereços IPv4 contém 32 bits e são divididos em endereço da rede e
endereço do host. As máscaras de subrede ou simplesmente Mask são conjuntos de bits
que mostram onde o endereço de rede termina e o onde o endereço de host começa. Para isto
são utilizados os bits 1 para as posições do endereço que representam a rede e os bits 0 para
as posições reservadas ao endereço dos hosts da rede.
Endereçamento IP - Classes
O endereço é composto de identificação da rede (endereço da rede ou NetID) e
identificação do host (endereço do host ou HostID). A organização de NetID e de HostID
define a classe de endereço, e a máscara de rede ajuda a identificar o NetID e o HostID, como
mostrado a seguir:

5

Rota de Aprendizagem
Redes de Computadores
Aula 03

As classes são designadas pelas letras A, B, C, D e E. Na Classe A o primeiro bit do
endereço é sempre 0 (zero), resultando em 224 ou 16.777.216 possíveis endereços de hosts (7
bits para NetID e 24 para HostID). Na Classe B os primeiros bits do endereço são sempre 10
(um, zero), resultando em 216 ou 65.536 possíveis endereços de hosts (14 bits para NetID e 16
para HostID). Na Classe C os primeiros bits do endereço são sempre 110 (um, um, zero),
resultando em 28 ou 256 possíveis endereços de hosts (21 bits para NetID e 8 para HostID). Na
Classe D os primeiros bits do endereço são sempre 1110 (um, um, um, zero). Esta classe é
conhecida por Multicast ID, dada a sua utilização padrão para grupos de multicast. Na Classe E
os primeiros bits do endereço são 1111 (um, um, um, um). Esta classe é de uso reservado
pelos gestores de endereços globais para uso em projetos de pesquisa e testes. A seguir uma
demonstração destas classes, na qual “n” refere-se ao NetID e “h” ao HostID.

6

Rota de Aprendizagem
Redes de Computadores
Aula 03

Endereçamento IP – Endereços reservados
Além dos endereços da Classe E existem determinados endereços que são reservados
para uso específico, isto é, nenhum host ou ativo de rede pode ser designado por estes
endereços. São os seguintes, os endereços reservados:
 127.x.x.x - Reservados para testes internos (também chamado de localhost ou
loopback);
 O primeiro e o último endereço da classe ou da sub-rede: O primeiro, por exemplo
192.168.10.0, é o endereço da rede. O último, por exemplo 192.168.255.255, é o
endereço de broadcast para a rede em questão.
Além disso existem os endereços específicos recomendados para as redes locais ou
redes internas conectadas à Internet. As faixas recomendadas para redes locais (internas) são:
 10.0.0.0 a 10.255.255.255
 172.16.0.0 a 172.31.255.255
 192.168.0.0 a 192.168.255.255
É por isto que sempre se verifica a ocorrência destes endereços nos hosts das redes
locais.
Notação Standard e CIDR
Notação Standard começa com o endereço e contém o prefixo que determina o
tamanho (máscara) da rede. Por exemplo, a representação 192.168.0.0 /24 corresponde a
uma sub-rede que contém 254 endereços possíveis, de 192.168.0.1 até 192.168.0.254, com

7

Rota de Aprendizagem
Redes de Computadores
Aula 03

192.168.0.0 sendo o endereço de rede e 192.168.0.255 sendo o endereço de broadcast para
esta rede.
Na representação 192.168.0.0 /22 tem-se uma sub-rede com 1022 possíveis endereços
de hosts, de 192.168.0.1 até 192.168.3.254, com 192.168.0.0 sendo o endereço de rede e
192.168.3.255 sendo o endereço de broadcast para esta rede.
Para o IPv4, uma representação alternativa usa o endereço de rede, escrito na forma
decimal com pontos, seguido da máscara de sub-rede após uma barra. Desta forma o endereço
192.168.0.0 /24 pode ser escrito como 192.168.0.0 255.255.255.0, pois contando os 24 bits da
esquerda para a direita temos:
11111111.11111111.11111111.00000000
Já o endereço 192.168.0.0 /22 pode ser escrito como 192.168.0.0 255.255.252.0, pois
contando os 22 bits da esquerda para a direita, temos:
11111111.11111111.11111100.00000000
A representação com a barra torna mais flexível o endereçamento, liberando-o do
emprego somente das classes-padrão de endereçamento. Por isto é chamada também de CIDR
- Classless Inter-Domain Routing ou Roteamento inter-domínio sem uso de classes, e serve
para o endereçamento e agregação de sub-redes, flexibilizando as máscaras de rede e
permitindo um maior aproveitamento dos endereços.
Endereçamento IP – IPv6
O IPv6 é a versão mais atual do protocolo IP, desenvolvida em função do esgotamento
de faixas de endereço do IPv4. Os endereços são representados por números de 128 bits,
permitindo assim a representação de 2128 hosts. O de, normalmente escritos como oito grupos
de 4 dígitos hexadecimais, como por exemplo:
2001:0db8:85a3:08d3:1319:8a2e:0370:7344
Ao escrever o endereço os grupos de vários dígitos seguidos de zeros (0000) podem
ser omitidos, como por exemplo:
2001:0db8:85a3:0000:0000:0000:0000:7344 é o mesmo endereço IPv6 que
2001:0db8:85a3::7344.

8

Rota de Aprendizagem
Redes de Computadores
Aula 03

Endereçamento IP – DHCP
O DHCP - Dynamic Host Configuration Protocol ou Protocolo de configuração dinâmica
de host é um protocolo de serviço TCP/IP que oferece configuração dinâmica, concessão de
endereços IP de host, máscara de sub-rede e Default Gateway (Gateway Padrão). Isto evita o
cansativo e recorrente trabalho de atribuição de endereços aos hosts de uma rede. O DHCP
funciona do seguinte modo: um host envia um pacote UDP em broadcast com uma requisição
DHCP para a porta 67. Um servidor DHCP que capturar este pacote irá responder, caso o
cliente se enquadrar numa série de critérios, para a porta 68 do host solicitante, com um
pacote contendo um endereço IP, uma máscara de rede e outros dados, como o default
gateway, servidores de DNS, etc.
Endereçamento IP – NAT
O NAT - Network Address Translation ou Tradução de Endereços de Rede é uma técnica
que permite reescrever o endereço de um host de uma rede interna quando este é colocado na
Internet, e vice-versa. Desta forma os endereços da rede interna (rede local), geralmente
padronizados, não são publicados na internet. Desde modo o uso de NAT torna a rede interna
mais protegida e reduz o número de endereços IP necessários para a rede externa. Porém só é
possível utilizar NAT com os protocolos TCP e UDP. É bom ressaltar que o NAT permite um
máximo de 65535 conexões ativas concorrentes, devido ao uso de 16 bits para a identificação
das portas utilizadas para a conversão.
Trocando Ideias
Acesse o fórum sobre ENDEREÇAMENTO e compartilhe suas descobertas, suas
experiências, exponha suas dúvidas. Faça contato com seus colegas de curso e de turma e
discuta o que aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula foi apresentado o conceito de internetworking e o endereçamento IP nas
versões IPv4 e IPv6, tratando também das classes de endereçamento e das máscaras de rede.

9

Rota de Aprendizagem
Redes de Computadores
Aula 03

Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos com seus
colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo
apresentado.
Autoavaliação

1) Cite os intervalos das redes privadas classe A, B e C assim como suas máscaras padrões.
2) Indique os endereços IP válidos para a rede 192.168.15.0, com máscara 255.255.255.0, além
do endereço de broadcast desta rede.
3) Informe a qual classe de endereçamento IP pertence cada um dos endereços IP abaixo, se este
é válido, ou se é de rede, de host, broadcast ou loopback:
a) 145.32.59.24
b) 200. 42.129.16
c) 127.0.23.21
d) 192.128.23.0
e) 172.16.11.255
f) 10.23.20.2
g) 200.234.34.23
h) 136.23.0.2
4) Uma rede composta de 10 hosts necessita de um esquema que represente o layout ou mapa
desta rede, o endereço IP e a máscara de cada um dos hosts. Observação: o endereço da rede
é 192.168.0.0. Você consegue elaborar? Que tal tentar em equipe?
5) Considere a sub-rede da estação de endereço IP 192.168.100.20 e máscara 255.255.255.248.
Pergunta-se: Qual é o endereço de broadcast desta rede?
a)192.168.100.0
b)192.168.100.23
c)192.168.100.255

10

Rota de Aprendizagem
Redes de Computadores
Aula 03

d)192.168.100.248
e)192.168.255.255
6) Uma empresa tem um endereço de rede classe C 200.10.57.0. Para subdividir a rede física em
3 sub-redes de pelo menos 20 hosts por sub-rede, qual dos endereços a seguir é um IP válido
para uma nova rede?
a)200.10.57.5
b)200.10.57.65
c)200.10.57.161
d)200.10.57.194
e)200.10.57.227

7) A rede interna de uma empresa tem os seguintes hosts que não estão conseguindo comunicarse uns com os outros.
a) IP = 192.168.0.1, Mask = 255.255.255.0
b) IP = 192.168.0.2, Mask = 255.255.0.255
c) IP = 192.168.10.3, Mask = 255.255.255.0
d) IP = 193.168.0.4, Mask = 255.255.255
Resolva o problema refazendo o endereçamento.
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.
Na internet:
 http://www.vivaolinux.com.br/artigo/255.255.255.0-A-matematica-das-mascaras-derede/?pagina=6
 http://www.subnet-calculator.com/
 http://www.vivaolinux.com.br/script/Calculadora-de-host-de-uma-rede

11

Rota de Aprendizagem
Redes de Computadores
Aula 03

 http://www.vivaolinux.com.br/dica/GIP-Calculadora-de-Endereco-IP/
 http://meuip.net.br/calculadora-ip.asp
 http://www.calculadora-redes.com/

12





CONVERSA INICIAL
Olá! Seja bem-vindo à mais uma aula da disciplina Rede de Computadores!
Hoje abordaremos a conexão entre redes de diversos tipos, o internetworking ou conexão inter-redes.
Para isto vamos apresentar os protocolos da camada 2 do TCP/IP, o protocolo IP e falar sobre o
endereçamento IP. O material, na sequência, dará continuidade ao estudo da interconexão entre redes,
o internetworking, abordando o endereçamento IP nas duas versões: IPv4 e IPv6.

Se quiser estudar mais sobre o assunto, recomendamos a leitura dos livros: Tanenbaum, 2011 – Seções
5.5 e 5.6. Kurose, 2003 – Seções 4.1, 4.4, 4.6 e 4.7.
CONTEXTUALIZANDO
Para iniciarmos nossos estudos, é necessário entendermos alguns conceitos. O primeiro deles é sobre o

internetworking. Você saberia definir esse termo?
Na atualidade, é comum que redes de uma mesma organização estejam dispersas geograficamente.
Também é comum a ligação de duas redes distintas, sejam do mesmo tipo, ou de diferentes tipos. A
conexão ou roteamento entre duas redes é chamada de internetworking ou conexão inter-redes, e é
tratada na camada 2 do protocolo TCP/IP, principalmente pelo protocolo IP.

As redes podem ser caracterizadas com base em vários parâmetros, tais como os protocolos
empregados, a topologia e a sistemática ou esquema de endereçamento. No ambiente de

internetworking, os roteadores têm conhecimento dos endereços de outros roteadores e dos endereços
de outras redes além da qual eles pertencem. Esta informação pode ser configurada estaticamente ou os
roteadores podem “aprender” os endereços usando um protocolo de roteamento de internetworking.
Protocolos de roteamento
Os protocolos de roteamento utilizados na rede interna da organização são chamados protocolos de

gateway interior ou Interior Gateway Protocol (IGP), como os protocolos RIP e OSPF. Roteamento entre
diferentes organizações requerem o Exterior Gateway Protocol (EGP) e há apenas um EGP para cada
rede, normalmente o Border Gateway Protocol (BGP).

Internetworking no TCP/IP e no ISO/OSI
Você está lembrado de que, no modelo TCP/IP, a camada de Rede combina as camadas de enlace de
dados (link) e a física do modelo ISO/OSI (camadas 1 e 2) para que haja independência da infraestrutura
de rede? A camada superior (camada 2 ou inter-rede, equivalente à camada de rede (camada 3) do
modelo ISO/OSI) trata do roteamento ou encaminhamento de pacotes entre os nós das redes.
No modelo TCP/IP, as camadas de Aplicação, Apresentação e Sessão (camadas 7, 6 e 5 do modelo
ISO/OSI) são combinadas e formam a camada de aplicação. Nesta camada, estão presentes os seguintes
protocolos ou serviços:
 DNS: Domain Name Service ou serviço de nomes do domínio;
 SMTP: Simple Mail Transfer Protocol ou protocolo simples de transferência de correio;

 FTP: File Transfer Protocol ou protocolo de transferência de arquivo;
 Ping: serviço / programa de teste de tráfego entre hosts e redes que funciona por meio de um
“eco” de pacotes;
 HTTP: Hyper Text Transfer Protocol ou protocolo de transferência de hipertexto;
 NFS: Network File System ou sistema de arquivo em rede;
 POP: Post Office Protocol ou protocolo de correio;
 Telnet: Terminal Link over Network ou Terminal Virtual da Rede.
As camadas de Enlace e Física (camadas 2 e 1 do modelo ISO/OSI) são unificadas na camada de Rede
(camada 1 do TCP/IP). Como já visto, isto se deve à necessidade de preservar, no TCP/IP, a
independência da rede.

Pilha de protocolos
Na camada 2 do TCP/IP (camada inter-redes), são definidos os protocolos responsáveis por tratar da
comunicação entre as redes, a saber:
 IP: Internet Protocol ou protocolo internet, é o mais conhecido e mais importante protocolo
desta camada, responsável, entre outras funcionalidades, pelo endereçamento dos hosts na
Internet, que também chamamos endereço IP. O IP faz o encaminhamento dos pacotes entre
as redes utilizando o endereço IP do host, da máscara de rede e do gateway padrão. Por
exemplo: endereço do host 192.168.1.25, máscara de rede 255.255.255.0 e gateway padrão
192.168.1.1.

 ARP: Address Resolution Protocol ou protocolo de resolução de endereço busca o endereço
físico da interface de rede que corresponde a um IP. Este endereço, também chamado MAC

Address, é um número de 48 bits, geralmente representado em hexadecimal, por exemplo:
94-eb-cd-26-5d-16
O ARP cria uma tabela em memória com a equivalência entre endereço físico e endereço IP. É
possível acessar esta tabela com o comando ARP–a, na linha de comando do Windows, por
exemplo:

Microsoft Windows [versão 6.3.9600]
(c) 2013 Microsoft Corporation. Todos os direitos reservados.
C:\Users\LuisGonzaga>arp -a
Interface: 192.168.25.79 --- 0x3
Endereço IP

Endereço físico

Tipo

192.168.25.1

06-e0-58-0f-c3-e8

dinâmico

192.168.25.8

2c-e4-12-03-46-4e

dinâmico

192.168.25.11

10-78-d2-49-a1-e1

dinâmico

192.168.25.25

78-e7-d1-55-d3-53

dinâmico

192.168.25.177

88-a7-3c-a6-3e-6f

dinâmico

192.168.25.202

2c-e4-12-00-56-77

192.168.25.255

ff-ff-ff-ff-ff-ff

dinâmico

estático

224.0.0.2

01-00-5e-00-00-02

estático

224.0.0.22

01-00-5e-00-00-16

estático

224.0.0.252

01-00-5e-00-00-fc

estático

224.0.0.253

01-00-5e-00-00-fd

estático

01-00-5e-7f-ff-fa

estático

239.255.255.250

Neste exemplo são mostrados todos os endereços IP com os quais o host pode trocar informações e
seus endereços físicos, isto é, os Mac Address.

 RARP: Reverse Address Resolution Protocol ou Protocolo de Resolução Reversa de
Endereços, associa um endereço físico (MAC Address) conhecido a um endereço IP. É necessário
haver um servidor ou serviço RARP na rede para responder às solicitações dos hosts, retornando
o IP ligado ao MAC Address fornecido. Como o próprio nome diz, faz o trabalho reverso do ARP.
 ICMP: Internet Control Message Protocol ou Protocolo Internet de Controle de Mensagem,
permite informar os erros ocorridos no processo de comunicação entre hosts. O protocolo IP não
trata os erros, mas os informa às camadas subjacentes que podem tratar, registrar ou comunicar
os erros. Os switches e os routers utilizam o ICMP para assinalar erros (delivery problem). Um
exemplo do uso do ICMP é o comando ping, que faz uso de mensagens ICMP. O comando
solicita um “eco” para um host destino. Se o host destino devolver o pacote enviado à origem,
então pode ser alcançado pela comunicação.

 IGMP: Internet Group Management Protocol, serve para controlar os membros de um
grupo de multicast controlando a entrada e a saída dos hosts deste grupo. Desta forma, o
protocolo otimiza os recursos de uma rede, pois os roteadores só enviam multicast para os hosts
de um determinado grupo. Multicast é a transmissão de áudio e/ou vídeo de um host para um
grupo ou conjunto de outros hosts previamente conhecidos. Como exemplos de uso de multicast
estão os jogos em rede, as videoconferências e a distribuição de vídeo pela rede no formado de

Video on Demand (VOD) e IP Television (IPTV).

Exemplos de internetworking
São exemplos típicos de internetworking:
 A comunicação ponto a ponto entre dois hosts de redes fisicamente separadas;
 Conexões entre hosts de uma rede local espalhados por locais distintos;
 Uma rede local, podendo ser a de um provedor de conteúdo (ISP), conectada à internet.
Vamos saber um pouco mais sobre o assunto? Então aprofunde seus conhecimentos assistindo ao vídeo
que o professor Luís Gonzaga preparou para você! Acesse o material on-line!

PESQUISE
Existem outros protocolos de roteamento? Como funcionam? Que tal fazer uma pesquisa sobre o assunto
na bibliografia da disciplina e na internet? Lembre-se que você pode sempre compartilhar as suas
descobertas com os seus colegas de turma e com o professor da disciplina!
Endereçamento IP
Todo host conectado à uma rede TCP/IP requer uma identificação exclusiva e universal perante a rede,
de forma que os pacotes endereçados a ele cheguem somente até ele. Para essa identificação, o host é
designado por um endereço IP. O endereço é um número binário de 32 bits, que pode endereçar até
4.294.967.296 hosts.

Esse número – o endereço – pode ser representado em binário:
01110101 10010101 00011101 00000010
Ou em decimal pontuado, que é a notação mais comum e mais fácil de entender e memorizar:
117.149.29.2
A notação decimal é resultado da transformação de cada conjunto de oito bits (octetos ou bytes) em um
número decimal, que pode variar de 0 a 255, representando um intervalo de 256 valores (28). Os
endereços IPv4 contêm 32 bits e são divididos em endereço da rede e endereço do host. As
máscaras de subrede, ou simplesmente Mask, são conjuntos de bits que mostram onde o endereço de
rede termina e onde o endereço de host começa. Para isto são utilizados os bits 1 para as posições do
endereço que representam a rede e os bits 0 para as posições reservadas ao endereço do host da rede.

Endereçamento IP - Classes
O endereço é composto de identificação da rede (endereço da rede ou NetID) e identificação do host
(endereço do host ou HostID). A organização de NetID e de HostID define a classe de endereço e a
máscara de rede ajuda a identificar o NetID e o HostID, como mostrado a seguir:

As classes são designadas pelas letras A, B, C, D e E. A seguir, você poderá acompanhar uma
demonstração destas classes, na qual “n” refere-se ao NetID e “h” ao HostID.
Na Classe A, o primeiro bit do endereço é sempre 0 (zero), resultando em 224 ou 16.777.216 possíveis
endereços de hosts (7 bits para NetID e 24 para HostID).

Na Classe B, os primeiros bits do endereço são sempre 10 (um, zero), resultando em 216 ou 65.536
possíveis endereços de hosts (14 bits para NetID e 16 para HostID).

Na Classe C, os primeiros bits do endereço são sempre 110 (um, um, zero), resultando em 28 ou 256
possíveis endereços de hosts (21 bits para NetID e 8 para HostID).

Na Classe D, os primeiros bits do endereço são sempre 1110 (um, um, um, zero). Esta classe é
conhecida por Multicast ID, dada a sua utilização padrão para grupos de mulitcast.

Na Classe E, os primeiros bits do endereço são 11110 (um, um, um, um, zero). Esta classe é de uso
reservado pelos gestores de endereços globais para uso em projetos de pesquisa e testes.

Endereçamento IP – Endereços reservados
Além dos endereços da Classe E, existem determinados endereços que são reservados para uso
específico, isto é, nenhum host ou ativo de rede pode ser designado por esses endereços. Os endereços
reservados são os seguintes:
 127.x.x.x: reservados para testes internos (também chamado de localhost ou loopback);
 O primeiro e o último endereço da classe ou da sub-rede: o primeiro, por exemplo,
192.168.10.0, é o endereço da rede. O último, por exemplo, 192.168.255.255, é o
endereço de broadcast para a rede em questão.

Além disso, existem os endereços específicos recomendados para as redes locais ou redes internas
conectadas à Internet. As faixas recomendadas para redes locais (internas) são:
 10.0.0.0 a 10.255.255.255
 172.16.0.0 a 172.31.255.255
 192.168.0.0 a 192.168.255.255
É por isto que sempre se verifica a ocorrência destes endereços nos hosts das redes locais.

Notação Standard e CIDR
Notação Standard começa com o endereço e contém o prefixo que determina o tamanho (máscara) da
rede. Por exemplo, a representação 192.168.0.0 /24 corresponde a uma sub-rede, que contém 254
endereços possíveis, de 192.168.0.1 até 192.168.0.254, com 192.168.0.0 sendo o endereço de rede e
192.168.0.255 sendo o endereço de broadcast para esta rede.
Na representação 192.168.0.0 /22 tem-se uma sub-rede com 1022 possíveis endereços de hosts, de
192.168.0.1 até 192.168.3.254, com 192.168.0.0 sendo o endereço de rede e 192.168.3.255 sendo o
endereço de broadcast para esta rede.

Para o IPv4, uma representação alternativa usa o endereço de rede, escrito na forma decimal com
pontos, seguido da máscara de sub-rede após uma barra. Desta forma o endereço 192.168.0.0 /24 pode
ser escrito como 192.168.0.0 255.255.255.0, pois, contando os 24 bits da esquerda para a direita,
temos: 11111111.11111111.11111111.00000000
Já o endereço 192.168.0.0 /22 pode ser escrito como 192.168.0.0 255.255.252.0, pois, contando os 22
bits da esquerda para a direita, temos: 11111111.11111111.11111100.00000000
A representação com a barra torna mais flexível o endereçamento, liberando-o do emprego somente das
classes-padrão de endereçamento. Por isso é chamada também de CIDR - Classless Inter-Domain

Routing ou Roteamento inter-domínio sem uso de classes, e serve para o endereçamento e agregação de
sub-redes, flexibilizando as máscaras de rede e permitindo um maior aproveitamento dos endereços.

Endereçamento IP – IPv6
O IPv6 é a versão mais atual do protocolo IP, desenvolvida em função do esgotamento de faixas de
endereço do IPv4. Os endereços são representados por números de 128 bits, permitindo assim a
representação de 2128 hosts. São normalmente escritos como oito grupos de 4 dígitos hexadecimais, por
exemplo:
2001:0db8:85a3:08d3:1319:8a2e:0370:7344
Ao escrever o endereço, os grupos de vários dígitos seguidos de zeros (0000) podem ser omitidos, como
por exemplo:
2001:0db8:85a3:0000:0000:0000:0000:7344
2001:0db8:85a3::7344.

é

o

mesmo

endereço

IPv6

que

Endereçamento IP – DHCP
O DHCP - Dynamic Host Configuration Protocol ou Protocolo de configuração dinâmica de host é um
protocolo de serviço TCP/IP que oferece configuração dinâmica, concessão de endereços IP de host,
máscara de sub-rede e Default Gateway (Gateway Padrão). Isso evita o cansativo e recorrente trabalho
de atribuição de endereços aos host de uma rede.
O DHCP funciona do seguinte modo: um host envia um pacote UDP em broadcast com uma requisição
DHCP para a porta 67. Um servidor DHCP que capturar este pacote irá responder, caso o cliente se
enquadre em uma série de critérios, para a porta 68 do host solicitante, com um pacote contendo um
endereço IP, uma máscara de rede e outros dados, como o default gateway, servidores de DNS etc.

Endereçamento IP – NAT
O NAT (Network Address Translation ou Tradução de Endereços de Rede) é uma técnica que permite
reescrever o endereço de um host de uma rede interna quando este é colocado na Internet e vice-versa.
Desta forma, os endereços da rede interna (rede local), geralmente padronizados, não são publicados na
internet.
Sendo assim, o uso de NAT torna a rede interna mais protegida e reduz o número de endereços IP
necessários para a rede externa. Porém só é possível utilizar NAT com os protocolos TCP e UDP. É bom
ressaltar que o NAT permite um máximo de 65535 conexões ativas concorrentes, devido ao uso de 16
bits para a identificação das portas utilizadas para a conversão.

Vamos assistir à mais uma videoaula do professor Luís Gonzaga. Acesse o material on-line e preste
bastante atenção para não ficar com dúvidas!
TROCANDO IDEIAS
Acesse o fórum sobre ENDEREÇAMENTO e compartilhe suas descobertas e suas experiências. Faça
contato com seus colegas de curso e de turma e discuta o que aprendeu. Esclareça suas dúvidas.
NA PRÁTICA
Vamos entender melhor o que é e como fazer um bom plano de endereçamento IP? Então não perca os
dois vídeos que estão disponíveis a seguir:
https://www.youtube.com/watch?v=h74MVDgfYV8
https://www.youtube.com/watch?v=8GjMjZFUMSk

SÍNTESE
Muito bem! Chegamos ao final de mais uma aula! Hoje, foi apresentado o conceito de internetworking e
o endereçamento IP nas versões IPv4 e IPv6, tratando também das classes de endereçamento e das
máscaras de rede.
Até a próxima!
COMPARTILHANDO
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos com seus colegas de curso e de
trabalho. Procure reforçar o entendimento sobre o conteúdo apresentado.




Rota de Aprendizagem
Redes de Computadores
Aula 04

Aula 04 - Parte 1 – Redes de Computadores
Introdução
Nesta aula serão tratadas as funcionalidades da camada de transporte. Para isto serão
abordados os protocolos da camada 3 do TCP/IP – TCP, UDP e SCTP e suas características
principais.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 6.1 a 6.5.
 Kurose, 2003 – Seções 3.3, 3.5 e 3.7
Contextualizando
O protocolo TCP
O Transmission Control Protocol, ou protocolo de controle de transmissão, é um dos
principais protocolos da Internet. É adequado às redes globais, pois verifica se os dados são
enviados pela rede da forma correta, na sequência apropriada e sem erros. É um protocolo da
camada de transporte do modelo TCP/IP (camada3), sobre o qual se assentam a maioria dos
demais protocolos e aplicações, como o SSH, FTP, HTTP — e praticamente toda a World Wide
Web.
O processo de transmissão nesta camada funciona da seguinte maneira: transmissor e
receptor criam pontos extremos – os sockets. Os Sockets são representados pelo endereço IP
e mais um número de 16 bits, denominado porta. Por exemplo: 192.168.10.1:8080. As
portas com valor abaixo de 1024 são chamadas de portas conhecidas e são reservadas
para serviços específicos do TCP. As portas conhecidas só podem ser inicializadas por
usuários com privilégio. Essas portas podem ser registradas para uso restrito em
www.iana.org (Internet Assigned Numbers Authority ou Autoridade de Designação de
Números da Internet).
Características do TCP
O protocolo TCP tem como principal característica a garantia da entrega da
informação, isto é, a confiabilidade da transmissão. As suas outras características são:

1

Rota de Aprendizagem
Redes de Computadores
Aula 04

 Orientado à conexão: É necessário estabelecer uma conexão entre os hosts que
pretende comunicar entre si. Para isto é necessário encaminhar, por meio da rede,
informações de um para o outro de forma que se reconheçam e consigam iniciar a
comunicação.

 Ponto a ponto: A comunicação acontece entre um host e outro do início ao fim, isto é,
um host é a origem e outro é o destino (e vice-versa) como se estivessem fisicamente
ligados.
 Confiabilidade: As informações encaminhadas por meio da rede têm a garantia da
entrega durante todo o processo de comunicação, incluindo-se a identificação, o
tratamento e a correção de erros.
 Full duplex: Uma vez estabelecida a conexão entre os hosts a comunicação flui nos dois
sentidos, fazendo com que ambos sejam, simultaneamente, origem e destino da
comunicação.
 Handshake: O processo de comunicação precisa estabelecer o reconhecimento mútuo
entre os hosts antes de iniciar a transmissão/recepção das informações. O TCP usa para
isso o triplo handshake com o objetivo de sincronizar algumas informações, como o
número de sequência dos pacotes, por exemplo.
 Entrega ordenada: Os pacotes da informação são entregues em sequência ordenada ao
destinatário, de forma que a informação original possa ser remontada ou reconstruída
para ser entregue à camada de aplicação exatamente como estava na origem.
 Controle de fluxo: O processo de comunicação inclui a confirmação do recebimento de
cada pacote e a avaliação da quantidade de informações recebidas e aceitas, podendo
inclusive atuar sobre parâmetros da comunicação para adequar o fluxo às condições da
rede naquele momento.
Isto significa, em resumo, que:
 Todas as conexões TCP são full duplex e ponto-a-ponto;
 Full duplex implica em tráfego fluindo em ambas as direções ao mesmo tempo;
 Ponto-a-ponto significa que cada conexão tem obrigatoriamente dois pontos terminais;

2

Rota de Aprendizagem
Redes de Computadores
Aula 04

 O TCP não permite broadcast e tampouco multicasting.

Portas conhecidas do TCP
Existem portas do TCP associadas a serviços e protocolos específicos, que não podem
ser utilizadas com outro propósito. Como já mencionado, estas portas são denominadas
portas conhecidas e seu valor está no limite de 1024. As mais conhecidas são as seguintes:

O processo de transmissão
Transmissor e receptor trocam informações na forma de segmentos. Os Segmentos
são compostos de um cabeçalho de tamanho fixo de 20 bytes e os dados da transmissão
(informações que o usuário quer transmitir ou necessita receber). O software decide o
tamanho do segmento, porém este é limitado ao payload do IP, que é de 64 kBytes (65.535
Bytes). O segmento também é limitado pelo MTU (Maximum Transfer Unit) do enlace de
dados, isto é, a capacidade máxima de encaminhamento de segmentos e seu tamanho.
Um pacote TCP
Um pacote do TCP contém, além das informações de usuário que estão em tráfego,
sinalizações e informações do processo de comunicação em si que buscam prover, entre

3

Rota de Aprendizagem
Redes de Computadores
Aula 04

outras características, a confiabilidade. Estas informações estão organizadas no pacote TCP da
seguinte maneira:

Os oito bits dos flags do TCP atuam no processo de comunicação com as seguintes
finalidades:
 CWR - Congestion Window Reduced ou janela de congestionamento reduzida, significa
que o fluxo de informação deve ser reuzido em função de perdas ou atraso na
informação;
 ECE - Confirma o “echo” da conexão TCP durante um handshake;
 URG – Indica que o pacote requer tratamento de urgência (pouco utilizado);
 ACK – Reconhecimento válido;
 PSH – Envio imediato dos dados, sem aguardar o preenchimento do buffer;
 RST, SYN e FIN – Processo de estabelecimento e liberação da conexão;
Conexão TCP
O TCP permite o estabelecimento de uma conexão normal, isto é, entre uma origem e
um destino, ou de uma conexão simultânea, na qual ambos os hosts são, ao mesmo tempo,
origem e destino, como mostrado abaixo:

4

Rota de Aprendizagem
Redes de Computadores
Aula 04

Neste caso ambas as conexões são estabelecidas e operam no modo full duplex
distintamente.
Pesquisa:
O que é, como funciona e qual a finalidade do processo de sliding windows ou janelas
deslizantes do TCP?

5

Rota de Aprendizagem
Redes de Computadores
Aula 04

Aula 04 - Parte 2 – Redes de Computadores
Introdução
Nesta aula são abordados os protocolos UDP e SCTP da camada 3 do TCP/IP, o seu
funcionamento e as suas características principais.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.4, 3.1, 4.3, 5.1 e 6.2.
 Kurose, 2003 – Seções 1.5, 1.7, 2.1 e 3.1.
Contextualizando
Protocolo UDP
User Datagram Protocol é um protocolo simples da camada de transporte que permite
que a aplicação escreva um datagrama encapsulado num pacote (IPv4 ou IPv6), o qual é então
enviado ao endereço IP do destino. Porém não há qualquer tipo de garantia que o pacote será
entregue. O protocolo UDP não é confiável, e se for necessário garantir a entrega, é preciso
implementar controles tais como timeouts (limite de tempo), retransmissões, acknowlegments
(reconhecimento), controle de fluxo, etc.
Cada datagrama UDP tem um tamanho e pode ser considerado como um registro
indivisível. O UDP é um serviço sem conexão, isto é, não há necessidade de manter uma
ligação entre o cliente e o servidor (ou entre origem e destino). Isto significa que um cliente
UDP pode criar um socket, enviar um datagrama para um servidor e imediatamente enviar
outro datagrama com o mesmo socket para um servidor diferente. Da mesma forma, um
servidor poderia ler datagramas vindos de diversos clientes, usando um único socket. O UDP
também fornece os serviços de broadcast e multicast, permitindo que um único cliente envie
pacotes para vários outros na rede.
Características do UDP
O protocolo UDP é a escolha adequada para fluxos de dados em tempo real,
especialmente aqueles que admitem uma certa perda ou dano de parte de seu conteúdo, tais

6

Rota de Aprendizagem
Redes de Computadores
Aula 04

como vídeos ou voz (VoIP). As aplicações sensíveis a atrasos na rede, mas pouco sensíveis a
perdas de pacotes, como jogos de computadores, também são candidatas naturais ao seu uso.
O UDP suporta broadcasting e multicasting, portanto, caso estes recursos sejam utilizados, o
UDP deverá necessariamente ser utilizado. Parte do desempenho obtido por comunicação
com o UDP deve-se ao fato de que este não perde tempo com criação ou destruição de
conexões. Em função disso, durante uma conexão o UDP troca apenas 2 pacotes, enquanto no
TCP esse número é superior a 10.
O UDP também contempla portas específicas para determinados tipos de serviço ou
operações, dentre as quais cabe citar:

O pacote UDP
Um pacote do UDP é extremamente simples, e contém as informações minimamente
necessárias para o tráfego das informações entre origem e destino, como mostrado:

7

Rota de Aprendizagem
Redes de Computadores
Aula 04

A porta fonte corresponde à porta utilizada pela aplicação emissora do segmento UDP.
Este campo representa um endereço de resposta para o destinatário. A porta destino
corresponde à porta utilizada pela aplicação no host destinatário. O comprimento informa o
tamanho total do segmento, em bytes, incluindo o tamanho do próprio cabeçalho. O checksum
contém uma soma de controle realizada de maneira a poder controlar a integridade do
segmento, permitindo ao destinatário validar se houve alguma alteração no conteúdo da
mensagem que a possa invalidar.
O uso do UDP
Em função de suas características o UDP é frequentemente usado para fluxos de dados
em tempo real, aplicações que requerem Multicasting e Broadcasting e em serviços que
admitem certa perda de dados, tendo em contrapartida uma alta velocidade de comunicação,
como é o caso de streaming de vídeo e de voz. Entre os diversos exemplos de uso do UDP
estão o Youtube e outros serviços de streaming, tanto de áudio quanto de vídeo, as conexões
P2P, o Skype e inúmeros serviços de VOIP, além de serviços de impressão remota.
Protocolo SCTP
Stream Control Transmission Protocol é um protocolo de transporte confiável que
opera sobre um serviço de pacotes não confiável e sem conexão, como é o caso do IP. O SCTP é
orientado a mensagens e utiliza o conceito de associação para estabelecer vários fluxos de
comunicação. Além disso provê suporte para Multihoming.
As principais características do SCTP são:
 Entrega confirmada de dados de usuário, livre de erros e não duplicados;
 Fragmentação de dados em conformidade com o MTU descoberto do caminho;
 Entrega sequencial de dados de usuário em múltiplos fluxos;
 Empacotamento opcional de múltiplas mensagens de usuário num único pacote SCTP;
 Tolerância a falhas de rede através do suporte a caminhos múltiplos (multihoming);
 O SCTP é rate adaptative, adaptando-se às variações da rede;

8

Rota de Aprendizagem
Redes de Computadores
Aula 04

Benefícios do SCTP
O SCTP é um protocolo mais adaptado às necessidades de comunicação das redes
modernas, e, portanto, apresenta alguns benefícios quando comparado ao TCP e ao UDP, como
segue:
 O SCTP provê transmissão confiável, e detecta quando os dados são descartados,
reordenados, duplicados ou corrompidos, retransmitindo os dados quando necessário;
 O SCTP é orientado a conexão;
 O SCTP usa o conceito de associação, o que o torna mais abrangente que a conexão
TCP. Enquanto uma conexão TCP estabelece apenas um único fluxo full duplex, uma
associação SCTP estabelece um número arbitrário de fluxos simplex. Porém, para
simular uma conexão TCP, basta criar um fluxo SCTP em cada direção;
 O SCTP tem potencial de substituir o TCP em diversas aplicações, e além disso pois
todas as portas reservadas pelo IANA ao TCP são automaticamente reservadas ao SCTP.
Pesquisa
O que é a arquitetura de aplicações cliente/servidor? Onde é utilizada e quais são as os
benefícios e as desvantagens do uso desta arquitetura?
Trocando Ideias
Acesse o fórum sobre TRANSPORTE e compartilhe suas descobertas, suas experiências,
exponha suas dúvidas... Faça contato com seus colegas de curso e de turma e discuta o que
aprendeu, e assim busque esclarecer suas dúvidas e reforçar seus conhecimentos.
Síntese
Nessa aula foram apresentados os protocolos da camada 3 – Transporte do modelo
TCP/IP, o TCP, o UDP e o SCTP, incluindo a exploração de suas características e os usos destes
protocolos na comunicação de dados.

9

Rota de Aprendizagem
Redes de Computadores
Aula 04

Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos estudados com
seus colegas de curso e de trabalho. Procure ampliar seu conhecimento sobre o conteúdo
apresentado.
Autoavaliação
- Qual a finalidade dos protocolos da camada de transporte do TCP/IP?
- Porque o TCP é considerado um protocolo confiável e o UDP não?
- O que dificulta o uso do TCP em aplicações sensíveis à atrasos na comunicação?
- O UDP faz algum tipo de controle de erro? Como?
- Porque os protocolos da camada 3 – Transporte do TCP/IP fazem referência às portas e não
aos endereços IP?
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.

10



CONVERSA INICIAL
Olá! Seja bem-vindo à quarta aula da disciplina Rede de Computadores!
Nesta aula, serão tratadas as funcionalidades da camada de transporte. Portanto, serão abordados os
protocolos da camada 3 do TCP/IP – TCP, UDP e SCTP e suas características principais. Também vamos
estudar os protocolos UDP e SCTP da camada 3 do TCP/IP, o funcionamento e as suas características
principais.

Para uma leitura complementar recomendamos: Tanenbaum, 2011 – Seções 1.4, 3.1, 4.3, 5.1, 6.1 a 6.5,
e Kurose, 2003 – Seções 1.5, 1.7, 2.1, 3.1, 3.3, 3.5 e 3.7
CONTEXTUALIZANDO
O protocolo TCP
O Transmission Control Protocol, ou Protocolo de Controle de Transmissão, é um dos principais
protocolos da Internet. É adequado às redes globais, pois verifica se os dados são enviados pela rede da
forma correta, na sequência apropriada e sem erros.

É um protocolo da camada de transporte do modelo TCP/IP (camada 3), sobre o qual se assentam a
maioria dos demais protocolos e aplicações, como o SSH, FTP, HTTP — e praticamente toda a World

Wide Web.
O processo de transmissão nesta camada funciona da seguinte maneira: transmissor e receptor criam
pontos extremos – os sockets. Os sockets são representados pelo endereço IP e mais um número de
16 bits, denominado porta, por exemplo, 192.168.10.1:8080. As portas com valor abaixo de 1024
são chamadas de portas conhecidas e são reservadas para serviços específicos do TCP. As portas
conhecidas só podem ser inicializadas por usuários com privilégio. Essas portas podem ser registradas
para uso restrito no Internet Assigned Numbers Authority ou Autoridade de designação de números:
www.iana.org

Características do TCP
O protocolo TCP tem como principal característica a garantia da entrega da informação, isto é, a
confiabilidade da transmissão. As suas outras características são:
 Orientado à conexão: é necessário estabelecer uma conexão entre os hosts que pretendem se
comunicar entre si. Para isso é necessário encaminhar, por meio da rede, informações de um para
o outro de forma que se reconheçam e consigam iniciar a comunicação.
 Ponto a ponto: a comunicação acontece entre um host e outro do início ao fim, isto é, um host é
a origem e outro é o destino (e vice-versa) como se estivessem fisicamente ligados.
 Confiabilidade: as informações encaminhadas por meio da rede têm a garantia da entrega
durante todo o processo de comunicação, incluindo-se a identificação, o tratamento e a correção de
erros.

 Full duplex: uma vez estabelecida a conexão entre os hosts a comunicação flui nos dois sentidos,
fazendo com que ambos sejam, simultaneamente, origem e destino da comunicação.
 Handshake: o processo de comunicação precisa estabelecer o reconhecimento mútuo entre os

hosts antes de iniciar a transmissão/recepção das informações. O TCP usa para isso o triplo
handshake com o objetivo de sincronizar algumas informações, como o número de sequência dos
pacotes, por exemplo.
 Entrega ordenada: os pacotes da informação são entregues em sequência ordenada ao
destinatário, de forma que a informação original possa ser remontada ou reconstruída para ser
entregue à camada de aplicação exatamente como estava na origem.
 Controle de fluxo: o processo de comunicação inclui a confirmação do recebimento de cada
pacote e a avaliação da quantidade de informações recebidas e aceitas, podendo inclusive atuar
sobre parâmetros da comunicação para adequar o fluxo às condições da rede naquele momento.

Isto significa, em resumo, que:
 Todas as conexões TCP são full duplex e ponto-a-ponto;
 Full duplex implica em tráfego fluindo em ambas as direções ao mesmo tempo;
 Ponto-a-ponto significa que cada conexão tem obrigatoriamente dois pontos terminais;
 O TCP não permite broadcast e tampouco multicasting.
Portas conhecidas do TCP
Existem portas do TCP associadas a serviços e protocolos
específicos, que não podem ser utilizadas com outro propósito.
Como já mencionado, essas portas são denominadas portas
conhecidas e seu valor está no limite de 1024. As mais conhecidas
são as seguintes:

O processo de transmissão
Transmissor e receptor trocam informações na forma de segmentos. Os Segmentos são compostos de
um cabeçalho de tamanho fixo de 20 bytes e os dados da transmissão (informações que o usuário quer
transmitir ou necessita receber).
O software decide o tamanho do segmento, porém este é limitado ao payload do IP, que é de 64 kBytes
(65.535 Bytes). O segmento também é limitado pelo MTU (Maximum Transfer Unit) do enlace de
dados, isto é, a capacidade máxima de encaminhamento de segmentos e seu tamanho.

Um pacote TCP
Um pacote do TCP contém, além das informações de usuário que estão em tráfego, sinalizações e
informações do processo de comunicação em si, que buscam prover, entre outras características, a
confiabilidade. Essas informações estão organizadas no pacote TCP da seguinte maneira:

Os oito bits dos flags do TCP atuam no processo de comunicação com as seguintes finalidades:
 CWR: Congestion Window Reduced ou janela de congestionamento reduzida, significa que o
fluxo de informação deve ser reduzido em função de perdas ou atraso na informação;
 ECE: confirma o “echo” da conexão TCP durante um handshake;
 URG: indica que o pacote requer tratamento de urgência (pouco utilizado);
 ACK: reconhecimento válido;
 PSH: envio imediato dos dados, sem aguardar o preenchimento do buffer;
 RST, SYN e FIN: processo de estabelecimento e liberação da conexão;

Conexão TCP
O TCP permite o estabelecimento de uma conexão normal, isto é, entre uma origem e um destino, ou de
uma conexão simultânea, na qual ambos os hosts são, ao mesmo tempo, origem e destino, como
mostrado abaixo. Neste caso, ambas as conexões são estabelecidas e operam no modo full duplex
distintamente.

Nossos estudos não param por aqui! Assista às explicações do professor Luís Gonzaga sobre o assunto
de hoje no vídeo que está disponível no material on-line!
PESQUISE
Agora, o que acha de fazer uma pesquisa sobre o tema da aula de hoje? Lembre-se que esta é uma
oportunidade importante para que você possa ampliar os seus conhecimentos! Sendo assim, responda a
questão a seguir:
O que é, como funciona e qual a finalidade do processo de sliding windows ou janelas
deslizantes do TCP?

Protocolo UDP

User Datagram Protocol é um protocolo simples da camada de transporte que permite que a aplicação
escreva um datagrama encapsulado em um pacote (IPv4 ou IPv6), o qual é então enviado ao endereço
IP do destino. Porém, não há qualquer tipo de garantia de que o pacote será entregue. O protocolo UDP
não é confiável, e se for necessário garantir a entrega, é preciso implementar controles, tais como

timeouts (limite de tempo), retransmissões, acknowlegments (reconhecimento), controle de fluxo etc.
Cada datagrama UDP tem um tamanho e pode ser considerado como um registro indivisível. O UDP é um
serviço sem conexão, isto é, não há necessidade de manter uma ligação entre o cliente e o servidor (ou
entre origem e destino).

Isto significa que um cliente UDP pode criar um socket, enviar um datagrama para um servidor e
imediatamente enviar outro datagrama com o mesmo socket para um servidor diferente. Da mesma
forma, um servidor poderia ler datagramas vindos de diversos clientes, usando um único socket. O UDP
também fornece os serviços de broadcast e multicast, permitindo que um único cliente envie pacotes
para vários outros na rede.
Características do UDP
O protocolo UDP é a escolha adequada para fluxos de dados em tempo real, especialmente aqueles que
admitem uma certa perda ou dano de parte de seu conteúdo, tais como vídeos ou voz (VoIP). As
aplicações sensíveis a atrasos na rede, mas pouco sensíveis a perdas de pacotes, como jogos de
computadores, também são candidatas naturais ao seu uso.

O UDP suporta broadcasting e multicasting, portanto, caso estes recursos sejam utilizados, o UDP deverá
necessariamente ser utilizado. Parte do desempenho obtido por comunicação com o UDP deve-se ao fato
de que este não perde tempo com criação ou destruição de conexões. Em função disso, durante uma
conexão, o UDP troca apenas dois pacotes, enquanto no TCP esse número é superior a 10.
O UDP também contempla portas específicas para
determinados tipos de serviço ou operações,
dentre as quais cabe citar:

O pacote UDP
Um pacote do UDP é extremamente simples, e contém as informações minimamente necessárias para o
tráfego das informações entre origem e destino, como mostrado:

Porta fonte: corresponde à porta utilizada pela aplicação emissora do segmento UDP. Este campo
representa um endereço de resposta para o destinatário;
Porta destino: corresponde à porta utilizada pela aplicação no host destinatário;
Comprimento: informa o tamanho total do segmento, em bytes, incluindo o tamanho do próprio
cabeçalho;

Checksum: contém uma soma de controle realizada de maneira a poder controlar a integridade do
segmento, permitindo ao destinatário validar se houve alguma alteração no conteúdo da mensagem que
a possa invalidar.

O uso do UDP
Em função de suas características, o UDP é frequentemente usado para fluxos de dados em tempo real,
aplicações que requerem Multicasting e Broadcasting e em serviços que admitem certa perda de dados,
tendo, em contrapartida, uma alta velocidade de comunicação, como é o caso de streaming de vídeo e
de voz.
Entre os diversos exemplos de uso do UDP estão o Youtube e outros serviços de streaming, tanto de
áudio quanto de vídeo, as conexões P2P, o Skype e inúmeros serviços de VOIP, além de serviços de
impressão remota.

Protocolo SCTP

Stream Control Transmission Protocol é um protocolo de transporte confiável que opera sobre um serviço
de pacotes não confiável e sem conexão, como é o caso do IP. O SCTP é orientado a mensagens e utiliza
o conceito de associação para estabelecer vários fluxos de comunicação. Além disso provê suporte para

Multihoming. As principais características do SCTP são:
 Entrega confirmada de dados de usuário, livre de erros e não duplicados;
 Fragmentação de dados em conformidade com o MTU descoberto do caminho;
 Entrega sequencial de dados de usuário em múltiplos fluxos;
 Empacotamento opcional de múltiplas mensagens de usuário em um único pacote SCTP;
 Tolerância a falhas de rede através do suporte a caminhos múltiplos (multihoming);
 O SCTP é rate adaptative, adaptando-se às variações da rede.

Benefícios do SCTP
O SCTP é um protocolo mais adaptado às necessidades de comunicação das redes modernas e, portanto,
apresenta alguns benefícios quando comparado ao TCP e ao UDP, como segue:
 O SCTP provê transmissão confiável, e detecta quando os dados são descartados,
reordenados, duplicados ou corrompidos, retransmitindo os dados quando necessário;
 O SCTP é orientado à conexão;
 O SCTP usa o conceito de associação, o que o torna mais abrangente que a conexão TCP.
Enquanto uma conexão TCP estabelece apenas um único fluxo full duplex, uma associação
SCTP estabelece um número arbitrário de fluxos simplex. Porém, para simular uma conexão
TCP, basta criar um fluxo SCTP em cada direção;
 O SCTP tem potencial para substituir o TCP em diversas aplicações, pois todas as portas
reservadas pelo IANA ao TCP são automaticamente reservadas ao SCTP.

Na videoaula disponível no material on-line, o professor Luís Gonzaga disserta um pouco mais sobre os
protocolos trabalhados na aula de hoje. Aproveite para tirar as dúvidas que possam ter surgido até aqui!
TROCANDO IDEIAS
Acesse o fórum sobre TRANSPORTE e compartilhe suas descobertas, suas experiências, exponha suas
dúvidas. Faça contato com seus colegas de curso e de turma e discuta o que aprendeu, e, assim, busque
esclarecer suas dúvidas e reforçar seus conhecimentos.

NA PRÁTICA
O que é a arquitetura de aplicações cliente/servidor? Onde é utilizada e quais são os benefícios e as
desvantagens do uso desta arquitetura?
Leia o texto indicado no link a seguir e procure as respostas para essas perguntas!
http://www.diegomacedo.com.br/arquitetura-de-aplicacoes-em-2-3-4-ou-n-camadas/

SÍNTESE
Chegamos ao final dos nossos estudos! Nessa aula foram apresentados os protocolos da camada 3 –
Transporte do modelo TCP/IP, o TCP, o UDP e o SCTP, incluindo a exploração de suas características e
os usos destes protocolos na comunicação de dados.
Até a próxima!
COMPARTILHANDO
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos estudados com seus colegas de
curso e de trabalho. Procure ampliar seu conhecimento sobre o conteúdo apresentado.




Redes de Computadores
Rota de Aprendizagem – Aula 05

Parte 1
Introdução
O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e o endereçamento
por meio de nomes, bem como sua resolução. São tratadas também a estruturação dos nomes, os
domínios e o registro de domínios na internet.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.6 e 7.1.
 Kurose, 2003 – Seção 2.5.
Contextualizando:
O que é o DNS?
O DNS – Domain Name System ou sistema de nomes de domínio é uma aplicação que realiza o
serviço de identificação de computadores na rede por meio de um nome. O DNS atende as outras
aplicações, permitindo o uso de endereços da camada de aplicação – URLs ou um endereço de e-mail –
ao invés de endereços lógicos da camada de rede (endereço IP). Diferentemente das pessoas, a rede
identifica os computadores por seu endereço IP, totalmente numérico e de difícil memorização. Por
causa disto é necessário um serviço que possa relacionar um nome de domínio ou de um host à um
endereço IP: este serviço é o DNS.
As pessoas preferem guardar nomes ao invés de números. O que é mais fácil de memorizar:
ava.uninter.com ou 200.150.68.244?
Para as redes pequenas uma simples tabela contendo os nomes e os respectivos endereços IP
dos hosts é suficiente, como era no início da Internet. Assim cada host mantém sua própria tabela local
e consegue endereçar toda a rede. Porém com um número imenso de hosts, como é atualmente, é
impraticável esta solução, pois haveria necessidade de uma enorme tabela. Além disso seria inviável
atualizar as tabelas hosts de todos os hosts ao mesmo tempo, cada vez que uma mudança ocorresse.
Uma solução seria armazenar uma única tabela em um host específico: isto, porém, geraria um tráfego
enorme na rede, além de sobrecarregar este computador. Outra solução seria dividir o grande volume
de informações para diversos hosts, que passam a atender a consulta daqueles que necessitam
converter nomes em endereços. Estes hosts passam a atuar como servidores DNS e estão organizados
em uma hierarquia dentro do name space ou espaço de nomes. Um espaço de nomes é uma relação
única, em toda a rede, entre um nome e um endereço IP. Um espaço de nome pode ser PLANO ou
HIERÁRQUICO. Um espaço de nomes plano contém um nome qualquer – uma sequência de caracteres,
-1

Redes de Computadores
Rota de Aprendizagem – Aula 05

como servidor_da_rede, por exemplo – associado a um endereço IP. Isto inviabiliza o seu uso em redes
grandes e complexas, pois pode gerar ambiguidades ou nomes duplicados. Um espaço de nomes
hierárquico contém nomes compostos de várias partes, cada qual fazendo referência à uma
característica ou localização do host. Esta é a forma utilizada na internet, na qual as partes dos nomes
são organizadas no formato de uma árvore invertida, formando assim os espaços de nomes de domínio.
Esta “árvore” de domínios comporta até 128 níveis, partindo da raiz – nível 0 –até o nível mais
baixo – nível 127. Cada nó ou subdivisão da árvore é identificado por um rótulo (label) exclusivo que
não se repetirá naquele nível. Uma sequência de rótulos separadas por pontos “.” forma um nome de
domínio, como no exemplo dado: ava.uninter.com. A leitura e a formação do nome de domínio são
sempre feitas de baixo para cima na árvore.
Os domínios podem ser genéricos – por especialidade – como “.edu”, “.com”, “.net”, por área
geográfica ou país, como “.br”, “.ch”, “.ar” para Brasil, China e Argentina, por exemplo, sempre utilizando
duas letras. Há também os domínios reversos, cuja finalidade é associar um IP a um nome. Neste caso o
endereço IP faz parte do nome, porém é escrito ao contrário, e associado aos nomes “arpa” e “in-addr”,
como por exemplo em 10.20.30.130.arpa.in-addr, que se refere ao endereço 130.30.20.10.
Os domínios contêm diversos servidores de DNS, sendo o principal chamado de servidor DNS
RAIZ. Este servidor define uma ZONA, à qual estão vinculados todos os demais servidores DNS
primários e secundários. O servidor primário armazena e mantém atualizada a tabela de nomes do
domínio, enquanto o servidor secundário mantém uma cópia desta tabela para atuar em caso de falha
do servidor primário.
Para que um nome possa figurar em um servidor de domínio é necessário que seja cadastrado
em uma entidade registradora homologada pela ICANN - Internet Corporation for Assigned Names and
Numbers – Corporação da Internet para Designação de Nomes e Números. No Brasil o cadastro é
mantido pelo registro.br aos cuidados da FAPESP – Fundação de Amparo à Pesquisa do Estado de São
Paulo. Juntamente com o nic.br – Núcleo de Informações e Coordenação do Ponto BR este cadastro
define os nomes de domínio para o território brasileiro.
Como funciona o DNS
O DNS consiste em uma aplicação cliente/servidor. Um host executando o módulo cliente
encaminha uma mensagem de consulta à um host executando o servidor – ou um servidor DNS. A
mensagem compõe-se de um cabeçalho com as informações do cliente e uma seção de perguntas, que
contém os nomes de domínios a serem traduzidos para endereços IP.O servidor DNS devolve uma
mensagem de resposta formada pelo cabeçalho, com as informações do cliente e do servidor, a seção
-2

Redes de Computadores
Rota de Aprendizagem – Aula 05

de perguntas, uma seção de respostas, uma seção de autoridades e uma seção de informações
adicionais.
O que acontece se um servidor primário não conseguir resolver um determinado nome? Ele
repassará aos nós superiores da hierarquia do domínio para que estes resolvam o nome. Caso a
solicitação chegue até o servidor raiz sem a descoberta do IP, um erro será devolvido na mensagem de
resposta.
Pesquisa
Existem vários servidores de DNS públicos, como o do Google, cujo IP é 8.8.8.8. Descubra outros
e informe os seus nomes e os IPs a seus colegas de curso através do fórum ENDEREÇAMENTO.
DDNS – Dynamic Domain Name System
O sistema de nomes de domínio dinâmico – DDNS é uma evolução do DNS devido às constantes
mudanças nas redes, com a inclusão de novos hosts e domínios ou eliminação de hosts ou domínios.
Promover uma atualização de grande escala é inviável de forma manual. No DDNS, quando um nome é
resolvido as informações são enviadas por meio de DHCP para o servidor primário do domínio, que
cuida da replicação deste novo conjunto para os demais servidores, incluindo os servidores de DNS
secundários. Para evitar o uso inadequado o DDNS pode usar mecanismos de autenticação, garantindo
que somente servidores autorizados possam publicar as mudanças.
DNSSEC – Domain Name System Secure
O sistema de nomes de domínio seguro é uma versão de DNS que utiliza a criptografia e a
assinatura digital para a manutenção e o acesso à base de dados do sistema. O uso deste tipo específico
de serviço tem por objetivo evitar ataques de DNS forjado.
Pesquisa
Onde é usado o DNSSEC e com que finalidade? O que é um ataque de DNS forjado? Pesquise e discuta
com os colegas no fórum ENDEREÇAMENTO.
DNS – Características
O DNS pode usar tanto o TCP quanto o UDP, e faz as conexões através da porta 53. Para pacotes
de mensagem de resposta cujo tamanho não exceda os 512 bytes – tamanho típico de um pacote UDP –
este protocolo, o UDP, será usado. Caso o tamanho da mensagem de resposta ultrapasse os 512 bytes
ou não seja conhecido o tamanho, então será usada uma conexão TCP.

-3

Redes de Computadores
Rota de Aprendizagem – Aula 05

Introdução

Parte 2

O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e a utilização de
aplicações para login em outro host, transferência de mensagens entre host – o correio eletrônico ou email e a transferência de arquivos entre hosts.
Leitura recomendada:
 Tanenbaum, 2011 – Seção 7.2
 Kurose, 2003 – Seção 2.3 e 2.4
TELNET
O programa aplicativo cliente/servidor TELNET – de TErminaL NETwork é uma aplicação para
serviços de terminal virtual que provê uma conexão a um sistema remoto por meio da rede. É a
aplicação padrão do TCP/IP para os serviços de terminal virtual de acordo com a ISO – International
Standard Organization. O TELNET permite que um host crie, por meio de terminal local, uma conexão a
um host remoto, fazendo com que este terminal se comporte como se fosse um terminal do sistema
remoto. Um terminal, neste cenário, é um dispositivo composto de Teclado, Monitor e Mouse – ou um
computador emulando terminal – que possibilita a interação do usuário com os sistemas do
computador remoto. O uso de terminal é típico de sistemas operacionais de tempo compartilhado Time sharing – como o UNIX e o LINUX. O TELNET provê uma interface universal chamada NVT –
Network Virtual Terminal – que utiliza um conjunto de caracteres padrão, pois hosts diferentes podem
usar diferentes conjuntos de caracteres, em função do idioma ou do sistema operacional utilizado por
cada um.
Para tratar os diferentes recursos existentes em cada host o TELNET permite ao cliente e o
servidor negociarem as opções de configuração antes do uso do serviço. Estas opções são recursos
extras disponíveis para terminais mais sofisticados, como cores, gráficos e teclas de função ou
aceleradoras. O TELNET faz a conversão de caracteres de acordo com o tipo de computador acessado,
por meio de um driver específico. Para estabelecer a comunicação com o host remoto o TELNET usa
uma conexão TCP e a porta 23 do servidor. O funcionamento do TELNET ocorre de três modos de
operação:
 O modo Padrão, utilizado quando nenhum outro modo for negociado, e aquele no qual o eco
é local, isto é, uma vez digitado um caractere, o próprio cliente (terminal local) faz a
-4

Redes de Computadores
Rota de Aprendizagem – Aula 05

apresentação do mesmo na tela, porém só transmite para o servidor (host remoto) a linha
inteira (ou até que pressionada a tecla <ENTER>).
 No modo Caractere cada vez que um caracter é digitado o mesmo é enviado ao servidor, que
o retransmite de volta para que o cliente faça a apresentação na tela. Isto gera dois efeitos:
em conexões mais lentas ou congestionadas, pode haver um retardo entre a digitação e a
apresentação do caracter; além disso cada caracter digitado vai gerar três segmentos de TCP
na rede.
 No modo Linha a edição de linhas (eco, correção, etc.) é realizada pelo cliente. Quando
finalizada a edição pela tecla <ENTER> então toda a linha é enviada para o servidor.
CORREIO ELETRÔNICO
Uma das aplicações mais conhecidas da internet é o correio eletrônico, ou o E-mail (do Inglês
Electronic Mail). No início da era da internet era possível trocar mensagens curtas e somente de texto
entre dois hosts distantes. Atualmente as mensagens de e-mail são compostas de texto, áudio, imagem
e vídeo, e podem ser encaminhadas a vários destinos simultaneamente. O serviço de correio eletrônico
usa uma arquitetura com três componentes principais, a saber:
 O User Agente (UA), agente de usuário, é o serviço ou aplicação responsável pelas operações
do e-mail no cliente, seja o remetente ou o destinatário;
 O Message Transfer Agent (MTA), agente de transferência de mensagens, é a aplicação
cliente/servidor que responde pelo envio de mensagens à um servidor de correio eletrônico;
 Message Access Agent (MAA), agente de acesso às mensagens, é a aplicação cliente/servidor
responsável por buscar as mensagens em um servidor de e-mail.
Um serviço de Correio Eletrônico pode operar de quatro modos distintos. No primeiro modo, o
remetente e destinatário est]ao conectados no no mesmo sistema. Neste caso é necessário apenas o uso
dos programas User Agent (UA). O remetente faz uso do UA para preparar e encaminhar seu e-mail para
o remetente que, quando usar seu UA, receberá a mensagem. É o caso típico do serviço “mail” do UNIX
/ LINUX.
Em um segundo modo, o remetente e destinatário estão conectados a sistemas distintos. Então
é necessário o uso de dois programas User Agent (UA) e um par de programas Message Transfer Agent
(MTA), que funcionam em um modelo cliente/servidor para encaminhar a mensagem de um sistema ao
outro. Este é o caso de uma mensagem de e-mail trocada entre dois sistemas UNIX / LINUX conectados
à rede.
-5

Redes de Computadores
Rota de Aprendizagem – Aula 05

Em um terceiro modo o Remetente faz parte de uma LAN / WAN e o destinatário está conectado
diretamente ao serviço de correio eletrônico. Neste modo é necessário o uso de dois programas User
Agent (UA) e dois pares de servidores Message Transfer Agent, cada par funcionando em modelo cliente
/ servidor para o encaminhamento da mensagem de um sistema até o outro.
Finalmente, no quarto modo, o remetente e destinatário estão conectados ao serviço de correio
eletrônico por meio de uma LAN / WAN. É necessário o uso de dois programas User Agent (UA), dois
pares de servidores Message Transfer Agent (MTA) e um par de servidores Message Access Agent
(MAA). Este é o cenário típico atualmente na internet
SMTP – Simple Mail Transfer Protocol
O SMTP - Simple Mail Transfer Protocol ou Protocolo Simples de Transferência de Mensagem é o
protocolo que define a comunicação entre cliente e servidor do Message Transfer Agent (MTA). O SMTP
utiliza a porta 25 (conexão em texto plano)1 ou a porta 465 (conexão criptografada via SSL). Em um
processo típico de envio de e-mail o SMTP é utilizado tanto entre o cliente (UA) e o servidor de correio
quanto entre os servidores de correio MTA).
POP3 – Post Office Protocol versão 3
O POP3 – Post Office Protocol versão 3 ou Protocolo de Posto de Correio é o protocolo que define
a comunicação entre cliente e servidor Message Access Agent (MAA) para acessar as mensagens
deixadas em um servidor de e-mail. O POP3 acessa as mensagens no servidor de e-mail e as
disponibiliza para o UA apresentá-las ao seu destinatário. O POP3 permite o acesso em dois modos, o
modo keep e o módulo delete. No modo keep as mensagens são acessadas, porém mantidas no servidor
de e-mail, e, portanto, podem ser acessadas novamente a partir de outro cliente MAA. No modo delete
as mensagens são acessadas e excluídas do servidor de e-mail, sendo mantidas no UA a partir deste
ponto. O POP3 utiliza a porta 110 do TCP para acessar as mensagens de correio eletrônico em um
servidor.

No Brasil o CGI.BR orientou, em 2012, usuários, provedores e operadoras de internet a utilizar a porta 587. O intuito é
uma medida de segurança para diminuir o número de spans: http://www.cgi.br/noticia/cgi-br-anuncia-ultima-etapa-dacampanha-para-diminuir-numero-de-spams-enviados-por-redes-brasileiras/309.
-6
1

Redes de Computadores
Rota de Aprendizagem – Aula 05

IMAP4 – Internet Mail Access Protocol versão 4
O IMAP – Internet Mail Access Protocol ou Protocolo de Acesso a Correio pela Internet é o
protocolo que define a comunicação entre cliente e servidor Message Access Agent (MAA) de forma
similar ao POP3, porém com muitos recursos adicionais, como por exemplo:
 É possível acessar o assunto de um e-mail antes de transferi-lo para o UA;
 É possível pesquisar um conteúdo específico nos e-mails do servidor;
 É possível baixar parcialmente um e-mail (sem as imagens, vídeos ou anexos, por exemplo);
 Também é possível que o usuário gerencie pastas e defina o armazenamento de suas
mensagens nestas pastas no servidor de e-mail.
O IMPA4 utiliza a porta 143 do TCP para as conexões cliente / servidor com o servidor de e-mail.
TRANSFERÊNCIA DE ARQUIVOS - FTP – File Transfer Protocol
O FTP – File Transfer Protocol ou Protocolo de Transferência de Arquivos é o protocolo padrão
do TCP/IP para transferência de arquivos entre hosts. É uma aplicação cliente / servidor que estabelece
duas conexões entre os hosts: uma para os dados e outra para o controle da transferência, e utiliza as
portas 20 e 21 para estas duas conexões. Para acessar o servidor e fazer uma transferência é necessário
ter uma conta com um nome de usuário (login) e uma senha. A transmissão dos dados do FTP é feita
por uma conexão TCP. É possível utilizar também o FTP Anônimo para arquivos de acesso público.
Neste caso, geralmente não é necessário login e senha, porém o padrão é que sejam:
Login: anonymous
Senha: guest
Nestes casos o acesso ao sistema é restrito e poucas operações são permitidas.
Outra alternativa para o FTP é o TFPT - Trivial File Transfer Protocol , um protocolo de
transferência de arquivos muito simples e muito semelhante ao FTP. É muito utilizado para transferir
pequenos arquivos entre hosts de uma rede, como, por exemplo, quando um terminal remoto ou um
cliente inicia o seu funcionamento, a partir do servidor.
Pesquisa
O FTP é utilizado por diversos serviços para a transferência de arquivos. Você consegue
identificar quais são estes outros?
Trocando Ideias
-7

Redes de Computadores
Rota de Aprendizagem – Aula 05

Acesse o fórum sobre APLICAÇÔES e compartilhe suas descobertas, suas experiências, exponha
suas dúvidas.... Faça contato com seus colegas de curso e de turma por meio do fórum e discuta o que
aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula foram apresentados os protocolos e serviços da camada de aplicação voltados para o
acesso remoto via terminal, o correio eletrônico e a transferência de arquivos entre hosts.
Compartilhando
Que tal compartilhar o que você aprendeu? Acesso o fórum sobre as aplicações e discuta com
seus colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo apresentado.
Autoavaliação
- Para que poderia ser usado o TELNET?
- O que é possível “negociar” em uma conexão TELNET?
- Qual é a função de um UA – User Agent no correio eletrônico?
- Porque necessita-se de POP3 e IMAP4 nos serviços de correio eletrônico?
- Quantas conexões o FTP utiliza para a transferência de arquivos? Qual a finalidade destas conexões?
Referências
Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo. Pearson,
2011.
Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem. São
Paulo. Pearson, 2003.

-8



CONVERSA INICIAL
Olá! Bem-vindo a mais uma aula da disciplina de Rede de Computadores!
Para este encontro, preparamos uma aula sobre a camada 4, que abarca a aplicação do modelo TCP/IP,
sua resolução, o endereçamento por meio de nomes, os domínios e o registro de domínios na internet.
Tenha um ótimo estudo!

CONTEXTUALIZANDO
O que é o DNS?
O DNS – Domain Name System ou sistema de nomes de domínio é uma aplicação que realiza o serviço
de identificação de computadores na rede por meio de um nome. O DNS atende às outras aplicações,
permitindo o uso de endereços da camada de aplicação – URLs ou um endereço de e-mail – ao invés de
endereços lógicos da camada de rede (endereço IP).
Diferentemente das pessoas, a rede identifica os computadores por seu endereço IP, totalmente
numérico e de difícil memorização. Por causa disto é necessário um serviço que possa relacionar um
nome de domínio ou de um host à um endereço IP: este serviço é o DNS.

Observação: as pessoas preferem guardar nomes ao invés de números. O que é mais fácil de
memorizar: ava.uninter.com ou 200.150.68.244?
Para as redes pequenas uma simples tabela contendo os nomes e os respectivos endereços IP dos hosts
é suficiente, como era no início da Internet. Assim cada host mantém sua própria tabela local e consegue
endereçar toda a rede.
Porém com um número imenso de hosts, como é atualmente, é impraticável esta solução, pois haveria
necessidade de uma enorme tabela. Além disso seria inviável atualizar as tabelas hosts de todos os hosts
ao mesmo tempo, cada vez que uma mudança ocorresse. Uma solução seria armazenar uma única
tabela em um host específico: isso, porém geraria um tráfego enorme na rede, além de sobrecarregar
este computador.

Outra solução seria dividir o grande volume de informações para diversos hosts, que passam a atender a
consulta daqueles que necessitam converter nomes em endereços.

Estes hosts passam a atuar como servidores DNS e estão organizados em uma hierarquia dentro do

name space ou espaço de nomes. Um espaço de nomes é uma relação única, em toda a rede, entre um
nome e um endereço IP.

Um espaço de nome pode ser PLANO ou HIERÁRQUICO.

Plano
Um espaço de nomes plano contém um nome qualquer – uma sequência de caracteres, como
servidor_da_rede, por exemplo – associado a um endereço IP. Isto inviabiliza o seu uso em redes
grandes e complexas, pois pode gerar ambiguidades ou nomes duplicados.

Hierárquico
Um espaço de nomes hierárquico contém nomes compostos de várias partes, cada qual fazendo
referência à uma característica ou localização do host. Esta é a forma utilizada na internet, na qual as
partes dos nomes são organizadas no formato de uma árvore invertida, formando assim os espaços de
nomes de domínio.

Essa “árvore” de domínios comporta até 128 níveis, partindo da raiz – nível 0 – até o nível mais baixo –
nível 127. Cada nó, ou subdivisão da árvore, é identificado por um rótulo (label) exclusivo que não se
repetirá naquele nível. Uma sequência de rótulos separadas por pontos “.” forma um nome de domínio,
como no exemplo dado: ava.uninter.com.

A leitura e a formação do nome de domínio são sempre feitas de baixo para cima na árvore.

Os domínios podem ser:
Genéricos – por especialidade – como “.edu”, “.com”, “.net”, por área geográfica ou país, como “.br”,
“.ch”, “.ar” para Brasil, China e Argentina, por exemplo, sempre utilizando duas letras.
Reversos, cuja finalidade é associar um IP a um nome. Neste caso o endereço IP faz parte do nome,
porém é escrito ao contrário, e associado aos nomes “arpa” e “in-addr”, como por exemplo em
10.20.30.130.arpa.in-addr, que se refere ao endereço 130.30.20.10.
Os domínios contêm diversos servidores de DNS, sendo o principal chamado de servidor DNS RAIZ. Este
servidor define uma ZONA, à qual estão vinculados todos os demais servidores DNS primários e
secundários. O servidor primário armazena e mantém atualizada a tabela de nomes do domínio,
enquanto o servidor secundário mantém uma cópia desta tabela para atuar em caso de falha do servidor
primário.

Para que um nome possa figurar em um servidor de domínio é necessário que seja cadastrado em uma
entidade registradora homologada pela ICANN - Internet Corporation for Assigned Names and Numbers
– Corporação da Internet para Designação de Nomes e Números.

No Brasil o cadastro é mantido pelo registro.br aos cuidados da FAPESP – Fundação de Amparo à
Pesquisa do Estado de São Paulo. Juntamente com o nic.br - Núcleo de Informações e Coordenação do
Ponto BR - este cadastro define os nomes de domínio para o território brasileiro.

Como funciona o DNS
O DNS consiste em uma aplicação cliente/servidor. Um host executando o módulo cliente encaminha
uma mensagem de consulta a um host executando o servidor – ou um servidor DNS. A mensagem
compõe-se de um cabeçalho com as informações do cliente e uma seção de perguntas, que contém os
nomes de domínios a serem traduzidos para endereços IP.

O servidor DNS devolve uma mensagem de resposta formada pelo cabeçalho, com as informações do
cliente e do servidor, a seção de perguntas, uma seção de respostas, uma seção de autoridades e uma
seção de informações adicionais.

Curiosidade: O que acontece se um servidor primário não conseguir resolver um determinado nome?
Ele repassará aos “nós” superiores da hierarquia do domínio para que estes resolvam o nome. Caso a
solicitação chegue até o servidor raiz sem a descoberta do IP, um erro será devolvido na mensagem de
resposta.
Assista ao primeiro vídeo do professor Luís Gonzaga, a seguir, e entenda melhor como funcionam esses
servidores e domínios!
http://ava.grupouninter.com.br/videos/video2.php?video=http://vod.grupouninter.com.br/2015/AGO/MT
180008-A05-P01.mp4

PESQUISE
Vamos aprofundar um pouco em cada um desses tipos de sistemas? Vamos começar pelo DNS e seus
tipos:
DDNS – Dynamic Domain Name System
O sistema de nomes de domínio dinâmico – DDNS é uma evolução do DNS devido às constantes
mudanças nas redes, com a inclusão de novos hosts e domínios ou eliminação de hosts ou domínios.
Promover uma atualização de grande escala é inviável de forma manual. No DDNS, quando um nome é
resolvido as informações são enviadas por meio de DHCP para o servidor primário do domínio, que cuida
da replicação deste novo conjunto para os demais servidores, incluindo os servidores de DNS secundário.
Para evitar o uso inadequado, o DDNS pode usar mecanismos de autenticação, garantindo que somente
servidores autorizados possam publicar as mudanças.

DNSSEC – Domain Name System Secure
O sistema de nomes de domínio dinâmico é uma versão de DNS que utiliza a criptografia e a assinatura
digital para a manutenção e o acesso à base de dados do sistema. O uso deste tipo específico de serviço
tem por objetivo evitar ataques de DNS forjado.
Existem vários servidores de DNS públicos, como o do Google, cujo IP é 8.8.8.8. Estamos no momento
em que você deve começar a pesquisar sobre o assunto, então acesse o Google para descobrir outros
servidores de DNS públicos e informe os seus nomes e os IPs a seus colegas de curso através do fórum
ENDEREÇAMENTO!
www.google.com.br

Uma das características do DNS é que ele pode usar tanto o TCP quanto o UDP e faz as conexões
através da porta 53:

Para pacotes de mensagem de resposta cujo tamanho não exceda os 512 bytes – tamanho típico de um
pacote UDP – este protocolo, o UDP, será usado. Caso o tamanho da mensagem de resposta ultrapasse
os 512 bytes, ou não seja conhecido o tamanho, então será usada uma conexão TCP.

Onde é usado o DNSSEC e com que finalidade? O que é um ataque de DNS forjado? Pesquise
e discuta com seus colegas no fórum ENDEREÇAMENTO.

TELNET
O programa aplicativo cliente/servidor TELNET – de TErminaL NETwork é uma aplicação para serviços
de terminal virtual que provê uma conexão a um sistema remoto por meio da rede. É a aplicação padrão
do TCP/IP para os serviços de terminal virtual de acordo com a ISO – International Standard

Organization.
O TELNET permite que um host crie, por meio de terminal local, uma conexão a um host remoto,
fazendo com que este terminal se comporte como se fosse um terminal do sistema remoto. Um terminal,
neste cenário, é um dispositivo composto de Teclado, Monitor e Mouse – ou um computador emulando
terminal – que possibilita a interação do usuário com os sistemas do computador remoto.
O uso de terminal é típico de sistemas operacionais de tempo compartilhado - Time sharing – como o
UNIX e o LINUX.

O TELNET provê uma interface universal chamada NVT – Network Virtual Terminal – que utiliza um
conjunto de caracteres padrão, pois hosts diferentes podem usar diferentes conjuntos de caracteres, em
função do idioma ou do sistema operacional utilizado por cada um.
Para tratar os diferentes recursos existentes em cada host o TELNET permite ao cliente e o servidor
negociarem as opções de configuração antes do uso do serviço. Estas opções são recursos extras
disponíveis para terminais mais sofisticados, como cores, gráficos e teclas de função ou aceleradoras.
O TELNET faz a conversão de caracteres de acordo com o tipo de computador acessado, por meio de
um driver específico. Para estabelecer a comunicação com o host remoto o TELNET usa uma conexão
TCP e a porta 23 do servidor.

O funcionamento do TELNET ocorre de três modos de operação:

Padrão: utilizado quando nenhum outro modo for negociado, e aquele no qual o eco é local, isto é, uma
vez digitado um caractere, o próprio cliente (terminal local) faz a apresentação do mesmo na tela, porém
só transmite para o servidor (host remoto) a linha inteira (ou até que pressionada a tecla <ENTER>).
Caractere: cada vez que um caractere é digitado o mesmo é enviado ao servidor, que o retransmite de
volta para que o cliente faça a apresentação na tela. Isto gera dois efeitos: em conexões mais lentas ou
congestionadas, pode haver um retardo entre a digitação e a apresentação do caractere; além disso
cada caractere digitado vai gerar três segmentos de TCP na rede.
Linha: a edição de linhas (eco, correção etc.) é realizada pelo cliente. Quando finalizada a edição pela
tecla <ENTER> então toda a linha é enviada para o servidor.

CORREIO ELETRÔNICO
Uma das aplicações mais conhecidas da internet é o correio eletrônico, ou o E-mail (do Inglês Electronic

Mail). No início da era da internet era possível trocar mensagens curtas e somente de texto entre dois
hosts distantes.

Atualmente as mensagens de e-mail são compostas de texto, áudio, imagem e vídeo, e podem ser
encaminhadas a vários destinos simultaneamente. O serviço de correio eletrônico usa uma arquitetura
com três componentes principais, a saber, o User Agent (UA), o Message Transfer Agent (MTA) e o

Message Access Agent (MAA).

O User Agent (UA)
Agente de usuário, é o serviço ou aplicação responsável pelas operações do e-mail no cliente, seja o
remetente ou o destinatário;
O Message Transfer Agent (MTA)
Agente de transferência de mensagens, é a aplicação cliente/servidor que responde pelo envio de
mensagens a um servidor de correio eletrônico;

Message Access Agent (MAA)
Agente de acesso às mensagens, é a aplicação cliente/servidor responsável por buscar as mensagens em
um servidor de e-mail.

Um serviço de Correio Eletrônico pode operar de quatro modos distintos:

No primeiro modo, o remetente e destinatário estão conectados no mesmo sistema. Neste caso é
necessário apenas o uso dos programas User Agent (UA). O remetente faz uso do UA para preparar e
encaminhar seu e-mail para o remetente que, quando usar seu UA, receberá a mensagem. É o caso
típico do serviço “mail” do UNIX/LINUX.
Em um segundo modo, o remetente e destinatário estão conectados a sistemas distintos. Então é
necessário o uso de dois programas User Agent (UA) e um par de programas Message Transfer Agent
(MTA), que funcionam em um modelo cliente/servidor para encaminhar a mensagem de um sistema ao
outro. Esse é o caso de uma mensagem de e-mail trocada entre dois sistemas UNIX/LINUX conectados à
rede.

Em um terceiro modo o Remetente faz parte de uma LAN/WAN e o destinatário está conectado
diretamente ao serviço de correio eletrônico. Nesse modo é necessário o uso de dois programas User

Agent (UA) e dois pares de servidores Message Transfer Agent, cada par funcionando em modelo
cliente/servidor para o encaminhamento da mensagem de um sistema até o outro.

Finalmente, no quarto modo, o remetente e destinatário estão conectados ao serviço de correio
eletrônico por meio de uma LAN/WAN. É necessário o uso de dois programas User Agent (UA), dois
pares de servidores Message Transfer Agent (MTA) e um par de servidores Message Access Agent
(MAA). Esse é o cenário típico atualmente na internet

SMTP – Simple Mail Transfer Protocol
O Protocolo Simples de Transferência de Mensagem é o protocolo que define a comunicação entre
cliente e servidor do Message Transfer Agent (MTA). O SMTP utiliza a porta 25 (conexão em texto plano)
ou a porta 465 (conexão criptografada via SSL). Em um processo típico de envio de e-mail o SMTP é
utilizado tanto entre o cliente (UA) e o servidor de correio quanto entre os servidores de correio MTA.

POP3 – Post Office Protocol versão 3
O POP3 – Post Office Protocol versão 3 ou Protocolo de Posto de Correio é o protocolo que define a
comunicação entre cliente e servidor Message Access Agent (MAA) para acessar as mensagens deixadas
em um servidor de e-mail. O POP3 acessa as mensagens no servidor de e-mail e as disponibiliza para o
UA apresentá-las ao seu destinatário. O POP3 permite o acesso em dois modos, o modo keep e o módulo

delete.
 No modo keep as mensagens são acessadas, porém mantidas no servidor de e-mail e, portanto,
podem ser acessadas novamente a partir de outro cliente MAA.
 No modo delete as mensagens são acessadas e excluídas do servidor de e-mail, sendo mantidas no
UA a partir desse ponto. O POP3 utiliza a porta 110 do TCP para acessar as mensagens de correio
eletrônico em um servidor.

IMAP4 – Internet Mail Access Protocol versão 4
O IMAP, ou Protocolo de Acesso a Correio pela Internet, é o protocolo que define a comunicação entre
cliente e servidor Message Access Agent (MAA) de forma similar ao POP3, porém com muitos recursos
adicionais, como por exemplo:
 É possível acessar o assunto de um e-mail antes de transferi-lo para o UA;
 É possível pesquisar um conteúdo específico nos e-mails do servidor;
 É possível baixar parcialmente um e-mail (sem as imagens, vídeos ou anexos, por exemplo);
 Também é possível que o usuário gerencie pastas e defina o armazenamento de suas mensagens
nestas pastas no servidor de e-mail.
O IMPA4 utiliza a porta 143 do TCP para as conexões cliente/servidor com o servidor de e-mail.

TRANSFERÊNCIA DE ARQUIVOS - FTP – File Transfer Protocol
O FTP, ou Protocolo de Transferência de Arquivos, é o protocolo padrão do TCP/IP para transferência de
arquivos entre hosts. É uma aplicação cliente/servidor que estabelece duas conexões entre os hosts:
uma para os dados e outra para o controle da transferência, e utiliza as portas 20 e 21 para essas duas
conexões. Para acessar o servidor e fazer uma transferência é necessário ter uma conta com um nome
de usuário (login) e uma senha. A transmissão dos dados do FTP é feita por uma conexão TCP. É
possível utilizar também o FTP Anônimo para arquivos de acesso público. Nesse caso, geralmente não é
necessário login e senha, porém o padrão é que sejam:
Login: anonymous
Senha: guest
Nestes casos o acesso ao sistema é restrito e poucas operações são permitidas.

Outra alternativa para o FTP é o TFPT - Trivial File Transfer Protocol, um protocolo de transferência de
arquivos muito simples e muito semelhante ao FTP.
É muito utilizado para transferir pequenos arquivos entre hosts de uma rede, como, por exemplo,
quando um terminal remoto ou um cliente inicia o seu funcionamento, a partir do servidor.
Caso você queira conhecer mais leituras indicadas

Assista agora a mais um vídeo do professor Luis

sobre esse assunto, procure o livro Redes de

para conhecer mais sobre esses protocolos e

Computadores, de Andrew Tenenbaum e David

domínios.

Wetherall, e acesse o site indicado a seguir, que
traz o livro Rede de Computadores e a
Internet de Kurose e Ross.
http://wps.aw.com/br_kurose_rede_1/7/2003/51
2809.cw/main/index.html

http://ava.grupouninter.com.br/videos/video2.ph
p?video=http://vod.grupouninter.com.br/2015/A
GO/MT180008-A05-P02.mp4

TROCANDO IDEIAS

O FTP é utilizado por diversos serviços para a transferência de arquivos. Você consegue identificar quais
são esses serviços?

Acesse o fórum sobre aplicações e compartilhe suas descobertas, suas experiências, exponha suas
dúvidas...

NA PRÁTICA

Você quer embasar ainda mais o seu estudo? Então aproveite o vídeo a seguir em que as características
e o funcionamento do DNS é melhor explicado. Não perca!

https://www.youtube.com/watch?v=i4KMcl0tuEg

SÍNTESE
Nessa aula foram apresentados os protocolos e serviços da camada de aplicação voltados para o acesso
remoto via terminal, o correio eletrônico e a transferência de arquivos entre hosts.

Isso inclui conhecimentos acerca do DNS, SMTP, FTP, HTTP, POP e TELNET.

Tudo isso para que você compreenda como essas redes funcionam com seus protocolos, aplicações e
serviços!

COMPARTILHANDO

Que tal compartilhar o que você aprendeu?

Existem muitos fóruns e comunidades dedicadas às redes de computadores e de internet por ai! Procureos e compartilhe o conhecimento que você construiu aqui!

Até nossa próxima e última aula!




Redes de Computadores
Rota de Aprendizagem – Aula 06

Parte 1
Introdução
O assunto desta aula é a rede mundial de computadores – a World Wide Web ou teia de alcance
mundial, na tradução livre – e os protocolos do modelo TCP/IP que lhe dão sustentação, como o HTTP,
e a linguagem HTML.
Leitura recomendada: Tanenbaum, 2011 – Seções 1.5.1 e 7.3. Kurose, 2013 – Seções 1.1 e 2.2
Contextualizando
A rede mundial de computadores é um universo de informações distribuídas por toda a terra,
apresentando características de flexibilidade, facilidade de acesso e recursos os mais variados.
Desenvolvida originalmente pela Organização Europeia para a Pesquisa Nuclear (em francês:
Organisation Européenne pour la Recherche Nucléaire), conhecida como CERN (acrônimo para Conseil
Européen pour la Recherche Nucléaire), o maior laboratório de pesquisa de física de partículas do
mundo, a WWW espalhou-se rapidamente pelos ambientes científicos e acadêmicos, não demorando
metade de uma década para chegar aos computadores pessoais e tornar-se o maior fenômeno da
história das comunicações.
World Wide Web
A World Wide Web é um serviço cliente/servidor distribuído, no qual um cliente (browser)
pode acessar serviços em um ou mais servidores distribuídos por diversas localidades. Os serviços
constituem-se em sua maioria em provimento de conteúdo. O conteúdo é distribuído em sites, e cada
site administra seus documentos ou páginas web, com um servidor provendo o acesso aos documentos
mediante a requisição do browser do cliente.
O cliente
O cliente (browser) é aplicação que viabiliza o acesso, a apresentação dos documentos e a
interação com o usuário. É formado por três partes: o controlador, que provê a interface com o usuário
(teclado, mouse e tela), os programas clientes, que efetivamente acessam os documentos arquivados
nos servidores, e os interpretadores, que apresentam os documentos de acordo com o padrao por eles
definidos.

-1

Redes de Computadores
Rota de Aprendizagem – Aula 06

O servidor
O servidor armazena as páginas e os elementos que as compõem. Ao receber uma solicitação de
um cliente, busca a página e a transfere para o cliente para que possa interpretá-las e exibi-las. O
servidor também mantém as páginas solicitadas anteriormente em cache para melhorar a eficiência,
pois é provável que o acesso à uma página não seja único. Um servidor é um computador que utiliza
técnicas multitarefa / multithread / multiprocessamento para melhorar o desempenho, e assim
providenciar o atendimento a vários clientes simultâneos.
URL - Uniform Resource Locator
A URL - Uniform Resource Locator ou localizadora uniforme de recursos é utilizada pelo
protocolo HTTP para prover o acesso a documentos distribuídos mundo afora. Uma URL é um padrão
para a especificação de qualquer tipo de informação na Internet. O formato de uma URL é:
protocolo://host:porta/path, onde:
Protocolo: Identifica o tipo de aplicação utilizada para acessar o conteúdo;
Host: Nome do computador que armazena as informações. Geralmente começa com a
designação www, porém isto não é obrigatório;
Porta: Número da porta (0 – 65535) para acesso ao Host
Path: O caminho para chegar até a informação na estrutura de diretórios do Host. Utiliza o
mesmo modelo do sistema operacional UNIX.
Cookies
O projeto original da internet não previa a interatividade hoje existente, com sites que permitem
acesso apenas a clientes registrados previamente, lojas virtuais e comercio eletrônico com carrinhos de
compra, portais nos quais os usuários podem configurar as páginas que querem acessar e sites de
anúncios e publicidade. Para que isto se tornasse possível foi necessário criar um recurso destinado a
endereçar requisitos e funcionalidades das páginas destes sites, o cookie. A função do cookie é
armazenar informações da sessão e do cliente no host utilizado para o acesso ao site. O formato de um
cookie geralmente é um arquivo de texto ou sequência de caracteres contendo, na maioria dos casos:
 O nome de domínio do cliente;
 Informações coletadas pelo servidor relativas à sessão do cliente
 Data e hora
-2

Redes de Computadores
Rota de Aprendizagem – Aula 06

Estas informações permitirão o registro de preferências e da interatividade com o usuário de um site
de compras, por exemplo.
Pesquisa
Existem cookies no computador que você está usando? Como eles são? O que ele s contém? Isso
representa um risco para você? E para a rede ou os demais computadores da rede?
Documentos WEB
Os documentos da web podem ser de um dos seguintes tipos:
 Estáticos
 Dinâmicos
 Ativos
Os documentos estáticos apresentam uma estrutura fixa. O seu conteúdo é definido na criação
do documento. Armazenados nos servidores, estes documentos são apresentados pelo servidor ao
cliente quando solicitados, sem sofrer qualquer mudança: o cliente recebe apenas uma cópia do
documento. Este documento é construído com tags do HTML – Hipertext Markup Language ou
linguagem de marcação de hipertexto. O browser do cliente então “monta” a exibição do documento
obedecendo as marcações do texto feitas pelas tags HTML.
Os documentos dinâmicos, ao invés disso, são criados pelo servidor à cada solicitação de um
cliente. O seu conteúdo é definido por uma aplicação ou por um script. Quando o documento é solicitado,
o servidor executa a aplicação ou script para gerar seu conteúdo. Estes documentos são geralmente
construídos com o uso conjunto de HTML e de código escrito em CGI, PHP, JSP, ASP, ColdFusion, etc. São
portanto caracterizados pelo processamento server side, ou seja, pelo processamento de informações
no servidor para a formatação dos documentos.
Os documentos ativos são os que implicam na execução de um código pelo próprio cliente. Estes
documentos resultam de uma interação com o usuário ou com o host do cliente. Estes códigos são
geralmente formados por Applets Java ou JavaScript. O que diferencia estes códigos é que os Applets são
compostos de código executável, enquanto o JavaScript é composto por texto plano. Estes documentos
são caracterizados pelo processamento client side, ou seja, pelo processamento de informações no
próprio cliente, quer seja par ao envio ao servidor quer seja para a formatação dos documentos a serem
exibidos.
-3

Redes de Computadores
Rota de Aprendizagem – Aula 06

HTML – HyperText Markup Language
A HTML – Hipertext Markup Language ou linguagem de marcação de hipertexto. É a linguagem
padrão para a criação de páginas da World Wide Web. É composta por tags de início e fim para a
formatação da apresentação do conteúdo. Estas tags são incluídas no texto do documento para definir
a formação e a apresentação. As tags utilizam os sinais < > para delimitar seu conteúdo ou abrangência,
e é possível inserir atributos e valores nas tags. O HTML permite o uso de hyperlinks para referenciar
conteúdos em locais diferentes, por meio de URLs, seja este conteúdo uma imagem um áudio, um vídeo
ou mesmo outra página ou documento. Atualmente os sites já empregam o uso de HTML 5, com diversas
novas tags e funcionalidades, especialmente as voltadas para o tratamento e apresentação de
multimídia e gráficos.
HTTP – HyperText Transfer Protocol
O HTTP - HyperText Transfer Protocol ou protocolo para transferência de hipertexto é o
protocolo utilizado para acessar os dados na WEB. Pode-se dizer que é uma combinação de FTP e SMTP:
faz a transferência de arquivos do mesmo modo que o FTP usando conexão TCP, porém com apenas
uma conexão. E utiliza mensagens para a requisição de dados como o SMTP.
O HTTP usa os serviços TCP na porta 80 por padrão. Além disso o HTTP também inclui comandos
ou métodos nas mensagens, tais como GET, POST e PUT, que são interpretados pelos clientes e
servidores da Web e geram respostas em formato de códigos, dentre os quais o mais conhecido é o 404
(Not Found). O HTTP requer uma conexão persistente, partindo do princípio que, uma vez transferida
e exibida uma página, haverá uma interação com o usuário que resultará em nova mensagem ou
consulta. Então o servidor mantém a conexão mesmo após enviar a resposta ao cliente.
O HTTP permite o uso de servidores PROXY, os quais mantém uma cópia dos documentos em
seu cache. Neste caso, o cliente consulta primeiro o PROXY: se a informação não for localizada, então o
próprio PROXY consulta o WEB Server para obter a informação atualizada. Isto reduz o tráfego na rede
de forma significativa, especialmente em redes locais de grande porte.
Pesquisa
Procure na literatura e na internet, ou junto a colegas de curso e de trabalho, modelos de páginas
da web que contenham documentos dos seguintes tipos:
 Estáticos
 Dinâmicos
-4

Redes de Computadores
Rota de Aprendizagem – Aula 06

 Ativos
Analise o código destas páginas (dica: use a tecla F12 no browser) e tente identificar as tags e os
elementos que as compõem.
Trocando Ideias
Acesse o fórum sobre WEB e compartilhe suas descobertas, suas experiências, exponha suas
dúvidas. Faça contato com seus colegas de curso e de turma e discuta o que aprendeu. Esclareça suas
dúvidas.

-5

Redes de Computadores
Rota de Aprendizagem – Aula 06

Parte 2
Introdução
O assunto desta aula é o gerenciamento de redes e o protocolo do modelo TCP/IP que possibilita
o gerenciamento, o SNMP.
Leitura recomendada: Tanenbaum, 2011 – Seções 6.6, 7.4 e 7.5. Kurose, 2013 – Capítulo 9.
Contextualizand
O gerenciamento de rede é uma atividade extensa e complexa que implica na configuração, no
monitoramento, na execução de teste e na elaboração de diagnósticos relativos à operação da rede. O
objetivo principal é manter a operação da rede de forma estável e eficiente, privilegiando a qualidade
dos serviços esperada pelos usuários. O gerenciamento também faz parte das atividades relativas à
segurança da informação.
As atividades de gerenciamento de redes são compostas de tarefas executadas pela combinação
de hardware e software e administradas por pessoas dedicadas às atividades principais do processo de
gerenciamento. O principal elemento deste processo é o protocolo de gerenciamento SNMP.
Sistema de Gerenciamento de Redes
Um sistema de gerenciamento de redes é composto de um conjunto de atividades e recursos
para atender às principais funções do gerenciamento de rede, que podem ser agrupadas em:
 Gerenciamento de configuração
 Gerenciamento de falhas
 Gerenciamento de desempenho
 Gerenciamento de segurança
 Gerenciamento de contabilização
Gerenciamento de configuração:
O gerenciamento de configuração tem por finalidade informar o estado de cada elemento e sua
relação com os demais a cada instante, incluindo as mudanças e problemas ocorridos. Geralmente estas
informações são fornecidas pelos processos de reconfiguração e de documentação da rede
A reconfiguração decorre da necessidade de ajustar os componentes e as características da
rede para adequá-las às mudanças ocorridas no ambiente no qual a rede opera, e pode refletir
alterações no Hardware, no Software e nas contas de usuário.
-6

Redes de Computadores
Rota de Aprendizagem – Aula 06

A documentação também deve contemplar a configuração atualizada de Hardware, de Software
e das contas de usuário. Esta documentação compõe-se de diagramas e documentos de especificações
com as configurações atualizadas. São informações importantes acerca dos equipamentos – que
compõem o inventário de hardware:
 O tipo
 A marca e o modelo
 O número de série
 O fornecedor, incluindo endereço, telefones de contato, e-mail e web site
 Data de aquisição
 Procedimento de garantia e assistência técnica/suporte
 Informações para a manutenção preventiva
 Localização e responsável pela guarda/posse.
Outro componente do gerenciamento de configuração de grande importância é a documentação
do software ou inventário de software, que deve ser integrada ao registro de hardware e contemplar
pelo menos as seguintes informações:
 O tipo
 Versão
 Histórico da instalação (data, hora, quem instalou, parâmetros utilizados)
 Acordo de licenciamento
 Arquivos criados e atualizados
 Patches e correções aplicadas
Gerenciamento de falhas
O gerenciamento de falhas trata do funcionamento adequado de cada elemento da rede,
buscando o bom funcionamento da rede como um todo. O processo de gerenciamento de falhas da rede
comporta duas abordagens: gerenciamento reativo e gerenciamento proativo. O gerenciamento reativo
abrange as tarefas de detecção, isolamento, correção e registro de falhas. O gerenciamento proativo tem
por objetivos impedir a ocorrência de falhas por meio de medidas de prevenção e identificação de sinais
divergentes, ou mesmo da utilização de critérios específicos como a vida útil e a capacidade de trabalho
de determinados elementos da rede. Estes critérios podem também servir de referência para a

-7

Redes de Computadores
Rota de Aprendizagem – Aula 06

manutenção preventiva / preditiva dos componentes e equipamentos e também para a evolução ou
atualização tecnológica que garanta a continuidade operacional.
Gerenciamento de desempenho
O gerenciamento de desempenho busca a melhor eficiência os equipamentos e da rede como um
todo, e trabalha e, conjunto com o gerenciamento de falhas. Trata-se do monitoramento e controle da
rede com base em critérios quantitativos e qualitativos que analisa constantemente a capacidade, o
tráfego na rede, o throughput e o tempo de resposta.
A capacidade de uma rede é determinada em seu projeto, e pelos equipamentos e meios de
transmissão que fazem parte da rede. A capacidade é limitada e, uma vez ultrapassada, resulta em
problemas das mais diversas naturezas, como queda da comunicação, atrasos, perda de informações,
entre outros. O tráfego representa a quantidade de bits ou bytes que são encaminhados e recebidos
pelos nós de rede em função do tempo, e o tráfego excessivo ou desbalanceado pode superar a
capacidade da rede. O throughput é a taxa de transferência medida em um nó da rede ou trecho da rede
para determinar se há um gargalo ou estrangulamento no tráfego. É comum avaliar o throughput em
equipamentos de borda (routers, bridges, modems) ou links que conectam redes, subredes ou pontos
distantes, pois estes elementos podem determinar o tráfego de toda a rede em função de
congestionamentos. Diferentemente do tráfego, que pode variar soente entre trechos da rede ou
subrede, o throughput pode variar de um nó para outro, definindo a existência de um estrangulamento
ou gargalo e significando que há um problema ou falta de capacidade naquele nó. O tempo de resposta
é o intervalo de tempo entre o encaminhamento de uma solicitação de usuário e o recebimento da
resposta. Pode diferenciar-se, e muito, em função do horário, sendo geralmente classificado em tempo
de resposta médio e o tempo de resposta em horários de pico. Uma dificuldade adicional na medida do
tempo de resposta é separar o tempo de resposta da rede e o tempo de resposta dos serviços fornecidos
por meio da rede, como o acesso à bases de dados e aplicações, pois a percepção do usuário decorre de
ambos.
Gerenciamento de segurança
O gerenciamento de segurança é o processo que concentra as atividades de controle de acesso à
rede e aos elementos da rede. É o responsável pela aplicação da política de segurança – especialmente
no que diz respeito a tráfego e acesso, e depende de todos os demais processos para fazer a aplicação,
o monitoramento e o controle de uso e acesso aos recursos da rede. A segurança da rede consiste em
-8

Redes de Computadores
Rota de Aprendizagem – Aula 06

garantir o acesso devido e vetar o indevido, bem como garantir a informação em tráfego pela rede. O
gerenciamento de segurança também é o responsável por registar o uso da rede para efeitos de Controle
e Auditoria.
Gerenciamento de contabilização
O processo de gerenciamento de contabilização providencia a quantificação de acessos e o uso
dos recursos da rede, conhecida como Tarifação. Esta medição é necessária para efeitos de desempenho
e segurança, e tem como principais objetivos evitar o monopólio de recursos escassos ou críticos da
rede – como o link de internet, por exemplo - e promover o uso da forma mais eficiente possível. Além
disso a contabilização provê informações para os administradores planejarem a expansão e a
atualização da rede em função da demanda e do desempenho. É comum também haver o fornecimento
de informações da tarifação para fins de Auditoria.
SNMP – Simple Network Management Protocol
O protocolo simples para gerenciamento de redes é um Framework para gerenciamento de
dispositivos em rede com base no TCP/IP e que usa o conceito de gerente e agente. É um protocolo do
nível de aplicação, o que permite sua utilização independe das características físicas da rede e dos
fabricantes do hardware. Um elemento gerente – ou gerenciador – é um host ou estação que executa
uma aplicação SNMP Cliente. Um elemento agente é um equipamento de rede que executa uma
aplicação SNMP Servidor. O gerenciamento é o resultado da interação entre o cliente e o(s) servidor(es).
O agente é responsável por coletar as informações e mantê-las em uma base de dados, e encaminhá-las
ao gerente quando solicitado, para que o gerente avalie as informações e também possa endereçar ações
ao equipamento no qual o agente está em execução. Os agentes também podem transmitir mensagens
de alerta, os traps, no caso de identificação de situações anômalas, falhas ou problemas de capacidade.
Desta forma o gerenciamento de redes por meio do SNMP ocorre com base em três funções
primordiais:
1) O monitoramento dos agentes feito por um gerente que solicita as informações, aas quais
refletem o comportamento e a situação do equipamento no qual o agente está instalado;
2) A execução de tarefas pelo agente em cumprimento à uma determinação de um gerente;
3) A comunicação de exceções por meio de um agente a um gerente.

-9

Redes de Computadores
Rota de Aprendizagem – Aula 06

O SNMP geralmente é implementado em uma ferramenta mais abrangente que cuida da criação
e atualização de estatísticas e de sua apresentação, geralmente em formato gráfico. Além disso o SNMP
conta com dois protocolos auxiliares:
 SMI – Structure of Management Information, ou estrutura de informações de gerenciamento;
 MIB – Management Information Base, ou base de informações de gerenciamento.

SMI– Structure of Management Information
O SMI é o protocolo que define as regras de atribuição de nomes, estabelece tipos de objetos e
mostra como codificar os objetos e valores. Porém não define o número de objetos, não lhes dá nomes
e tampouco atua na associação entre s objetos e seus valores.
MIB – Management Information Base, ou base de informações de gerenciamento
O MIB é o protocolo que cuida da criação de um conjunto de objetos, nomes, tipos e relações
entre si para um equipamento gerenciável da rede, formando um banco de dados para o equipamento.
Estas informações serão solicitadas pelo SNMP e, em função delas, determinadas ações poderão ser
comandas ao agente.
Síntese
Foram apresentados nesta aula os protocolos de grande importância para o uso e para o
gerenciamento das redes. O mundo WWW e o protocolo HTTP, em conjunto com a linguagem HTML,
que tornaram a internet um padrão mundial e algo que não pode mais ser dissociado do cotidiano das
pessoas e das organizações. Pode-se dizer que estes protocolos definiram o que chamamos de internet
na atualidade, dando um formato característico e tornando-a uma ferramenta de fácil utilização.
Já o protocolo SNMP possibilita o gerenciamento de redes extensas e complexas de forma
simplificada e eficaz, possibilitando o uso de forma adequada e cada vez mais seguro, além de
possibilitar a evolução contínua dos serviços prestados por meio da rede.
Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre a www, o HTTP e HTML e o
gerenciamento de redes com seus colegas de curso e de trabalho. Procure expandir e aprofundar o
conhecimento sobre o conteúdo apresentado lendo as páginas recomendadas da bibliografia e
acessando o conteúdo indicado.
- 10

Redes de Computadores
Rota de Aprendizagem – Aula 06

Autoavaliação
- Qual a relação entre WWW e HTTP?
- Quais as semelhanças entre HTTP e FTP? E entre HTTP e SMTP?
- Para que serve uma URL, e como é composta?
- Qual é estrutura de um browser, e qual é a finalidade de seus componentes?
- Quantos tipos de documentos WEB existem, e quais são suas características?
- Defina em poucas palavras o HTML.
- Quais são as funções básicas do gerenciamento?
- Compare o gerenciamento de falhas com o gerenciamento de desempenho, e defina qual é mais
importante para a segurança da rede.
- Como funciona o SNMP?
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo. Pearson,
2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem. 6ª
Ed. São Paulo. Pearson, 2013.

- 11



CONVERSA INICIAL
Sejam bem-vindos a mais uma aula de Rede de Computadores!
O assunto deste encontro é a rede mundial de computadores – a World Wide
Web ou teia de alcance mundial, na tradução livre – e os protocolos do
modelo TCP/IP que lhe dão sustentação, como o HTTP e a linguagem HTML.
Falaremos também do gerenciamento dessas redes e de como o protocolo do
modelo TCP/IP o possibilita através do SNMP.
Boa aula!
CONTEXTUALIZANDO
A rede mundial de computadores é um universo de informações distribuídas
por toda a terra, apresentando características de flexibilidade, facilidade de
acesso e recursos muito variados.
Desenvolvida originalmente pela Organização Europeia para a Pesquisa
Nuclear (em francês: Organisation Européenne pour la Recherche Nucléaire),
conhecida como CERN1, a World Wide Web (WWW) espalhou-se rapidamente
pelos ambientes científicos e acadêmicos, não demorando metade de uma
década para chegar aos computadores pessoais e tornar-se o maior
fenômeno da história das comunicações.
O vídeo a seguir pode trazer várias respostas às suas primeiras curiosidades
sobre a WWW, aproveite!
https://www.youtube.com/watch?v=RysvkZm0U5U
World Wide Web
A World Wide Web é um serviço cliente/servidor distribuído, no qual um
cliente (browser) pode acessar serviços em um ou mais servidores
distribuídos por diversas localidades. Os serviços constituem-se em sua
maioria em provimento de conteúdo. O conteúdo é distribuído em sites, e
cada site administra seus documentos ou páginas web, com um servidor

1

Acrônimo para Conseil Européen pour la Recherche Nucléaire (CERN), é o
maior laboratório de física de partículas do mundo, localizado em Meyrin, na
região em Genebra, na fronteira Franco-Suíça.

provendo o acesso aos documentos mediante a requisição do browser do
cliente.
O cliente
O cliente (browser) é aplicação que viabiliza o acesso, a apresentação dos
documentos e a interação com o usuário. É formado por três partes: o
controlador, que provê a interface com o usuário (teclado, mouse e tela), os
programas clientes, que efetivamente acessam os documentos arquivados
nos servidores, e os interpretadores, que apresentam os documentos de
acordo com o padrão por eles definidos.
O servidor
O servidor armazena as páginas e os elementos que as compõem. Ao receber
uma solicitação de um cliente, busca a página e a transfere para o cliente para
que possa interpretá-las e exibi-las. O servidor também mantém as páginas
solicitadas anteriormente em cache para melhorar a eficiência, pois é
provável que o acesso a uma página não seja único. Um servidor é um
computador que utiliza técnicas multitarefa/multithread/multiprocessamento
para melhorar o desempenho e, assim, providenciar o atendimento a vários
clientes simultâneos.
URL - Uniform Resource Locator
A URL - Uniform Resource Locator ou localizadora uniforme de recursos - é
utilizada pelo protocolo HTTP para prover o acesso a documentos distribuídos
mundo afora. Uma URL é um padrão para a especificação de qualquer tipo de
informação na Internet. O formato de uma URL é:
protocolo://host:porta/path
Protocolo: identifica o tipo de aplicação utilizada para acessar o conteúdo.
Host: nome do computador que armazena as informações. Geralmente
começa com a designação WWW, porém isso não é obrigatório.
Porta: número da porta (0 – 65535) para acesso ao Host.
Path: o caminho para chegar até a informação na estrutura de diretórios do
Host. Utiliza o mesmo modelo do sistema operacional UNIX.
Cookies
O projeto original da internet não previa a interatividade hoje existente, com
sites que permitem acesso apenas a clientes registrados previamente, lojas
virtuais e comercio eletrônico com carrinhos de compra, portais nos quais os
usuários podem configurar as páginas que querem acessar e sites de anúncios
e publicidade.
Para que isso se tornasse possível, foi necessário criar um recurso destinado a
endereçar requisitos e funcionalidades das páginas desses sites, o cookie. A
função do cookie é armazenar informações da sessão e do cliente no host
utilizado para o acesso ao site. O formato de um cookie geralmente é um
arquivo de texto ou sequência de caracteres contendo, na maioria dos casos:
o nome de domínio do cliente; informações coletadas pelo servidor relativas
à sessão do cliente e data e hora.

Estas informações permitirão o registro de preferências e da interatividade
com o usuário de um site de compras, por exemplo.
PESQUISE
Vamos começar a pesquisar?
Existem cookies no computador que você está usando? Como eles são? O que
eles contêm? Isso representa um risco para você?
Pesquise tudo isso, poderá ser importante para o seu aprendizado!
Documentos WEB
Os documentos da web podem ser de um dos seguintes tipos:
Continue sua pesquisa, na literatura e na internet, ou junto a colegas de curso
e de trabalho, sobre modelos de páginas da web que contenham documentos
dos seguintes tipos: estáticos, dinâmicos e ativos. Analise o código dessas
páginas (dica: use a tecla F12) e tente identificar as tags e os elementos que
as compõem!
Os documentos estáticos apresentam uma estrutura fixa. O seu conteúdo é
definido na criação do documento. Armazenados nos servidores, esses
documentos são apresentados pelo servidor ao cliente quando solicitados,
sem sofrer qualquer mudança: o cliente recebe apenas uma cópia do
documento. Este documento é construído com tags do HTML – Hipertext
Markup Language ou linguagem de marcação de hipertexto. O browser do
cliente, então, “monta” a exibição do documento obedecendo as marcações
do texto feitas pelas tags HTML.
Os documentos dinâmicos, ao invés disso, são criados pelo servidor à cada
solicitação de um cliente. O seu conteúdo é definido por uma aplicação ou
por um script. Quando o documento é solicitado, o servidor executa a
aplicação ou script para gerar seu conteúdo. Esses documentos são
geralmente construídos com o uso conjunto de HTML e de código escrito em
CGI, PHP, JSP, ASP, ColdFusion etc. São, portanto, caracterizados pelo
processamento server side, ou seja, pelo processamento de informações no
servidor para a formatação dos documentos.
Os documentos ativos são os que implicam na execução de um código pelo
próprio cliente. Esses documentos resultam de uma interação com o usuário
ou com o host do cliente. Esses códigos são geralmente formados por Applets
Java ou JavaScript. O que diferencia esses códigos é que os Applets são
compostos de código executável, enquanto o JavaScript é composto por texto
plano. Esses documentos são caracterizados pelo processamento client side,
ou seja, pelo processamento de informações no próprio cliente, quer seja
para o envio ao servidor, quer seja para a formatação dos documentos a
serem exibidos.

HTML – HyperText Markup Language
A HTML – Hipertext Markup Language ou linguagem de marcação de
hipertexto. É a linguagem padrão para a criação de páginas da World Wide
Web. É composta por tags de início e fim para a formatação da apresentação
do conteúdo. Essas tags são incluídas no texto do documento para definir a
formação e a apresentação.
As tags utilizam os sinais < > para delimitar seu conteúdo ou abrangência e é
possível inserir atributos e valores nas tags. O HTML permite o uso de
hyperlinks para referenciar conteúdos em locais diferentes, por meio de URLs,
seja esse conteúdo uma imagem, um áudio, um vídeo ou mesmo outra página
ou documento.
Atualmente os sites já empregam o uso de HTML 5, com diversas novas tags e
funcionalidades, especialmente as voltadas para o tratamento e apresentação
de multimídia e gráficos.
HTTP – HyperText Transfer Protocol
O HTTP - HyperText Transfer Protocol ou protocolo para transferência de
hipertexto é o protocolo utilizado para acessar os dados na WEB. Pode-se
dizer que é uma combinação de FTP e SMTP: faz a transferência de arquivos
do mesmo modo que o FTP usando conexão TCP, porém com apenas uma
conexão e utiliza mensagens para a requisição de dados como o SMTP.
O HTTP usa os serviços TCP na porta 80 por padrão. Além disso, o HTTP
também inclui comandos ou métodos nas mensagens, tais como GET, POST e
PUT, que são interpretados pelos clientes e servidores da Web e geram
respostas em formato de códigos, dentre os quais o mais conhecido é o 404
(Not Found).
O HTTP requer uma conexão persistente, partindo do princípio que, uma vez
transferida e exibida uma página, haverá uma interação com o usuário que
resultará em nova mensagem ou consulta. Então o servidor mantém a
conexão mesmo após enviar a resposta ao cliente.
O HTTP permite o uso de servidores PROXY, os quais mantém uma cópia dos
documentos em seu cache. Nesse caso, o cliente consulta primeiro o PROXY:
se a informação não for localizada, então o próprio PROXY consulta o WEB
Server para obter a informação atualizada. Isso reduz o tráfego na rede de
forma significativa, especialmente em redes locais de grande porte.
O gerenciamento de rede é uma atividade extensa e complexa que implica na
configuração, no monitoramento, na execução de teste e na elaboração de
diagnósticos relativos à operação da rede. O objetivo principal é manter a
operação da rede de forma estável e eficiente, privilegiando a qualidade dos
serviços esperada pelos usuários. O gerenciamento também faz parte das
atividades relativas à segurança da informação.
As atividades de gerenciamento de redes são compostas de tarefas
executadas pela combinação de hardware e software e administradas por
pessoas dedicadas às atividades principais do processo de gerenciamento. O
principal elemento desse processo é o protocolo de gerenciamento SNMP.

Sistema de Gerenciamento de Redes
Um sistema de gerenciamento de redes é composto de um conjunto de
atividades e recursos para atender às principais funções do gerenciamento de
rede, que podem ser agrupadas em cinco gerenciamentos de: Configuração;
Falhas; Desempenho; Segurança e Contabilização.
O gerenciamento de configuração tem por finalidade informar o estado de
cada elemento e sua relação com os demais a cada instante, incluindo as
mudanças e problemas ocorridos. Geralmente essas informações são
fornecidas pelos processos de reconfiguração e de documentação da rede.
A reconfiguração decorre da necessidade de ajustar os componentes e as
características da rede para adequá-las às mudanças ocorridas no ambiente
no qual a rede opera, e pode refletir alterações no Hardware, no Software e
nas contas de usuário.
A documentação também deve contemplar a configuração atualizada de
Hardware, de Software e das contas de usuário. Essa documentação compõese de diagramas e documentos de especificações com as configurações
atualizadas. Veja a seguir as informações e componentes importantes para
Hardware e Software.
São informações importantes acerca dos equipamentos – que compõem o
inventário de hardware: o tipo; a marca e o modelo; o número de série; o
fornecedor, incluindo endereço, telefones de contato, e-mail e web site; data
de aquisição; procedimento de garantia e assistência técnica/suporte;
informações para a manutenção preventiva; localização e responsável pela
guarda/posse.
Outro componente do gerenciamento de configuração de grande importância
é a documentação do software ou inventário, que deve ser integrada ao
registro de hardware e contemplar pelo menos as seguintes informações: o
tipo; versão; histórico da instalação (data, hora, quem instalou e parâmetros
utilizados); acordo de licenciamento; arquivos criados e atualizados; patches e
correções aplicadas.
Gerenciamento de falhas
O gerenciamento de falhas trata do funcionamento adequado de cada
elemento da rede, buscando o bom funcionamento da rede como um todo. O
processo de gerenciamento de falhas da rede comporta duas abordagens:
gerenciamento reativo e gerenciamento proativo.
 O reativo abrange as tarefas de detecção, isolamento, correção e
registro de falhas.
 O proativo tem por objetivos impedir a ocorrência de falhas por meio
de medidas de prevenção e identificação de sinais divergentes, ou
mesmo da utilização de critérios específicos como a vida útil e a
capacidade de trabalho de determinados elementos da rede.
Esses critérios podem também servir de referência para a manutenção
preventiva/preditiva dos componentes e equipamentos e, também, para a
evolução ou atualização tecnológica que garanta a continuidade operacional.

Gerenciamento de desempenho
O gerenciamento de desempenho busca a melhor eficiência os equipamentos
e da rede como um todo, e trabalha em conjunto com o gerenciamento de
falhas. Trata-se do monitoramento e controle da rede com base em critérios
quantitativos e qualitativos que analisa constantemente a capacidade, o
tráfego na rede, o throughput e o tempo de resposta.
A capacidade de uma rede é determinada em seu projeto e pelos
equipamentos e meios de transmissão que fazem parte da rede. A capacidade
é limitada e, uma vez ultrapassada, resulta em problemas das mais diversas
naturezas, como queda da comunicação, atrasos, perda de informações,
entre outros.
O tráfego representa a quantidade de bits ou bytes que são encaminhados e
recebidos pelos nós de rede em função do tempo, e o tráfego excessivo ou
desbalanceado pode superar a capacidade da rede.
O throughput é a taxa de transferência medida em um nó da rede ou trecho
da rede para determinar se há um gargalo ou estrangulamento no tráfego. É
comum avaliar o throughput em equipamentos de borda (routers, bridges,
modems) ou links que conectam redes, subredes ou pontos distantes, pois
esses elementos podem determinar o tráfego de toda a rede em função de
congestionamentos. Diferentemente do tráfego, que pode variar somente
entre trechos da rede ou subrede, o throughput pode variar de um nó para
outro, definindo a existência de um estrangulamento ou gargalo e
significando que há um problema ou falta de capacidade naquele nó.
O tempo de resposta é o intervalo de tempo entre o encaminhamento de
uma solicitação de usuário e o recebimento da resposta. Pode diferenciar-se,
e muito, em função do horário, sendo geralmente classificado em tempo de
resposta médio e o tempo de resposta em horários de pico. Uma dificuldade
adicional na medida do tempo de resposta é separar o tempo de resposta da
rede e o tempo de resposta dos serviços fornecidos por meio da rede, como o
acesso às bases de dados e aplicações, pois a percepção do usuário decorre
de ambos.
Gerenciamento de segurança
O gerenciamento de segurança é o processo que concentra as atividades de
controle de acesso à rede e aos elementos da rede. É o responsável pela
aplicação da política de segurança – especialmente no que diz respeito a
tráfego e acesso, e depende de todos os demais processos para fazer a
aplicação, o monitoramento e o controle de uso e acesso aos recursos da
rede.
A segurança da rede consiste em garantir o acesso devido e vetar o indevido,
bem como garantir a informação em tráfego pela rede. O gerenciamento de
segurança também é o responsável por registar o uso da rede para efeitos de
Controle e Auditoria.

Gerenciamento de contabilização
O processo de gerenciamento de contabilização providencia a quantificação
de acessos e o uso dos recursos da rede, conhecida como Tarifação.
Essa medição é necessária para efeitos de desempenho e segurança, e tem
como principais objetivos evitar o monopólio de recursos escassos ou críticos
da rede – como o link de internet, por exemplo - e promover o uso da forma
mais eficiente possível.
Além disso, a contabilização provê informações para os administradores
planejarem a expansão e a atualização da rede em função da demanda e do
desempenho. É comum também haver o fornecimento de informações da
tarifação para fins de Auditoria.
SNMP – Simple Network Management Protocol
O protocolo simples para gerenciamento de redes é um Framework para
gerenciamento de dispositivos em rede com base no TCP/IP e que usa o
conceito de gerente e agente. É um protocolo do nível de aplicação, o que
permite sua utilização independe das características físicas da rede e dos
fabricantes do hardware. Um elemento gerente – ou gerenciador – é um host
ou estação que executa uma aplicação SNMP Cliente. Um elemento agente é
um equipamento de rede que executa uma aplicação SNMP Servidor. O
gerenciamento é o resultado da interação entre o cliente e o(s) servidor(es).
O agente é responsável por coletar as informações e mantê-las em uma base
de dados, e encaminhá-las ao gerente quando solicitado, para que o gerente
avalie as informações e também possa endereçar ações ao equipamento no
qual o agente está em execução. Os agentes também podem transmitir
mensagens de alerta, os traps, no caso de identificação de situações
anômalas, falhas ou problemas de capacidade.
Dessa forma, o gerenciamento de redes por meio do SNMP ocorre com base
em três funções primordiais:
1. O monitoramento dos agentes feito por um gerente que solicita as
informações, que refletem o comportamento e a situação do
equipamento no qual o agente está instalado;
2. A execução de tarefas pelo agente em cumprimento à determinação de
um gerente;
3. A comunicação de exceções por meio de um agente a um gerente.
O SNMP geralmente é implementado em uma ferramenta mais abrangente
que cuida da criação e atualização de estatísticas e de sua apresentação,
geralmente em formato gráfico. Além disso, o SNMP conta com dois
protocolos auxiliares:
 SMI – Structure of Management Information, ou estrutura de
informações de gerenciamento;
 MIB – Management Information Base, ou base de informações de
gerenciamento.

SMI– Structure of Management Information
O SMI é o protocolo que define as regras de atribuição de nomes, estabelece
tipos de objetos e mostra como codificar os objetos e valores. Porém não
define o número de objetos, não lhes dá nomes e tampouco atua na
associação entre s objetos e seus valores.
MIB – Management Information Base, ou base de informações de
gerenciamento
O MIB é o protocolo que cuida da criação de um conjunto de objetos, nomes,
tipos e relações entre si para um equipamento gerenciável da rede, formando
um banco de dados para o equipamento. Estas informações serão solicitadas
pelo SNMP e, em função delas, determinadas ações poderão ser comandas ao
agente.
TROCANDO IDEIAS
Acesse o fórum sobre WEB e compartilhe suas descobertas em pesquisas,
suas experiências e exponha suas dúvidas. Aproveite também para fazer o
contato com seus colegas de curso e de turma e discuta o que aprendeu.
NA PRÁTICA
Os quatro vídeos a seguir falam mais sobre a prática do gerenciamento de
redes, assista e complemente seu estudo!
https://www.youtube.com/watch?v=RntTxnDsM9g
https://www.youtube.com/watch?v=PqgDoG4gLK0
https://www.youtube.com/watch?v=q2DkfPzXgAA
https://www.youtube.com/watch?v=B1sIGZczwUM
SÍNTESE
Foram apresentados nessa aula os protocolos de grande importância para o
uso e para o gerenciamento das redes. O mundo WWW e o protocolo HTTP,
em conjunto com a linguagem HTML, tornaram a internet um padrão mundial
e algo que não pode mais ser dissociado do cotidiano das pessoas e das
organizações.
Pode-se dizer que esses protocolos definiram o que chamamos de internet na
atualidade, dando um formato característico e tornando-a uma ferramenta de
fácil utilização. Já o protocolo SNMP possibilita o gerenciamento de redes
extensas e complexas de forma simplificada e eficaz, possibilitando o uso de
forma adequada e cada vez mais seguro, além de possibilitar a evolução
contínua dos serviços prestados por meio da rede.
COMPARTILHANDO
Que tal compartilhar o que você aprendeu?
Discuta sobre a www, o HTTP e HTML e o gerenciamento de redes com seus
colegas de curso e de trabalho. Procure expandir e aprofundar o
conhecimento sobre o conteúdo apresentado lendo as páginas recomendadas
da bibliografia e acessando o conteúdo indicado!
Assim, terminamos a nossa disciplina de Redes de Computadores.
Até mais!




---------------------------------------------------------------------------------
uninter sistemas operacionais

05/05/2022 22:49

UNINTER

SISTEMAS OPERACIONAIS
AULA 1

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/29

05/05/2022 22:49

UNINTER

CONVERSA INICIAL
Computadores são dispositivos eletrônicos criados para auxiliar nas tarefas do cotidiano das
pessoas. São máquinas incríveis, com grande poder de processamento e capacidade de
armazenamento. Os denominados sistemas de computação são compostos basicamente pelo
hardware (dispositivos físicos) e software (tarefas e rotinas previamente programadas) de forma
dependente, ou seja, só funcionam juntos, sendo praticamente inúteis sozinhos.
Essa interdependência é inicialmente comprovada pela necessidade de gerenciar os
componentes do hardware para funcionar corretamente, pois, quando ligados, os circuitos
eletrônicos ficam disponíveis para receber instruções ou tarefas, mas, se não forem enviadas,
tornam-se apenas uma peça decorativa.
Os sistemas computacionais eram a princípio grandes mainframes ou desktops, mas
atualmente, com o advento da internet das coisas (internet of things – IoT), eles estão presentes em
quase todos os dispositivos que utilizamos, como smartphones, tablets, smartwatches, smartTVs,
consoles de jogos, entre outros. Mesmo tão presentes no cotidiano das pessoas, poucos sabem
que, para que todos esses equipamentos nos auxiliem nas tarefas a que se propõem, são
necessárias rotinas de gestão e controle, implementadas em software e denominadas sistemas
operacionais.
Eles são responsáveis pela inicialização do hardware pelo kernel, e também pelo controle e
gestão segura dos dispositivos, dos processadores (CPU), das memórias e da entrada e saída de
dados. Também é responsável pela gestão e pelo controle do armazenamento e do uso de arquivos,
escalonamento de tarefas e gerenciamento de processos e recursos. Em síntese, é um grande
gestor das atividades do computador que interage com o usuário.

https://univirtus.uninter.com/ava/web/roa/

2/29

05/05/2022 22:49

UNINTER

É importante conhecer e entender essas tarefas de gestão e seus conceitos relacionados para
compreendermos o que é necessário para escolher, instalar, configurar e administrar sistemas
operacionais, desde a inicialização até a utilização pelo usuário final.
Nesta disciplina, além de desenvolver as competências necessárias para essas atividades,
apresentaremos e definiremos diversas outras rotinas. O conteúdo previsto contempla inicialmente
os conceitos e as definições de sistema operacional, numa visão geral, com um breve histórico e
evolução, apresentando seus objetivos e funções. Também apresentaremos sua classificação pela
arquitetura e pelos tipos e exemplos de sistemas operacionais.
Seguindo a definição de gestão apresentada, nesta disciplina veremos a gerência:
De processador e de processos;
De memória;
De dispositivos de entrada e saída;
De arquivos;
De proteção de usuários.
E os temas desta aula são:
1. Conceitos e definições de sistema operacional – visão geral;
2. Histórico e evolução;
3. Objetivos e funções;
4. Arquitetura e classificação;
5. Tipos e exemplos.
Aproveite o conteúdo e bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES INICIAIS – VISÃO GERAL
Segundo Tanenbaum e Bos (2016), sistema operacional é um programa que, do ponto de
vista do programador, acrescenta uma variedade de novas instruções e características acima e além
do que o nível ISA fornece. Normalmente, o sistema operacional é implementado, em grande parte,
em software, mas não há nenhuma razão teórica para não ser colocado em hardware, como
acontece com os microprogramas (quando estão presentes). Para abreviar, chamamos o nível que
https://univirtus.uninter.com/ava/web/roa/

3/29

05/05/2022 22:49

UNINTER

ele implementa de operating system machine (OSM), ou seja, “nível de máquina de sistema
operacional”.
Stallings (2017) define sistema operacional como um programa que gerencia os recursos do
computador, fornece serviços para os programadores e estabelece uma ordem de execução de
outros programas. É essencial certo conhecimento sobre sistemas operacionais para entender os
mecanismos pelos quais a CPU controla o computador – em particular, o efeito das interrupções e
o gerenciamento da hierarquia de memória.
Sistema operacional é o software que controla a execução de programas num processador e
gerencia os recursos do computador. Diversas funções desempenhadas pelo sistema
operacional, incluindo as duas mais relevantes para estudar a arquitetura e organização de
computadores – escalonamento de processos e gerenciamento de memória –, só podem ser
executadas de modo rápido e eficiente se ele dispuser de um suporte adequado do hardware do
processador.
Quase todos os processadores dispõem desse suporte, em maior ou menor extensão, incluindo
hardware de gerenciamento de memória virtual e de gerenciamento de processos. Isso inclui
registradores de propósito especial e áreas de armazenamento temporário, além de um conjunto de
circuitos para tarefas básicas de gerenciamento de recursos.
assim, um sistema de computação é constituído basicamente de dois elementos
interdependentes: o hardware e o software. O primeiro é basicamente composto de circuitos
eletrônicos internos: CPU (processador), memórias (primárias e secundárias), portas de
comunicação (entrada/saída), entre outros, como os periféricos externos (teclado, mouse, monitor,
câmera, microfone, dispositivos USB etc.). O segundo, por sua vez, é composto basicamente de
duas categorias:
1. Software de aplicação, representado por programas destinados ao usuário do sistema, que
constitui a razão final de seu uso (exemplo: editores de texto, multimídia players, editores de
imagem, jogos etc.);
2. Software de sistema, que está entre os aplicativos e o hardware. Trata-se de uma camada de
software multifacetada e complexa, denominada genericamente de sistema operacional, como
ilustra a Figura 1.

https://univirtus.uninter.com/ava/web/roa/

4/29

05/05/2022 22:49

UNINTER

Figura 1 – Sistema operacional

Fonte: I000S_Pixels; Hani Suwaryo; Crystal Eye Studio; Marisha; Den Rozhnovsky; Weera.OTP; DND_Project;
Nerthuz/Shutterstock.

A Figura 1 apresenta o sistema operacional como uma fronteira, uma interface entre o hardware
e os aplicativos. É ele que gerencia e orienta a fantástica transformação de pulsos elétricos do
hardware (representados pelos binários 0 e 1) nas mais diversas aplicações.
São essenciais para o funcionamento de todos os sistemas de computação, desde os
smartphones aos supercomputadores. Mesmo sendo muitos os sistemas operacionais existentes,
eles têm e seguem as mesmas regras e princípios. Devido à sua complexidade e ao seu tamanho, o
aprendizado de sistemas operacionais é tido como algo reservado a especialistas ou hackers,
contudo, é na verdade essencial para todos os profissionais de computação, pois as ferramentas
implementadas nos algoritmos dos sistemas operacionais afetam diretamente o comportamento e o
desempenho das aplicações. São também responsáveis pelos serviços de rede e pela segurança do
sistema e dos utilizadores.

TEMA 2 – HISTÓRIA E EVOLUÇÃO

https://univirtus.uninter.com/ava/web/roa/

5/29

05/05/2022 22:49

UNINTER

A primeira geração de computadores – também chamada de Geração 0 – foi a geração dos
computadores mecânicos, acionados por engrenagens e manivelas, dependendo totalmente do
usuário – o operador do sistema. Todas as tarefas eram manuais, e ainda não havia recursos para
automatizá-las eletronicamente.
Descrever a história e a evolução dos sistemas operacionais e dos computadores é muito
conveniente pois, até a 3ª geração dos computadores (1965-1980), descrita pelo cientista Robert
Noyce na integração de circuitos – o chip –, os computadores dependiam exclusivamente do
conhecimento e da habilidade de seus operadores – os usuários. Foi somente na 3ª geração que os
sistemas operacionais iniciaram seu desenvolvimento, como descreveremos aqui.
Os computadores têm sua história descrita e apresentada em 6 gerações. As 3 primeiras são de
computadores sem sistemas operacionais. Eram as seguintes:
0. Mecânicos (1642-1945);
1. Válvulas (1945-1955);
2. Transistores (1955-1965).
As 3 gerações seguintes são as de computadores com sistemas operacionais:
3. Integração (1965-1980);
4. Muita integração (1980-?);
5. Computadores invisíveis (atualmente).

2.1 GERAÇÃO 0 (MECÂNICOS) (1642-1945): MÁQUINAS SEM SISTEMA
OPERACIONAL
Surgiram no século XVII e eram compostos exclusivamente de elementos mecânicos, com
grande rigidez nos programas a executar. Hoje são chamadas de máquina dedicadas. As Figuras 2,
3 e 4 ilustram alguns exemplos dessa geração:

Figura 2 – Calculadora de Pascal (1642)

https://univirtus.uninter.com/ava/web/roa/

6/29

05/05/2022 22:49

UNINTER

Crédito: © CC-20/Edal Anton Lefterov.

Figura 3 – Máquina diferencial Babbage (1823)

Crédito: © CC-20/GFDL CC-BY-SA.

Figura 4 – Máquina Hollerith (1886)

https://univirtus.uninter.com/ava/web/roa/

7/29

05/05/2022 22:49

UNINTER

Crédito: © CC-20/Adam Schuster.

A geração dos mecânicos tem como marco histórico a máquina de Turing.
Colossus: o primeiro computador, mas ainda considerado mecânico, foi criado em 1946 por
Allan Turing, semelhante a um autômato finito, com memória ilimitada e irrestrita. Era capaz de
fazer tudo que um computador real faz, entretanto não resolvia certos problemas. O modelo de
Turing usava uma fita infinita como memória, tendo uma cabeça de fita que podia se mover, ler e
escrever símbolos.
Inicialmente, a fita continha apenas a entrada, e todo o restante estava em branco. Para
armazenar informação, escrevia sobre a fita, e para ler informação escrita, movia a cabeça para a
posição em que a informação era escrita, continuando a computar até produzir uma saída. As saídas
“aceite” e “rejeite” eram obtidas entrando em estados designados de aceitação e rejeição. Se não
entrasse em estado de aceitação ou rejeição, continuava para sempre, sem parar.

2.2 GERAÇÃO 1 (VÁLVULAS) (1945-1955): COMPUTADORES ELETRÔNICOS,
AINDA SEM SISTEMA OPERACIONAL
Essa é a primeira geração de computadores modernos. As válvulas necessitavam de muito
tempo para aquecer e consumiam muita energia elétrica. Eram grandes, porém frágeis, sua
manutenção era cara, e sua programação, feita com a ligação de fios ou cartões. Seus circuitos
eram interligados por quilômetros de fios instalados manualmente, atingindo velocidades na ordem
de milissegundos (1/1.000).

https://univirtus.uninter.com/ava/web/roa/

8/29

05/05/2022 22:49

UNINTER

John Mauchley (1907-1980) e Presper Eckert (1919-1995) construíram o Eniac em 1946, o 1º
computador eletrônico.

Figura 5 – Eniac

Crédito: Everett Historical/Shutterstock.

Ele tinha 18 mil válvulas e 1,5 mil relés, pesava 30 toneladas e tinha 20 registradores.
Consumia 140 quilowatts, e sua programação era feita em 6 mil chaves (Figura 6).

Figura 6 – Operação do Eniac

Crédito: © CC-20/U.S. Army Photo.

O matemático John von Neumann (1903-1957) foi colaborador do projeto Eniac, cujo
aperfeiçoamento foi o IAS, referência ao local onde foi desenvolvido – o Institute for Advanced
Studies, da universidade de Princeton. Credita-se a von Newmann a definição de uma arquitetura de
computadores com programa armazenado, utilizado até hoje. A Figura 7 ilustra essa definição:
https://univirtus.uninter.com/ava/web/roa/

9/29

05/05/2022 22:49

UNINTER

Figura 7 – Arquitetura de von Neumann

Fonte: Guerra, 2020.

Ele é considerado o “pai” do computador, pois em sua arquitetura utiliza aritmética binária e a
organização em quatro unidades:
1. Memória;
2. Unidade aritmética e lógica;
3. Unidade de controle;
4. Parte de E/S.
A arquitetura de von Neumann apresenta computadores de programa armazenado,
armazenando dados e programas na memória, e com ciclo de instrução repetitivo, executando cada
instrução com base numa sequência de etapas programadas. As características básicas do IAS o
apresentam como fundamental no estudo de arquitetura de computadores. Suas especificações
continuam válidas até hoje e têm memória com mil posições, denominadas palavras, cada uma com
valor de 40 bits. Seu dados e suas instruções são representadas em binários e gravadas (memória);
21 instruções de 20 bits, com 2 campos de 8 bits (código de operação); e outro com 12 bits
(endereço) para localizar cada uma das mil palavras, com endereços de 000 a 999.

2.3 GERAÇÃO 2 – TRANSISTORES (1955-1965): OS PRIMEIROS PROJETOS
DE SISTEMA OPERACIONAL
John Bardeen (1908-1991), Walter Brattain (1902-1987) e William Shockley (1910-1989),
funcionários da AT&T, criaram o transistor. Com as mesmas funções das válvulas, mas com custo
menor, consumem menos energia, são mais rápidos e confiáveis, sendo utilizados até hoje.
https://univirtus.uninter.com/ava/web/roa/

10/29

05/05/2022 22:49

UNINTER

Nessa geração foram criados os barramentos, um conjunto de fios paralelos usados para
conectar os componentes de um computador. Trata-se de uma ruptura importante em relação à
arquitetura da máquina IAS, centrada na memória e, desde então, foi adotada pela maioria dos
computadores de pequeno porte.
Foi apenas em 1953 que se iniciou o desenvolvimento do primeiro sistema operacional – por
sua simplicidade, chamado de monitor –, desenvolvido pelos usuários do computador IBM 701, do
Centro de Pesquisas da General Motors, para tentar automatizar tarefas até então manuais.
Posteriormente, esse sistema seria reescrito para um computador IBM 704, pelo grupo de usuários
da IBM (Weizer, 1981).
Em 1961, o pesquisador Fernando Corbató, do Massachusetts Institute of Technology (MIT),
com seu grupo de pesquisa, anunciou o desenvolvimento do compatible time-sharing system
(CTSS), o primeiro sistema operacional com compartilhamento de tempo (Corbató; Daggett; Daley,
1962).

2.4 GERAÇÃO 3 – INTEGRAÇÃO (1965-1980): INÍCIO DOS SISTEMAS
OPERACIONAIS
Essa foi a geração das “famílias de computadores”: mesmo tipo de máquina, com diferentes
capacidades

e

preços.

Tinham

uma

unidade

de

controle

com

microprogramação

e

multiprogramação, e vários programas compartilhavam a memória e dividiam CPU.
Com alta capacidade de processamento, utilizavam 32 bits e instrução de 250 nanossegundos,
com memória de 16 Mbytes. Sua memória principal
era orientada a byte, com um conjunto de programas gerenciadores de recursos
de hardware – o sistema operacional.
Essa geração tornou-se muito importante pois, além do sistema operacional, integrou os
circuitos pelo chip. Em 1968, Robert Noyce e Gordon Moore fundaram a Intel Corporation, criadora
do chip de memória de 1 KB e da lei de Moore: a integração de transistores em circuito integrado
dobra a cada 24 meses, mantendo-se os custos.
Em 1965, a IBM lançou o OS/360, um sistema operacional avançado, com compartilhamento de
tempo e um excelente suporte a discos. No mesmo ano, um projeto conjunto entre MIT, General
https://univirtus.uninter.com/ava/web/roa/

11/29

05/05/2022 22:49

UNINTER

Electric (GE) e Bell Labs deﬁniu o multiplexed information and computing service (Multics), que por
décadas inﬂuenciou vários outros sistemas operacionais.
Em 1969, Ken Thompson e Dennis Ritchie, pesquisadores da Bell Labs, desenvolveram a
primeira versão do Unix.

2.5 GERAÇÃO 4 – MUITA INTEGRAÇÃO (1980-?): POPULARIZAÇÃO DOS
COMPUTADORES E DOS SISTEMAS OPERACIONAIS
Marcian Hoff Junior, engenheiro da Intel, criou o Intel 4004, um microprocessador de 4 bits e
108 KHz, que tinha 2.300 transistores, velocidade de 60 mil operações/s e preço inicial de US$ 200.
Desde 1980, a miniaturização dos componentes internos e os avanços se relacionaram à escala de
integração dos circuitos integrados. A partir daqui, os sistemas operacionais ganharam destaque e
tiveram sua importância reconhecida. É nessa geração que famosas empresas foram fundadas e
conceitos foram criados. Acompanhe.
O primeiro destaque é o lançamento do sistema operacional da empresa Microsoft, o MS-DOS,
em 1981. Três anos após, em 1984, a Apple lançou o Mac OS 1.0, desenvolvido para os
computadores da linha Macintosh, o primeiro sistema operacional a ter uma interface gráﬁca
incorporada ao sistema. No ano seguinte, a Microsoft lançou o aplicativo com interface gráﬁca MSWindows 1.0.
Em 1987, Andrew S. Tanenbaum, professor de computação e autor de vários best-sellers,
desenvolveu o Minix, um sistema operacional didático simpliﬁcado, baseado na API do Unix. No
mesmo ano, a IBM e a Microsoft apresentaram a primeira versão de um sistema multitarefa
destinado a substituir o MS-DOS e o Windows: o OS/2. A parceria foi rompida em seguida, e a IBM
deu sequência ao OS/2, enquanto a Microsoft investiu no Windows.

2.6 GERAÇÃO 5 (ATUAL): COMPUTADORES INVISÍVEIS
Tanenbaum e Bos (2016) definem nossa atual geração como a geração dos computadores
invisíveis. Foi dado esse nome porque antigamente se falava que, no futuro (que é hoje), os
computadores estariam por toda parte, embutidos nos mais diversos locais, executando inusitadas
funções, como abertura de portas, acendimento de luzes, enfim, escondidos nos componentes
(invisíveis).
https://univirtus.uninter.com/ava/web/roa/

12/29

05/05/2022 22:49

UNINTER

Em 1991, um estudante de graduação em ciência da computação, Linus Torvalds (aluno de
Tanenbaum), utilizou o Minix como base para iniciar o desenvolvimento do Linux.

Figura 8 – Logotipo do Linux

Fonte: Rose Carson/Shutterstock.

A Microsoft só retornou em 1993, com o lançamento do Windows NT, o primeiro sistema 32 bits
da empresa. No mesmo ano, houve o lançamento dos Unix de código aberto – FreeBSD e NetBSD
–, e a Apple lançou o Newton OS, considerado o primeiro sistema operacional móvel, com gestão de
energia e suporte para tela de toque.
Nos anos seguintes, muitos novos sistemas operacionais surgiram. Listamos alguns a seguir:
1995: Windows 95;
1996: Windows NT 4.0; Mac OS 7.6 (first officially-named Mac OS);
1998: Windows 98; Novell NetWare 5;
2000: Windows Millennium Edition; Windows 2000;
2001: Windows XP; Mac OS X Cheetah (v. 10.0) – o novo SO da Apple, com arquitetura
distinta de suas versões anteriores, derivada da família Unix BSD;
2006: Windows Vista;
2007: iPhone OS 1 – lançamento do sistema operacional iOS, derivado do sistema operacional
Darwin;
2008: Android 1.0 – SO baseado em Linux para dispositivos móveis;

https://univirtus.uninter.com/ava/web/roa/

13/29

05/05/2022 22:49

UNINTER

2009: Windows 7;
2011: Solaris 11 11/11;
2012: Windows 8; Windows Phone 8;
2013: Windows CE 8.0; BlackBerry 10;
2015: Windows 10;
2017: Windows 10 Mobile Fall Creators Update;
2018: Windows Server 2019; iOS 13.1 – iPadOS 13.1;
2019: macOS Catalina (v10.15);
2020: Linux 5.6; NetBSD 9.0; Android 11.
Apresentamos o registro histórico de apenas alguns destaques. Sugerimos que você consulte a
bibliografia para conhecer muitas outras datas e sistemas operacionais.

TEMA 3 – OBJETIVOS E FUNÇÕES
Agora veremos os objetivos básicos do sistema operacional, como ele é estruturado para
alcançá-los e quais desafios ele deve resolver.
Existe uma grande distância entre circuitos eletrônicos, dispositivos de hardware e os
programas aplicativos em software. Os circuitos são complexos, acessados por interfaces de baixo
nível (geralmente usando as portas de entrada/saída do processador), e muitas vezes suas
características e seu comportamento dependem da tecnologia usada em sua construção (Maziero,
2019).
Por exemplo, a forma de acessar dados em disco (HD ou SSD) via hardware de baixo nível
(Sata III) é muito diferente do acesso a dados semelhantes em cartão de memória ou leitores de
discos óticos (DVD ou blu-ray). Toda essa grande diversidade de hardware pode tornar-se uma
grande dificuldade para quem o utiliza (como desenvolvedores de aplicativo). Então é desejável que
todas essas características e diferenças tecnológicas sejam abstraídas e se tornem invisíveis aos
aplicativos e aos utilizadores do sistema computacional.
É aqui que entra em cena o sistema operacional. Trata-se de uma camada de software que
opera entre o hardware e os aplicativos, como vimos no Tema 1 e conforme a Figura 10. É um
software de estrutura ampla e complexa que incorpora aspectos de baixo nível (como drivers de
https://univirtus.uninter.com/ava/web/roa/

14/29

05/05/2022 22:49

UNINTER

dispositivos e gerência de memória física) e de alto nível (como softwares utilitários e interface
gráﬁca).

Figura 10 – Estrutura típica de sistema operacional (Android)

Fonte: Guerra, 2020.

Stallings (2017) descreve que o sistema operacional é um programa que controla a execução
de aplicativos e age como interface entre o usuário e o hardware do computador. Tem
basicamente dois objetivos:
1. Conveniência: um sistema operacional visa tornar mais conveniente o uso do computador;
2. Eficiência: um sistema operacional permite uma utilização mais eficiente dos recursos do
sistema.
Os objetivos básicos de um sistema operacional, descritos por Maziero (2019), podem ser
sintetizados em duas palavras-chave: abstração e gerência. Vejamos em detalhes seus principais
aspectos.
https://univirtus.uninter.com/ava/web/roa/

15/29

05/05/2022 22:49

UNINTER

Abstração de recursos: acessar os recursos de hardware de um sistema de computação pode
ser uma tarefa complexa, devido às características especíﬁcas de cada dispositivo físico e à
complexidade de suas interfaces. Assim, o sistema operacional deve deﬁnir interfaces abstratas
para os recursos do hardware, visando atender os seguintes objetivos:
Prover interfaces de acesso mais simples que as de baixo nível, para simpliﬁcar a
construção de aplicativos. Por exemplo: para ler dados de um disco rígido, um programador
de aplicação usa o conceito de arquivo, que implementa uma visão abstrata do disco rígido,
acessível por operações como open, read e close. Se tivesse que acessar o disco diretamente,
seria necessário manipular portas de entrada/saída e registradores com comandos para o
controlador de disco (sem falar na diﬁculdade de localizar os dados desejados dentro do
disco);
Tornar os aplicativos independentes do hardware. Ao deﬁnir uma interface abstrata de
acesso a um dispositivo de hardware, o sistema operacional desacopla o hardware dos
aplicativos e permite que ambos evoluam de forma mais autônoma. Por exemplo, o código de
um editor de textos não deve depender da tecnologia de discos utilizada no sistema;
Deﬁnir interfaces de acesso homogêneas para dispositivos com tecnologias distintas.
Com suas abstrações, o sistema operacional permite aos aplicativos usar a mesma interface
para dispositivos diversos. Por exemplo, um aplicativo acessa dados em disco por meio de
arquivos e diretórios, sem precisar se preocupar com a estrutura real de armazenamento dos
dados, que podem estar num disquete, num disco Sata, numa máquina fotográﬁca digital
conectada à porta USB, num CD ou mesmo num disco remoto, compartilhado pela rede.
O hardware e o software usados para fornecer aplicações aos usuários podem ser vistos sob a
forma de uma organização hierárquica (ou em camadas), conforme a Figura 11.

Figura 11 – Camadas e visões de um sistema de computação

https://univirtus.uninter.com/ava/web/roa/

16/29

05/05/2022 22:49

UNINTER

Fonte: Stallings, 2017.

O usuário final – que vai utilizar essas aplicações – geralmente não se interessa pela arquitetura
do computador nem pelos detalhes do hardware. Ele vê o sistema de computação como uma
aplicação, pois os aplicativos são a última camada entre o sistema e o usuário, trazendo assim a
interface entre eles.
Os softwares de aplicação (apps) são desenvolvidos numa linguagem de programação por um
analista/desenvolvedor. Se fossem escritos usando o conjunto de instruções do processador e, além
disso, tivessem também que controlar o hardware do computador, a tarefa de desenvolver
programas seria extremamente complexa, quase impossível.
Para facilitar essa tarefa, existe um conjunto de programas de sistema. Alguns desses
programas são conhecidos como utilitários, que implementam funções usadas frequentemente e
criam programas, gerenciam arquivos e controlam dispositivos de E/S. Um programador usa esses
recursos para desenvolver uma aplicação que, ao ser executada, invoca os utilitários para
desempenhar certas funções.
O software de sistema mais importante é o sistema operacional, que esconde os detalhes do
hardware do programador, fornecendo uma interface conveniente para o uso do sistema. Ele age
como um mediador, facilitando o acesso e o uso de aplicativos e serviços para o programador. O
sistema operacional tipicamente fornece serviços para as seguintes atividades, que descrevem
algumas de suas funções:
Criação de programas: o sistema operacional apresenta uma variedade de recursos e
serviços para auxiliar o programador a desenvolver programas, como editores e depuradores.

https://univirtus.uninter.com/ava/web/roa/

17/29

05/05/2022 22:49

UNINTER

Esses serviços tipicamente são oferecidos na forma de programas utilitários, que na verdade
não são parte do sistema operacional, mas podem ser acessados por ele;
Execução de programas: várias tarefas precisam ser cumpridas para um programa ser
executado. Instruções e dados devem ser carregados na memória principal. Dispositivos de
E/S e arquivos precisam ser inicializados, e outros recursos devem ser preparados. O sistema
operacional cumpre todas essas tarefas para o usuário;
Acesso a dispositivos de E/S: cada dispositivo de E/S tem seu próprio conjunto peculiar de
instruções ou sinais de controle para operação. O sistema operacional cuida dos detalhes do
uso de cada dispositivo, de modo que o programador possa pensar apenas em termos de
operações simples de leitura e de escrita;
Acesso controlado aos arquivos: no caso de arquivos, o controle deve incluir não apenas
um entendimento sobre a natureza do dispositivo de E/S (unidade de disco ou de fita), mas
também sobre o formato dos arquivos no meio de armazenamento. Mais uma vez, o sistema
operacional cuida dos detalhes. Além disso, no caso de sistemas usados simultaneamente por
vários usuários, ele fornece mecanismos de proteção para controlar o acesso aos arquivos;
Acesso ao sistema: no caso de sistemas compartilhados ou públicos, o sistema operacional
controla o acesso ao sistema como um todo e a recursos específicos também. A função de
acesso deve proteger o sistema contra o uso não autorizado, tanto para recursos quanto para
dados de usuários, e resolver conflitos em caso de contenção de um recurso;
Detecção e reação aos erros: diversos erros podem ocorrer durante a operação de um
sistema de computação, incluindo erros de hardware internos e externos, como erro de
memória e falha, ou mau funcionamento de dispositivo, além de vários erros de software, como
overflow em operação aritmética, tentativa de endereçar uma área de memória não permitida e
a impossibilidade de o sistema operacional atender à requisição de uma aplicação. Em cada
caso, o sistema operacional deve reagir no sentido de eliminar a condição de erro, com o
menor impacto possível sobre as aplicações em execução. Essa reação pode variar, desde
terminar a execução do programa que causou o erro até tentar executar novamente a
operação ou, simplesmente, relatar a ocorrência do erro à aplicação;
Monitoração: um bom sistema operacional mantém estatísticas de uso de vários recursos e
monitora parâmetros de desempenho, como o tempo de resposta. Em qualquer sistema, essa
informação é útil para antecipar a necessidade de futuros melhoramentos e para a sintonia do

https://univirtus.uninter.com/ava/web/roa/

18/29

05/05/2022 22:49

UNINTER

sistema, aumentando seu desempenho. Num sistema multiusuário, essa informação também
pode ser usada para tarifação, pela utilização de recursos.

3.1 SISTEMA OPERACIONAL COMO GERENTE DE RECURSOS – UM
OBJETIVO E UMA FUNÇÃO
Os aplicativos utilizam o hardware para atingir seus objetivos e tarefas, como criar, editar e
imprimir documentos, tocar músicas, exibir vídeos e imagens, ler e armazenar arquivos de dados e
informações, conectar-se à internet, entre outros. Num sistema com várias atividades simultâneas
(multitarefas), podem ocorrer conﬂitos na utilização do hardware, quando duas ou mais tarefas
precisam dos mesmos recursos para ser executadas. Uma das funções do sistema operacional é
deﬁnir políticas para gerenciar o uso dos recursos de hardware pelos aplicativos e resolver eventuais
disputas e conﬂitos.
O sistema operacional é o responsável por gerenciar o uso desses recursos. Portanto, é o
sistema operacional que controla o processamento, o armazenamento e a transferência de dados,
pois, gerenciando os recursos do computador, o sistema detém o controle das suas funções básicas.
Esse controle é exercido de maneira curiosa. Normalmente, pensamos no mecanismo de
controle como algo externo ao que é controlado ou, pelo menos, como algo que é uma parte distinta
e separada do que é controlado (por exemplo, um sistema de aquecimento residencial é controlado
por um termostato, que é completamente distinto do sistema de geração de calor e do aparato de
distribuição de calor). Não é o caso do sistema operacional que, como mecanismo de controle, é
incomum em dois aspectos:
O sistema operacional é um software como outro qualquer, sendo executado pelo processador,
e o sistema operacional frequentemente renuncia ao controle do processador para, em seguida,
obter o controle novamente; nada mais é do que um programa de computador. Semelhante a outros
softwares, ele contém instruções para o processador; a diferença-chave está na intenção do
programa.
O sistema operacional direciona o processador no uso dos recursos do sistema, assim como na
execução de outros programas. Mas, para que o processador execute outros programas, ele deve
interromper a execução do sistema operacional. Dessa maneira, ele libera o controle ao

https://univirtus.uninter.com/ava/web/roa/

19/29

05/05/2022 22:49

UNINTER

processador, para que ele possa executar algum trabalho “útil”, e então retoma o controle por tempo
suficiente para preparar o processador e executar uma próxima tarefa.
A Figura 12 apresenta os principais recursos gerenciados pelo sistema operacional:

Figura 12 – Camadas e visões de um sistema de computação

Fonte: Stallings, 2017.

Uma parte do sistema operacional reside na memória principal (RAM). Essa parte inclui o
núcleo (kernel), que contém as funções mais usadas pelo sistema operacional, além de outras
partes do sistema operacional em uso naquele momento. Outros dados e programas de usuário
ocupam o restante da memória principal (RAM). Então, a gestão da memória é feita com a alocação
controlada, em conjunto, pelo sistema operacional e pelo hardware de gerenciamento de memória
da CPU.
A gestão de recursos (dispositivos) de E/S é outra tarefa do sistema operacional, que decide
quando um dispositivo de E/S pode (ou não) ser usado pelo programa em execução, controlando o
acesso e o uso de arquivos.
A seguir, apresentamos exemplos de gestão de recursos do hardware.
A concorrência pela utilização do tempo de CPU (que futuramente estudaremos) é essencial
para que ocorra um grande número de tarefas pelo mesmo computador, que normalmente tem mais
tarefas a processar do que a quantidade de processadores disponíveis, complementando o conceito
de redução da ociosidade da CPU. O gerenciamento de recursos é fundamental para balancear sua
utilização, com distribuição justa entre os aplicativos e para que cada um deles seja executado na
velocidade adequada, cumprindo suas funções sem prejudicar as demais. No caso de um sistema
de computação com múltiplos processadores, essa decisão se estende a todos eles.
https://univirtus.uninter.com/ava/web/roa/

20/29

05/05/2022 22:49

UNINTER

Essa função é a gerência do processador – também conhecida como gerência de
processos, de tarefas ou de atividades –, que visa distribuir a capacidade de processamento de
forma justa entre as aplicações, evitando que uma aplicação monopolize esse recurso, respeitando,
assim, as prioridades definidas pelos usuários. O sistema operacional provê a ilusão de que existe
um processador independente para cada tarefa, o que facilita o trabalho dos programadores de
aplicações e permite construir sistemas mais interativos. Também faz parte da gerência de
atividades fornecer abstrações para sincronizar atividades interdependentes e prover formas de
comunicação entre elas.
O mesmo ocorre com a memória RAM, que também deve ser distribuída de forma justa entre as
aplicações. Aqui é descrita então a gerência de memória, cujo objetivo é fornecer a cada aplicação
uma área de memória própria, independente e isolada das demais aplicações, inclusive do sistema
operacional. O isolamento das áreas de memória das aplicações melhora a estabilidade e
segurança do sistema como um todo, pois impede aplicações com erros (ou aplicações maliciosas)
de interferir no funcionamento das demais aplicações. Além disso, caso a memória RAM existente
seja insuficiente para as aplicações, o sistema operacional pode aumentá-la de forma transparente
às aplicações, usando o espaço disponível num meio de armazenamento secundário (como um
disco rígido). Uma importante abstração construída pela gerência de memória (com o auxílio do
hardware) é a noção de memória virtual, que desvincula os endereços de memória vistos por cada
aplicação dos endereços acessados pelo processador na memória RAM. Com isso, uma aplicação
pode ser carregada em qualquer posição livre da memória, sem que seu programador se preocupe
com os endereços de memória em que ela irá executar.
A gerência de dispositivos, por sua vez, recebe destaque, pois cada periférico do computador
tem suas particularidades; assim, o procedimento de interação com uma placa de rede é
completamente diferente da interação com um disco rígido Sata. Todavia, existem muitos problemas
e abordagens em comum para o acesso aos periféricos. Por exemplo, é possível criar uma
abstração única para a maioria dos dispositivos de armazenamento, como cartão de memória, SSD,
CD-ROMs etc., na forma de um vetor de blocos de dados.
A função da gerência de dispositivos (também conhecida como gerência de entrada/saída) é
implementar a interação com cada dispositivo por meio de drivers e criar modelos abstratos que
permitam agrupar vários dispositivos similares sob a mesma interface de acesso. Outro recurso em
que o acesso deve ser mutuamente exclusivo (apenas um aplicativo por vez) é a impressão. O
https://univirtus.uninter.com/ava/web/roa/

21/29

05/05/2022 22:49

UNINTER

sistema operacional resolve essa questão utilizando o recurso de spooling (que estudaremos
futuramente), além de deﬁnir uma ﬁla de trabalhos a imprimir (print jobs), normalmente executados
de forma sequencial (first in, first out).
A gerência de arquivos é construída sobre a gerência de dispositivos e visa criar arquivos e
diretórios, definindo sua interface de acesso e as regras para seu uso. É importante observar que os
conceitos abstratos de arquivo e diretório são tão importantes e difundidos que muitos sistemas
operacionais costumam usá-los para permitir o acesso a recursos que nada têm a ver com
armazenamento. Exemplos disso são as conexões de rede (nos sistemas Unix e Windows, cada
socket TCP é visto como um descritor de arquivo, com o qual pode-se ler ou escrever dados) e as
informações internas do sistema operacional (como o diretório Proc do Unix).
A gerência de proteção de dados e usuários é outra importante tarefa de gestão de recursos.
Com computadores conectados em rede e compartilhados por vários usuários, é importante definir
claramente os recursos que cada usuário pode acessar, as formas de acesso permitidas (leitura,
escrita etc.), além de garantir que essas definições sejam cumpridas. Por exemplo, a proteção
contra os ataques de negação de serviço (denial of service – DoS[1]), comuns na internet. É
responsabilidade do sistema operacional do servidor detectar e impedir ataques como esses, em
que todos os recursos do sistema são monopolizados por um único usuário.
Para proteger os recursos do sistema contra acessos indevidos, é necessário:
Definir usuários e grupos de usuários;
Identificar os usuários que se conectam ao sistema por procedimentos de autenticação;
Definir e aplicar regras de controle de acesso aos recursos, relacionando todos os usuários,
recursos e formas de acesso, aplicando essas regras por procedimentos de autorização;
Registrar o uso dos recursos pelos usuários, para fins de auditoria e contabilização.
Assim, um sistema operacional visa abstrair o acesso e gerenciar os recursos de hardware,
provendo aos aplicativos um ambiente de execução abstrato, no qual o acesso aos recursos se faz
por interfaces simples, independentes das características e detalhes de baixo nível, minimizando os
conﬂitos no uso do hardware (Maziero, 2019).
As principais funções dos sistemas operacionais estão diretamente ligadas aos objetivos, pois,
para cumprir os objetivos de abstração e gerência, eles devem atuar em várias frentes. Cada um
https://univirtus.uninter.com/ava/web/roa/

22/29

05/05/2022 22:49

UNINTER

dos recursos do sistema tem suas particularidades, que impõem exigências específicas para
gerenciá-los e abstraí-los. Essas são as principais funcionalidades implementadas por um sistema
operacional típico.
Além dessas funcionalidades básicas oferecidas pela maioria dos sistemas operacionais, várias
outras se agregam aos sistemas modernos, para cobrir aspectos complementares, como a interface
gráfica, suporte de rede, fluxos multimídia, fontes de energia etc.
As funcionalidades do sistema operacional geralmente são interdependentes: por exemplo, a
gerência do processador depende de aspectos da gerência de memória, assim como a gerência de
memória depende da gerência de dispositivos e da gerência de proteção.

TEMA 4 – ARQUITETURA: CLASSIFICAÇÃO
É essencial conhecer as diferenças entre as arquiteturas dos sistemas operacionais para
escolher o mais adequado a cada situação. Algumas características básicas diferenciam os vários
tipos de sistemas operacionais, que
são classificados, segundo a arquitetura, quanto ao tempo de resposta e à entrada de dados
em sistema operacional, em lote (batch), interativos, tempo real e híbridos.
Essas características envolvem dois aspectos independentes. O primeiro especifica se o
sistema de computação é interativo ou é se um sistema de processamento em lotes (batch). Num
sistema interativo, o programador/usuário interage diretamente com o computador, normalmente
com um teclado e um monitor de vídeo, para requisitar a execução de tarefas (jobs) ou efetuar
transações. Além disso, ele pode, dependendo da natureza da aplicação, comunicar-se com o
computador durante a execução de uma tarefa.
Num sistema de processamento em lotes (batch), ocorre o oposto. O programa de um usuário é
agrupado com programas de outros usuários, e esse lote de programas é submetido à execução por
um operador de computador. Quando a execução do programa termina, os resultados são
impressos para ser entregues ao usuário. Hoje em dia são raros os sistemas que fazem
processamento exclusivamente em lotes, no entanto, é útil examiná-los brevemente para
entendermos melhor os sistemas operacionais atuais.

https://univirtus.uninter.com/ava/web/roa/

23/29

05/05/2022 22:49

UNINTER

O batch não exige interação com o usuário. A entrada de dados é feita por um dispositivo,
geralmente arquivos em disco, processamento de cálculos, compilações, ordenações e backups. Os
sistemas interativos – também conhecidos como sistemas de tempo compartilhado – geralmente
permitem a interação com usuário por meio de terminais, vídeo, teclado e mouse.
Com os sistemas de processamento em tempo real, o tempo de resposta é o fator principal do
sistema, utilizado em monitoramentos, controle de tráfego aéreo, de usinas nucleares etc. Os
sistemas híbridos são uma combinação de sistema batch com sistemas interativos.
Quanto à execução de tarefas, os sistemas operacionais são classificados como sistemas
monotarefa, multitarefa e multiprocessamento. Trata-se de outro aspecto independente, que
especifica se o sistema de computação emprega multiprogramação ou não.
A multiprogramação é uma tentativa de deixar o processador ocupado o maior tempo possível,
mantendo-o trabalhando em mais de um programa de cada vez. Diversos programas são
simultaneamente carregados na memória, e o tempo do processador é dividido entre eles. A
alternativa para esse tipo é um sistema de monoprogramação (uniprogramação), que executa
apenas um programa de cada vez.
Os sistemas monotarefa executam uma única aplicação de cada vez; já nos sistemas
multitarefa

várias

tarefas

concorrem

pelos

recursos

de

processamento.

Os

sistemas

multiprocessados têm duas ou mais CPUs interligadas, trabalhando em conjunto e fortemente ou
fracamente acopladas.
Os sistemas com multiprocessadores fortemente acoplados têm duas ou mais CPUs, que
compartilham uma única memória e são controladas por um único sistema operacional. Os
fracamente acoplados têm duas ou mais CPUs, cada uma com sua memória, sendo controladas
por sistemas operacionais independentes.
Quanto à estrutura, os sistemas operacionais são classificados basicamente como monolíticos,
em camadas, máquinas virtuais e cliente servidor.
Os

sistemas

operacionais

ainda

são

classificados

como

sistemas

operacionais

de

computadores de grande porte, servidores, computadores pessoais e sistemas operacionais
embarcados. Os embarcados são sistemas que controlam dispositivos móveis ou que não são
computadores, como micro-ondas, geladeiras, PDAs etc.
https://univirtus.uninter.com/ava/web/roa/

24/29

05/05/2022 22:49

UNINTER

Os sistemas operacionais modernos se dividem em várias camadas, e cada uma prova
serviços à camada superior mais próxima, protegendo a camada mais inferior, o núcleo do sistema
(ou kernel) do sistema operacional.
Os recursos do kernel são acessados por chamadas de sistema (system calls) de forma
protegida para não danificar o sistema. As instruções que têm o poder de comprometer o sistema
são conhecidas como instruções privilegiadas (modo kernel), enquanto as instruções não
privilegiadas não oferecem perigo.
Chamadas de sistema são os comandos de acesso às funções do sistema operacional e podem
ser divididos em chamadas: para gerenciar processos, para sinalização, para gerenciar arquivos,
manipular diretórios, proteger e gerenciar o tempo.

TEMA 5 – TIPOS E EXEMPLOS
Já classificados e denominados, os sistemas operacionais passam então a dividir-se em grupos
especializados, sendo mais indicados a certas demandas e menos a outras. A seguir, apresentamos
alguns tipos de sistemas operacionais. Muitos se encaixam em mais de um deles. Vejamos:
Batch (de lote): os sistemas operacionais mais antigos trabalhavam “por lote”, ou seja, todos
os programas a executar eram colocados numa fila, com seus dados e demais informações
para a execução. O processador recebia os programas e os processava sem interagir com os
usuários, o que permitia um alto grau de utilização do sistema. Atualmente, esse conceito se
aplica a sistemas que processam tarefas sem interação direta com os usuários, como os
sistemas de processamento de transações bancárias. Além disso, o termo “em lote” também é
usado para designar um conjunto de comandos que deve ser executado em sequência, sem
interferência do usuário. Exemplos: os clássicos IBM OS/360 e o VAX/VMS, entre outros;
De rede: um sistema operacional de rede deve ter suporte à operação em rede, ou seja, a
capacidade de oferecer às aplicações locais recursos localizados em outros computadores
conectados à rede, como arquivos e impressoras. Ele também deve disponibilizar seus
recursos locais aos demais computadores de forma controlada. A maioria dos sistemas
operacionais atuais oferece esse tipo de funcionalidade, dispensando exemplos;
Distribuído: num sistema operacional distribuído, os recursos de cada computador estão
disponíveis a todos que estejam conectados à rede, de forma transparente aos usuários. Ao
https://univirtus.uninter.com/ava/web/roa/

25/29

05/05/2022 22:49

UNINTER

lançar uma aplicação, o usuário interage com sua interface, mas não sabe onde está
executando ou armazenando seus arquivos: o sistema é quem decide, de forma transparente
ao usuário. Sistemas operacionais distribuídos já existem há muito tempo (como o Amoeba)
(Tanenbaum et al., 1991); recentemente, os ambientes de computação em nuvem têm
implementado esse conceito. Numa aplicação cloud (nuvem), o usuário interage com a
interface da aplicação num computador ou telefone, mas não tem uma visão clara das
máquinas em que seus dados estão sendo processados e armazenados. Exemplo: AWS
(Amazon Web Services) e Docker;
Multiusuário: um sistema operacional multiusuário deve suportar a identificação do “dono” de
cada recurso dentro do sistema (arquivos, processos, áreas de memória, conexões de rede) e
impor regras de controle de acesso para impedir o uso desses recursos por usuários não
autorizados. Essa funcionalidade é fundamental para a segurança dos sistemas operacionais
de rede e distribuídos. Grande parte dos sistemas atuais são multiusuários;
Servidor: um sistema operacional servidor deve permitir a gestão eficiente de muitos recursos
(disco, memória, processadores), impondo prioridades e limites sobre o uso dos recursos pelos
usuários e seus aplicativos. Normalmente um sistema operacional servidor também tem
suporte à rede e aos multiusuários. Exemplos: Windows Server 2019 e Oracle Linux Server;
Desktop: um sistema operacional “de mesa” é voltado ao atendimento do usuário doméstico
ou corporativo para atividades corriqueiras, como editar textos e gráficos, e reproduzir mídia.
Suas principais características são a interface gráfica, o suporte à interatividade e a operação
em rede. Exemplos de desktops: Windows 10, Linux e macOS X;
Móvel: um sistema operacional móvel é usado em equipamentos de uso pessoal compactos,
como smartphones e tablets. Nesse contexto, as principais prioridades são a gestão eficiente
da energia (bateria), a conectividade nos diversos tipos de rede (wi-fi, GSM, bluetooth, NFC
etc.) e a interação com uma grande variedade de sensores (GPS, giroscópio, luminosidade,
tela de toque, leitor de digitais etc.). Android e iOS são exemplos dessa categoria;
Embarcado: um sistema operacional é dito embarcado (embutido ou embedded) quando é
construído para operar sobre um hardware com poucos recursos de processamento,
armazenamento e energia. Aplicações típicas desse tipo de sistema aparecem em sistemas de
automação e controladores automotivos, equipamentos eletrônicos de uso doméstico (leitores
de DVD, TVs, micro-ondas, centrais de alarme etc.). Muitas vezes um sistema operacional
embarcado se apresenta na forma de uma biblioteca a ser ligada ao programa da aplicação
https://univirtus.uninter.com/ava/web/roa/

26/29

05/05/2022 22:49

UNINTER

durante sua compilação. LynxOS, TinyOS, Contiki e VxWorks são exemplos de sistemas
operacionais embarcados;
Tempo real: são sistemas em que o tempo é essencial. Ao contrário da ideia usual, um
sistema operacional de tempo real não precisa ser necessariamente ultrarrápido; sua
característica essencial é ter um comportamento temporal previsível, ou seja, seu tempo de
resposta deve ser previsível no melhor e no pior caso de operação. A estrutura interna de um
sistema operacional de tempo real deve ser construída de forma a minimizar esperas e
latências imprevisíveis, como tempos de acesso a disco e sincronizações excessivas.
Exemplos de sistemas operacionais de tempo real incluem o QNX, RT-Linux e VxWorks.
Muitos sistemas embarcados têm características de tempo real, e vice-versa. Existem sistemas
de tempo real críticos (hard real-time systems), nos quais a perda de um prazo pelo sistema pode
perturbar seriamente o sistema físico sob seu controle, com graves consequências humanas,
econômicas ou ambientais. Exemplos desse tipo de sistema são o controle de funcionamento de
uma turbina de avião ou um freio ABS.
Por outro lado, nos sistemas de tempo real não críticos (soft real-time systems), a perda de um
prazo é perceptível e degrada o serviço prestado, sem maiores consequências. Exemplos desse tipo
de sistema são os softwares de reprodução de mídia: em caso de atrasos, podem ocorrer falhas na
música que está sendo tocada.

FINALIZANDO
Nesta aula apresentamos os conteúdos iniciais de sistemas operacionais. No Tema 1,
enfatizamos os conceitos e as definições por uma visão geral; no Tema 2, o histórico e a evolução
dos sistemas operacionais, utilizando uma linha do tempo em paralelo à história e à evolução dos
computadores, descritas em suas gerações, visualizando as gerações das máquinas e seus
sistemas operacionais em cada período da história.
No Tema 3, vimos os objetivos, funções e princípios fundamentais que estabelecem as
atividades desenvolvidas pelos sistemas operacionais. O destaque desse tema é o item 3.1, que
descreve o sistema operacional como gerente de recursos, seu principal objetivo e função, pois ele é
responsável por gerenciar o uso dos recursos computacionais. As principais atividades de gestão

https://univirtus.uninter.com/ava/web/roa/

27/29

05/05/2022 22:49

UNINTER

foram descritas nesse tema e servirão como base para entendermos os temas das aulas seguintes,
quando estudarmos os processos (tarefas) de gestão.
Na sequência, definimos e apresentamos a classificação e a arquitetura dos sistemas
operacionais para, em seguida, finalizar o conteúdo introdutório com a apresentação de tipos e
exemplos atuais, permitindo o conhecimento suficiente para a escolha correta de sistemas
operacionais adequados às necessidades de cada situação do cotidiano, nos mais diversos
ambientes.
Enfim, compreender esses conceitos é o princípio para entender as atividades desenvolvidas
pelos sistemas computacionais. Assim, futuramente ampliaremos nosso conhecimento com os
conceitos das principais atividades de gerência feitas pelos sistemas operacionais, individualmente
apresentadas e descritas.

REFERÊNCIAS
ARPACI-DUSSEAU, R.; ARPACI-DUSSEAU, A. Operating systems: three easy pieces.
Madison: Arpaci-Dusseau Books, 2014.
CORBATÓ, F.; DAGGETT, M.; DALEY, R. An experimental time-sharing system. In:
PROCEEDINGS OF THE SPRING JOINT COMPUTER CONFERENCE, 1., New York. Anais… New
York: ACM, 1962.
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. Rio de Janeiro:
LTC, 2007.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: UFPR, 2019.
SILBERSCHATZ, A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.
SILBERSCHATZ, A.; GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro: Campus, 2016.
STALLINGS, W. Operating systems: internals and design principles. 9. ed. London: Pearson,
2017.
https://univirtus.uninter.com/ava/web/roa/

28/29

05/05/2022 22:49

UNINTER

TANENBAUM, A. S.; BOS, H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.
TANENBAUM, A. S. et al. The Amoeba distributed operating system – a status report.
Computer Communications, v. 14, p. 324-335, jul. 1991.
TANENBAUM, A. S.; WOODHULL, A. S. Sistemas operacionais: projeto e implementação. 3.
ed. Porto Alegre: Bookman, 2008.
WEIZER, N. A history of operating systems. Datamation, [S.l.], p. 119-126, jan. 1981.

[1] Formas de ataque virtual que utilizam diversas técnicas para forçar um servidor de rede a
dedicar seus recursos para atender um determinado usuário em detrimento dos demais. Por
exemplo, ao abrir milhares de conexões simultâneas num servidor de e-mail, um atacante pode
reservar para si todos os recursos do servidor (processos, conexões de rede, memória e
processador), fazendo com que os demais usuários não sejam mais atendidos.

https://univirtus.uninter.com/ava/web/roa/

29/29

05/05/2022 22:50

UNINTER

SISTEMAS OPERACIONAIS
AULA 2

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/24

05/05/2022 22:50

UNINTER

CONVERSA INICIAL
Seguindo os conteúdos previstos e a definição de gestão apresentada, nesta aula são
apresentados os conceitos e as técnicas das gerências de processos e do processador
subdivididos e descritos em cinco temas:
Princípios de gestão de processos (concorrência).
Tarefas (conceitos, gerência e ciclo).
Processos (contextos e definições).
Threads (definição e modelos/tipos).
Gerência do processador (escalonamento).
Aproveite e bons estudos!

TEMA 1 – PRINCÍPIOS DE GESTÃO DE PROCESSOS
Stallings (2017, p. 241, grifo nosso) define o sistema operacional como “um programa que
gerencia os recursos do computador, fornece serviços para os programadores e estabelece uma
ordem de execução de outros programas”. Ele (SO) é o software que controla a execução de
programas em um processador e gerencia os recursos do computador.
Uma das funções desempenhadas pelo SO, considerada a mais relevante nesta aula, é o
escalonamento de processos. Quase todos os processadores dispõem do suporte a esse recurso,
em maior ou menor extensão, incluindo hardware de gerenciamento de processos. Isso inclui
registradores de propósito especial e áreas de armazenamento temporário, além de um conjunto de
circuitos para realizar tarefas básicas de gerenciamento de recursos. (Tanenbaum; Woodhull, 2008)

https://univirtus.uninter.com/ava/web/roa/

2/24

05/05/2022 22:50

UNINTER

Sistemas operacionais podem ser vistos como um conjunto de rotinas executadas de forma
concorrente e ordenada. A possibilidade de o processador executar instruções ao mesmo tempo que
outras operações, por exemplo operações de E/S, permite que diversas tarefas sejam executadas
concorrentemente pelo sistema (Siqueira, 2020).
O conceito de concorrência é o princípio básico para o projeto e a implementação dos sistemas
multiprogramáveis. Nos sistemas multiprogramáveis, vários programas podem estar residentes em
memória, concorrendo pela utilização do processador. Dessa forma, quando um programa solicita
uma operação de E/S, outros programas podem utilizar o processador (Siqueira, 2020).
O sistema operacional implementa diversos mecanismos de software e/ou de hardware para
possibilitar a concorrência entre programas. Um sistema de computação quase sempre tem mais
atividades a executar que o número de processadores disponíveis. Assim, é necessário criar
métodos para multiplexar o(s) processador(es) da máquina entre as atividades presentes. Além
disso, como as diferentes tarefas têm necessidades distintas de processamento e nem sempre a
capacidade de processamento existente é suficiente para atender a todas, estratégias precisam ser
definidas para que cada tarefa receba uma quantidade de processamento que atenda suas
necessidades (Maziero, 2019).
Por outro lado, um processador convencional somente trata um fluxo de instruções de cada vez.
Até mesmo computadores com vários processadores, várias cores ou com tecnologia hyperthreading, por exemplo, têm mais atividades a executar que o número de processadores disponíveis
(Maziero, 2019).
Como fazer para atender simultaneamente as múltiplas necessidades de processamento dos
usuários?
Uma solução ingênua para esse problema seria equipar o sistema com um processador para cada
tarefa, mas essa solução ainda é inviável econômica e tecnicamente. Outra solução seria
multiplexar o processador entre as várias tarefas que requerem processamento, ou seja,
compartilhar o uso do processador entre as várias tarefas, de forma a atendê-las da melhor
maneira possível.
Para uma gestão eficaz do processamento, é fundamental compreender o conceito de tarefa. O
próximo tema aborda o conceito de tarefa, como estas são definidas, quais os seus estados
possíveis e como/quando elas mudam de estado. (Maziero, 2019, p. 40-41)

https://univirtus.uninter.com/ava/web/roa/

3/24

05/05/2022 22:50

UNINTER

TEMA 2 – TAREFAS (CONCEITOS, GERÊNCIA E CICLO)
Uma tarefa é definida por (Maziero, 2019, p. 41) como sendo a
[...] execução de um fluxo sequencial de instruções, construído para atender uma finalidade
específica: realizar um cálculo complexo, a edição de um gráfico, a formatação de um disco etc.
Assim, a execução de uma sequência de instruções em linguagem de máquina, normalmente
gerada pela compilação de um programa escrito em uma linguagem qualquer, é denominada
“tarefa” ou “atividade” (do inglês task).

Maziero (2019, p. 41, grifo do original) ressalta as diferenças entre tarefa e programa:
Programa é um conjunto de uma ou mais sequências de instruções escritas para resolver um
problema específico, constituindo assim uma aplicação ou utilitário. O programa representa um
conceito estático, sem um estado interno definido (que represente uma situação específica da
execução) e sem interações com outras entidades (o usuário ou outros programas).
Tarefa é a execução sequencial, por um processador, da sequência de instruções definidas em um
programa para realizar seu objetivo. Trata-se de um conceito dinâmico, que possui um estado
interno bem definido a cada instante (os valores das variáveis internas e a posição atual da
execução evoluem com o tempo) e interage com outras entidades: o usuário, os dispositivos
periféricos e/ou outras tarefas.

Tarefas podem ser implementadas de várias formas, como processos ou threads, que serão
apresentados nos temas seguintes, confira!
Maziero (2019, p. 41) apresenta que
Fazendo uma analogia simples, pode-se dizer que um programa é o equivalente de uma “receita
de torta” dentro de um livro de receitas (um diretório) guardado em uma estante (um disco) na
cozinha (o computador). Essa receita de torta define os ingredientes necessários (entradas) e o
modo de preparo (programa) da torta (saída). Por sua vez, a ação de “executar” a receita,
providenciando os ingredientes e seguindo os passos definidos na mesma, é a tarefa propriamente
dita.
[...]
A cada momento, a cozinheira (o processador) está seguindo um passo da receita (posição da
execução) e tem uma certa disposição dos ingredientes e utensílios em uso (as entradas e
variáveis internas da tarefa).
Assim como uma receita de torta pode definir várias atividades interdependentes para elaborar a
torta (preparar a massa, fazer o recheio, assar, decorar, etc.), um programa também pode definir
várias sequências de execução interdependentes para atingir seus objetivos.
https://univirtus.uninter.com/ava/web/roa/

4/24

05/05/2022 22:50

UNINTER

Maziero (2019, p. 42) prossegue:
Dessa forma, as tarefas definem as atividades a serem realizadas dentro do sistema de
computação. Como geralmente há muito mais tarefas a realizar que processadores disponíveis, e
as tarefas não têm todas a mesma importância, a gerência de tarefas tem uma grande importância
dentro de um sistema operacional.

Leitura complementar
Leia o capítulo 4.3, A gerência de tarefas, do livro indicado:
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: Ed. UFPR, 2019.
Os sistemas monotarefa foram:
Os primeiros sistemas de computação, nos anos 40, executavam apenas uma tarefa de cada vez.
Nestes sistemas, cada programa binário era carregado do disco para a memória e executado até
sua conclusão. Os dados de entrada da tarefa eram carregados na memória junto à mesma e os
resultados obtidos no processamento eram descarregados de volta no disco após a conclusão da
tarefa. Todas as operações de transferência de código e dados entre o disco e a memória eram
coordenadas por um operador humano. Esses sistemas primitivos eram usados sobretudo para
aplicações de cálculo numérico, muitas vezes com fins militares (problemas de trigonometria,
balística, mecânica dos fluidos etc.). (Maziero, 2019, p. 42-43)

Os sistemas multitarefas surgiram logo em seguida, pois
Como a velocidade de processamento era muito maior que a velocidade de comunicação com os
dispositivos de entrada e saída, o processador ficava ocioso durante os períodos de transferência
de informação entre disco e memória.

Se a operação de entrada/saída envolvesse fitas

magnéticas, o processador podia ficar parado vários minutos, aguardando a transferência de
dados. O custo dos computadores e seu consumo de energia eram elevados demais para deixálos ociosos por tanto tempo.
A solução encontrada para resolver esse problema foi permitir ao monitor suspender a execução
da tarefa que espera dados externos e passar a executar outra tarefa. Mais tarde, quando os
dados de que a tarefa suspensa necessita estiverem disponíveis, ela pode ser retomada no ponto
onde parou. Para tal, é necessário ter mais memória (para poder carregar mais de um programa
ao mesmo tempo) e criar mecanismos no monitor para suspender uma tarefa e retomá-la mais
tarde.
Uma forma simples de implementar a suspensão e retomada de tarefas de forma transparente
consiste no monitor fornecer um conjunto de rotinas padronizadas de entrada/saída à tarefas;
essas rotinas implementadas pelo monitor recebem as solicitações de entrada/saída de dados das
https://univirtus.uninter.com/ava/web/roa/

5/24

05/05/2022 22:50

UNINTER

tarefas e podem suspender uma execução quando for necessário, devolvendo o controle ao
monitor.
[...]
Essa evolução levou a sistemas mais produtivos (e complexos), nos quais várias tarefas podiam
estar em andamento simultaneamente: uma ativa (executando) e as demais prontas (esperando
pelo processador) ou suspensas (esperando dados ou eventos externos). (Maziero, 2019, p. 44)

O diagrama de estados básicos das tarefas da Figura 1 ilustra o comportamento de uma tarefa:

Figura 1 – Diagrama de estados das tarefas

Fonte: com base em Maziero, 2019.

2.1 CICLO DE VIDA DAS TAREFAS
A estrutura do diagrama de ciclo de vida das tarefas pode variar de acordo com a interpretação
dos autores. Por exemplo, a forma trazida neste texto condiz com a apresentada em Silberschatz,
Gagne e Galvin (2018) e outros autores.
Por outro lado, o diagrama apresentado em Tanenbaum e Bos (2016) divide o estado
“suspenso” em dois subestados separados: bloqueado, quando a tarefa aguarda a ocorrência de
algum evento (tempo, entrada/saída etc.), e suspenso, para tarefas bloqueadas que foram movidas
da memória RAM para a área de troca pelo mecanismo de paginação em disco. Todavia, tal
distinção de estados não faz mais sentido nos sistemas operacionais atuais baseados em memória
paginada, pois neles os processos podem se executar mesmo estando somente parcialmente
carregados na memória.
O diagrama apresentado na Figura 2 é conhecido na literatura da área como diagrama de ciclo
de vida das tarefas.
https://univirtus.uninter.com/ava/web/roa/

6/24

05/05/2022 22:50

UNINTER

Figura 2 – Diagrama de ciclo de vida das tarefas

Fonte: com base em Maziero, 2019.

Os estados e as transições do ciclo de vida têm o seguinte significado (Maziero, 2019):
Nova: A tarefa está sendo criada, seu código está sendo carregado em memória, junto com as
bibliotecas necessárias, e as estruturas de dados do núcleo estão sendo atualizadas para permitir
sua execução.
Pronta: A tarefa está em memória, pronta para iniciar ou retomar sua execução, apenas
aguardando a disponibilidade do processador. Todas as tarefas prontas são organizadas em uma
fila (fila de prontas, ready queue ou run queue), cuja ordem é determinada por algoritmos de
escalonamento, que são apresentados e definidos no Tema 5 desta aula.
Executando: O processador está dedicado à tarefa, executando suas instruções e fazendo avançar
seu estado.
Suspensa: A tarefa não pode executar porque depende de dados externos ainda não disponíveis
(do disco ou da rede, por exemplo), aguarda algum tipo de sincronização (o fim de outra tarefa ou
a liberação de algum recurso compartilhado) ou simplesmente espera o tempo passar (em uma
operação sleeping, por exemplo).
Terminada: O processamento da tarefa foi encerrado e ela pode ser removida da memória do
sistema.
Tão importantes quanto os estados das tarefas apresentados na Figura 2.2 são as transições entre
esses estados, que são explicadas a seguir:
→ Nova: Esta transição ocorre quando uma nova tarefa é admitida no sistema e começa a ser
preparada para executar.

https://univirtus.uninter.com/ava/web/roa/

7/24

05/05/2022 22:50

UNINTER

Nova → Pronta: ocorre quando a nova tarefa termina de ser carregada em memória, juntamente
com suas bibliotecas e dados, estando pronta para executar.
Pronta → Executando: esta transição ocorre quando a tarefa é escolhida pelo escalonador para
ser executada (ou para continuar sua execução), dentre as demais tarefas prontas.
Executando → Pronta: esta transição ocorre quando se esgota a fatia de tempo destinada à tarefa
(ou seja, o fim do quantum); como nesse momento a tarefa não precisa de outros recursos além
do processador, ela volta à fila de tarefas prontas até recebê-lo novamente.
Executando → Suspensa: caso a tarefa em execução solicite acesso a um recurso não disponível,
como dados externos ou alguma sincronização, ela abandona o processador e fica suspensa até o
recurso ficar disponível.
Suspensa → Pronta: quando o recurso solicitado pela tarefa se torna disponível, ela pode voltar a
executar, portanto volta ao estado de pronta para aguardar o processador (que pode estar
ocupado com outra tarefa).
Executando → Terminada: ocorre quando a tarefa encerra sua execução ou é abortada em
consequência de algum erro (acesso inválido à memória, instrução ilegal, divisão por zero, etc.).
Na maioria dos sistemas a tarefa que deseja encerrar avisa o sistema operacional através de uma
chamada de sistema (no Linux é usada a chamada exit).
Terminada → ·: Uma tarefa terminada é removida da memória e seus registros e estruturas de
controle no núcleo são liberados.
[...]
Nos sistemas operacionais de mercado é possível consultar o estado das tarefas em execução no
sistema. Isso pode ser feito no Windows, por exemplo, através do utilitário “Gerenciador de
Tarefas” (Maziero, 2019, p. 47-48).

Para Maziero (2019), tarefa é a unidade básica de atividade dentro de um sistema operacional.
Tarefas podem ser implementadas de várias formas, como processos, threads, transações e jobs.

2.2 CONTEXTOS
De acordo com Maziero (2019, p. 51),
[...] uma tarefa possui um estado interno bem definido, que representa sua situação atual: a
posição de código que ela está executando, os valores de suas variáveis e os recursos que ela
utiliza, por exemplo. Esse estado se modifica conforme a execução da tarefa evolui. O estado de
uma tarefa em um determinado instante é denominado contexto. /Uma parte importante do
contexto de uma tarefa diz respeito ao estado interno do processador durante sua execução, como
https://univirtus.uninter.com/ava/web/roa/

8/24

05/05/2022 22:50

UNINTER

o valor do contador de programa (PC - Program Counter), do apontador de pilha (SP - Stack
Pointer) e demais registradores. Além do estado interno do processador, o contexto de uma tarefa
também inclui informações sobre os recursos usados por ela, como arquivos abertos, conexões de
rede e semáforos.

A Figura 3 ilustra os contextos do processo ou tarefa.

Figura 3 – Contextos de processo ou tarefa

Fonte: com base em Machado, 1997, citado por Maia, 2001.

Na mesma obra, Maziero (2019, p. 51-52, grifo nosso) descreve que
A cada tarefa presente no sistema é associado um descritor, ou seja, uma estrutura de dados no
núcleo que representa essa tarefa. Nessa estrutura de dados são armazenadas as informações
relativas ao seu contexto e os demais dados necessários à sua gerência, como prioridades, estado
etc. Essa estrutura de dados é geralmente chamada de TCB (Task Control Block) ou PCB
(Process Control Block).
Um TCB tipicamente contém as seguintes informações:
identificador do processo (PID – Process Identifier);
estado do processo (novo, pronto, executando, suspenso, terminado);
informações de contexto do processador (valores dos registradores);
lista de áreas de memória usadas pelo processo;
listas de arquivos abertos, conexões de rede e outros recursos usados pelo processo
(exclusivos ou compartilhados com outras tarefas);
https://univirtus.uninter.com/ava/web/roa/

9/24

05/05/2022 22:50

UNINTER

informações de gerência e contabilização (prioridade, usuário proprietário, data de início,
tempo de processamento já decorrido, volume de dados lidos/escritos etc.).
Dentro do núcleo, os descritores das tarefas são geralmente organizados em listas ou vetores de
TCBs. Por exemplo, normalmente há uma lista de tarefas prontas para executar, uma lista de
tarefas aguardando acesso ao disco rígido etc.

TEMA 3 – PROCESSOS (CONTEXTOS E DEFINIÇÕES)
Um processo pode ser entendido inicialmente como um programa em execução, só que seu
conceito é mais abrangente. Este conceito torna-se mais claro quando pensamos de que forma os
sistemas multiprogramáveis (multitarefa) atendem os diversos usuários (tarefas) e mantêm
informações a respeito dos vários programas que estão sendo executados concorrentemente.
(Machado, 1997, citado por Maia, 2001, p. 21)

Processo é definido pelos autores clássicos Silberschatz, Gagne e Galvin (2018) e Tanenbaum
e Bos (2016) como equivalente a tarefas, com seus respectivos recursos, como arquivos abertos e
canais de comunicação, em uma área de memória delimitada e isolada das demais. Ou seja, um
processo é definido como uma espécie de “cápsula” isolada de execução, contendo uma tarefa e
seus recursos. Essa visão é mantida.
De fato, segundo Maziero (2019, p. 54),
[...] os sistemas operacionais mais antigos, até meados dos anos 80, suportavam somente um
fluxo de execução em cada processo. Assim, as unidades de execução (tarefa) e de recursos
(processo) se confundiam. No entanto, quase todos os sistemas operacionais atuais suportam a
existência de mais de uma tarefa em cada processo. Hoje em dia, o processo deve ser visto como
uma unidade de contexto, ou seja, um contêiner de recursos utilizados por uma ou mais tarefas
para sua execução, com áreas de memória (código, dados, pilha), informações de contexto e
descritores de recursos do núcleo (arquivos abertos, conexões de rede, etc.). Um processo pode
então conter várias tarefas, que compartilham esses recursos. Os processos são isolados entre si
pelos mecanismos de proteção providos pelo hardware (isolamento de áreas de memória, níveis
de operação e chamadas de sistema), impedindo que uma tarefa acesse um recurso atribuído ao
processo.
Os sistemas operacionais atuais geralmente associam por default uma única tarefa a cada
processo, o que corresponde à execução de um programa sequencial (iniciado pela função main()
de um programa em C, por exemplo). Caso se deseje associar mais tarefas ao mesmo processo,
cabe ao desenvolvedor escrever o código necessário para solicitar ao núcleo a criação dessas
tarefas adicionais, usualmente sob a forma de threads, que são apresentadas no próximo tema. O

https://univirtus.uninter.com/ava/web/roa/

10/24

05/05/2022 22:50

UNINTER

núcleo do sistema operacional mantém descritores de processos, denominados PCBs (Process
Control Blocks), descritos no tema anterior.

Segundo Maziero (2019), um processo possui informações dos contextos de hardware, de
software e de endereçamento de memória, como já ilustrado na Figura 3.
Definido por Maia (2001, p. 22):
O contexto de hardware é fundamental para a implementação dos sistemas de tempo
compartilhado (time-sharing), onde os processos se revezam na utilização do processador,
podendo ser interrompidos e, posteriormente, restaurados como se nada tivesse acontecido. A
troca de um processo por outro na CPU, realizada pelo sistema operacional, é denominada
mudança de contexto (context switching). A mudança de contexto consiste em salvar o conteúdo
dos registradores da CPU e carregá-los com os valores referentes ao do processo que esteja
ganhando a utilização do processador. Essa operação resume-se, então, em substituir o contexto
de hardware de um processo pelo de outro.

Nos sistemas atuais, segundo Maziero (2019, p. 53-54),
[...] a realização de uma troca de contexto, envolvendo a interrupção da tarefa atual, o salvamento
de seu contexto e a reativação da próxima tarefa, é uma operação relativamente rápida (alguns
microssegundos, dependendo do hardware e do sistema operacional). A execução do
escalonador, entretanto, pode ser bem mais demorada, sobretudo se houverem muitas tarefas
prontas para executar. Por esta razão, muitos sistemas operacionais não executam o escalonador
a cada troca de contexto, mas apenas periodicamente, quando há necessidade de reordenar a fila
de tarefas prontas.

O contexto de software é descrito por Maia (2001, p. 22) em sua dissertação e
[...] especifica características do processo que vão influir na execução de um programa, como o
número máximo de arquivos abertos simultaneamente ou o tamanho do buffer para operações de
E/S. Essas características são determinadas no momento da criação do processo, mas algumas
podem ser alteradas durante sua existência. O contexto de software define basicamente três
grupos de informações de um processo: sua identificação, suas quotas e seus privilégios.
O espaço de endereçamento é a área de memória do processo onde um programa poderá ser
executado, além do espaço para os dados utilizados por ele. Cada processo possui seu próprio
espaço de endereçamento, que deve ser protegido do acesso dos demais processos.

Os processos são executados de forma cíclica alternando seu estado, como ilustra a Figura 4:

https://univirtus.uninter.com/ava/web/roa/

11/24

05/05/2022 22:50

UNINTER

Figura 4 – Estados do processo

Fonte: com base em Maziero, 2019.

Definido por Maia (2001), um processo está no estado de execução (running) quando está
sendo processado pela CPU. Estado de pronto (ready) ocorre quando apenas aguarda uma
oportunidade para executar, ou seja, espera que o sistema operacional aloque a CPU para sua
execução. Estado de espera (wait) é quando aguarda algum evento externo ou algum recurso para
poder prosseguir seu processamento.

3.1 PROBLEMAS DE COMUNICAÇÃO ENTRE PROCESSOS OU THREADS
A comunicação entre processos é outro importante aspecto a ser considerado:
Tarefas associadas ao mesmo processo podem trocar informações facilmente, pois compartilham
as mesmas áreas de memória. Todavia, isso não é possível entre tarefas associadas a processos
distintos. Para resolver esse problema, o núcleo deve prover às aplicações chamadas de sistema
que permitam a comunicação interprocessos (IPC – Inter-Process Communication). (Maziero,
2019, p. 57)

Contudo, processos podem solicitar recursos, mesmo que estejam em posse de recursos
obtidos anteriormente. Caso estes recursos já estejam alocados em outros processos, o processo
solicitante deve aguardar pela liberação daquele. Essa é a condição natural do sistema de alocação
de recursos, porém alguns problemas naturalmente podem ocorrer. Neste caso, temos os problemas
de comunicação entre processos ou threads (Oliveira, 2015).
Condição de corrida: também chamada de corriza de hazards, é uma das consequências da
sincronização incorreta. Essa condição gera a disputa de recursos do sistema por múltiplos
processos, ou threads, causando o corrompimento dos dados. Isso faz com que parte desses dados
sejam modificadas por um processo/thread, e parte, por outro, ou seja, acontece quando dois ou
mais processos entram simultaneamente na região crítica (Oliveira, 2015).
https://univirtus.uninter.com/ava/web/roa/

12/24

05/05/2022 22:50

UNINTER

Starvation: conhecido também como livelock, acontece quando processos e/ou threads estão
em execução, mas nada acontece. Isso ocorre geralmente quando dois ou mais processos/threads
então trabalhando com intenções contrarias, situação em que o que é feito por um processo/thread é
desfeito pelo outro. Também ocorre quando um processo/thread tenta o acesso a um recurso que
está sendo utilizado por outro processo/thread – o SO pede para que este aguarde sua liberação,
porém o processo/thread não está preparado para a espera, ou seja, ele vai continuar solicitando o
recurso indefinidamente, mesmo que o recurso seja liberado, pois o processo/thread não foi
programado para uma “rejeição” (Oliveira, 2015).
Deadlock: é o problema mais terrível e mais estudado em sistemas operacionais. Trata-se de
uma situação em que dois ou mais processos/threads estão em estado simultâneo de espera, cada
um aguardando que um dos demais libere um bloqueio para ele poder prosseguir, ou seja, um
conjunto de N processos está em deadlock quando cada um dos N processos está bloqueado à
espera de um recurso que somente pode ser liberado por um processo desse conjunto (Oliveira,
2015).

Figura 5 – Situação de impasse – deadlock

Créditos: Ilya kovshik/Shutterstock.

TEMA 4 – THREADS (DEFINIÇÃO E MODELOS/TIPOS)
“Os primeiros sistemas operacionais suportavam uma única tarefa por processo” (Maziero,
2019, p. 58). Cada processo tem seu espaço de endereçamento individual e apenas um fluxo de
controle (thread). “À medida em que as aplicações se tornavam mais complexas, essa limitação se
tornou bem inconveniente” (Maziero, 2019, p. 58), pois, algumas vezes, desejamos ter vários fluxos
de controle (threads) no mesmo espaço de endereçamento simulando uma execução em paralelo,

https://univirtus.uninter.com/ava/web/roa/

13/24

05/05/2022 22:50

UNINTER

como se cada fluxo fosse visto realmente como um processo distinto (exceto pelo fato de
compartilharem um único espaço de endereçamento) (Oliveira, 2015).
Por exemplo, um editor de textos geralmente executa tarefas simultâneas de edição, formatação,
paginação e verificação ortográfica sobre os mesmos dados (o texto em edição). Da mesma forma,
processos que implementam servidores de rede (de arquivos, bancos de dados etc.) devem
gerenciar as conexões de vários usuários simultaneamente, que muitas vezes requisitam as
mesmas informações. Essas demandas evidenciaram a necessidade de suportar mais de uma
tarefa operando sobre os mesmos recursos, ou seja, dentro do mesmo processo. (Maziero, 2019,
p. 58)

Thread é definida por Maziero (2019, p. 58) como “um fluxo de execução independente. Um
processo pode conter uma ou mais threads, cada uma executando seu próprio código e
compartilhando recursos com as demais threads localizadas no mesmo processo”. Alguns autores
usam também o termo processo leve (lightweigth process) como sinônimo de thread.
Cada thread é caracterizada por um código em execução e um pequeno contexto local, o Thread
Local Storage (TLS), composto pelos registradores do processador e uma área de pilha em
memória, para que a thread possa armazenar variáveis locais e efetuar chamadas de funções.
Threads são também utilizadas para implementar fluxos de execução dentro do núcleo do SO,
neste caso recebendo o nome de threads de núcleo (em oposição às threads dos processos,
denominadas user threads).
Além de representar as threads de usuário dentro do núcleo, as threads de núcleo também
incluem atividades internas do núcleo, como rotinas de drivers de dispositivos ou tarefas de
gerência. (MAZIERO, 2019, p. 58-59).

Muitas threads podem existir dentro de um único contexto de processo, cooperando entre si a
fim de realizar um dado cálculo e compartilhando o espaço de endereçamento e o restante do
contexto desse processo. (multithread).
Um ambiente multithread se utiliza dos mesmos mecanismos de concorrência entre processos,
interrupções, exceções e a comunicação entre processos (inter process comunication – IPC),
essenciais para permitir acesso concorrente a um recurso compartilhado (Oliveira, 2015).

4.1 MODELOS DE THREADS
As threads contidas nos processos, segundo Maziero (2019, p. 59), “definidas no espaço de
usuário, devem ser gerenciadas pelo núcleo do sistema operacional. Essa gerência pode ser feita de
https://univirtus.uninter.com/ava/web/roa/

14/24

05/05/2022 22:50

UNINTER

diversas formas, conforme os seguintes modelos de implementação de threads”:

4.1.1 O modelo N:1
Os sistemas operacionais mais antigos suportavam apenas processos sequenciais, com um único
fluxo de execução em cada um. Os desenvolvedores de aplicações contornaram esse problema
construindo bibliotecas para salvar, modificar e restaurar os registradores da CPU dentro do
processo, permitindo assim criar e gerenciar vários fluxos de execução (threads) dentro de cada
processo, sem a participação do núcleo.
Com essas bibliotecas, uma aplicação pode lançar várias threads conforme sua necessidade, mas
o núcleo do sistema irá sempre perceber (e gerenciar) apenas um fluxo de execução dentro de
cada processo (ou seja, o núcleo irá manter apenas uma thread de núcleo por processo). Esta
forma de implementação de threads é denominada Modelo de Threads N:1, pois N threads dentro
de um processo são mapeadas em uma única thread no núcleo. Esse modelo também é
denominado fibers ou ainda green threads.
[...]
O modelo de threads N:1 é muito utilizado, por ser leve e de fácil implementação. Como o núcleo
somente vê uma thread, a carga de gerência imposta ao núcleo é pequena e não depende do
número de threads dentro da aplicação. Essa característica torna este modelo útil na construção
de aplicações que exijam muitos threads, como jogos ou simulações de grandes sistemas.
(Maziero, 2019, p. 59-60, grifo do original)

Por outro lado, de acordo com Maziero, o modelo de threads N:1 apresenta alguns problemas:
as operações de entrada/saída são realizadas pelo núcleo; se uma thread de usuário
solicitar a leitura do teclado, por exemplo, a thread de núcleo correspondente será
suspensa até a conclusão da operação, bloqueando todas as threads daquele processo;
o núcleo do sistema divide o tempo de processamento entre as threads de núcleo. Assim,
um processo com 100 threads irá receber o mesmo tempo de processador que outro com
apenas uma thread, ou seja, cada thread do primeiro processo irá receber 1/100 do tempo
que recebe a thread única do outro processo;
threads do mesmo processo não podem executar em paralelo, mesmo se o computador
dispuser de vários processadores ou cores, porque o núcleo somente escalona as threads
de núcleo nos processadores. (2019, p. 60)

4.1.2 O modelo 1:1
Maziero (2019, p. 60-61, grifo do original) descreve que:
A necessidade de suportar aplicações multithread levou os desenvolvedores de sistemas
operacionais a incorporar a gerência dos threads do processo no núcleo do sistema. Para cada
https://univirtus.uninter.com/ava/web/roa/

15/24

05/05/2022 22:50

UNINTER

thread de usuário foi então associado um thread correspondente dentro do núcleo, suprimindo com
isso a necessidade de bibliotecas de threads. Essa forma de implementação é denominada
Modelo de Threads 1:1. Este é o modelo mais frequente nos sistemas operacionais atuais, como
o Windows NT e seus descendentes, além da maioria dos UNIXes.
[...]
O modelo 1:1 resolve vários problemas: caso uma thread de usuário solicite uma operação
bloqueante, somente sua thread de núcleo correspondente será suspensa, sem afetar as demais
threads do processo. Além disso, a distribuição de processamento entre as threads é mais justa e,
caso o hardware tenha mais de um processador, mais threads do mesmo processo podem
executar ao mesmo tempo, o que não era possível no N:1.
O modelo de threads 1:1 é adequado para a maioria das situações usuais e atende bem às
necessidades das aplicações interativas e servidores de rede. No entanto, é pouco escalável: a
criação de um número muito grande de threads impõe uma carga elevada ao núcleo do sistema,
inviabilizando aplicações com muitas tarefas (como grandes servidores Web e simulações de
grande porte).

4.1.3 O modelo N:M
Para resolver o problema de escalabilidade da abordagem 1:1, alguns sistemas operacionais
implementam um modelo híbrido, que agrega características dos modelos anteriores. Nesse novo
modelo, uma biblioteca gerencia um conjunto de N threads de usuário (dentro do processo), que é
mapeado em M < N threads no núcleo.
O conjunto de threads de núcleo associadas a um processo, denominado thread pool, geralmente
contém uma thread para cada thread de usuário bloqueada, mais uma thread para cada
processador disponível; esse conjunto pode ser ajustado dinamicamente, conforme a necessidade
da aplicação. (Maziero, 2019, p. 61, grifo do original)

4.2 FERRAMENTAS PARA PROCESSOS E THREADS
Algumas tarefas específicas auxiliam o sistema operacional no controle e gestão dos processos
e threads. Essas rotinas estão descritas a seguir:
Região crítica: também chamada de seção crítica. É a parte do sistema que permite acesso
concorrente entre os processos, por exemplo: spool de impressão, buffer de memória etc.
Exclusão mútua: é uma técnica usada em programação concorrente para evitar que dois ou
mais processos ou threads tenham acesso simultaneamente a um recurso compartilhado do
sistema, ou seja, a uma região crítica.

https://univirtus.uninter.com/ava/web/roa/

16/24

05/05/2022 22:50

UNINTER

Sinais: são interrupções de software que notificam ao processo que um evento ocorreu. Os
sinais não permitem que processos especifiquem dados para trocar com outros processos.
São utilizados para sincronização entre processos e SO, ou seja, os sinais só ocorrem entre
processos ou entre processos e o SO.
Trap: é o sinal que o processo envia para o SO solicitando um serviço protegido deste (por
exemplo, sua entrada em uma região crítica). Um trap bloqueia o processo até que o serviço
requerido por este ao sistema operacional seja realizado (Oliveira, 2015).

TEMA 5 – GERÊNCIA DO PROCESSADOR (ESCALONAMENTO)
As tarefas de gestão do processor são descritas individualmente, e suas rotinas são
apresentadas neste último tema, complementando os temas anteriores, que descreveram a
concorrência, os processos e as threads.
A política de escalonamento de um sistema operacional tem diversas funções básicas, como a
de manter o processador ocupado a maior parte do tempo, auxiliando o hardware no objetivo de
minimizar a ociosidade, balancear o uso da CPU entre processos, privilegiar a execução de
aplicações críticas, maximizar o throughput do sistema e oferecer tempos de resposta razoáveis
para usuários interativos (Oliveira, 2015).
Essas funções são apresentadas nesse tema e complementam uma das funções básicas dos
sistemas operacionais, apresentada em aula anterior: o escalonamento de processos.
Em ambientes que implementam apenas processos, o escalonamento é realizado com base
nos processos prontos para execução. Em sistemas que implementam threads, o escalonamento é
realizado considerando os threads no estado de pronto (Machado; Maia, 2007), independentemente
do processo.
Justificando a utilização do nome escalonador, o termo é originário da tradução do termo
escalonador de tarefas (task scheduler) e é um dos componentes mais importantes da gerência de
tarefas, pois decide a ordem de execução das tarefas prontas. “O algoritmo utilizado no escalonador
define o comportamento do sistema operacional, permitindo obter sistemas que tratem de forma
mais eficiente e rápida as tarefas a executar, que podem ter características diversas” (Maziero,
2019, p. 70).
https://univirtus.uninter.com/ava/web/roa/

17/24

05/05/2022 22:50

UNINTER

Antes de se definir o algoritmo usado por um escalonador de tarefas, é necessário ter em mente a
natureza das tarefas que o sistema irá executar. Existem vários critérios que definem o
comportamento de uma tarefa; uma primeira classificação possível diz respeito ao seu
comportamento temporal:
Tarefas de tempo real: exigem previsibilidade em seus tempos de resposta aos eventos externos,
pois geralmente estão associadas ao controle de sistemas críticos, como processos industriais,
equipamentos médicos etc.
Tarefas interativas: são tarefas que recebem eventos externos (do usuário ou através da rede) e
devem respondê-los rapidamente, embora sem os requisitos de previsibilidade das tarefas de
tempo real. Esta classe de tarefas inclui a maior parte das aplicações dos sistemas desktop e dos
servidores.
Tarefas em lote (batch): são tarefas sem requisitos temporais explícitos, que normalmente
executam sem intervenção do usuário, como procedimentos de backup, varreduras de antivírus,
cálculos numéricos longos, tratamentos de grandes massas de dados em lote, renderização de
animações etc.
Além dessa classificação, as tarefas também podem ser classificadas de acordo com seu
comportamento no uso do processador:
Tarefas orientadas a processamento (CPU-bound tasks): são tarefas que usam intensivamente
o processador na maior parte de sua existência. Essas tarefas passam a maior parte do tempo nos
estados pronta ou executando.
Tarefas orientadas a entrada/saída (I/O-bound tasks): são tarefas que dependem muito mais dos
dispositivos de entrada/saída que do processador. Essas tarefas ficam boa parte de suas
existências no estado suspenso, aguardando respostas às suas solicitações de leitura e/ou escrita
de dados nos dispositivos de entrada/saída. (Maziero, 2019, p. 70-71, grifo do original)

5.1 CRITÉRIOS DE ESCALONAMENTO
Os objetivos e as metas de cada sistema operacional determinam quais são os principais
aspectos para a implementação de uma política de escalonamento adequada. Os principais critérios,
segundo Machado e Maia (2007), são:
Utilização do processador: na maioria dos sistemas, é desejável que o processador
permaneça a maior parte do tempo ocupado (Oliveira, 2015).
Throughput: representa o número de processos executados em um determinado intervalo de
tempo (Oliveira, 2015).

https://univirtus.uninter.com/ava/web/roa/

18/24

05/05/2022 22:50

UNINTER

Tempo de processador /tempo de UCP: é o tempo que um processo leva no estado de
execução durante seu processamento (Machado; Maia, 2007).
Tempo de espera: tempo total que um processo permanece na fila de pronto durante seu
processamento, aguardando para ser executado (Oliveira, 2015).
Tempo de turnaround: é o tempo que um processo demora desde a sua criação até seu
término, levando em consideração todo o tempo gasto em espera para alocação de memória,
espera na fila de pronto, processamento na UCP e fila de espera, como nas operações de E/S
(Machado; Maia, 2007). É uma medida típica de sistemas em lote, nos quais não há interação
direta com os usuários do sistema. Não deve ser confundido com o tempo de processamento
(Maziero, 2019).
Tempo de resposta: tempo decorrido entre uma requisição ao sistema ou uma aplicação e o
instante em que a resposta é exibida. Essa medida de desempenho é típica de sistemas
interativos, como sistemas desktop e de tempo real, e depende sobretudo da rapidez no
tratamento das interrupções de hardware pelo núcleo e do valor do quantum de tempo, para
permitir que as tarefas interativas cheguem mais rápido ao processador quando saem do
estado suspenso (Maziero, 2019).

5.2 TIPOS DE ESCALONAMENTOS
As políticas de escalonamento de um sistema operacional podem ser classificadas em
preemptivo ou não preemptivo (cooperativo):
Preemptivos: são a possibilidade de o sistema operacional interromper um processo em
execução e substituí-lo por um outro (Siqueira, 2020). Nesses sistemas, uma tarefa pode perder o
processador caso termine seu quantum de tempo, execute uma chamada de sistema ou ocorra uma
interrupção que acorde uma tarefa mais prioritária (que estava suspensa aguardando um evento)
(Machado; Maia, 2007). “A cada interrupção, exceção ou chamada de sistema, o escalonador
reavalia todas as tarefas da fila de prontas e decide se mantém ou substitui a tarefa atualmente em
execução” (Maziero, 2019, p. 72).
No escalonamento preemptivo, o sistema operacional pode interromper um processo em
execução e passá-lo para o estado de pronto, com o objetivo de alocar outro processo na UCP.
Em um sistema preemptivo simples, normalmente as tarefas só são interrompidas quando o
processador está no modo usuário; a thread de núcleo correspondente a cada tarefa não sofre
https://univirtus.uninter.com/ava/web/roa/

19/24

05/05/2022 22:50

UNINTER

interrupções. Entretanto, os sistemas mais sofisticados implementam a preempção de tarefas
também no modo núcleo. Essa funcionalidade é importante para sistemas de tempo real, pois
permite que uma tarefa de alta prioridade chegue mais rapidamente ao processador quando for
reativada. (Maziero, 2019, p. 72)

Não preemptivo (sem interrupção ou cooperativos): este foi o primeiro tipo de escalonamento
implementado nos sistemas multiprogramáveis, em que predominava tipicamente o processamento
bath (Oliveira, 2015).
A tarefa em execução permanece no processador tanto quanto possível, só liberando-o caso
termine de executar, solicite uma operação de entrada/saída ou libere explicitamente o processador,
voltando à fila de tarefas prontas. Esses sistemas são chamados de cooperativos por exigir a
cooperação das tarefas entre si na gestão do processador (Oliveira, 2015), para que todos possam
executar.
First-in-first-out (FIFO): o processo que chegar primeiro ao estado de pronto é o selecionado
para execução (Maziero, 2019).
First-come, first served (FCFS): “A forma de escalonamento mais elementar consiste em
simplesmente atender as tarefas em sequência, à medida em que elas se tornam prontas (ou seja,
conforme sua ordem de ingresso na fila de tarefas prontas) e tem como principal vantagem sua
simplicidade” (Maziero, 2019, p. 73).
Round-robin (RR): “A adição da preempção por tempo ao escalonamento FCFS dá origem ao
algoritmo de escalonamento por revezamento, ou Round-Robin” (Maziero, 2019, p. 74). É menos
eficiente para a execução de tarefas em lote, entretanto, por distribuir melhor o uso do processador
entre as tarefas ao longo do tempo, é melhor para aplicações interativas. Deve-se observar que os
algoritmos de escalonamento FCFS e RR não consideram a importância das tarefas nem seu
comportamento em relação ao uso dos recursos (Maziero, 2019).
Shortest-job-first (SJF): seleciona primeiro o processo de menor tempo de processador ainda
por executar. Menor tarefa primeiro consiste em atribuir o processador à menor (mais curta) tarefa
da fila de tarefas prontas (Maziero, 2019).
Shortest remaining time first (SRTF):

https://univirtus.uninter.com/ava/web/roa/

20/24

05/05/2022 22:50

UNINTER

O algoritmo SJF é cooperativo, ou seja, uma vez que uma tarefa recebe o processador, ela
executa até encerrar. Em uma variante preemptiva, o escalonador deve comparar a duração
prevista de cada nova tarefa que ingressa no sistema com o tempo de processamento restante
das demais tarefas presentes, inclusive aquela que está executando no momento. Caso a nova
tarefa tenha um tempo restante menor, ela recebe o processador. (Maziero, 2019, p. 76)

Escalonamento cooperativo: é uma implementação que busca aumentar o grau de
multiprogramação em políticas de escalonamentos que não possuam mecanismos de preempção.
Neste caso, um processo em execução pode voluntariamente liberar o processador para outro
processo (Oliveira, 2015).
Escalonamento circular: é um escalonamento do tipo preemptivo, projetado especialmente
para sistemas de tempo compartilhado. Quando um processo passa para o estado de execução,
existe um tempo-limite para uso contínuo do processador denominado fatia de tempo (time slice) ou
quantum (Oliveira, 2015).
Escalonamento por prioridades: é um escalonamento do tipo preemptivo realizado com base
em um valor associado a cada processo denominado prioridade de execução. O processo com
maior prioridade no estado de pronto é sempre o escolhido para execução, e processos com valores
iguais são escalonados seguindo critérios de FIFO (Machado; Maia, 2007).
Circular com prioridades: implementa o conceito de fatia de tempo e de prioridade de
execução associada a cada processo (Oliveira, 2015).
Escalonamento por múltiplas filas: existem diversas filas de processos no estado de pronto,
cada qual com uma prioridade específica. Os processos são associados às filas em função de
características próprias, como importância para a aplicação, tipo de processamento ou área de
memória necessária (Oliveira, 2015).
Escalonamento por múltiplas filas com realimentação: é semelhante ao escalonamento por
múltiplas filas, porém os processos podem trocar de filas durante seu processamento. Possibilidade
de reorganizar os processos nas filas de acordo com o seu comportamento (Machado; Maia, 2007).

FINALIZANDO

https://univirtus.uninter.com/ava/web/roa/

21/24

05/05/2022 22:50

UNINTER

Após a apresentação das principais atividades de gestão em aula anterior, iniciamos o estudo
da gestão avançada do sistema, na qual as rotinas (tarefas) de gestão de processos e/ou tarefas e
do processador (escalonamento) foram individualmente apresentadas e descritas.
Foram apresentados e definidos os conceitos e as técnicas subdivididos em cinco temas. No
primeiro tema, uma introdução, com os princípios de gestão de processos, em uma explicação
sobre o conceito de concorrência, afinal o sistema operacional é o software que controla a execução
de programas em um processador, gerencia os recursos do computador e pode ser visto como um
conjunto de rotinas executadas de forma concorrente e ordenada (Oliveira, 2015).
No segundo tema, foi ampliado o conceito, pois, para uma gestão eficaz do processamento, é
fundamental compreender o conceito de tarefa, definida por Maziero (2019) como a execução de
um fluxo sequencial de instruções construído para atender uma finalidade específica denominada
“tarefa” ou “atividade” (do inglês task).
Foi também apresentado o conceito de tarefa, como são definidas, quais são os seus estados
possíveis e como/quando elas mudam de estado (Maziero, 2019), além do ciclo de vida e dos
contextos de hardware e software. Foram ressaltadas as diferenças entre tarefa e programa.
No tema seguinte, vimos os processos em seus contextos e definições. Processo pode ser
entendido inicialmente como um programa em execução, só que seu conceito é mais abrangente e
define a forma como os sistemas multiprogramáveis (multitarefa) atendem os diversos usuários e
tarefas e mantêm informações sobre vários programas em execução concorrente (Machado, 1997,
citado por Maia, 2001). É definido por autores clássicos, por exemplo Silberschatz (2018) e
Tanenbaum e Bos (2016), como equivalentes a tarefas, com seus recursos (arquivos abertos,
conexões de rede), em uma área de memória delimitada e isolada das demais, uma espécie de
“cápsula” isolada de execução, que contém uma tarefa e seus recursos. Essa visão ainda é mantida.
Finalizamos o tema com a apresentação dos problemas de comunicação entre os processos.
Na sequência, foram definidas e apresentadas as threads e seus modelos e/ou tipos. Devido à
necessidade de suportar mais de uma tarefa em operação sobre os mesmos recursos, no mesmo
processo, a thread é definida como um fluxo de execução independente. Um processo pode conter
uma ou mais threads, cada uma executando seu próprio código e compartilhando recursos com as
demais threads localizadas no mesmo processo, também denominado processo leve (lightweigth
process). Ainda foram definidos os modelos das threads contidas nos processos.
https://univirtus.uninter.com/ava/web/roa/

22/24

05/05/2022 22:50

UNINTER

Em seguida, finalizando o conteúdo da aula no último tema, a gerência do processador, com a
definição de escalonamento, termo originário da tradução de escalonador de tarefas (task
scheduler), é um dos componentes mais importantes da gerência de tarefas, que decide a ordem de
execução das tarefas prontas (Maziero, 2019). Completando as definições, foram apresentados os
critérios e os tipos de escalonamento.
Nas aulas seguintes, os demais conceitos de gerência serão apresentados e definidos, não
perca!

REFERÊNCIAS
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. São Paulo: LTC,
2007.
MAIA, L. P. SOsim: simulador para o ensino de sistemas operacionais. 97. Dissertação (Mestre
em Ciências em Informática) – Universidade Federal do Rio de Janeiro, Rio de Janeiro, 2001.
Disponível em: <http://www.lapolli.pro.br/escolas/unicid/SistOpera/laboratorio/Tese.pdf>. Acesso em:
9 set. 2020.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: Ed. UFPR, 2019.
OLIVEIRA, C. A. Material de apoio Sistemas Operacionais. Disponível em: <http://univirtus.
uninter.com/ava/web/#/ava/roa/3083381/> Acesso em: 5 jul. 2020.
SILBERSCHATZ, A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.
SIQUEIRA,

F.

de.

Sistemas

operacionais.

Disponível

em:

<https://sites.google.com/site/proffernandosiqueiraso/aulas>. Acesso em: 9 set. 2020.
STALLINGS, W. Operating systems: internals and design principles. 9. ed. [S.l.]: Pearson,
2017.
TANENBAUM, A. S.; BOS, H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.

https://univirtus.uninter.com/ava/web/roa/

23/24

05/05/2022 22:50

UNINTER

TANENBAUM, A. S.; WOODHULL; A. S. Sistemas operacionais, projeto e implementação.
3. ed. Porto Alegre: Bookman, 2008.
TEDESCO, K. Concorrência, paralelismo, processos, threads. Treinaweb. Disponível em:
<https://www.treinaweb.com.br/blog/concorrencia-paralelismo-processos-threads-programacaosincrona-e-assincrona>. Acesso em: 9 set. 2020.

https://univirtus.uninter.com/ava/web/roa/

24/24



05/05/2022 22:52

UNINTER

SISTEMAS OPERACIONAIS
AULA 3

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/23

05/05/2022 22:52

UNINTER

CONVERSA INICIAL
Descritos anteriormente como “dispositivos eletrônicos criados para auxiliar nas tarefas do
cotidiano das pessoas”, os computadores são máquinas incríveis, com grande poder de
processamento e capacidade de armazenamento. São compostos basicamente pelo hardware
(dispositivos físicos) e software (tarefas e rotinas previamente programadas) de forma dependente.
Sem memória de leitura/escrita de informações pela CPU, não há computador digital com programa
armazenado.
O hardware tem como principais componentes a CPU, as memórias e os dispositivos de E/S, e
cada um deles é individualmente gerenciado e controlado pelo sistema operacional. Apresentada a
gerência de processos e do processador (CPU), agora apresentaremos a gerência de memória,
uma tarefa elementar que pode fazer toda a diferença na escolha do sistema operacional mais
adequado aos objetivos iniciais de conveniência e eficiência.
Enquanto a principal atividade de gestão de processador e de processos é o escalonamento, na
gestão de memória é a alocação de memória, seguida pelas estratégias de paginação e
segmentação. Contudo, de nada são válidas as explicações sobre as tarefas avançadas de gestão
sem abordar os conceitos básicos. Então, vamos lá?
O conteúdo desta aula contempla a definição de gestão (gerência) de memória e o seguinte
roteiro:
Conceitos e definições – visão geral;
Tipos e padrões de memória – classificação básica
Alocação;
Estratégias de paginação;
Memória virtual.
https://univirtus.uninter.com/ava/web/roa/

2/23

05/05/2022 22:52

UNINTER

Bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES – VISÃO GERAL
Anteriormente definimos sistema operacional como um programa que gerencia os recursos do
computador, em particular, o gerenciamento da hierarquia de memória (Stallings, 2018). Trata-se do
software que executa diversas funções, em especial: escalonamento de processos (já
apresentado) e gerenciamento de memória, que veremos a partir de agora. Acompanhe!
Para que as funções sejam executadas de modo rápido e eficiente, é necessário que o sistema
operacional disponibilize o suporte adequado do hardware do processador. Quase todos os
processadores dispõem desse suporte, em maior ou menor extensão, incluindo hardware de
gerenciamento de memória virtual e de gerenciamento de processos, incluindo registradores de
propósito especial e áreas de armazenamento temporário, além de um conjunto de circuitos para
realizar tarefas básicas de gerenciamento de recursos.
Fundamentais para qualquer sistema de computação, temos as memórias, em especial a
memória de usuário (random access memory – RAM), memória de acesso aleatório (aleatório no
sentido de que os processos podem acessar localizações de dados em qualquer ordem – Deitel;
Deitel; Choffnes, 2017) ou memória principal.
Memórias são recursos escassos e caros. Um desafio aos projetistas de sistemas é
desenvolver sistemas operacionais leves, que ocupem a menor quantidade de bytes de memória e
simultaneamente otimizem os recursos computacionais. Num sistema multiprogramável, a
quantidade de memória disponível contribui diretamente para definir o número de processos que
podem ser alocados e consequentes à capacidade de processamento do sistema computacional.
Essa etapa é responsabilidade da gerência de memória, que tem como meta manter o maior
número de processos residentes na memória principal, permitindo maximizar o compartilhamento do
processador e demais recursos computacionais, auxiliando no combate à ociosidade da CPU.
Tão relevante quanto quaisquer definições técnicas sobre as memórias, a gestão eficiente
desse precioso recurso é fundamental para o bom desempenho de qualquer sistema operacional.
Exemplo marcante no mercado é o popular Windows, que desde a sua primeira versão enfrenta
esse dilema. Por definição, todas as “janelas” fechadas permanecem como “em espera”, visando
https://univirtus.uninter.com/ava/web/roa/

3/23

05/05/2022 22:52

UNINTER

uma melhor performance, mas acabam obtendo o inverso, sendo necessária uma quantidade de
memória cada vez maior. Uma solução bastante comum são softwares de terceiros que “limpam” os
arquivos dos processos já encerrados.
Em outros sistemas operacionais, essa solução está incorporada (built-in), dispensando o
entendimento de temas mais complexos, atendendo objetivos básicos da conveniência e eficiência,
comprovadas com a utilização de outro sistema operacional no mesmo equipamento.
No primeiro sistema operacional (Kali Linux 2020) são necessários menos de 512 MB de
memória RAM para o funcionamento inicial, enquanto no segundo sistema operacional (Windows 10
1909) são necessários mais de 3 GB de memória RAM para as mesmas tarefas básicas. Esse
exemplo real (estudo de caso) aqui descrito será apresentado futuramente.
O gerenciamento de memória é normalmente feito por software e por hardware de propósito
especial. O gerenciador de memória é definido por Deitel, Deitel e Choffnes (2017) como um
componente do sistema operacional responsável pelo esquema de organização da memória do
sistema, com as estratégias de gerenciamento de memória, determinando como o espaço de
memória disponível é alocado a processos e como responder a mudanças na utilização da memória
de um processo.
Ele também interage com hardware de gerenciamento de memória de propósito específico (se
houver algum disponível) para melhorar o desempenho. Nesta aula e em aulas futuras,
descreveremos diversas estratégias de gerenciamento e organização de memória.
Deitel, Deitel e Choffnes (2017) complementam que cada estratégia de gerenciamento de
memória difere quanto ao modo como responde a certas perguntas:
Quando a estratégia recupera um novo programa e seus dados para colocá-los na memória?
A estratégia recupera o programa e seus dados quando o sistema os requisita
especificamente, ou ela tenta se antecipar às requisições do sistema?
Em que lugar da memória principal a estratégia posiciona o próximo programa a ser executado
e seus dados?
Ela minimiza o espaço desperdiçado (compactando programas e dados a mais que puder em
áreas disponíveis da memória) ou minimiza o tempo de execução (posicionando programas e
dados o mais rapidamente possível)?
https://univirtus.uninter.com/ava/web/roa/

4/23

05/05/2022 22:52

UNINTER

Se um novo programa ou novos dados devem ser colocados na memória principal (e se esta
estiver frequentemente cheia), a estratégia substitui quais programas ou dados que já estão na
memória?
Ela deve substituir os mais velhos, os usados com menos frequência ou os menos usados
recentemente?
Há sistemas implementados que usam essas e outras estratégias de gerenciamento de
memória. Portanto, trata-se de uma importante função do sistema operacional, composta por
diversas rotinas e estratégias, e cada uma será descrita e analisada nos temas seguintes.
Acompanhe!

TEMA 2 – TIPOS E PADRÕES DE MEMÓRIA – CLASSIFICAÇÃO
BÁSICA
Elementar para uma boa gestão é conhecer seus componentes. Neste tema, apresentaremos
os tipos e padrões das memórias, permitindo uma classificação quanto às seguintes características:
Capacidade de armazenamento (tamanho em bytes);
Velocidade (taxa de transferência e tempo de acesso);
Custo de armazenamento (e seu respectivo custo material/monetário);
Consumo de energia e volatilidade (dependência da energia).
Essa classificação é simples e funcional, pois, quanto maior a capacidade de armazenamento,
menores seus custos e velocidades (desempenho), e vice-versa. Veja a Figura 1:

Figura 1 – Hierarquia de memórias – uma classificação (o símbolo ≈ significa aproximadamente)

https://univirtus.uninter.com/ava/web/roa/

5/23

05/05/2022 22:52

UNINTER

Memória volátil: é aquela em que se perde o conteúdo com a ausência de energia elétrica;
são memórias rápidas e pequenas;
Registradores: são usados geralmente para endereçar a memória – são voláteis;
Memória cache: o tamanho do barramento de endereços é igual ao tamanho da palavra.
Oriunda do francês cacher, que significa esconder. Contém os dados e/ou instruções mais
recentemente referenciadas pelo processador.
Quando a CPU precisa de uma palavra de memória, primeiro busca essa palavra no cache.
Somente no caso de ela não estar armazenada lá é que a busca será na memória principal. Se uma
parte substancial dos acessos for satisfeita pelo cache, o tempo médio de acesso a uma palavra em
memória será pequeno, próximo ao tempo de acesso à CPU. Na execução de um programa de
computador, muitas referências são feitas num pequeno conjunto de posições de memória.
Cache é um dispositivo interno a um sistema que serve de intermediário entre a CPU e o
dispositivo principal de armazenamento (memória principal). O acesso à memória principal pode
ser demorado, por isso vale a pena armazenar as informações mais procuradas num meio mais
rápido.

https://univirtus.uninter.com/ava/web/roa/

6/23

05/05/2022 22:52

UNINTER

Deitel, Deitel e Choffnes (2017) apresentam nas “Reflexões sobre sistemas operacionais,
caching” que os projetistas de sistemas devem equilibrar o custo e o desempenho de vários
dispositivos de armazenamento para atender às necessidades dos usuários. Todos usamos caching
na vida real.
De modo geral, cache é um lugar para armazenar provisões que podem ser acessadas
rapidamente; esquilos armazenando bolotas (frutos do carvalho) enquanto se preparam para o
inverno é uma forma de caching. Guardamos lápis, canetas, grampos, fitas e clipes nas gavetas da
mesa de trabalho para poder ter acesso rápido a eles quando precisarmos (em vez de buscá-los no
armário de suprimentos). Sistemas operacionais empregam muitas técnicas de caching, como
caching de dados e instruções para acesso rápido em memórias cache de alta velocidade, e caching
de dados de discos na memória principal para acesso rápido enquanto um programa está em
execução.
Projetistas de sistemas operacionais devem ser cuidadosos ao usar caching, porque num
sistema de computador os dados em cache são uma cópia dos dados cujo original é mantido num
nível mais baixo da hierarquia da memória. A cópia em cache geralmente é aquela na qual as
mudanças são feitas em primeiro lugar; desse modo, rapidamente pode ficar fora de sincronia com
os dados originais, causando inconsistência.
Se um sistema falhar quando o cache contiver dados atualizados, mas o original não, os dados
modificados poderão se perder. Portanto, sistemas operacionais frequentemente copiam os dados
em cache para o original – esse processo é denominado esvaziamento de cache. Sistemas de
arquivos distribuídos muitas vezes colocam o cache tanto no servidor quanto no cliente, o que torna
ainda mais complexa a consistência do cache.

2.1 MEMÓRIA PRINCIPAL
A memória principal armazena programas em execução e os dados utilizados por eles. É a
memória primária, que também é volátil.
A CPU processa instruções obtidas da memória principal, e os resultados são retransmitidos a
ela. A unidade básica de memória é o bit (binary digit – dígito binário), uma abstração de valores 0
ou 1, pois fisicamente é mais fácil distinguir entre dois valores distintos do que de mais valores –
“tensão”, “corrente”.
https://univirtus.uninter.com/ava/web/roa/

7/23

05/05/2022 22:52

UNINTER

A memória é formada por um conjunto de células (ou posições), cada uma das quais podendo
guardar uma informação. Todas as células de uma dada memória têm o mesmo número de bits, e os
números que identificam (referenciam) a posição da célula na memória são chamados de
endereços. A célula é a menor unidade endereçável da memória. Seus endereços são
indexadores, pelos quais os programas podem referenciar dados na memória.
Os computadores modernos agrupam as células (ou bytes) em palavras (words). Por exemplo:
uma palavra de 32 bits tem 4 bytes (ou 4 células). Nesses computadores, a palavra é a parte mínima
de dados que podem ser transferidos de/para a memória principal. A informação na palavra pode ser
um dado ou uma instrução, portanto, “processadores de 32 bits” têm palavras e registradores de 32
bits. O número de bits do barramento de endereços em geral (mas não obrigatoriamente) é igual ao
número de bits dos registradores, e as instruções são (em geral) de 32 bits. Cada instrução deve
tratar palavras de 32 bits (movimentar, somar, subtrair etc.) como dados armazenados em
registradores de 32 bits.
Outra denominação da memória principal é a memória de acesso randômico (RAM). A célula
pode ser acessada sem ter que percorrer os endereços anteriores. O tempo de acesso é
praticamente o mesmo para todas as células, e é memória volátil. Recebe o nome randômico, pois
os processos podem acessar localizações de dados em qualquer ordem; mas, em caso contrário, as
localizações de dados num meio de armazenamento sequencial (por exemplo, fita) devem ser lidas
em sequência. Diferentemente de fitas e discos rígidos, as latências da memória para cada
endereço da memória principal são essencialmente iguais (Deitel; Deitel; Choffnes, 2017).

2.2 MEMÓRIA SECUNDÁRIA
Sua primeira característica é denominada memória não volátil, que retém o padrão de bits
original, mesmo que a energia seja desligada. É também chamada de memória endereçada
sequencialmente, na qual, para obter a informação de um endereço, é necessário percorrer os
endereços anteriores (por exemplo, fita magnética).
São memórias não endereçadas diretamente, isto é, os dados são transmitidos (enviados) para
a memória primária antes de a CPU executá-los. Esse é um procedimento necessário, devido à
volatilidade. Como dito, são não voláteis, o que permite guardar os dados permanentemente e,

https://univirtus.uninter.com/ava/web/roa/

8/23

05/05/2022 22:52

UNINTER

dessa forma, é possível executar programas e ler arquivos contendo os dados quando o computador
for ligado novamente, garantindo o armazenamento de dados a longo prazo.
São diversos tipos e modelos de memórias secundárias, entre eles os discos rígidos (HDs)
convencionais e removíveis, memórias flash, discos de estado sólido (SSD), discos óticos, entre
outros. Sistemas operacionais modernos utilizam a memória flash para expandir a memória principal
como memória virtual, como veremos no Tema 5.
As memórias secundárias são responsáveis por armazenar dados e informações (data storage),
e esse amplo conceito será definido e apresentado nas próximas aulas.

TEMA 3 – ALOCAÇÃO
Todos os softwares do sistema de computação, desde o sistema operacional até os aplicativos,
dependem de memória disponível para serem executados. Neste tópico, apresentaremos a
sequência das tarefas de gestão das memórias, em especial a estratégia utilizada para evitar
conflitos entre aplicações e garantir espaço para a execução, a alocação e os principais conceitos
relacionados.
Utilizando os mecanismos de hardware de memória, o sistema operacional prevê espaços e
disponibiliza áreas de memória para os processos (ou para o próprio núcleo), conforme a
necessidade. Segundo Maziero (2019), alocar memória significa reservar áreas de memória RAM
para serem usadas por um processo, por um descritor de socket ou de arquivo no núcleo, por um
cache de blocos de disco, entre outros. Ao final de seu uso, cada área de memória alocada é
liberada (ou deveria ser) pela entidade que a solicitou e colocada à disposição do sistema para
novas alocações.
O alocador de memória é o mecanismo responsável pela alocação e liberação de áreas de
memória. Em linhas gerais, o alocador reserva ou libera partes da memória RAM de acordo com o
fluxo de solicitações que recebe (de processos ou do núcleo do sistema operacional). Para isso, o
alocador deve manter um registro contínuo de quais áreas estão sendo usadas e quais estão livres.
Para ser eficiente, deve fazer alocações rapidamente e minimizar o desperdício de memória (Wilson
et al., 1995).

https://univirtus.uninter.com/ava/web/roa/

9/23

05/05/2022 22:52

UNINTER

Considerando a atualização constante e a diversidade nos padrões de funcionamento, a
complexidade da tarefa de alocação torna necessária a separação dos alocadores em:
Alocador de memória física: organiza a memória física do computador, alocando e liberando
grandes áreas de memória para carregar processos ou atender requisições do núcleo;
Alocador de espaço de núcleo: o núcleo do sistema operacional continuamente cria e destrói
muitas estruturas de dados relativamente pequenas, como descritores de arquivos abertos, de
processos, sockets de rede, pipes etc. O alocador de núcleo obtém áreas de memória do
alocador físico e as utiliza para alocar essas estruturas no núcleo;
Alocador de espaço de usuário: um processo pode solicitar blocos de memória para
armazenar estruturas de dados dinâmicas, por meio de operações como malloc e free. O
alocador de memória do processo geralmente é implementado por bibliotecas providas pelo
sistema operacional, como a LibC. Essas bibliotecas interagem com o núcleo para solicitar o
redimensionamento da seção Heap do processo quando necessário (Maziero, 2019).
Descrita por Maziero (2019), a estratégia de alocação básica traz que o problema básico de
alocação consiste em manter uma grande área de memória primária (RAM) e atender a um fluxo de
requisições de alocação e liberação de partes dessa área para o sistema operacional e/ou as
aplicações. Essas requisições ocorrem o tempo todo, em função das atividades em execução no
sistema, e devem ser atendidas rapidamente. Como resultado (efeito) das alocações e liberações, a
área de memória inicialmente vazia se transforma numa sequência de áreas ocupadas (alocadas) e
áreas livres, que evolui a cada nova requisição. Essas informações são geralmente mantidas em
uma ou mais listas duplamente encadeadas (ou árvores) de áreas de memória.

3.1 ESTRATÉGIAS DE GERENCIAMENTO E ALOCAÇÃO DE MEMÓRIA
Deitel, Deitel e Choffnes (2017) apresentam em paralelo as estratégias de alocação e de
gerenciamento de memória, projetadas para conseguir o melhor uso possível da memória principal,
sendo divididas em: 1) de busca; 2) de posicionamento; e 3) de substituição. Estratégias de busca
determinam quando transferir a próxima porção de um programa ou dados para a memória principal
por meio do armazenamento secundário. São divididas em dois tipos: 1) estratégias de busca sob
demanda; e 2) estratégias de busca antecipada.

https://univirtus.uninter.com/ava/web/roa/

10/23

05/05/2022 22:52

UNINTER

Durante muitos anos era comum empregar uma estratégia de busca sob demanda, com a qual
o sistema posicionava a próxima porção do programa ou de dados na memória principal quando um
programa em execução os referenciava. Projetistas acreditavam que, como em geral não podemos
prever os trajetos de execução que os programas tomarão, a sobrecarga envolvida em adivinhações
excederia em muito os benefícios. Atualmente, entretanto, muitos sistemas aumentaram seu
desempenho empregando estratégias de busca antecipada, que tentam carregar parte de um de
programa ou de dados na memória antes que sejam referenciados.
Estratégias de posicionamento determinam em que lugar da memória principal o sistema deve
colocar programas ou dados que chegam. São consideradas as estratégias de posicionamento firstfit (o primeiro que couber), best-fit (o que melhor couber), worst-fit (o que pior couber) e next-fit (o
próximo que couber).
Quando a memória estiver muito cheia para acomodar um novo programa, o sistema deverá
remover parte de um programa (ou ele todo) e dos dados que residem correntemente na memória. A
estratégia de substituição do sistema determina que parte remover (Deitel; Deitel; Choffnes,
2017). Vejamos alguns exemplos:
Alocação contígua simples: a memória principal é subdivida em duas áreas: uma para o
sistema operacional e outra para o programa do usuário;
Alocação particionada estática ou fixa: a memória era dividida em pedaços de tamanho fixo,
chamados partições. O tamanho das partições estabelecido na inicialização do sistema era
definido em função do tamanho dos programas que executariam no ambiente;
Alocação fixa com código absoluto: os programas só podem ser executados em
posições físicas dememória;
Alocação fixa com código relocável: todas as referências a endereços no programa se
relacionam ao início do código, e não a endereços físicos de memória. Nesse tipo de
alocação, o principal problema é a fragmentação interna, os espaços que sobram nas
partições ao alocar aplicações e o tamanho menor que a partição;
Alocação particionada dinâmica: as partições são criadas de acordo com o tamanho dos
programas que serão executados, eliminando o problema da fragmentação interna. Cada vez
que surge um novo programa a ser executado, criam-se novas partições, e com isso surge um
novo problema: a fragmentação externa (partições tão pequenas que não são suficientes para
alocar os programas necessários).
https://univirtus.uninter.com/ava/web/roa/

11/23

05/05/2022 22:52

UNINTER

As estratégias de alocação de memória surgiram para minimizar a fragmentação externa. Ao
longo da vida de um sistema, áreas de memória são alocadas e liberadas continuamente. Com isso,
podem surgir áreas livres (“buracos” na memória) entre as áreas alocadas. Esse fenômeno se
chama fragmentação externa, pois fragmenta a memória livre, fora das áreas alocadas.
A fragmentação externa é muito prejudicial, porque limita a capacidade de alocar a memória do
sistema. Além disso, quanto mais fragmentada a memória livre, maior o esforço necessário para
gerenciá-la, pois mais longas serão as listas encadeadas de área de memória livre. Pode-se
enfrentar o problema da fragmentação externa de duas formas: minimizando sua ocorrência, com
estratégias de alocação (desfragmentando periodicamente a memória do sistema), ou permitindo a
fragmentação interna (Maziero, 2019).
As estratégias de alocação são, em síntese, estratégias de posicionamento anteriormente
apresentadas. Vejamos:
First-fit (“o primeiro que se encaixa” ou “o primeiro que couber”): consiste em escolher a
primeira área livre que satisfaça o pedido de alocação. Sua vantagem é a rapidez, sobretudo
se a lista de áreas livres for muito longa;
Best-fit (“o que melhor se encaixa” ou “o que melhor couber”): consiste em escolher a menor
área possível que possa receber a alocação, minimizando o desperdício de memória. Contudo,
algumas áreas livres podem ficar pequenas demais e, portanto, inúteis;
Worst-fit (“o que pior se encaixar” ou “o que pior couber”): consiste em escolher sempre a
maior área livre possível, de forma que a “sobra” seja grande o suficiente para ser usada em
outras alocações;
Next-fit (“o próximo que se encaixar” ou “o próximo que couber”): variante da estratégia first-fit
que percorre a lista de áreas com base na última área alocada ou liberada, para que o uso das
áreas livres seja distribuído de forma mais homogênea no espaço de memória.
Diversas pesquisas demonstram que as abordagens mais eficientes são a best-fit e a first-fit,
sendo esta última bem mais rápida (Johnstone; Wilson, 1999). Além dos alocadores de uso geral,
pode-se desenvolver alocadores customizados para aplicações específicas. Uma técnica muito
usada em sistemas de tempo real, por exemplo, é o memory pool (reserva de memória). Nessa
técnica, um conjunto de blocos de mesmo tamanho é pré-alocado, constituindo um pool. A aplicação

https://univirtus.uninter.com/ava/web/roa/

12/23

05/05/2022 22:52

UNINTER

pode então obter e liberar blocos de memória desse pool com rapidez, pois o alocador só precisa
registrar quais blocos estão livres ou ocupados (Maziero, 2019).

TEMA 4 – ESTRATÉGIAS DE PAGINAÇÃO
Apresentaremos agora quais programas e dados podem ser divididos em pedaços de tamanho
fixo denominados páginas, que podem ser posicionadas em qualquer “moldura de página”
disponível. Nesses tipos de sistema, as estratégias de posicionamento são triviais e gerenciadas
com o auxílio de políticas de alocação e substituição de páginas.
A política de alocação de páginas determina quantos frames cada processo pode manter na
memória principal. São duas as estratégias utilizadas:
1. Alocação fixa: cada processo tem um número máximo de páginas que pode ser utilizado
durante sua execução;
2. Alocação variável: o número máximo de páginas alocadas ao processo pode variar durante
sua execução.
Já a política de substituição de páginas consiste na atuação do sistema operacional na
substituição de páginas (page out e page in) quando o processo atinge o número máximo de
páginas alocadas. A estratégia working set tem o objetivo de reduzir o problema de thrashing
(sucessivos page faults e I/O de páginas) e erros de page faults (páginas não encontradas na
memória).
A paginação de memória, especialmente a paginação em disco, consiste em técnicas para que
um dispositivo de armazenamento secundário seja uma extensão da memória RAM, de forma
transparente para as aplicações. Partes ociosas da memória podem ser transferidas para alguma
memória secundária, liberando a memória RAM para outros usos. Caso algum processo tente
acessar esse conteúdo posteriormente, ele deverá ser trazido de volta à memória, e essa
transferência de dados entre memória principal e secundária é feita pelo sistema operacional, de
forma transparente para os processos (Maziero, 2019).
Existem diversas técnicas para usar um espaço de armazenamento secundário como extensão
da memória RAM, com ou sem o auxílio do hardware. Entre elas, destacam-se a overlay, a
swapping e a paging.
https://univirtus.uninter.com/ava/web/roa/

13/23

05/05/2022 22:52

UNINTER

4.1 OVERLAY
A técnica de overlay divide a memória em área do sistema operacional, área do módulo
principal do programa do usuário e uma área de troca entre os módulos secundários do programa do
usuário, denominada área de overlay. Essa organização em módulos é feita pelo desenvolvedor e
permite que eles sejam carregados numa mesma região de memória em momentos distintos. Esses
módulos (overlays) são gerenciados por uma biblioteca específica.
Essa técnica permite executar programas maiores que a quantidade de memória disponível, e
está representada pela Figura 2:

Figura 2 – Overlay

Fonte: elaborado com base em Machado; Maia, 2007.

4.2 SWAPPING
Swapping é uma técnica aplicada à gerência de memória para programas que esperam por
memória livre para serem executadas. Nessa situação, o sistema escolhe um processo residente,
que é transferido da memória principal (RAM) para a memória secundária (swap out), geralmente
https://univirtus.uninter.com/ava/web/roa/

14/23

05/05/2022 22:52

UNINTER

em disco, liberando a memória para executar outros processos. Caso esse processo seja
novamente executado (entrar na fila de prontos do escalonador), ele é novamente carregado na
memória principal (swap in).
Essa é outra alternativa para expandir a capacidade de processamento da máquina, pois alocar
um espaço em disco para transferir arquivos da memória principal para a área de swapping (e viceversa) também permite executar processos maiores que a quantidade de memória principal (RAM)
disponível.

4.3 PAGING
Já a técnica de paging consiste em mover páginas individuais, conjuntos de páginas ou mesmo
segmentos da memória principal para a secundária (page out). Se o processo tentar acessar alguma
dessas páginas mais tarde, é gerada uma interrupção de page fault (falta de página), e o núcleo do
sistema operacional recarrega a página faltante na memória principal (page in). Essa é a técnica
mais utilizada nos sistemas operacionais atuais, por sua flexibilidade, rapidez e eficiência.

4.4 ALGORITMOS DE SUBSTITUIÇÃO DE PÁGINAS
Como a transferência de páginas entre a memória principal e a secundária é feita pelo núcleo
do sistema operacional, é responsabilidade dele escolher quais páginas retirar da memória,
auxiliado por algoritmos de substituição de páginas. Assim, quando um processo tentar acessar uma
página que está na memória secundária, o núcleo recebe um alerta e traz a página de volta à
memória para poder ser acessada. Para cada página transferida ao disco, a tabela de páginas do
processo é atualizada.
Os algoritmos de substituição de páginas têm o objetivo de selecionar os frames com as
menores chances de serem referenciados num futuro próximo. Com base no princípio da localidade,
a maioria dos algoritmos tenta prever o comportamento futuro das aplicações em função do
comportamento passado, avaliando o número de vezes que uma página foi referenciada, quando foi
carregada para a memória principal e o intervalo de tempo da última referência.
Segundo Maziero (2019), vários critérios podem ser usados para escolher quais páginas
transferir da memória RAM para o armazenamento secundário. Alguns deles são os seguintes:

https://univirtus.uninter.com/ava/web/roa/

15/23

05/05/2022 22:52

UNINTER

Idade da página: tempo em que a página está na memória (páginas muito antigas talvez
sejam pouco usadas);
Frequência de acessos à página: páginas muito acessadas num passado recente
possivelmente ainda o serão num futuro próximo;
Data do último acesso: páginas há mais tempo sem acesso possivelmente serão pouco
acessadas num futuro próximo (sobretudo se os processos respeitarem o princípio da
localidade de referências);
Prioridade do processo proprietário: processos de alta prioridade, ou de tempo real, podem
precisar de suas páginas de memória rapidamente; se elas estiverem no disco, seu
desempenho ou tempo de resposta poderão se prejudicar;
Conteúdo da página: páginas cujo conteúdo seja código executável exigem menos esforço do
mecanismo de paginação, porque seu conteúdo já está mapeado no disco (dentro do arquivo
executável correspondente ao processo). Por outro lado, páginas de dados alteradas precisam
ser salvas na área de troca;
Páginas especiais: páginas com buffers de operações de entrada/saída podem trazer
dificuldades ao núcleo caso não estejam na memória quando ocorrer a transferência de dados
entre o processo e o dispositivo físico.
O processo também pode solicitar que certas páginas com informações sensíveis (como senhas
ou chaves criptográficas) não sejam copiadas na área de troca, por motivos de segurança.
A escolha correta das páginas a retirar da memória física é um fator essencial para a eficiência
do mecanismo de paginação. Más escolhas poderão remover da memória páginas muito usadas,
aumentando a taxa de faltas de página e diminuindo o desempenho do sistema. Veremos agora os
principais algoritmos de substituição de páginas.
O algoritmo Ótimo seleciona para substituição uma página que não será mais referenciada no
futuro, ou aquela que levará o maior intervalo de tempo para ser novamente utilizada. Simplificando:
a melhor página a remover da memória num dado instante é a que ficará mais tempo sem ser usada
pelos processos, mas, como o comportamento futuro dos processos não pode ser previsto com
precisão, esse algoritmo não é implementável.
No algoritmo Aleatório (Random) todas as páginas alocadas na memória principal têm a
mesma chance de serem selecionadas, inclusive os frames frequentemente referenciados, pois
https://univirtus.uninter.com/ava/web/roa/

16/23

05/05/2022 22:52

UNINTER

consiste em escolher aleatoriamente as páginas. Consome pouco recurso de memória, mas tem
baixa eficiência.
O algoritmo de ordem First In, First Out (Fifo) seleciona para substituição a primeira página
utilizada (e que está há mais tempo na memória), e páginas mais antigas podem ser removidas para
dar lugar a novas páginas. Esse algoritmo é muito simples de implementar, pois os números das
páginas recém-carregadas na memória são registrados no final da lista, enquanto os números das
próximas páginas a substituir na memória estão no início da lista. No entanto, não oferece bons
resultados. Seu principal defeito é considerar somente a idade da página, sem levar em conta sua
importância. Páginas carregadas na memória há muito tempo podem ser frequentemente
acessadas.
Para o algoritmo Least Frequently Used (LFU), a página que tiver o contador com o menor
número de referências será escolhida, ou seja, o algoritmo evita selecionar páginas bastante
utilizadas. O problema é que somente as páginas que estão há pouco tempo na memória podem ser
selecionadas.
O algoritmo Least Recently Used (LRU) (menos usado recentemente) seleciona a página na
memória principal que está há mais tempo sem ser referenciada. É necessário que cada página
tenha associado a ela o momento do último acesso, que deve ser atualizado a cada referência a um
frame. Quando for necessário substituir uma página, o sistema fará a busca por um frame que esteja
há mais tempo sem ser referenciado.
Outra maneira de implementar o LRU é com uma lista encadeada, em que todas as páginas
estariam ordenadas pelo momento da última referência, partindo do pressuposto de que páginas
recentemente acessadas no passado provavelmente serão acessadas num futuro próximo, evitando
removê-las da memória, mas isso gera um elevado custo de implementação.
O algoritmo Not Recently Used (NRU) (ou não usado recentemente) leva em conta o bit de
referência de cada página e o bit de modificação (dirty bit), que indica se o conteúdo de uma página
foi modificado depois de ter sido carregada na memória. É bastante semelhante ao LRU, mas
menos sofisticado.
Para implementar esse algoritmo, é necessário um bit adicional, conhecido como bit de
referência (BR), que indica se a página foi utilizada recentemente e está presente em cada entrada
https://univirtus.uninter.com/ava/web/roa/

17/23

05/05/2022 22:52

UNINTER

da tabela de páginas. Quando uma página é carregada para a memória principal, o bit de referência
é alterado pelo hardware, indicando que a página foi referenciada (BR=1). Quando uma página for
substituída, o sistema seleciona um dos frames que não tenha sido utilizado recentemente, ou seja,
com o bit de referência igual a zero.
Há também o algoritmo Fifo com buffer de páginas, que combina uma lista de páginas
alocadas (LPA) com uma lista de páginas livres (LPL). A LPA organiza todas as páginas que estão
sendo utilizadas na memória principal, podendo ser implementada como uma lista única para todos
os processos, ou uma lista individual para cada processo. Independente da política utilizada, a LPA
organiza as páginas alocadas há mais tempo na memória no início da lista, e as mais recentes no
final. Da mesma forma, a LPL organiza todos os frames livres da memória principal; as páginas
livres há mais tempo estão no início, as mais recentes, no final.
Sempre que um processo necessita alocar uma nova página, o sistema utiliza a primeira página
da LPL, colocando-a no final da LPA. Caso o processo tenha que liberar uma página, o mecanismo
de substituição seleciona o frame em uso há mais tempo na memória, isto é, o primeiro da LPA,
colocando-o no final da LPL.
É importante notar que a página selecionada e que entrou na LPL continua disponível na
memória principal por um determinado intervalo de tempo. Caso essa página seja novamente
referenciada e ainda não tenha sido alocada, basta retirá-la da LPL e devolvê-la ao processo. Nesse
caso, a LPL funciona como um buffer de páginas, evitando o acesso à memória secundária. Por
outro lado, se a página não for mais referenciada, com o passar do tempo chegará ao início da LPL,
quando será utilizada para outro processo. Caso a página seja posteriormente referenciada, o
sistema terá que carregá-la novamente da memória secundária.
O algoritmo Fifo circular utiliza como base o Fifo, porém as páginas alocadas na memória
estão numa estrutura de lista circular, semelhante a um relógio. Esse algoritmo é implementado com
pequenas variações na maioria dos sistemas Unix. Para implementar o algoritmo, existe um ponteiro
que guarda a posição da página mais antiga na lista, e cada página tem associado um bit de
referência, indicando se ela foi recentemente referenciada. Quando é necessário substituir uma
página, o sistema verifica se o frame apontado tem o bit de referência desligado (BR=0). Nesse
caso, a página é selecionada para descarte pois, além de ser a mais antiga, não foi utilizada
recentemente. Por outro lado, se a página apontada tem o bit de referência ligado (BR=1), o bit é
https://univirtus.uninter.com/ava/web/roa/

18/23

05/05/2022 22:52

UNINTER

desligado e o ponteiro é incrementado, pois, apesar de ser a página mais antiga, foi utilizada
recentemente. O processo se repete até encontrar uma página com bit de referência igual a zero.
Nesse algoritmo, é possível que todos os frames tenham o bit de referência ligado. Nesse caso,
o ponteiro percorrerá toda a lista, desligando o bit de referência de cada página. Ao final, a página
mais antiga é selecionada. O bit de referência permite conceder a cada página uma segunda chance
antes de ser substituída. É possível melhorar a eficiência do algoritmo utilizando o bit de modificação
juntamente com o bit de referência, como apresentado no esquema NRU.

TEMA 5 – MEMÓRIA VIRTUAL
A memória virtual é uma técnica sofisticada e poderosa de gerência de memória, em que a
memória principal e a secundária são combinadas, dando ao usuário a ilusão de existir uma
memória muito maior que a capacidade real da memória principal.
O conceito de memória virtual fundamenta-se em não vincular o endereçamento feito pelo
programa dos endereços físicos da memória principal.
Para ocultar a organização complexa da memória física e simplificar os procedimentos de
alocação da memória aos processos, os sistemas de computação modernos implementam a noção
de memória virtual, na qual existem dois tipos de endereço de memória distintos:
1. Endereços físicos (ou reais): são os endereços dos bytes de memória física do computador.
Esses endereços são definidos pela quantidade de memória disponível na máquina.
2. Endereços lógicos (ou virtuais): são os endereços de memória usados pelos processos e
pelo sistema operacional e, portanto, usados pelo processador durante a execução. Esses
endereços são definidos de acordo com o espaço de endereçamento do processador.
Ao executar, os processos “enxergam” somente a memória virtual. Assim, durante a execução
de um programa, o processador gera endereços lógicos para acessar a memória, que devem então
ser traduzidos para os endereços físicos correspondentes na memória RAM em que as informações
desejadas se encontram.
Por questões de desempenho, a tradução de endereços lógicos em físicos é feita por um
componente específico do hardware do computador, denominado unidade de gerência de memória
https://univirtus.uninter.com/ava/web/roa/

19/23

05/05/2022 22:52

UNINTER

(memory management unit – MMU). Na maioria dos processadores atuais, a MMU se encontra
integrada ao chip da própria CPU.
A MMU intercepta os endereços lógicos emitidos pelo processador e os traduz para os
endereços físicos correspondentes na memória da máquina, permitindo seu acesso pelo
processador. Caso o acesso a determinado endereço lógico não seja possível (por não estar
associado a um endereço físico, por exemplo), a MMU gera uma interrupção de hardware para
notificar o processador sobre a tentativa de acesso indevido. O comportamento da MMU e as regras
de tradução de endereços são configuradas pelo núcleo do sistema operacional (Maziero, 2019).
O mecanismo de tradução é essencial pois, sempre que o processo referenciar um endereço
virtual, a unidade de gerência de memória verifica pelo bit de validade se a página que contém o
endereço referenciado está ou não na memória principal. Caso a página não esteja na memória,
ocorre um page fault. Para corrigir o erro, o sistema deverá transferir a página da memória
secundária para a principal.
Além de desacoplar os endereços lógicos dos endereços físicos e fazer a tradução entre
ambos, a noção de memória virtual também permite implementar a proteção de memória do núcleo
e dos processos entre si, fundamentais para a segurança e estabilidade do sistema.
Para implementar a proteção de memória entre processos, o núcleo mantém regras distintas de
tradução de endereços lógicos para cada processo e reconfigura a MMU a cada troca de contexto.
Assim, o processo em execução, a cada instante, tem sua própria área de memória e é impedido
pela MMU de acessar áreas de memória dos demais processos. Além disso, a configuração das
MMUs mais sofisticadas inclui a definição de permissões de acesso às áreas de memória. Essa
funcionalidade permite implementar as permissões de acesso às diversas áreas de cada processo e
impedir os processos de acessar áreas exclusivas do núcleo do sistema operacional.
As principais estratégias de tradução de endereços usadas pelas MMUs são por partições,
usadas nos primeiros sistemas de memória virtual, e por segmentos e por páginas, usadas nos
sistemas atuais.
A memória virtual por paginação é a técnica de gerência de memória com a qual o espaço de
endereçamento real é dividido em blocos de mesmo tamanho chamados páginas. Já a memória
virtual por segmentação é a técnica de gerência de memória com a qual o espaço de
https://univirtus.uninter.com/ava/web/roa/

20/23

05/05/2022 22:52

UNINTER

endereçamento virtual é dividido em blocos de tamanhos diferentes chamados segmentos.
Enquanto na paginação existe o problema da fragmentação interna, na segmentação surge o
problema da fragmentação externa.
A técnica de swapping apresentada é o exemplo mais popular de memória virtual, pois diversos
sistemas operacionais (como o Linux) exigem (como requisito básico) a definição em disco de uma
partição de swap, normalmente com o dobro do tamanho da memória principal (RAM) disponível.

FINALIZANDO
Os conteúdos da gerência de memória foram apresentados e definidos nesta aula. Trata-se de
uma tarefa elementar que pode fazer toda a diferença na escolha do sistema operacional mais
adequado aos objetivos iniciais de conveniência e eficiência. Mostramos que a gestão de memória
tem como meta manter o maior número de processos residentes na memória principal, permitindo
maximizar o compartilhamento do processador e demais recursos computacionais, auxiliando no
combate à ociosidade da CPU.
No Tema 2, apresentamos tipos e padrões de memória numa classificação básica, pois
conhecer os componentes é elementar para uma boa gestão. Também mostramos os tipos e
padrões das memórias, permitindo uma classificação simples e funcional, pois, quanto maior a
capacidade de armazenamento, menores seus custos e velocidades (desempenho) – e vice-versa,
como vimos na Figura 1.
No Tema 3, descrevemos a alocação de memória, em que todos os softwares do sistema de
computação, desde o sistema operacional até os aplicativos, dependem de memória disponível para
serem executados. Apresentamos a sequência das tarefas de gestão das memórias, em especial a
estratégia utilizada para evitar conflitos entre aplicações e garantir espaço para a execução, a
alocação e os principais conceitos relacionados, ressaltando que alocar memória significa reservar
áreas de memória RAM para serem usadas por um processo.
Demos destaque ao item 3.1, que trata das estratégias de gerenciamento e alocação de
memória: first-fit (“o primeiro que se encaixa”, ou “primeiro que couber”), best-fit (“o que melhor se
encaixa”, ou “o que melhor couber”), worst-fit (“o que pior se encaixa”, ou “o que pior couber”) e o
next-fit (“o próximo que se encaixa”, ou “o próximo que couber”).
https://univirtus.uninter.com/ava/web/roa/

21/23

05/05/2022 22:52

UNINTER

No Tema 4, vimos as estratégias de paginação, apresentando quais programas e dados podem
ser divididos em pedaços de tamanho fixo denominados páginas, que podem ser posicionados em
qualquer “moldura de página” disponível e gerenciadas com o auxílio de políticas de alocação e
substituição de páginas, com as técnicas overlay, swapping e paging.
No item 4.4, apresentamos os algoritmos de substituição de páginas, considerando a idade da
página, frequência de acessos a ela, data do último acesso, prioridade do processo proprietário,
conteúdo da página e páginas especiais. Os principais algoritmos de substituição são: Ótimo;
Aleatório; de ordem Fifo; LFU; LRU; NRU; Fifo com buffer de páginas; e Fifo circular.
No Tema 5, falamos sobre a memória virtual, uma técnica sofisticada e poderosa de gerência de
memória, em que a memória principal e a secundária são combinadas, dando ao usuário a ilusão de
existir uma memória muito maior que a capacidade real da memória principal. Fundamenta-se em
não vincular o endereçamento feito pelo programa dos endereços físicos da memória principal,
com destaque à MMU, que permite implementar a proteção de memória do núcleo e dos
processos entre si. Finalizamos o tópico apresentando as principais estratégias de tradução de
endereços usadas pelas MMUs, por partições, segmentos e páginas, paginação e segmentação.
Compreender esses conceitos possibilita uma melhor e mais eficiente escolha do sistema
operacional, obedecendo aos critérios e às necessidades de cada software aplicativo e de cada
usuário.

REFERÊNCIAS
DEITEL, P. J.; DEITEL, H. M.; CHOFFNES, D. R. Sistemas operacionais. 3. ed. São Paulo:
Pearson Brasil, 2017.
JOHNSTONE, M. S.; WILSON, P. R. The memory fragmentation problem: solved? ACM
SIGPLAN Notices, New York, v. 34, n. 3, p. 26-36, 1999.
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. São Paulo: LTC,
2007.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: UFPR, 2019.

https://univirtus.uninter.com/ava/web/roa/

22/23

05/05/2022 22:52

UNINTER

STALLINGS, W. Operating systems: internals and design principles. 9. ed. London: Pearson,
2018.
WILSON, P. R. et al. Dynamic storage allocation: a survey and critical review. New York:
Springer, 1995. Disponível em: <https://users.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf>.
Acesso em: 20 jun. 2020.

https://univirtus.uninter.com/ava/web/roa/

23/23



05/05/2022 22:54

UNINTER

SISTEMAS OPERACIONAIS
AULA 4

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/22

05/05/2022 22:54

UNINTER

CONVERSA INICIAL
Os computadores são compostos basicamente pelo hardware e pelo software, de forma
dependente, como definimos em aulas anteriores. O hardware tem como principais componentes a
CPU, as memórias e os dispositivos de E/S, cada um dos quais é individualmente gerenciado e
controlado pelo sistema operacional. Após a apresentação da gerência de processos e do
processador (CPU) e da gerência de memória em aulas anteriores, agora apresentaremos a
gerência de dispositivos de E/S. Já estudamos as definições das atividades de gestão de
processador e de processos e da gestão de memória, com uma análise de processos de gestão de
entrada e saída. Nesta aula, completaremos os conceitos de gestão dos elementos do hardware
pelo sistema operacional. Vamos lá?
O Sistema Operacional deve controlar todos os dispositivos de E/S de um computador. Deve
emitir comandos para os dispositivos, interceptar interrupções e tratar erros. Deve também fornecer
uma interface simples e fácil de usar; na medida do possível, a interface deveria ser a mesma para
todos os dispositivos. Ou seja, para o usuário, dados de um arquivo ou de um dispositivo de rede, as
chamadas ao sistema são iguais, mudando apenas os parâmetros de entrada (Sousa Filho;
Alexandre, 2013)
Os conteúdos previstos para nossas discussões contemplam nesta aula a gestão (gerência) de
dispositivos de entrada e saída, apresentados e definidos em cinco temas: conceitos e definições de
gestão de E/S; gerenciador de dispositivos; device drivers; controladores de dispositivos; e técnicas
avançadas de E/S.

TEMA 1 – CONCEITOS E DEFINIÇÕES DE GESTÃO DE E/S

https://univirtus.uninter.com/ava/web/roa/

2/22

05/05/2022 22:54

UNINTER

Segundo Guardia e Senger (2015). o controle da entrada e saída (E/S – ou I/O input/output) de
dados dos dispositivos é uma das funções principais de um sistema operacional. Para promover o
compartilhamento seguro do uso dos recursos, contudo, não é permitido aos processos o acesso
direto a dispositivos de entrada e saída. Assim, cabe ao SO oferecer serviços (chamadas de
sistema) que permitam ler e escrever dados.
A interação dos programas com o SO para o acesso aos dispositivos pode ocorrer enviando e
recebendo bytes de/para dispositivos de caractere, ou realizando operações de arquivos em
dispositivos de bloco (Guardia; Senger, 2015).
Um dispositivo de bloco é aquele que armazena informação em blocos de tamanho fixo, cada
um com seu próprio endereço. Os tamanhos de blocos variam de 512 bytes a 32.768 bytes. A
propriedade essencial de um dispositivo de blocos é que cada bloco pode ser lido ou escrito
independentemente dos outros. Discos são dispositivos de blocos mais comuns (Sousa Filho;
Alexandre, 2013).
Há outro tipo de dispositivos de E/S, que é o dispositivo de caractere, que envia ou recebe um
fluxo de caracteres, sem considerar qualquer estrutura de blocos. Ele não é endereçável e não
dispõe de qualquer operação de posicionamento. Impressoras, interface de rede, mouses e a maior
parte de outros dispositivos diferentes do disco são considerados dispositivos de caractere (Sousa
Filho; Alexandre, 2013).
Os Sistema Operacionais devem atuar nas seguintes operações de E/S (Guardia; Senger,
2015):
emitir comandos para os dispositivos;
atender interrupções geradas pelos dispositivos;
tratar erros nas operações dos dispositivos;
prover uma interface para a utilização dos dispositivos; se possível, a mesma para todos eles,
de forma que a sintaxe das operações seja independente dos dispositivos.
Para entender como o SO trata os dispositivos, é importante conhecer alguns aspectos de suas
operações (Guardia; Senger, 2015).
Gerenciar entrada/saída (E/S) envolve muitos componentes de sistema operacional, como
ilustra a figura a seguir.
https://univirtus.uninter.com/ava/web/roa/

3/22

05/05/2022 22:54

UNINTER

Figura 1 – Componentes de suporte de E/S do Windows XP

Fonte: Elaborado com base em Deitel; Deitel, 2017.

Deitel e Deitel (2017) descrevem os componentes da figura individualmente. Processos de
modo usuário interagem com um subsistema de ambiente (como o subsistema Win32), e não
diretamente com componentes de modo núcleo. Os subsistemas de ambiente passam requisições
de E/S para o gerenciador de E/S, que interage com drivers de dispositivo para tratar essas
requisições. Frequentemente, vários drivers de dispositivo organizados em uma pilha de drivers
cooperam para atender a uma requisição de E/S.
Um componente em destaque é o gerenciador de dispositivos plug-and-play (PnP), que
reconhece novos dispositivos quando são conectados ao sistema. No entanto, é necessário que tais
dispositivos apresentem suporte ao recurso. Ele disponibiliza recursos como portas de E/S ou canais
de DMA. Dispositivos desenvolvidos mais recentemente suportam PnP.
O gerenciador de energia administra a política de gerenciamento de energia do sistema
operacional. A política de energia determina se é preciso reduzir a energia para certos dispositivos,
para conservá-la, ou se é possível mantê-los completamente energizados, de modo a garantir alta
responsividade (Deitel; Deitel, 2017).

https://univirtus.uninter.com/ava/web/roa/

4/22

05/05/2022 22:54

UNINTER

Para a gerência de Entrada/Saída, considera-se um componente de gerenciamento de
memória, que inclui o controle de usos diversos da áreas de armazenamento temporário, ou uma
interface geral para os diversos controladores de dispositivos, utilizando rotinas de controle (device
drivers) dos diversos dispositivos (Silberschatz; Galvin; Gagne, 2016).
Segundo Machado e Maia (2007), a gerência de entrada/saída no Unix foi desenvolvida de
forma integrada ao sistema de arquivos. O acesso aos dispositivos de E/S, como terminais, discos e
a própria rede, é feito por meio de arquivos especiais. Cada dispositivo está associado a um ou mais
arquivos especiais, localizados no diretório /dev. Por exemplo, uma impressora pode ser o arquivo
/dev/lp; um terminal, /dev/ttyl; e uma interface de rede, /dev/net.
Os arquivos especiais podem ser acessados da mesma forma que qualquer outro arquivo,
utilizando simplesmente as chamadas de sistema (system calls) de leitura e gravação. No Unix,
todas as operações de E/S são realizadas como uma sequência de bytes, inexistindo os conceitos
de registro ou método de acesso. Isso permite enviar o mesmo dado para diferentes dispositivos de
saída, como um arquivo em disco, terminal, impressora ou linha de comunicação. Dessa forma, as
system calls de E/S podem manipular qualquer tipo de dispositivo de maneira uniforme (Machado;
Maia, 2007).
O subsistema de E/S é a parte do kernel responsável por lidar com as funções de entrada e
saída independentes do dispositivo, como buffering e controle de acesso. Para permitir a
comunicação entre o subsistema de E/S e os diferentes drivers de maneira uniforme, o sistema
implementa uma interface com os device drivers, padronizada com base nas especificações Device
Driver Interface (DOI) e Driver Kernel lnterface (DKl) (Machado; Maia, 2007).
Os device drivers têm a função de isolar os dispositivos de E/S do restante do kernel, tomandoo independente da arquitetura de hardware. Para cada dispositivo, existe um device driver
associado. Os device drivers são acoplados ao sistema operacional quando o kemel é gerado.
Sempre que um novo dispositivo é acrescentado ao sistema, o driver correspondente deve ser
acoplado ao núcleo. A tarefa de geração do kernel não é simples, exigindo que o sistema seja
reinicializado (Machado; Maia, 2007).
A figura a seguir apresenta as camadas que compõem a gerência de E/S no Unix. Os
processos se comunicam com o subsistema de E/S por meio das system calls de E/S.

https://univirtus.uninter.com/ava/web/roa/

5/22

05/05/2022 22:54

UNINTER

Figura 2 – Gerência de E/S

Fonte: Elaborado com base em Deitel; Deitel, 2017; crédito: NATASHA ZALEVSKAYA/SHUTTERSTOCK

As versões mais recentes do Unix, como o Linux, permitem que os device drivers possam ser
acoplados ao núcleo com o sistema em funcionamento, sem a necessidade de uma nova geração
do kernel e reinicialização de sistema (Machado; Maia, 2007).
Os device drivers podem ser divididos em dois tipos: orientados a bloco e orientados a
caractere. Os device drivers orientados a bloco estão ligados a dispositivos como discos rígidos
(HDs) e discos ópticos (BlueRay), que permitem a transferência de blocos de informações do
mesmo tamanho (Machado; Maia, 2007).
Os drivers orientados a caractere são voltados para conectar dispositivos como terminais e
impressoras, que transferem informação de tamanho variável, geralmente caractere a caractere, ou
uma sequência de caracteres.
Na última camada do sistema operacional, os aplicativos (System Apps) oferecem ao utilizador
o acesso aos recursos físicos (hardware), como ilustra a Figura 3, já apresentada em aulas
anteriores.

https://univirtus.uninter.com/ava/web/roa/

6/22

05/05/2022 22:54

UNINTER

Figura 3 – System apps e recursos físicos

Por exemplo, ao executar o app câmera, o usuário acessa o recurso de hardware (câmera) de
forma rápida e transparente, ficando com a sensação de que o acesso é direto da tela para as
lentes. Mas, como ilustram os blocos (verde – Java API Framework; roxo – Native C/C++ libraries;
amarelo – ART; e azul claro – HAL), do app até as lentes da câmera são executadas inúmeras
outras tarefas e funções (softwares).
Cada uma das etapas é responsável pela integração de todas as características disponíveis e
pela correta execução. Filtros, efeitos especiais 3D e animações são exemplos de recursos de
software.

https://univirtus.uninter.com/ava/web/roa/

7/22

05/05/2022 22:54

UNINTER

No caso das operações orientadas a bloco, deve existir a preocupação de minimizar o número
de transferências entre o dispositivo e a memória. utilizando o buffer cache.
O buffer cache é uma área na memória principal onde ficam armazenados temporariamente os
blocos recentemente referenciados. Por exemplo, quando uma operação de leitura a disco é
realizada, o subsistema de E/S verifica se o bloco está no buffer cache. Se o bloco se encontra no
cache, é possível passá-lo diretamente para o sistema de arquivos, sem acesso ao disco,
melhorando assim o desempenho do sistema.
O núcleo do Sistema Operacional (kernel) acessa dispositivos de sistema por meio da interface
de E/S. O núcleo abstrai os detalhes do hardware de um sistema, fornecendo uma interface comum
para chamadas ao sistema de E/S. O núcleo agrupa dispositivos em classes; membros de cada
classe de dispositivos executam funções similares, o que permite ao núcleo abordar as
necessidades de desempenho de certos dispositivos (ou classes de dispositivos) individualmente
(Deitel; Deitel, 2017).

TEMA 2 – GERENCIADOR DE DISPOSITIVOS
Como abordamos em aulas anteriores, aqui entra em cena o Sistema Operacional (SO), que é
uma camada de software que opera entre o hardware e os aplicativos. É um software de estrutura
ampla e complexa, que incorpora aspectos de baixo nível (como drivers de dispositivos e gerência
de memória física) e de alto nível (como softwares utilitários e a interface gráﬁca).
A Figura 4 ilustra o gerenciamento de dispositivos pelo SO.

Figura 4 – Gerenciamento de dispositivos

https://univirtus.uninter.com/ava/web/roa/

8/22

05/05/2022 22:54

UNINTER

Fonte: Elaborado com base em Coutinho, 2010.

O sistema operacional deve fornecer ao utilizador acesso aos dispositivos de forma
transparente, mas nem sempre isso ocorre com perfeição. Podem ocorrer falhas, em cujos casos o
acesso aos dispositivos pode ser realizado utilizando uma GUI (Graphic User Interface), aplicativo
interativo com interface gráfica, que fornece ao utilizador dados técnicos e informações detalhadas
sobre cada dispositivo de hardware conectado ao sistema de computação, auxiliando a resolução de
eventuais conflitos ou falhas.
É também desejável (e muito importante) que o sistema operacional disponibilize ao usuário
acesso fácil e simples (transparente) a quaisquer novos dispositivos incluídos, em especial os plugand-play (PnP), aqueles que apresentam como principal característica o recurso conectar e usar,
conforme descrevemos no Tema 1, ao abordar o gerenciador de plug-and-play (PnP).
Os sistemas computacionais atuais apresentam centenas de dispositivos interconectados, dos
mais diversos tipos e padrões; cada um deles é individualmente gerenciado, apresentando
informações particulares (endereços, tamanho, função etc.), descritas e gerenciadas pelos softwares
de gerência. As figuras a seguir ilustram exemplos de gerenciadores de dispositivos.

Figura 5 – Gerenciador de Dispositivos Kali-Linux

https://univirtus.uninter.com/ava/web/roa/

9/22

05/05/2022 22:54

UNINTER

Fonte: Andre Roberto Guerra.

Figura 6 – Gerenciador de Dispositivos Windows 10

Fonte: Andre Roberto Guerra.

Figura 7 – Gerenciador de Dispositivos Apple MacOS X

https://univirtus.uninter.com/ava/web/roa/

10/22

05/05/2022 22:54

UNINTER

Fonte: Andre Roberto Guerra.

A gerência de dispositivos recebe destaque, pois cada periférico do computador tem suas
particularidades; assim, o procedimento de interação com uma placa de rede é completamente
diferente da interação com um disco rígido SATA (Maziero, 2019). Todavia, existem muitos
problemas e abordagens em comum para o acesso aos periféricos.
Por exemplo, é possível criar uma abstração única para a maioria dos dispositivos de
armazenamento, como cartão de memória, SSD, CD-ROMs etc., na forma de um vetor de blocos de
dados.
A função da gerência de dispositivos (também conhecida como gerência de entrada/saída) é
implementar a interação com cada dispositivo, por meio de drivers, e criar modelos abstratos que
permitam agrupar vários dispositivos similares sob a mesma interface de acesso.
A impressão é outro recurso em que o acesso deve ser efetuado de forma mutuamente
exclusiva (apenas um aplicativo por vez). O sistema operacional resolve essa questão utilizando o
recurso de Spooling, além de definir uma fila de trabalhos a imprimir (print jobs), normalmente
executados sequencialmente (First In First Out). (Maziero, 2019)
Melo Neto (2014) descreve que a gerência de dispositivos de entrada/saída é uma das
principais e mais complexas funções do sistema operacional. Sua implementação é estruturada por
https://univirtus.uninter.com/ava/web/roa/

11/22

05/05/2022 22:54

UNINTER

meio de camadas de um modelo semelhante ao apresentado para o sistema operacional, utilizando
o conceito de máquina de níveis. As camadas de mais baixo nível escondem características das
camadas superiores, oferecendo uma interface simples e confiável ao usuário em suas aplicações.

TEMA 3 – DEVICE DRIVERS
Neste tema, vamos estudar o elemento de software responsável pelo funcionamento dos
dispositivos, os device drivers.
A camada inferior de software – drivers de dispositivos (device drivers) – é composta por um
conjunto de módulos de software, cada um implementado para fornecer os mecanismos de acesso a
um dispositivo de entrada e saída específico. O principal objetivo dos drivers de dispositivos é
“esconder” as diferenças entre os vários dispositivos de entrada e saída, fornecendo à camada
superior uma “visão uniforme” dos dispositivos, com uma interface de programação única (Oliveira;
Carissimi; Toscani, 2010).
Segundo Nigri (2018), uma vez que o Sistema Operacional tem que suportar todos os tipos de
hardware, não faria muito sentido que o programa que controla cada modelo disponível de cada tipo
de dispositivo ficasse no kernel. Se assim fosse, haveria um grande desperdício de memória. Para
resolver isso, existem os device drivers.
Os módulos controlam funções específicas, sendo carregados pelo kernel à medida que os
dispositivos são detectados pelo sistema. No entanto, ao contrário dos programas de usuário, uma
vez que o device driver é carregado, ele passa a funcionar junto com o kernel e em “kernel mode”
(quase como uma parte dele); da mesma forma que o kernel, os device drivers têm acesso irrestrito
ao hardware do computador (Nigri, 2018).
Nem todo device driver serve para controlar um dispositivo. Alguns servem para implantar
funções intermediárias (como se comunicar com o barramento USB em que os dispositivos são
conectados), enquanto outros servem para implementar funções não obrigatórias do kernel (como o
protocolo IPV6, que nem sempre é suportado pela rede local).
Outra característica importante dos device drivers, segundo Nigri (2018), é o fato de que eles
normalmente não são programados pelas mesmas pessoas que implementam o kernel. Na maioria
das vezes, os times nem são da mesma empresa. Isso possibilita que um fabricante de dispositivo
https://univirtus.uninter.com/ava/web/roa/

12/22

05/05/2022 22:54

UNINTER

seja capaz de programar sozinho o device driver, de modo a fornecer, aos compradores do seu
dispositivo, suporte em vários sistemas operacionais diferentes.
Em termos gerais, quando compramos uma placa de rede, e na caixa está escrito “funciona em
Windows e em MAC OSX”, o fabricante está dizendo que estão disponíveis device drivers para tais
sistemas. Afinal, com o driver correto, qualquer sistema operacional pode utilizar os dispositivos
(Nigri, 2018).
Em sistemas operacionais atuais, há também o gerenciamento de credenciais de usuário, tema
que será apresentado, definido e explicado em aula específica. No entanto, as imagens a seguir
ilustram as atribuições de políticas locais do Windows 10, indicando que apenas usuários
administradores (o usuário padrão do Windows 10 é administrador) tem a permissão de carregar ou
descarregar os drivers de dispositivo. A Figura 8 apresenta uma explicação detalhada da função
carregar e descarregar drivers de dispositivo.
Assim, conhecendo os recursos do sistema operacional, o usuário avançado pode estabelecer
políticas e normas para melhor desempenho, permitindo ou negando a determinados usuários ou
grupos de usuários acesso às funções das ferramentas.

Figura 8 – Editor de política de Grupo Local do Windows 10

Fonte: Andre Roberto Guerra.

Figura 9 – Explicação sobre carga de drivers do Windows 10

https://univirtus.uninter.com/ava/web/roa/

13/22

05/05/2022 22:54

UNINTER

Fonte: Andre Roberto Guerra.

Segundo Melo Neto (2014), o device driver, ou apenas driver, tem como função implementar a
comunicação do subsistema de E/S com os dispositivos, através de controladores. Enquanto o
subsistema de E/S trata de funções ligadas a todos os dispositivos, os drivers tratam apenas dos
seus aspectos particulares.
Os drivers têm como função receber comandos gerais sobre acessos aos dispositivos e traduzilos em comandos específicos para aquele dispositivo em questão. Cada driver manipula somente
um tipo de dispositivo ou grupos de dispositivos semelhantes.
O driver está integrado diretamente às funções do controlador. Trata-se do componente do
sistema que reconhece as características particulares do funcionamento de cada dispositivo de E/S,
como número de registradores do controlador, funcionamento e comandos específicos. Os
controladores serão explicados e definidos no próximo tema. Sua função principal é receber os
comandos abstratos do subsistema de E/S e traduzi-los para comandos que o controlador possa
entender e executar (Melo Neto, 2014).
Além disso, o driver pode realizar outras funções, como a inicialização do dispositivo e seu
gerenciamento. Os drivers fazem parte do núcleo do sistema operacional, sendo escritos geralmente
em assembly. Como os drivers são códigos reentrantes que executam em modo kernel, qualquer
erro de programação pode comprometer o funcionamento do sistema. Por isso, um driver deve ser
cuidadosamente desenvolvido e testado (Melo Neto, 2014)

https://univirtus.uninter.com/ava/web/roa/

14/22

05/05/2022 22:54

UNINTER

Devido ao alto grau de dependência entre os drivers e o restante do kernel do sistema, os
fabricantes desenvolvem, para um mesmo dispositivo, diferentes drivers, um para cada arquitetura
de processador (32 ou 64bits), um para cada sistema operacional, inclusive para versões diferentes.
Sempre que um novo dispositivo é instalado, o driver do dispositivo deve ser adicionado ao kernel
do sistema (Melo Neto, 2014).
Nos sistemas mais antigos, a inclusão de um novo driver significava a recompilação do kernel,
uma operação complexa que exigia a reinicialização do sistema. Atualmente, os sistemas
operacionais permitem a fácil instalação de novos drivers; os drivers são carregados dinamicamente,
sem a necessidade de reinicialização. Alguns sistemas permitem até mesmo a instalação física de
dispositivos com o computador ligado (hot swap ou hot plug) (Melo Neto, 2014).
Além dessas definições, Maziero (2019) complementa que um driver de dispositivo, ou
simplesmente driver, é o componente do sistema operacional responsável por interagir com um
controlador de dispositivo. Cada tipo de dispositivo tem seu próprio driver, muitas vezes fornecido
pelo fabricante.
Cada driver é geralmente capaz de tratar um único tipo de dispositivo, ou uma família de
dispositivos correlatos do mesmo fabricante. Internamente, um driver consiste em um conjunto de
funções, que são ativadas pelo núcleo do sistema operacional, conforme necessário (Maziero,
2019).
Existem três grupos de funções implementadas por um driver, ilustradas na figura a seguir.

Figura 10 – Funções do driver

Fonte: Maziero, 2019.

https://univirtus.uninter.com/ava/web/roa/

15/22

05/05/2022 22:54

UNINTER

Segundo Maziero (2019), as funções de entrada/saída de dados (data I/O functions) são
responsáveis pela transferência de dados entre o dispositivo e o sistema operacional; essas funções
recebem e enviam dados de acordo com a classe dos dispositivos: caracteres (bytes), blocos de
tamanho fixo (discos), blocos de tamanho variável (pacotes de rede) ou áreas de memória
compartilhadas entre o dispositivo e a CPU (imagens/vídeo e outros).
As funções de gerência (mgmt [management] functions) são responsáveis pela gestão do
dispositivo e do próprio driver. Além de funções para coordenar a inicialização e finalização do driver
e do dispositivo, geralmente são fornecidas funções para configurar o dispositivo, para desligar ou
colocar em espera o dispositivo quando não está em uso, e para tratar erros no dispositivo. Algumas
dessas funções podem ser disponibilizadas aos processos no espaço de usuário, através de
chamadas de sistema específicas.
As funções de tratamento de eventos (event handling) são ativadas quando uma requisição de
interrupção é gerada pelo dispositivo.
Toda requisição de interrupção gerada pelo dispositivo é encaminhada ao controlador de
interrupções do hardware, que a entrega ao núcleo do sistema operacional. No núcleo, um tratador
de interrupções (IRq handler) reconhece e identifica a interrupção junto ao controlador, e em seguida
envia uma notificação de evento a uma função do driver, para o devido tratamento (Maziero, 2019).
Além das funções descritas, um driver mantém estruturas de dados locais, para armazenar
informações sobre o dispositivo e sobre as operações em andamento. Os drivers normalmente
executam dentro do núcleo do sistema operacional, em modo privilegiado.
Por se configurarem como código de terceiros executando com acesso total ao hardware,
constituem um dos maiores riscos à estabilidade e à segurança do sistema operacional. Drivers mal
construídos ou mal configurados são fontes frequentes de problemas como travamentos ou
reinicializações inesperadas (Maziero, 2019).

TEMA 4 – CONTROLADORES DE DISPOSITIVOS
Controladores de dispositivos também são conhecidos como interfaces, por servirem como
meio de comunicação entre o Sistema Operacional e os devices (dispositivos). São componentes
eletrônicos (hardware) responsáveis por manipular diretamente os dispositivos de Entrada/Saída.
https://univirtus.uninter.com/ava/web/roa/

16/22

05/05/2022 22:54

UNINTER

Em geral, apresentam memória e registradores próprios para executar instruções enviadas pelo
device driver (Zambiasi, 2011).
O device driver comunica-se com os dispositivos indiretamente, através do controlador, de
modo que há um controlador para cada tipo de dispositivo físico de entrada/saída (disco,
impressora, fita etc.). Em geral, o controlador pode ser uma placa independente acoplada a CPU por
um slot, ou pode ser implementado diretamente na placa do processador (Siqueira, 2020).
Os controladores são descritos por Melo Neto (2014) como componentes de hardware
responsáveis por manipular diretamente os dispositivos de E/S. O sistema operacional, mais
exatamente o driver, comunica-se com os dispositivos através dos controladores, por uma placa
independente ou implementada diretamente na placa-mãe. A figura a seguir ilustra a interconexão.

Figura 11 – Interconexão entre controladores

Fonte: Baggio, 2018. Crédito: Bioraven/Shutterstock.

O controlador tem memória e registradores próprios, utilizados na execução de instruções
enviadas pelo driver. Essas instruções, de baixo nível, são responsáveis pela comunicação entre o
controlador e o dispositivo de E/S. (Melo Neto, 2014)
Inicialmente, o device driver executa as operações de Entrada/Saída gravando os comandos
nos registradores do controlador. O controlador executa a operação com o dispositivo enquanto a
UCP pode realizar outras tarefas. Em seguida, o device driver testa os resultados através dos
registradores do controlador. (Zambiasi, 2011)

https://univirtus.uninter.com/ava/web/roa/

17/22

05/05/2022 22:54

UNINTER

Em operações de leitura, o controlador deve armazenar em seu buffer interno uma sequência
de bits provenientes do dispositivo, até formar um bloco.
Após verificar a ocorrência de erros, o bloco pode ser transferido para um buffer de E/S na
memória principal. A transferência do bloco do buffer interno do controlador para o buffer de E/S na
memória principal pode ser realizada pelo processador ou por um controlador de DMA (Melo Neto,
2014). A técnica de DMA será apresentada no próximo tema.
Alguns controladores, particularmente os de discos, implementam técnicas de cache
semelhante às implementadas pelos sistemas de arquivos, na tentativa de melhorar o desempenho
das operações de E/S.
Normalmente, o controlador avisa ao sistema operacional do término de uma operação de
gravação, quando os dados no buffer do controlador são gravados no disco (write-through caching).
O controlador também pode ser configurado para avisar do término da gravação, mesmo
quando os dados ainda se encontram no buffer do controlador e a operação de gravação no disco
não foi realizada (write-back caching). Dessa forma é possível obter ganhos consideráveis de
desempenho (Melo Neto, 2014).

TEMA 5 – TÉCNICAS AVANÇADAS DE E/S
DMA (Direct Memory Access), ou acesso direto à memória, é uma funcionalidade implementada
nos processadores e sistemas computacionais em geral, com o objetivo de melhorar o desempenho
e aumentar a velocidade do processamento de dados (Robolivre, 2020).
Em uma definição simples, o processo consiste em ler ou gravar dados diretamente em um
periférico, sem a necessidade de ocupar o processador com essa tarefa. É muito útil, principalmente
em sistemas com pouco poder de processamento, e por isso se popularizou rapidamente com a
chegada dos computadores pessoais.
Um exemplo prático e muito claro da utilidade do DMA é o monitor. A quantidade de dados
processados para mostrar uma imagem na tela em tempo real é muito grande. Se apenas o
processador do PC trabalhasse para realizar essa tarefa, provavelmente, ao colocarmos um vídeo
para rodar, não conseguiríamos fazer mais nada. Porém, como podemos perceber, não é bem isso o
https://univirtus.uninter.com/ava/web/roa/

18/22

05/05/2022 22:54

UNINTER

que acontece. Por quê? O uso da técnica de DMA evita que o processador fique ocupado com a
transferência do bloco para a memória. O controlador de DMA é um dispositivo de hardware que
pode fazer parte do computador ou pode ser um dispositivo independente (Robolivre, 2020).
Em operações de leitura, o controlador armazena uma sequência de bits do dispositivo no seu
buffer interno e verifica a ocorrência de erros. Caso inexistam erros, o bloco é transmitido para a
memória principal (RAM).
Na maioria dos dispositivos orientados a bloco, como os dispositivos de armazenamento de
longo prazo (discos), é implementada a técnica de DMA para transferência de dados entre o
controlador e a memória principal (Zambiasi, 2011), como ilustra a figura a seguir.

Figura 12 – Técnica de DMA

Fonte: Elaborado com base em Robolivre, 2020.

Há ainda um componente adicional, o Controlador de DMA (DMAC – DMA Controller). O DMAC
trabalha paralelo à CPU. Ele é o responsável por controlar todo o processo de gravação ou leitura
de dados com uma interferência mínima da CPU. Resumidamente, o DMAC deve ser previamente
definido com alguns dados para o correto funcionamento: endereço da fonte; posição inicial da
memória; quantidade de bytes.
Com esses dados, o DMAC envia um pedido de interrupção à CPU, que cede ao DMAC o
controle do fluxo de dados do periférico a ser utilizado, por exemplo um leitor de DVD. Assim, esse
tráfego passa a ser controlado diretamente pelo DMAC; quando termina a tarefa (de gravação ou
https://univirtus.uninter.com/ava/web/roa/

19/22

05/05/2022 22:54

UNINTER

leitura), este envia um novo pedido de interrupção à CPU, para informar que ela já pode retomar o
controle do fluxo de dados que havia cedido anteriormente.
Dessa forma, a CPU economiza em tempo de processamento, acelerando as tarefas realizadas
por esses processos (Robolivre, 2020).
Em microcontroladores, esse é um recurso muito importante. Tendo em vista que a sua
capacidade de processamento normalmente é bastante limitada, se comparada a um PC, o DMA
torna os microcontroladores muito mais robustos e funcionais. No entanto, não são todos os
microcontroladores que apresentam essa capacidade; normalmente, apenas os mais novos ou os
criados com alguns fins específicos (como os tocadores de MP3). Para ter certeza, é necessário
verificar o datasheet (Robolivre, 2020).
Outra técnica avançada é o SCSI (Small Computer Systems Interface), Interface de Pequenos
Sistemas de Computação. Este pe um padrão popular para a conexão de dispositivos ao
computador, inicialmente utilizado em RISC. Define padrões de hardware e software que permitem
conectar ao computador qualquer tipo de dispositivo, mesmo de fabricantes diferentes. O Sistema
Operacional deve estar configurado com um driver SCSI e o hardware com um controlador SCSI, no
qual os periféricos são conectados (Zambiasi, 2011).

FINALIZANDO
Nesta aula, apresentamos conteúdos sobre a gestão de dispositivos de entrada e saída,
completando as definições das tarefas de gerenciamento dos principais componentes do hardware
(CPU, memórias e dispositivos de E/S) pelos sistemas operacionais,com destaque para conceitos e
definições.
Já no segundo tema, apresentamos o gerenciador de dispositivos, utilizando figuras de
exemplos em sistemas operacionais populares e atuais, que proporcionam a visualização das
funcionalidades dessa importante ferramenta.
No terceiro tema, estudamos os device drivers, essenciais para a comunicação entre o SO e os
dispositivos, contribuindo para que qualquer novo device ou periférico conectado funcione, de forma
transparente para o usuário. O conhecimento das rotinas descritas é muito importante, pois drivers
mal escritos podem gerar sérios prejuízos, culminando na insatisfação dos utilizadores.
https://univirtus.uninter.com/ava/web/roa/

20/22

05/05/2022 22:54

UNINTER

No quarto tema, definimos os controladores de dispositivos, mais uma vez com figuras
ilustrando seu funcionamento, facilitando assim a compreensão desse conjunto de componentes,
que aumenta a eficiência e a gestão das E/S. Finalizando a aula, no último tema trabalhamos com
técnicas avançadas de E/S (DMA). O acesso direto à memória é uma funcionalidade implementada
em CPUs e sistemas computacionais em geral, com o objetivo de melhorar o desempenho e
aumentar a velocidade do processamento de dados. Em uma definição simples, consiste em
ler/gravar dados diretamente em um periférico, sem ocupar a CPU, sendo muito útil em sistemas
com pouco poder de processamento, popular entre os PCs. Evita que a CPU se ocupe com a
transferência do bloco para a memória. O controlador de DMA é um dispositivo de hardware que
pode fazer parte do computador ou pode ser um dispositivo independente (Robolivre, 2020).
A compreensão desses conceitos completa o entendimento das atividades de gestão dos
principais componentes do hardware do computador (CPU, memórias e dispositivos de E/S)
desenvolvidos pelos sistemas computacionais. Nas aulas seguintes, vamos ampliar esse
conhecimento, com os conceitos de atividades de gerência e proteção de arquivos e usuários. Não
perca!

REFERÊNCIAS
BAGGIO, M. Sistemas Operacionais. IFSul, 2018. Disponível em: <https://sites.google.com/
site/ifsulmiguel/>. Acesso em: 20 out. 2020.
COUTINHO, B. C. Sistemas Operacionais. Colatina: CEAD / IFES, 2010.
DEITEL; P. J.; DEITEL, H. Java How to Program, Early Objects. London: Pearson, 2017.
GUARDIA, H. C.; SENGER, H. Gerenciamento de Entrada e Saída. São Carlos: UFSCar,
2015.
MACHADO, F. B.; MAIA, P. L. Arquitetura de Sistemas Operacionais. 4. ed. Curitiba: LTC,
2007.
MAZIERO, C. Sistemas Operacionais: Conceitos e Mecanismos. Curitiba: Editora UFPR,
2019.

https://univirtus.uninter.com/ava/web/roa/

21/22

05/05/2022 22:54

UNINTER

MELO NETO, A. Gerência de Dispositivos. USP, São Paulo, 2014. Disponível em:
<https://www.ime.usp.br/~adao/AGD.pdf>. Acesso em: 20 out. 2020.
NIGRI,

A.

Sistemas

Operacionais

–

Parte

1.

Winco,

2018.

Disponível

em:

<https://blog.winco.com.br/sistemas-operacionais-parte-1/>. Acesso em: 20 out. 2020.
OLIVEIRA, R. S.; CARISSIMI, A. S.; TOSCANI, S. S. Sistemas Operacionais. 7. ed. Porto
Alegre: Bookman, 2010.
ROBOLIVRE – Plataforma Robótica Livre. DMA: Acesso Direto à Memória. Disponível em:
<http://www.roboliv.re/conteudo/dma-acesso-direto-a-memoria>. Acesso em: 20 out. 2020.
SILBERSCHATZ, A.; GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro: Campus, 2016.
SIQUEIRA,

F.

Sistemas

Operacionais.

Disponível

em:

<https://sites.google.com/site/

proffernandosiqueiraso/>. Acesso em: 20 out. 2020.
SOUSA FILHO G. F.; ALEXANDRE, E. S. M. Introdução à computação. João Pessoa: Editora
da

UFPB,

2013.

Disponível

em:

<http://producao.virtual.ufpb.br/books/camyle/introducao-a-

computacao-livro/livro/livro.pdf>. Acesso em: 20 out. 2020.
ZAMBIASI, S. P. Sistemas Operacionais: Gerência de Dispositivos. Florianópolis: UFSC, 2011.
Disponível em: <https://www.gsigma.ufsc.br/~popov/aulas/so1/>. Acesso em: 20 out. 2020.

https://univirtus.uninter.com/ava/web/roa/

22/22



05/05/2022 22:55

UNINTER

SISTEMAS OPERACIONAIS
AULA 5

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/29

05/05/2022 22:55

UNINTER

CONVERSA INICIAL
Os sistemas computacionais (os computadores) possuem como principais componentes do
hardware a CPU, as memórias os dispositivos de E/S, que são gerenciados pelo software de
sistema, o sistema operacional, todos descritos e apresentados anteriormente e agora, nesta aula,
serão complementados pela gestão de arquivos, considerada como a principal ferramenta de
interação entre o usuário e o sistema de computação.
A parte mais visível de um sistema operacional é o seu sistema de arquivos. Programas
aplicativos utilizam o sistema de arquivos (via chamadas de sistema) para criar, ler, gravar e remover
arquivos. Usuários utilizam interativamente o sistema de arquivos (via shell) para listar, alterar
propriedades e remover arquivos. A conveniência e a facilidade de uso de um sistema operacional
são fortemente determinadas pela interface, estrutura e contabilidade de seu sistema de arquivos
(Unicamp, S.d.)
Desde os primórdios da computação, percebeu-se a necessidade de armazenar informações
para uso posterior, como programas e dados.

Figura 1 – Arquivos e pastas digitais

https://univirtus.uninter.com/ava/web/roa/

2/29

05/05/2022 22:55

UNINTER

Créditos: Andrea Danti/Shutterstock.

Hoje, parte importante do uso de um computador consiste em recuperar e apresentar
informações previamente armazenadas, como documentos, fotografias, músicas e vídeos. O próprio
SO também precisa manter informações armazenadas para uso posterior, como programas,
bibliotecas e configurações.

Figura 2 – Visualização de arquivos digitais

Créditos: Nata-Lia/Shutterstock.

https://univirtus.uninter.com/ava/web/roa/

3/29

05/05/2022 22:55

UNINTER

Para simplificar o armazenamento e a busca dessas informações, surgiu o conceito de arquivo.
Portanto, os sistemas operacionais são responsáveis (também) pelo controle e gestão segura e
controle do armazenamento e uso de arquivos.
Nesta aula, apresentaremos nos próximos capítulos os principais conceitos relacionados a
arquivos, seu uso e a forma como são implementados e gerenciados pelo sistema operacional, nos
cinco seguintes temas:
Conceitos e definições de arquivos;
Acesso (utilização);
Estrutura de diretórios, subdiretórios e atalhos;
Armazenamento de dados (arquivos) a longo prazo;
O sistema de arquivos e seus tipos.

TEMA 1 – CONCEITOS E DEFINIÇÕES DE ARQUIVOS
Os arquivos de um sistema de computação (ou simplesmente computador) são formados por
informações logicamente relacionadas, podendo representar programas (instruções) ou dados.
Também definidos como um conjunto de registros definidos pelo sistema de arquivos que será
apresentado no tema 5 desta aula.
Para Tannenbaum (2016), os arquivos podem ser entendidos como uma sequência de bytes
não interpretadas pelo sistema, dependendo-se de aplicações apropriadas para sua correta
utilização, sendo um poderoso mecanismo de abstração que permite ao usuário e seus programas
utilizarem dados armazenados dentro do sistema computacional.
É por meio da manipulação dos arquivos que são realizadas as operações de escrita e a leitura
de dados de forma transparente, evitando que sejam conhecidos detalhes do funcionamento, com
que essas operações tratam e armazenam a informação.
Em sua forma mais simples, segundo Maziero (2019), um arquivo contém basicamente uma
sequência de bytes, que pode ser estruturada de forma a representar diferentes tipos de informação,
como imagens, música, textos ou código executável. Essa estrutura interna do arquivo pode ser
entendida pelo kernel (núcleo do sistema operacional) ou somente pelas aplicações que acessam
esse conteúdo.
https://univirtus.uninter.com/ava/web/roa/

4/29

05/05/2022 22:55

UNINTER

O kernel geralmente reconhece apenas alguns poucos formatos de arquivos, como binários
executáveis e bibliotecas. Os demais formatos de arquivos são vistos pelo núcleo apenas como
sequências de bytes opacas, sem um significado específico, cabendo às aplicações interessadas
interpretá-las.
Uma aplicação pode definir um formato próprio para armazenar seus dados, ou pode seguir
formatos padronizados. Por exemplo, há um grande número de formatos padronizados para o
armazenamento de imagens, como JPEG, GIF, PNG e TIFF, mas também existem formatos de
arquivos proprietários, definidos por algumas aplicações específicas, como os formatos PSD e XCF
(dos editores gráficos Adobe Photoshop e GIMP, respectivamente).
Mas a adoção de um formato proprietário ou exclusivo limita o uso das informações
armazenadas, pois somente aplicações que reconheçam aquele formato específico conseguem ler
corretamente as informações do arquivo.

Figura 3 – Identificação de arquivos digitais

Créditos: Tele52/Shutterstock.

A organização dos arquivos, segundo (Cunha, 2017), consiste no modo como os dados estão
internamente armazenados, podendo ter uma estrutura de acordo com a função do tipo de
informação contida no arquivo.

https://univirtus.uninter.com/ava/web/roa/

5/29

05/05/2022 22:55

UNINTER

Maziero (2019) apresenta o arquivo como uma unidade de armazenamento de informações, e
que além de seu conteúdo, um arquivo é caracterizado por atributos ou metadados, que são
informações adicionais relativas ao conteúdo, e operações ou ações que podem ser realizadas
sobre o conteúdo e/ou sobre os atributos dos arquivos, que variam de acordo com o sistema de
arquivos utilizado.
Os atributos mais usuais presentes na maioria dos sistemas, segundo Deitel (2017) e
Tannenbaum (2016), são os seguintes:
Nome: uma string que identifica o arquivo para o usuário;
Tipo: indicação do formato dos dados contidos no arquivo, como áudio, vídeo, imagem, texto
etc. Muitos sistemas operacionais usam parte do nome do arquivo para identificar o tipo de seu
conteúdo, na forma de uma extensão;
Tamanho: indicação do tamanho (em bytes) do conteúdo do arquivo;
Datas: para fins de gerência, é importante manter as datas mais importantes relacionadas ao
arquivo, como suas datas de criação, de último acesso e de última modificação do conteúdo;
Proprietário: em sistemas multiusuários, cada arquivo tem um proprietário, que deve estar
corretamente identificado;
Permissões de acesso: indicam que usuários têm acesso àquele arquivo e que formas de
acesso são permitidas (leitura, escrita, remoção etc.);
Localização: indicação do dispositivo físico onde o arquivo se encontra e da posição do
arquivo dentro deste.
Além desses, vários outros atributos podem ser associados a um arquivo, por exemplo para
indicar se ele é um arquivo de sistema, se está visível aos usuários, se tem conteúdo binário ou
textual etc.
Cada sistema de arquivos normalmente define seus próprios atributos específicos, além dos
atributos usuais acima. Mas nem sempre os atributos oferecidos por um sistema de arquivos são
suficientes para exprimir todas as informações a respeito de um arquivo. Nesse caso, a solução
encontrada pelos usuários é usar o nome do arquivo para registrar a informação desejada.
Portanto, muitos sistemas operacionais utilizam a extensão (atributo de tipo) da segunda parte
do nome do arquivo, como uma referência para o tipo de seu conteúdo. Particularmente, no SO

https://univirtus.uninter.com/ava/web/roa/

6/29

05/05/2022 22:55

UNINTER

Windows, podem ser associadas aplicações a determinadas extensões, auxiliando o usuário, por
exemplo:
Programa.exe (arquivo executável – instrução);
Texto.txt (arquivo texto – dados);
Classe.Java (arquivo texto, código fonte de um aplicativo escrito em Java);
Audiofile.mp3 (arquivo de áudio – formato MP3).
Para (Maziero, 2019), a forma mais básica de organização é por meio de uma sequência não
estruturada de bytes, cuja organização e interpretação é de inteira responsabilidade da aplicação
que irá utilizá-los.
Um arquivo é essencialmente uma sequência de bytes armazenada em um dispositivo físico
não volátil, como um disco rígido ou de estado sólido, que preserva seu conteúdo mesmo quando
desligado. Cada arquivo possui um nome ou outra referência, que permita sua localização e acesso.
Do ponto de vista do usuário e das aplicações, o arquivo é a unidade básica de armazenamento
de informação em um dispositivo não volátil, pois para eles não há forma mais simples de
armazenamento persistente de dados.
Arquivos são extremamente versáteis em conteúdo e capacidade, podendo conter desde um
texto com alguns poucos caracteres até vídeos com dezenas de gigabytes, ou ainda mais (Maziero,
2019).
Cunha, Preuss e Macedo (2017) citam que, genericamente, arquivos comuns utilizados pelos
usuários para o armazenamento de informações podem ser considerados como do tipo texto,
quando seu conteúdo pode ser visualizado diretamente, ou do tipo binário, quando seu conteúdo
precisa ser interpretado por uma aplicação para poder ser visualizado.
Os arquivos executáveis também são arquivos binários, cuja execução é realizada diretamente
pelo SO.
Alguns sistemas operacionais estabelecem diferentes organizações de arquivos e cada arquivo
deve seguir a um modelo suportado. As organizações mais conhecidas e implementadas são a
sequencial, relativa e indexada.

https://univirtus.uninter.com/ava/web/roa/

7/29

05/05/2022 22:55

UNINTER

Como um dispositivo de armazenamento pode conter milhões de arquivos, esses arquivos são
então organizados em estruturas hierárquicas denominadas diretórios para facilitar sua localização e
acesso pelos usuários.
Portanto, se o sistema de arquivos é a parte mais visível de um sistema operacional, é muito
importante como os engenheiros e desenvolvedores de sistemas operacionais tratam de sua
imagem, afinal cada utilizador tem sua preferência e os SO diferem entre si, como ilustram as
imagens. Confiram:

Figura 4 – Prompt de comando de listagem de arquivos Linux

Figura 5 – Prompt de comando de listagem de arquivos Windows

https://univirtus.uninter.com/ava/web/roa/

8/29

05/05/2022 22:55

UNINTER

Figura 6 – Gerenciador de arquivos Linux

Figura 7 – Gerenciador de arquivos Windows

https://univirtus.uninter.com/ava/web/roa/

9/29

05/05/2022 22:55

UNINTER

TEMA 2 – ACESSO (UTILIZAÇÃO)
Deitel (2017) define que um sistema de arquivos deve permitir que os usuários possam criar,
modificar e eliminar arquivos, bem como realizar sua duplicação ou a transferência de dados entre
arquivos. Além disso, deve possibilitar o compartilhamento de arquivos por meio de mecanismos
controlados e bem definidos. Também é desejável que as operações de cópia de segurança dos
arquivos (backup) e sua restauração sejam suportadas e que seja possível a adoção ou
implementação de procedimentos de proteção e segurança, com uma interface amigável e
consistente, admitindo a realização de operações apenas por meio dos nomes simbólicos dos
arquivos, garantindo independência do dispositivo utilizado.
O sistema operacional, por meio de seu sistema de arquivos, deve prover um conjunto de
operações para manipulação dos arquivos e de seu conteúdo e também dos diretórios.
Para Maziero (2019), uma vez o arquivo aberto, a aplicação pode ler os dados contidos nele,
modificá-los ou escrever novos dados. Há várias formas de se lerem ou se escreverem dados em
um arquivo, que dependem da estrutura interna deste. Considerando apenas arquivos simples,
vistos como uma sequência de bytes, duas formas de acesso são usuais: o acesso sequencial e o
acesso aleatório.

https://univirtus.uninter.com/ava/web/roa/

10/29

05/05/2022 22:55

UNINTER

2.1 ACESSO SEQUENCIAL
No acesso sequencial, os dados são sempre lidos e/ou escritos em sequência, do início ao final
do arquivo. Para cada arquivo aberto por uma aplicação é definido um ponteiro de acesso, que
inicialmente aponta para a primeira posição do arquivo. A cada leitura ou escrita, esse ponteiro é
incrementado e passa a indicar a posição da próxima leitura ou escrita. Quando esse ponteiro atinge
o final do arquivo, as leituras não são mais permitidas, mas as escritas podem sê-lo, permitindo
acrescentar dados ao final dele. A chegada do ponteiro ao final do arquivo é normalmente sinalizada
ao processo por meio de um flag de fim de arquivo (EoF – End-of-File).

2.2 ACESSO ALEATÓRIO
No método de acesso aleatório (ou direto), pode-se indicar a posição no arquivo onde cada
leitura ou escrita deve ocorrer, sem a necessidade de um ponteiro de posição corrente. Assim, caso
se conheça previamente a posição de um determinado dado no arquivo, não há necessidade de
percorrê-lo sequencialmente até encontrar o dado desejado. Essa forma de acesso é muito
importante em gerenciadores de bancos de dados e aplicações congêneres, que precisam acessar
rapidamente as posições do arquivo correspondentes.
Na prática, a maioria dos sistemas operacionais usa o acesso sequencial como modo básico de
operação, mas oferece operações para mudar a posição do ponteiro de acesso do arquivo caso
necessário, o que permite então o acesso direto a qualquer registro do arquivo (Maziero, 2019).
O acesso mapeado em memória é uma forma particular de acesso aleatório ao conteúdo de um
arquivo. O mapeamento em memória faz uso dos mecanismos de paginação em disco. Nessa
modalidade de acesso, o arquivo é associado a um vetor de bytes (ou de registros) de mesmo
tamanho na memória principal, de forma que cada posição do vetor corresponda à sua posição
equivalente no arquivo.
Quando uma posição específica do vetor na memória é lida pela primeira vez, é gerada uma
falta de página. Nesse momento, o mecanismo de memória virtual intercepta o acesso à memória, lê
o conteúdo correspondente no arquivo e o deposita no vetor, de forma transparente à aplicação, que
em seguida pode acessá-lo. Escritas no vetor são transferidas para o arquivo por um procedimento
similar. Caso o arquivo seja muito grande, podem-se mapear em memória apenas partes dele.

https://univirtus.uninter.com/ava/web/roa/

11/29

05/05/2022 22:55

UNINTER

O acesso mapeado em memória é extensivamente usado pelo núcleo para carregar código
executável (programas e bibliotecas) na memória. Como somente as partes efetivamente acessadas
do código serão carregadas em RAM, esse procedimento é usualmente conhecido como paginação
sob demanda (demand paging), pois os dados são lidos do arquivo para a memória em páginas.
Alguns sistemas operacionais oferecem também a possibilidade de acesso indexado aos dados
de um arquivo, que implementa arquivos cuja estrutura interna pode ser vista como uma tabela de
pares chave/valor. Os dados do arquivo são armazenados em registros com chaves (índices)
associados a eles e podem ser recuperados, usando essas chaves como em um banco de dados
relacional.
Como o próprio núcleo desse sistema implementa os mecanismos de acesso e indexação do
arquivo, o armazenamento e a busca de dados nesse tipo de arquivo costumam ser muito rápidos,
dispensando bancos de dados para a construção de aplicações mais simples. A maioria dos
sistemas operacionais de mercado não implementa essa funcionalidade diretamente no núcleo
(Maziero, 2019)
As aplicações e o sistema operacional usam arquivos para armazenar e recuperar dados. O
acesso aos arquivos é feito por meio de um conjunto de operações, geralmente implementadas sob
a forma de chamadas de sistema e funções de bibliotecas.
Para os arquivos, vistos como unidades, devem ser oferecidas operações essenciais, citadas
por Deitel, Deitel e Choffnes (2017) e por Tannenbaum (2016):
Criação (create): cria um novo arquivo. a criação de um novo arquivo implica em alocar espaço
para ele no dispositivo de armazenamento e definir valores para seus atributos;
Exibição (type ou list): exibe o conteúdo de um arquivo;
Catalogação (cat ou dir): lista os arquivos existentes em um determinado diretório ou unidade;
Abertura (open): prepara (abre) o arquivo para uso. Antes que uma aplicação possa ler ou
escrever dados em um arquivo, ela deve solicitar ao sistema operacional a abertura desse
arquivo. O sistema irá então verificar se o arquivo desejado existe, verificar se as permissões
associadas ao arquivo permitem aquele acesso, localizar seu conteúdo no dispositivo de
armazenamento e criar uma referência para ele na memória da aplicação;
Cópia (copy): copia o conteúdo de um arquivo para outro;
Renomeação (rename): troca o nome do arquivo;
https://univirtus.uninter.com/ava/web/roa/

12/29

05/05/2022 22:55

UNINTER

Modificação de atributos (get ou set): obtém ou modifica os atributos de um arquivo;
Fechamento (close): encerra o uso do arquivo evitando sua alteração. Ao concluir o uso do
arquivo, a aplicação deve informar ao sistema operacional que este não é mais necessário, a
fim de liberar as estruturas de gerência do arquivo mantidas na memória do núcleo;
Eliminação (erase, delete ou destroy): remove (elimina) o arquivo do dispositivo, descartando
seus dados e liberando o espaço ocupado por ele.
Em relação ao conteúdo e à manipulação dos dados armazenados nos arquivos, devem
também existir operações para:
Pesquisa (seek ou find) para determinar uma posição para escrita ou leitura em um arquivo;
Leitura (read): possibilita a leitura de dados contidos nos arquivos;
Escrita (write): efetua a gravação de dados em um arquivo;
Inserção (insert): inclusão de um dado em um arquivo;
Anexação (append): adição de novos dados em um arquivo existente;
Atualização (update): modificação de um dado existente em um arquivo;
Eliminação (delete): remoção de um dado existente em um arquivo.
Como muitos sistemas de arquivos suportam diretórios, operações específicas devem ser
providas para sua utilização (Tannenbaum, 2016):
Criação (create): efetua a criação e preparo de um novo diretório;
Navegação (traverse): permite a navegação entre diretórios do sistema;
Pesquisa (search): possibilita a localização de arquivos em um diretório;
Leitura (read) que permite a leitura do conteúdo de um diretório, ou seja, sua catalogação ou
listagem;
Abertura (open): operação que permite a leitura de um diretório;
Renomeação (rename): troca o nome de um diretório;
Fechamento (close): operação que encerra o uso de um dado diretório;
Remoção (delete ou remove): elimina um diretório e opcionalmente seu conteúdo.
Ainda podem ser possíveis outras operações sobre arquivos e diretórios, como inclusão ou
remoção de ligações (links e atalhos), obtenção de informações sobre arquivos ou diretórios,
associação com aplicativos, dentre outras.

https://univirtus.uninter.com/ava/web/roa/

13/29

05/05/2022 22:55

UNINTER

Todas as operações suportadas pelo SO para manipulação de arquivos e diretórios estão
disponíveis para utilização em programas por meio das chamadas do sistema (system calls).

TEMA 3 – ESTRUTURA DE DIRETÓRIOS, SUBDIRETÓRIOS E
ATALHOS
A estrutura de diretórios é um padrão de estruturas hierárquicas adotado pela maioria dos
sistemas operacionais, utilizado essencialmente para organizar os conteúdos, separando os
arquivos de sistema e de usuários, bem como permitir nova organização nas pastas ou diretórios
adjacentes.
As figuras do Tema 1 ilustram exemplos de estruturas de diretórios dos sistemas operacionais
Linux e Windows, reapresentados e complementados pelas figuras a seguir:

Figura 8 – Estrutura de diretórios

Créditos: Mmaxer/Shutterstock.

Figura 9 – Organização de pastas

Créditos: Kmis/Shutterstock.
https://univirtus.uninter.com/ava/web/roa/

14/29

05/05/2022 22:55

UNINTER

A Unicamp (S.d.) apresenta que convém também observar que é possível colocar os
subdiretórios do diretório raiz em partições separadas. O objetivo é facilitar a manutenção do
sistema e aumentar a segurança dos dados.
Portanto, a distribuição do diretório raiz em várias partições é uma escolha pessoal do
administrador do sistema.
Os sistemas operacionais atuais que aqui foram apresentados possuem inúmeras ferramentas
(softwares) que auxiliam na gestão dos arquivos, acessadas por meio do próprio gerenciador de
arquivos ou mesmo por meio de outras ferramentas avançadas.
Ao abrir um arquivo, o sistema operacional utiliza o nome do arquivo e o seu diretório ou
caminho (path) que são fornecidos pelo utilizador, para localizar os blocos do disco associados ao
arquivo. O mapeamento do nome nos inodes está associado com a forma como o sistema de
diretório encontra-se organizado.
A estrutura de diretório usada no UNIX é bastante simples. Cada entrada contém o nome do
arquivo e o número do seu inode, representados por 16 bytes, sendo, 2 bytes para o número do
inode e 14 bytes para o nome. Todos os diretórios do UNIX são arquivos e podem conter um número
arbitrário destas entradas de 16 bytes.
Quando um arquivo é aberto, o sistema deve, por meio do nome do arquivo, localizar os seus
blocos no disco, caso o nome do arquivo seja relativo, isto é, associado ao diretório corrente.
No sistema operacional Linux, é frequentemente sugerido que os seguintes diretórios possuam
uma partição própria: /root /tmp, /home, /opt, /usr e /usr/local, como ilustra a reapresentação da
Figura 6 do Tema 1, confiram:

Figura 10 – Gerenciador de arquivos Linux.

https://univirtus.uninter.com/ava/web/roa/

15/29

05/05/2022 22:55

UNINTER

Créditos: Kmis/Shutterstock.

TEMA 4 – ARMAZENAMENTO DE DADOS (ARQUIVOS) A LONGO
PRAZO
Os dispositivos de armazenamento secundário são memórias não voláteis, utilizados para
armazenar dados de forma permanente, ou seja, de forma confiável e íntegra, mesmo quando o
sistema computacional permanece desligado por longos períodos de tempo. Para que isso ocorra
(possa ser realizado de modo permanente), é necessária uma adequada organização desses dados
nos dispositivos destinados ao armazenamento secundário, por exemplo: unidades de disco (HDD,
SSD), flash drives (pendrives), unidades de fita magnética (DAT) (Cunha; Preuss; Macedo, 2017).
O sistema operacional controla as operações sobre os arquivos, organizando seu
armazenamento no sistema de arquivos (file system), que possui um método de acesso, que é a
forma como os dados são armazenados nos arquivos.
O sistema de arquivos é o responsável pelo gerenciamento de arquivos, um conjunto de
mecanismos de armazenamento, referência, compartilhamento e segurança. Também possui
mecanismos de integridade que asseguram que os dados de um arquivo permanecem íntegros
(Deitel, 2017).

https://univirtus.uninter.com/ava/web/roa/

16/29

05/05/2022 22:55

UNINTER

O gerenciamento de espaço em disco é uma importante tarefa para o armazenamento, pois
como apresentado, os arquivos são normalmente armazenados em dispositivos de memória
secundária (disco). Para o armazenamento há duas possíveis estratégias para armazenamento em
um arquivo com n bytes: n bytes consecutivos do disco são alocados; ou o arquivo é dividido em um
número de blocos não necessariamente contíguos. A mesma política está presente no sistema de
gerenciamento de memória entre a segmentação pura e a paginação.
Armazenar um arquivo como uma sequência contígua de bytes apresenta um problema óbvio
que é o crescimento do arquivo, uma ocorrência muito comum. O arquivo provavelmente terá que
ser movido no disco. O mesmo problema é apresentado para segmentação na memória, exceto que
mover um segmento na memória é uma operação relativamente mais rápida.
Por essa razão, normalmente todos os sistemas de arquivos armazenam os arquivos em blocos
de tamanho fixo, que não precisam ser adjacentes, salvo alguns sistemas operacionais,
notadamente os voltados à computação de tempo real, cujo armazenamento contínuo é adotado por
razões de desempenho.
Uma vez decidido armazenar arquivos em blocos de tamanho fixo, a questão é definir qual será
o tamanho do bloco a ser usado. Devido à forma como os discos são organizados, os setores, as
trilhas e os cilindros são candidatos óbvios para a unidade de alocação.
Uma unidade de alocação grande, tal como um cilindro, implica que muitos arquivos, até
mesmo arquivos de 1 byte, deverão ocupar o cilindro inteiro. Por outro lado, usar uma unidade de
alocação pequena, significa que cada arquivo terá muitos blocos. A leitura de cada bloco
normalmente requer uma busca e uma latência rotacional. Assim, a leitura de arquivos consistindo
de muitos blocos pequenos será lenta.
É compromisso usual escolher um bloco de tamanho 512, 1K ou 2K bytes. Se um bloco de
tamanho 1K for escolhido em um disco com setor de 512 bytes, então o sistema de arquivo sempre
irá ler ou escrever em dois setores consecutivos, e tratá-los como uma unidade indivisível.
Uma vez escolhido o tamanho do bloco, a próxima questão é como manter o rastreamento de
blocos livres no disco. Dois métodos são largamente usados e apresentados a seguir.
O primeiro, ilustrado na Figura 11, consiste no uso de uma lista ligada de blocos, com cada
elemento da lista armazenando tantos blocos livres quanto possível. Com elementos de 1K e o
https://univirtus.uninter.com/ava/web/roa/

17/29

05/05/2022 22:55

UNINTER

número do bloco de 16 bits, cada elemento na lista de blocos livre armazena 511 blocos livres. Um
disco com 20 gigabytes necessita de uma lista ocupando aproximadamente 40K blocos para apontar
para todos os 20G blocos do disco (ou seja, a lista ocupa 0,2% do disco).

Figura 11 – Blocos livres armazenados em lista ligada

Uma outra técnica de gerenciamento de espaço livre é o mapa de bits. Um disco com n blocos
necessita de um mapa de bits com n bits. Blocos livres são representados por 1s no mapa de bits;
blocos alocados por 0s (ou vice-versa). Um disco com 20 Gigabytes necessita de 20M bits para o
mapa, volume equivalente a 2500 blocos (ou seja, o mapa ocupa apenas 0,013% do disco).
Não é surpresa que um mapa de bit necessite de menos espaço, desde que usa um bit por
bloco, versus 16 bits da lista ligada. Entretanto, para um disco cheio (com poucos blocos livres) a
lista ligada necessita de menos espaço que o mapa de bits.
No armazenamento de arquivos, se um arquivo consistir de uma sequência de blocos, o
sistema de arquivos deve ter uma maneira de acessar todos os blocos do arquivo.
Como visto acima, um método possível consiste em armazenar os blocos de um arquivo em
uma lista ligada. Cada bloco de disco de 1024 ou 33 blocos para encontrar o dado. Ler 33 blocos
para buscar um dado, é inaceitável.
Entretanto, a ideia de representar um arquivo como uma lista encadeada, pode ser ainda
explorada se mantermos os ponteiros em memória. A Figura 12 mostra o esquema de alocação
https://univirtus.uninter.com/ava/web/roa/

18/29

05/05/2022 22:55

UNINTER

usado pelo MS-DOS.
Nesse exemplo, temos três arquivos, A com os blocos 6,8,4 e 2; B com os blocos 5, 9 e 12; e C
com os blocos 10, 3 e 13 bytes, contém 1022 bytes de dados e um ponteiro de 2 bytes para o
próximo elemento da lista.
Esse método tem duas desvantagens, entretanto. Primeiro, o número de bytes de dados em um
elemento da lista não é uma potência de 2, o que frequentemente é uma desvantagem para sua
manipulação.
Segundo, e mais sério, o acesso aleatório é de difícil implementação. Se um programa busca o
byte 32768 de um arquivo, o sistema operacional tem que percorrer 32768/1022.

Figura 12 – Mapa de bits

A forma de armazenamento consiste em dispor os dados em setores ou blocos consecutivos
nas unidades de disco, porém, como os arquivos são constantemente modificados e eliminados, a
alocação não consegue manter um arquivo de forma sequencial.
Esse fato provoca o que se chama de fragmentação, quando começam a surgir setores livres
entre os setores ocupados. Se o arquivo aumenta de tamanho, um novo setor, provavelmente bem
longe do último ocupado, será alocado para dar continuidade nos dados do arquivo, deixando o
arquivo fragmentado. Se o tamanho do arquivo for reduzido, um espaço no sistema de arquivos
ficará ocioso e gerará uma fragmentação do sistema de arquivos.
https://univirtus.uninter.com/ava/web/roa/

19/29

05/05/2022 22:55

UNINTER

Normalmente os SO oferecem algum tipo de utilitário que realiza a desfragmentação do sistema
de arquivos, movendo os arquivos de modos que todos os blocos de cada arquivo fiquem de modo
contíguo e que não haja espaço vazio entre eles.
Para definir um sistema de arquivos em um disco ou unidade de armazenamento, é necessário
realizar o particionamento do disco, criando as partições, em que cada partição é independente das
outras, ou seja, cada partição pode ter o seu próprio sistema de arquivos.
Dessa forma, podemos, por exemplo, instalar o Linux em uma partição e o Windows em outra
partição, em um mesmo disco rígido. A tabela, onde são armazenadas as informações sobre as
partições, fica no primeiro setor do disco e chama-se MBR (Master Boot Record). O MBR é um
padrão antigo que define a estrutura das partições, mantendo a informação sobre como as partições
lógicas estão organizadas no disco.
Usando essa estrutura, há algumas limitações. Um disco pode dividir-se em um máximo de 4
partições primárias ou em até 3 partições primárias e 1 partição estendida. Uma partição estendida
pode dividir-se em múltiplas partições lógicas. Cada partição primária e lógica tem a sua própria
unidade.
Como o MBR usa 32 bits para guardar informações das partições, cada partição apenas pode
ter um tamanho máximo de 2 TB e toda a informação das partições é guardada apenas em um único
local, o MBR.
Os novos sistemas computacionais permitem o uso de GPT (Tabela de Partição Guid), que é
uma nova forma de realizar o particionamento de discos rígidos. O GPT traz muitos benefícios
comparativamente ao tradicional MBR (Master boot record), entre os quais se destacam:
Suporte para partições bem maiores do que 2 TB;
Suporte para até 128 partições primárias;
Melhor estrutura/ organização ao nível das partições;
Mecanismos para detecção de dados e partições corrompidas;
Aumento da probabilidade de recuperação de dados, na existência de setores do disco
danificados, uma vez que tem um cabeçalho secundário (Secondary GPT Header) que
funciona como backup da tabela de partições;
Manutenção da compatibilidade com o MBR, para sistemas legados.
https://univirtus.uninter.com/ava/web/roa/

20/29

05/05/2022 22:55

UNINTER

Depois de realizado o particionamento do disco é necessário realizar a formatação da partição,
escolhendo um sistema de arquivos para esta, de acordo com o SO que vai ser usado.

TEMA 5 – SISTEMA DE ARQUIVOS E SEUS TIPOS
Do ponto de vista do usuário, o aspecto mais importante do sistema de arquivos é como este se
apresenta, isto é, o que constitui um arquivo, como os arquivos são identificados e protegidos, que
operações são permitidas sobre os arquivos, e assim por diante.

5.1 FUNDAMENTOS BÁSICOS DOS SISTEMAS DE ARQUIVOS
A maior parte dos sistemas operacionais trazem a seguinte proposta para armazenamento de
informação: permitir aos usuários deﬁnir objetos chamados arquivos, que podem armazenar
programas, dados, ou qualquer outra informação.
Esses arquivos não são parte endereçável de nenhum processo e o sistema operacional provê
chamadas de sistema para criar, destruir, ler, atualizar e proteger arquivos. Todos os sistemas
operacionais visam uma independência dos dispositivos de armazenamento, permitindo acessar um
arquivo sem especificar em qual dispositivo este se encontra fisicamente armazenado.
Um programa que lê um arquivo de entrada e escreve um arquivo de saída deve ser capaz de
operar com arquivos armazenados em quaisquer dispositivos, sem necessidade de um código
especial para explicitar o tipo de periférico.
Alguns

sistemas

operacionais

proveem

maior

independência

dos

dispositivos

de

armazenamento que outros.
No UNIX, por exemplo, um sistema de arquivos pode ser montado em qualquer dispositivo de
armazenamento, permitindo que qualquer arquivo seja acessado pelo seu nome (path name), sem
considerar o dispositivo físico.
No MS-DOS, por outro lado, o usuário deve especificar em qual dispositivo cada arquivo se
encontra (exceto quando um dispositivo é default e for omitido). Assim, se o dispositivo default for o
drive C, para executar um programa localizado no drive A com arquivos de entrada e de saída no

https://univirtus.uninter.com/ava/web/roa/

21/29

05/05/2022 22:55

UNINTER

drive B, cada um deles dever ser especificado juntamente com o nome do arquivo, seguindo o
modelo: A:programa < B:entrada > B:saída

5.2 TIPOS DE SISTEMAS DE ARQUIVOS
A Figura 13 apresenta alguns tipos de sistemas de arquivos, comuns à maioria dos sistemas
operacionais. Confiram:

Figura 13 – Tipos de sistemas de arquivos do GParted Linux

Os principais tipos de Sistemas de arquivos, de acordo com os sistemas operacionais mais
usuais e formato nativo de arquivos, são:
Para os sistemas operacionais Apple Macintosh:
HFS – Hierarchical File System: é um sistema de arquivos desenvolvido pela Apple Computer
para uso em computadores rodando o Mac OS, também pode ser referenciado como HFS Standard
e Mac OS Standard, sendo que o seu sucessor HFS Plus também é chamado HFS Extended ou
Mac OS Extended;
Para os sistemas operacionais Unix (FreeBSD, OpenBSD, Linux, Solaris):
UFS: o Unix File System (UFS), é um sistema de arquivos usado por simplesmente FFS. É o
sistema original do tipo i-nodes;
SWAP: sistema de arquivo para o arquivo de paginação da memória virtual do Linux;
https://univirtus.uninter.com/ava/web/roa/

22/29

05/05/2022 22:55

UNINTER

Reiser: criado por Hans Reiser e inicialmente mantido pela empresa Namesys, o ReiserFS foi
o primeiro sistema de arquivos com suporte a journaling incluído no kernel do Linux;
Ext2 (second extended file system): sistema de arquivos para dispositivos de blocos (disco
rígido, disquete, pendrive). O Ext2 foi projetado e implementado para corrigir as deficiências do
Ext e prover um sistema que respeitasse a semântica do Unix;
Ext3: o Ext3 (third extended file system) é um sistema de arquivos desenvolvido para o Linux,
que acrescenta o recurso de journaling ao Ext2. O journaling é o controle de transações que
permite desfazer uma operação que falhou e voltar ao último estado seguro do sistema;
Ext4: sistema de arquivos do Linux desenvolvido para ser o sucessor do Ext3 a partir de 2006.
As novas funcionalidades propostas são: alocação tardia (delay ed allocation); marcas
temporais com maior resolução (nanossegundos) verificação de integridade do journal (jornal
check sums) e suporte para tamanhos maiores de volumes e arquivos;
XFS: sistema de arquivos inicialmente desenvolvido pela Silicon Graphics Inc. para o seu
sistema operacional IRIX. Posteriormente teve seu código fonte liberado e foi adaptado para
funcionar no Linux. Usa alocação dinâmica de i-nodes e journaling;
HPFS: sistema de arquivos utilizado pelo OS/2 da IBM, com recursos que se aproximam muito
dos permitidos pelo NTFS como nome de arquivos com até 254 caracteres incluindo espaços,
partições de até 512 GB e unidades de alocação de 512 bytes. Embora muito eficiente, esse
sistema de arquivos caiu em desuso juntamente com o OS/ 2, sendo suportado atualmente
somente pelo Linux;
JFS: o Journaling File System é um sistema de arquivos desenvolvido pela IBM, disponível em
licença open-source, com o intuito de ser utilizado nos UNIXes que a IBM vendia. Além de
possuir journal, ele permite que as partições do sistema sejam redimensionadas sem que seja
necessário desligar o computador.
O sistema de arquivos JFS também usa a estrutura i-node para armazenar a localização dos
blocos de cada arquivo nas estruturas físicas do disco, a versão JFS2 armazena esses i-nodes em
uma árvore binária para acelerar o acesso a essas informações;
Para os sistemas operacionais Microsoft MS-DOS/ Windows:
FAT16 ou FAT: sistema básico usado no MS-DOS da década de 90 e nos sistemas Windows
atuais. Suporta somente nomes com 8 caracteres e extensão de 3 caracteres;

https://univirtus.uninter.com/ava/web/roa/

23/29

05/05/2022 22:55

UNINTER

FAT32: usado nos sistemas últimos MS-DOS e Windows. Tem suporte a nomes longos e é
largamente usado em pendrives e cartões de memória, devido à simplicidade da sua estrutura.
Apresenta uma limitação de que o maior arquivo não pode exceder 4GB;
NTFS: usado nos Windows atuais, apresenta um algo grau de confiabilidade com controle de
permissões de usuários, suporte à criptografia e compactação;
Para os discos ópticos (CDs/DVDs/BDs (BluRay Disc)
IS09660: padrão internacional que especifica como os dados são fisicamente gravados no CD
(setor por setor) em uma árvore de diretório (até oito níveis de diretórios). CD-ROMs criados
de acordo com as especificações ISO 9660 Nível 1 podem ser lidos em vários sistemas
operacionais (Macintosh, DOS, Windows e Linux);
Joliet: padrão desenvolvido pela Microsoft para o Windows 95 que permite que CDs sejam
gravados usando nomes de arquivo longos. O padrão Joliet permite usar nomes de arquivos
com até 64 caracteres de comprimento, incluindo espaços, e também permite usar caracteres
Unicode para um melhor suporte internacional. O padrão Joliet grava o nome de arquivo
padrão DOS associado (8 + 3 caracteres) para cada arquivo de modo que o CD possa ser lido
em sistemas DOS ou em versões anteriores do Windows;
RockRidge: extensão que permite nomes longos para o IS09660 file system, usado com o
Linux;
El Torito: pode ser usado para produzir CD-ROMs bootáveis (inicializáveis);
UDF: Universal Disk Format é um padrão desenvolvido pela Optical Storage Technology
Association (OSTA) e é um sistema de arquivos usado com tecnologias de disco óptico, tal
como DVD e BluRay Disc. Este padrão é particularmente útil na gravação de arquivos muito
grandes (maiores que 1 GB). O sistema de arquivos UDF permite uma maior flexibilidade em
comparação com os sistemas Joliet ou ISO 9660.
Diferentes sistemas operacionais podem usar diferentes sistemas de arquivos. Atualmente, o
NTFS (New Technology File System) é o sistema de arquivos padrão do Windows, já o Ext4 é o
mais usado no Linux.

5.3 SISTEMAS DE ARQUIVOS WINDOWS

https://univirtus.uninter.com/ava/web/roa/

24/29

05/05/2022 22:55

UNINTER

O NTFS (New Technology File System) é um sistema de arquivos que surgiu juntamente com o
lançamento do Windows NT. Por apresentar excelente desempenho e confiabilidade, foi adotado nas
várias versões Windows.
O NTFS possui várias características, em caso de falhas, por exemplo, quando o computador
tem um desligamento repentino, ele tem a capacidade de reverter os dados para a condição anterior
ao problema. O NTFS também possui a característica de suportar uma replicação de dados, controle
de permissões de acesso e possui muita eficiência no trabalho com grandes arquivos e também
unidades de discos bastante cheias. Suporta criptografia, indexação e compactação.
Cada unidade ou volume de disco é identificada com uma letra, começando por padrão com C.
Armazena as estruturas de controle do sistema de arquivos em duas áreas distintas do disco para
garantir a integridade, no caso de falha em uma área do disco.

5.4 SISTEMAS DE ARQUIVOS LINUX
O Linux é um SO que dá suporte a diversos sistemas de arquivos. Atualmente, o sistema de
arquivos mais utilizado é o ext4 desenvolvido para ser o sucessor do ext3 a partir de 2006. O Ext4
apresenta inúmeros novos aprimoramentos quanto a desempenho, escalabilidade e confiabilidade e
suporta sistemas de arquivos de até 1 exabyte (um bilhão de Gigabytes).
Apresenta uma performance considerada muito boa, principalmente para o seu uso em
máquinas de grande porte, superando a capacidade de armazenamento do EXT3. O novo sistema
de journaling do EXT4 melhora a quantidade de arquivos e processos suportados pelo Linux.
Devido à alocação tardia, existe uma considerável redução de fragmentação, por ele melhorar
nas decisões do sistema sobre o arquivo levando em consideração o tamanho deste, porém isso
apresenta riscos de ocorrência de perda de dados em caso de desligamentos abruptos.
No Linux, um diretório (corresponde ao conceito de pasta do Windows) pode ter outros
diretórios (subdiretórios) ou arquivos. O diretório acima, onde um subdiretório foi criado, é chamado
de diretório pai.
O Linux implementa um sistema de arquivos baseado nos i-nodes do Unix, em que há uma
tabela na unidade de armazenamento onde são controlados os nomes, permissões e atributos de
cada arquivo ou diretório, bem como os endereços dos blocos iniciais de cada arquivo ou diretório.
https://univirtus.uninter.com/ava/web/roa/

25/29

05/05/2022 22:55

UNINTER

Os demais endereços das partes de cada arquivo ou diretório são gravados espalhados pelo disco,
próximos aos blocos dos respectivos arquivos e diretórios.
O diretório raiz do Linux (ou diretório/) é o diretório com maior hierarquia entre todos os
diretórios do sistema. Isto significa que todos os diretórios do Linux ficam abaixo deste diretório. A
Figura 14 apresenta alguns exemplos de diretórios que ficam abaixo do diretório raiz:

Figura 14 – Prompt de comando de listagem de arquivos Linux

bin – diretório com os comandos disponíveis para os usuários (não privilegiados);
boot – diretório com os arquivos do boot de inicialização;
dev – diretório com as definições dos dispositivos de entrada/saída;
etc – diretório com os arquivos de configuração do sistema;
home – diretório que armazena os diretórios dos usuários do sistema;
lib – diretório com as bibliotecas e módulos (carregáveis) do sistema;
mnt – diretório usado para montagem de partições;
proc – diretório com informações sobre os processos do sistema;
https://univirtus.uninter.com/ava/web/roa/

26/29

05/05/2022 22:55

UNINTER

root – diretório home do root (administrador do sistema);
sbin – diretório com os aplicativos usados na administração do sistema;
tmp – diretório com arquivos temporários;
usr – diretório com aplicativos e arquivos utilizados pelos usuários;
var – diretório com arquivos de dados variáveis (spool, logs etc.).

FINALIZANDO
Nesta aula foi apresentado o principal componente responsável pela interface ou interação
humano computador, pois os arquivos são frequentemente a justificativa de acesso ao dispositivo.
Apresentados e explicados os termos que definem os arquivos e a sua gerência, em especial no
primeiro tema, numa visão geral, com diversas imagens que auxiliam.
No segundo tema, foram apresentados os conteúdos que descrevem que, após efetuado o
acesso ao(s) arquivo(s) de forma sequencial e/ou aleatória, o sistema deve oferecer. Além das
operações essenciais, devem também existir operações para o conteúdo e a manipulação dos
dados armazenados nos arquivos, e para muitos sistemas de arquivos que suportam diretórios,
devem ser oferecidas operações específicas.
No tema seguinte, foi a vez das definições das estruturas de diretórios, subdiretórios e atalhos,
com a tarefa de localizar os seus blocos no disco, por meio do nome do arquivo, quando associado
ao diretório corrente, com o objetivo de facilitar a manutenção do sistema e aumentar a segurança
dos dados.
O armazenamento de dados (arquivos) a longo prazo é o quarto tema, e nele foram definidos e
apresentados inicialmente as operações sobre os arquivos, que organizam seu armazenamento no
sistema de arquivos (file system) com um método de acesso (forma como dados são armazenados
nos arquivos).
Ao final, o sistema de arquivos e seus tipos fecham a conceituação e as definições, com a
proposta para armazenamento de informação de permitir aos usuários deﬁnir arquivos, armazenar

https://univirtus.uninter.com/ava/web/roa/

27/29

05/05/2022 22:55

UNINTER

programas, dados, ou qualquer outra informação, com o detalhamento dos tipos especiais para os
sistemas operacionais Apple Macintosh, Microsoft e Unix.

REFERÊNCIAS
CUNHA, G. B., PREUSS, E., MACEDO, R. T. Sistemas operacionais. Santa Maria, RS: UFSM,
2017.
DEITEL, P. J., DEITEL, H. M., CHOFFNES, D. R. Sistemas operacionais. 3. ed. São Paulo:
Pearson, 2017.
GUIA

LINUX.

Sistemas

de

arquivos.

Guia

Linux,

S.d.

Disponível

em:

<https://guialinux.uniriotec.br/sistemas-de-arquivos/>. Acesso em: 2 nov. 2020.
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. Rio de Janeiro:
LTC, 2014.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Ed. da UFPR, 2019.
SILBERSCHATZ, A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.
SILBERSCHATZ, A.; GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro: Campus, 2016.
STALLINGS, W. Operating systems: internals and design principles. 9. ed. São Paulo:
Pearson, 2017.
TANENBAUM, A. S.; BOS, H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.
TANENBAUM, A. S.; WOODHULL, A. S. Sistemas operacionais: projeto e implementação 3.
ed. Porto Alegre: Bookman, 2008.
UNICAMP

–

Universidade

Estadual

de

Campinas.

Disponível

em:

<https://www.unicamp.br/unicamp/>. Acesso em: 2 nov. 2020.

https://univirtus.uninter.com/ava/web/roa/

28/29

05/05/2022 22:55

https://univirtus.uninter.com/ava/web/roa/

UNINTER

29/29





05/05/2022 22:56

UNINTER

SISTEMAS OPERACIONAIS
AULA 6

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/24

05/05/2022 22:56

UNINTER

CONVERSA INICIAL
Desde a nossa primeira aula, são apresentados conceitos e definidos termos relacionados à
gerência dos sistemas de computação. Agora, finalizamos o conteúdo das aulas com a gerência de
proteção de arquivos e usuários, tema atual e essencial para a boa gestão do item mais precioso
dos sistemas, os dados e informações dos usuários, armazenados nos arquivos.
De alguma forma, tudo o que desenvolvemos e produzimos está digitalizado, seja no
smartphone, seja no flash drive portátil, na central multimídia de um veículo, no relógio (smartwatch),
nos óculos (smartglasses) ou em qualquer outro dispositivo vestível (weareble); e, principalmente,
nos computadores tradicionais, nos desktops, nas workstations, nos servidores; e, atualmente, na
nuvem (cloud computing), em grandes data centers especializados das gigantes da tecnologia da
informação (TI) (exemplos: Google, Microsoft, Apple, Oracle, Amazon).
E essas preciosas informações são alvo dos cibercriminosos, que, das mais diversas formas
(exemplo: crypto-ransomware WannaCry[1]), buscam a propriedade da informação, ou seja, as
credenciais que permitam total controle sobre os arquivos, desde o simples acesso de leitura até a
total e absoluta exclusão de dados, gerando grandes prejuízos, pois todos sabemos o valor de
nossos dados, desde as mais simples conversas com contados até as mais elaboradas fórmulas e
projetos. Com os mais diversos propósitos, desde conhecer e explorar nossos hábitos até obter
nossas informações mais confidenciais e sigilosas (dados econômicos/financeiros, privados etc.), os
cibercriminosos, conhecedores desse valor e preparados para explorar as “brechas” de segurança,
são contratados para executarem ataques a sistemas vulneráveis, em que se desconhece ou
simplesmente se negligencia um melhor cuidado da informação, e que não utilizam os padrões e
políticas de segurança adequados, visando à manutenção da confidencialidade, disponibilidade e
integridade dos dados. Nesses casos, os cibercriminosos conquistam altas taxas de sucesso em
suas investidas.
https://univirtus.uninter.com/ava/web/roa/

2/24

05/05/2022 22:56

UNINTER

Mas aqueles que conhecem as definições e práticas de gestão de proteção de arquivos,
fazendo o uso dos procedimentos recomendados, conseguem níveis satisfatórios de defesa e
proteção contra esses ataques e ameaças, preparando-se da melhor forma contra eles. Devido a
tamanha complexidade, há cursos superiores específicos sobre cibersegurança, além da certificação
profissional de empresas especializadas. Contudo, todas as técnicas de ataque e defesa envolvem
diretamente os arquivos de usuários e os sistemas operacionais que os geram e mantêm. Portanto,
conhecer as definições e propriedades alinhadas às tarefas de gestão apresentadas nas atividades
práticas fornece o conhecimento inicial para uma preparação que exige formação continuada em
cursos mais específicos e avançados.
Para Maziero (2019), a segurança de um sistema de computação diz respeito à garantia de
algumas propriedades fundamentais associadas às informações e recursos presentes em um
sistema. Provavelmente, é em seu computador pessoal que a maioria dos seus dados está gravada
e é por meio dele que você acessa redes e realiza transações bancárias e comerciais. Por isso,
mantê-lo seguro é essencial para se proteger dos riscos (Maziero, 2019). Muitas vezes, os atacantes
estão interessados no acesso a uma grande quantidade de devices, independentemente de quais
são e das configurações que possuem. Por isso, acreditar que seu computador está protegido, por
ele supostamente não apresentar atrativos para um atacante, pode ser um grande erro (Cert, 2016).
Os conteúdos previstos para esta aula teórica abrangem a gerência e a proteção de usuários,
que serão individualmente descritas e apresentadas nos cinco temas a seguir:
1. Conceitos e definições de segurança;
2. Riscos, ameaças e vulnerabilidades;
3. Criptografia;
4. Autenticação, gerenciamento e controle de acesso;
5. Gerenciamento e proteção de usuários.
Aproveite e bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES DE SEGURANÇA
https://univirtus.uninter.com/ava/web/roa/

3/24

05/05/2022 22:56

UNINTER

O professor Luis Gonzaga de Paulo apresenta, na reportagem intitulada Aumento de ataques
cibernéticos alertam para a necessidade de se ter cuidados com a proteção, que:
Um ataque cibernético é um evento que tem por objetivo atingir as bases da segurança da
informação: a confidencialidade, a integridade e a disponibilidade da informação. Para tanto usam
técnicas, métodos e ferramentas com o propósito de ter acesso indevido a informações restritas,
falsificar, alterar ou destruir informações de valor ou tornar inviável o uso dessas informações ou o
acesso a elas. Geralmente são parte de planos bem orquestrados por quadrilhas do crime
organizado, mas pode ser executado de forma amadora, por alguém com algum conhecimento
técnico ou mesmo um aprendiz, ou por serviços de espionagem e grupos terroristas. É bom
salientar que nem sempre o ataque é motivado por interesses financeiros, embora esse seja o
principal fator em grande parte dos ataques. (Paulo, 2020, citado por Zanluca, 2020)

Em português, a palavra segurança abrange muitos significados distintos e por vezes
conflitantes, como define Maziero (2019). Em inglês, as palavras security, safety e reliability
permitem definir mais precisamente os diversos aspectos da segurança: a palavra security se
relaciona a ameaças intencionais, como intrusões, ataques e roubo de informações; a palavra safety
se relaciona a problemas que possam ser causados pelo sistema aos seus usuários ou ao ambiente,
como acidentes provocados por erros de programação; por fim, o termo reliability é usado para
indicar sistemas confiáveis, construídos para tolerar erros de software, de hardware ou dos usuários
(Avizienis et al., 2004; Maziero, 2019).
Nesta aula, serão considerados somente os aspectos de segurança relacionados ao termo
security, ou seja, à proteção do sistema contra ameaças intencionais. Trataremos dos principais
conceitos de segurança, como propriedades e princípios de segurança, ameaças, vulnerabilidades e
ataques típicos em sistemas operacionais, concluindo com uma descrição da infraestrutura de
segurança típica de um sistema operacional. Grande parte dos tópicos de segurança apresentados
não são exclusivos de sistemas operacionais, se aplicam a sistemas de computação em geral
(Maziero, 2019).
Outras boas definições dos termos segurança e seguro podem ser obtidas no Michaelis
dicionário brasileiro da língua portuguesa (2015):
segurança
[...]
2 Estado do que se acha seguro ou firme; estabilidade, solidez.

https://univirtus.uninter.com/ava/web/roa/

4/24

05/05/2022 22:56

UNINTER

[...]
5 Condição ou estado do que está livre de danos ou riscos.
6 Crença ou opinião firme; certeza, confiança, firmeza [...].
[...]
seguro
[...]
3 Que envolve pouco ou nenhum risco; eficaz, garantido [...].
4 Livre de perigo ou não exposto a ele; protegido, testo.
[...]
6 Que oferece segurança contra ataques, acidentes, desastres ou danos de qualquer outra
natureza [...].
[...]
11 Que não oferece dúvida; certo, incontestável, indubitável.
12 Em que se pode crer ou ter confiança [...]. (Michaelis, 2015)

1.1 INFORMAÇÃO
Em complemento à definição de segurança, torna-se necessária a definição de informação,
pois, como descrito pelo professor Luis Gonzaga de Paulo (2020),
vivemos na Era da Informação, e produzimos, armazenamos e movemos diariamente uma
quantidade incalculável de informação. Apesar da quantidade de informação ter passado por um
grande impulso a partir da invenção da imprensa, por Gutemberg, foi a partir do final do século
XVIII, com a invenção da fotografia, seguida do telégrafo – que inaugurou a era das
telecomunicações – que a quantidade de informação produzida, disponível e transportada ganhou
tamanha proporção.

Numa reflexão sobre o que é informação, temos, então, nomes, números, imagens e sons,
sensações, enfim, tudo que podemos experimentar com nossos sentidos – e, além deles, com o uso
da tecnologia – e que tenha algum uso, propósito, que possa ser utilizado por meio da razão ou da
emoção, tudo isso é informação. E tudo isso tem valor, um valor mensurável ou não (Paulo, 2020).

https://univirtus.uninter.com/ava/web/roa/

5/24

05/05/2022 22:56

UNINTER

Mas, na TI, o conceito de informação é diferenciado, a começar pela separação entre
informação e dados. Dados são elementos, valores, grandezas medidas e ainda por analisar ou
processar por meio de recursos computacionais. Informações são os resultados dessa análise ou
processamento, que, mediante processos e regras definidas, tornam-se inteligíveis e utilizáveis
pelos seres humanos. Entretanto, ambos – dados ou informações – têm um valor intrínseco,
requerendo um tratamento pelo qual possam manter sua utilidade e seu valor (Paulo, 2020).
A norma ABNT NBR ISO/IEC 27002:2103 define informação como um ativo – isto é, bem,
patrimônio – de uma organização, de grande importância e valor e que, por isso, necessita de
proteção adequada (ABNT, 2013). Para isso, deve-se considerar a informação em suas diversas
formas e nos diversos meios utilizados para obtê-la, armazená-la, transportá-la e modificá-la:
O valor da informação vai além das palavras escritas, números e imagens: conhecimentos,
conceito, ideias e marcas são exemplos de formas intangíveis da informação. Em um mundo
interconectado, a informação e os processos relacionados, sistemas, redes e pessoas envolvidas
nas suas operações são informações que, como os outros ativos importantes, têm valor para o
negócio da organização e, consequentemente requerem proteção contra vários riscos. (ABNT,
2013)

Devido à grande diversidade de informações, no ambiente pessoal e no ambiente corporativo, é
necessário classificar as informações, isto é, diferenciá-las em função de níveis e critérios
específicos, como a sua natureza, o seu valor e o seu grau de importância. Esses critérios e níveis
podem definir o grau de sigilo e confidencialidade a ser aplicado à informação. É também em função
desses critérios que serão definidos os mecanismos de controle e proteção das informações.
Certamente, você já ouviu ou leu a respeito de informações confidenciais, secretas, de caráter
reservado ou público. São exemplos de classificações para informações que determinam quem,
quando e onde pode-se ter acesso, transportar ou modificar determinadas informações (Paulo,
2020).
De maneira semelhante aos arquivos e tarefas, conforme definido nas aulas anteriores, a
informação também percorre um ciclo de vida, isto é, um período compreendido entre a criação ou
origem da informação e o momento em que ela pode ser descartada. Durante esse ciclo de vida, a
informação é manuseada, manipulada ou tratada, podendo sofrer alterações, desde que
controladas, de modo a não perder seu valor. Ela também pode ser armazenada ou transportada –
submetida a processos que, entretanto, não mudam seu significado ou valor. Nesse ciclo de vida, a

https://univirtus.uninter.com/ava/web/roa/

6/24

05/05/2022 22:56

UNINTER

informação também está exposta a riscos – isto é, está vulnerável –, por exemplo, o roubo, a perda
ou a alteração indevida. Para evitar que isso ocorra, é necessário proteger a informação e monitorar
seu ciclo de vida por completo. Esse é o principal objetivo da segurança da informação (Paulo,
2020).

Figura 1 – Ciclo de vida da informação

Fonte: Paulo, 2020.

1.2 SEGURANÇA DA INFORMAÇÃO
Para se garantir a segurança da informação, é necessário que os seguintes princípios básicos
sejam respeitados:
Confidencialidade: deve-se assegurar que a informação será acessível somente a quem tem
autorização de acesso;
Integridade: deve-se assegurar que a informação não foi alterada durante o seu processo de
transporte;
Disponibilidade: deve-se assegurar que usuários autorizados tenham acesso a informações e
recursos a estas associados, quando por eles requeridos (Projetos, 2019).
Além desses princípios básicos, outras propriedades importantes estão geralmente associadas
à segurança de um sistema, segundo Maziero (2019):
Autenticidade: todas as entidades de um sistema são autênticas ou genuínas; em outras
palavras, os dados associados a essas entidades são verdadeiros e correspondem às
informações do mundo real que elas representam, como as identidades dos usuários, a origem
dos dados de um arquivo etc.
Irretratabilidade: todas as ações realizadas no sistema são conhecidas e não podem ser
escondidas ou negadas por seus autores; essa propriedade também é conhecida como
irrefutabilidade ou não repúdio.

https://univirtus.uninter.com/ava/web/roa/

7/24

05/05/2022 22:56

UNINTER

É função do sistema operacional garantir a manutenção das propriedades de segurança para
todos os recursos sob sua responsabilidade. Essas propriedades podem estar sujeitas a violações
decorrentes de erros humanos ou de software, praticadas por indivíduos mal-intencionados
(maliciosos), internos ou externos ao sistema (Maziero, 2019).
De acordo com a norma ABNT NBR ISO/IEC 27002:2013:
A segurança da informação é alcançada pela implementação de um conjunto adequado de
controles, incluindo políticas, processos, procedimentos, estrutura organizacional e funções de
software e hardware. Estes controles precisam ser estabelecidos, implementados, monitorados,
analisados criticamente e melhorados, quando necessário, para assegurar que os objetivos do
negócio e a segurança da informação sejam atendidos. (ABNT, 2013)

1.3 PRINCÍPIOS DE SEGURANÇA DA INFORMAÇÃO
Além das técnicas usuais de engenharia de software usadas para a produção de sistemas
corretos, segundo Maziero (2019), a construção de sistemas computacionais seguros é pautada por
uma série de princípios específicos, relativos tanto à construção do sistema quanto ao
comportamento dos usuários e dos atacantes. Alguns dos princípios mais relevantes, compilados
por Maziero (2019), são indicados a seguir:
Privilégio mínimo: todos os usuários e programas devem operar com o mínimo possível de
privilégios ou permissões de acesso necessários para poderem funcionar. Dessa forma, os
danos provocados por erros ou ações maliciosas intencionais serão, também, minimizados.
Separação de privilégios: sistemas de proteção baseados em mais de um controle ou regra
são mais robustos, pois, se o atacante conseguir burlar um dos controles, mesmo assim não
terá acesso ao recurso. Em um sistema bancário, por exemplo, uma operação de valor
elevado pode requerer a autorização de dois gerentes.
Mediação completa: todos os acessos a recursos, tanto diretos quanto indiretos, devem ser
verificados pelos mecanismos de segurança. Eles devem estar dispostos de forma a ser
impossível contorná-los.
Default seguro: o mecanismo de segurança deve identificar claramente os acessos
permitidos; caso um certo acesso não seja explicitamente permitido, ele deve ser negado.
Esse princípio impede que acessos inicialmente não previstos no projeto do sistema sejam
inadvertidamente autorizados.
https://univirtus.uninter.com/ava/web/roa/

8/24

05/05/2022 22:56

UNINTER

Economia de mecanismo: o projeto de um sistema de proteção deve ser pequeno e simples,
para que possa ser facilmente e profundamente analisado, testado e validado.
Compartilhamento mínimo: mecanismos compartilhados entre usuários são fontes potenciais
de problemas de segurança, devido à possibilidade de haver fluxos de informação imprevistos,
entre usuários. Por isso, o uso de mecanismos compartilhados deve ser minimizado, sobretudo
se envolver áreas de memória compartilhadas. Por exemplo, caso uma funcionalidade de um
sistema operacional possa ser implementada como chamada a um núcleo ou como função de
biblioteca, deve-se preferir essa última forma, pois envolve menos compartilhamento.
Projeto aberto: a robustez do mecanismo de proteção não deve depender da ignorância dos
atacantes; ao invés disso, o projeto deve ser público e aberto, dependendo somente do
segredo de poucos itens, como listas de senhas ou chaves criptográficas. Um projeto aberto
também torna possível a sua avaliação por terceiros independentes, provendo confirmação
adicional da segurança do mecanismo.
Proteção adequada: cada recurso computacional deve ter um nível de proteção coerente com
seu valor intrínseco. Por exemplo, o nível de proteção requerido em um servidor web de
serviços bancários é bem distinto daquele de um terminal público de acesso à internet.
Facilidade de uso: o uso dos mecanismos de segurança deve ser fácil e intuitivo, caso
contrário eles serão evitados pelos usuários.
Eficiência: os mecanismos de segurança devem ser eficientes no uso dos recursos
computacionais, de forma a não afetarem significativamente o desempenho do sistema ou as
atividades de seus usuários.
Elo mais fraco: a segurança do sistema é limitada pela segurança de seu elemento mais
vulnerável, seja ele o sistema operacional, sejam as aplicações, a conexão de rede ou o
próprio usuário.
Esses princípios devem pautar a construção, configuração e operação de qualquer sistema
computacional com requisitos de segurança. A maioria dos problemas de segurança dos sistemas
atuais provém da não observação desses princípios (Maziero, 2019).

TEMA 2 – RISCOS, AMEAÇAS E VULNERABILIDADES
Como mencionado por Paulo (2020), a informação está sujeita a riscos, seja no seu processo
de produção e manuseio, seja no seu armazenamento ou em seu transporte por qualquer meio.
https://univirtus.uninter.com/ava/web/roa/

9/24

05/05/2022 22:56

UNINTER

Esses riscos são decorrência dos diversos fatores envolvidos nesses processos: pessoas,
tecnologias, ambientes, fenômenos naturais e o seu próprio desgaste ou fadiga pelo uso.
“Os incidentes, isto é, as ocorrências que transformam a possibilidade do risco em um
acontecimento, um fato, podem comprometer uma ou mais características da segurança da
informação” (Paulo, 2020), com probabilidade de que uma ameaça venha a explorar ou agir em face
de uma vulnerabilidade, gerando um incidente de segurança da informação que fira aspectos
básicos da segurança da informação, identificados com o acrônimo CID: confidencialidade,
integridade e disponibilidade (Paulo, 2020), conforme apresentado no item 1.2.
Por meio de registros históricos, da análise matemática ou estatística, é possível determinar a
probabilidade da ocorrência do risco e o impacto que essa ocorrência – ou incidente – pode causar
nos negócios. Ao processo de avaliação de riscos executado dessa maneira denomina-se análise de
riscos (Paulo, 2020).
Para o professor Carlos Alberto Maziero (2019), ameaça pode ser considerada qualquer ação
que coloque em risco as propriedades de segurança do sistema descritas na seção anterior. Alguns
exemplos de ameaças às propriedades básicas de segurança seriam:
Ameaças à confidencialidade: um processo vasculhar as áreas de memória de outros
processos, arquivos de outros usuários, o tráfego de rede nas interfaces locais ou áreas do
núcleo do sistema, buscando acesso a dados sensíveis como números de cartão de crédito,
senhas, conteúdos de e-mails privados etc.
Ameaças à integridade: um processo alterar as senhas de outros usuários, instalar
programas, drivers ou módulos de núcleo maliciosos, visando obter o controle do sistema,
roubar informações ou impedir o acesso de outros usuários.
Ameaças à disponibilidade: um usuário alocar para si todos os recursos do sistema, como a
memória, o processador ou o espaço em disco, para impedir que outros usuários possam
utilizá-lo (Maziero, 2019).
Para Paulo (2020), as ameaças são agentes ou eventos que, podendo explorar ou agir perante
uma vulnerabilidade, representam um risco.
Para evitar incidentes de segurança da informação, uma organização necessita conhecer e
gerenciar seus ativos – incluindo-se, entre esses, as informações de valor – e as suas
https://univirtus.uninter.com/ava/web/roa/

10/24

05/05/2022 22:56

UNINTER

vulnerabilidades. O processo de identificação e avaliação dos ativos, asset assessment ou
inventário, deve, então, identificar, descrever e localizar cada ativo, seu uso e controles de
segurança atuais e as ameaças às quais eles estão expostos ou submetidos (Paulo, 2020).
Maziero (2019) conclui que, obviamente, para cada ameaça possível, devem existir estruturas,
no sistema operacional, que impeçam sua ocorrência, como controles de acesso às áreas de
memória e arquivos, quotas de uso de memória e processador, verificação de autenticidade de
drivers e outros softwares etc. As ameaças podem ou não se concretizar, dependendo da existência
e da correção dos mecanismos construídos para evitá-las ou impedi-las. As ameaças podem se
tornar realidade na medida em que existam vulnerabilidades que permitam sua ocorrência (Maziero,
2019)
Como já visto e apresentado por Paulo (2020), a informação é um valioso ativo – isto é, um bem
ou patrimônio da organização. No entanto, para fazer uso desse valioso bem, de forma a empregá-lo
adequadamente ao processo produtivo da organização, é necessário prover meios para interagir
com a informação no seu ciclo de vida. Esses meios são os ativos da informação ou da TI.
Os ativos compreendem uma vasta gama de dispositivos, equipamentos e componentes, desde
os circuitos de comunicação de dados até os softwares – os programas –, passando por redes,
meios de armazenamento, computadores e periféricos. Cada ativo está sujeito a incidentes que
podem influenciar na segurança da informação, seja pelo seu uso intenso, por se tratar de uma nova
tecnologia cuja efetividade na segurança da informação ainda não foi comprovada; seja por haver
interesses escusos em relação ao seu possível alto valor. Enfim, tais ativos estão expostos a falhas
de segurança da informação, possuindo pontos fracos que podem vir a ser explorados ou
apresentarem comportamento incompatível, fraquezas, às quais denominamos vulnerabilidades. Ou
seja, vulnerabilidades são pontos fracos, nos ativos da informação, que podem ser explorados ou
fazê-los apresentar falhas, gerando incidentes de segurança da informação (Paulo, 2020).
Além disso, para Paulo (2020), estendendo o conceito de ativos às pessoas e processos da
organização que atuam no ciclo de vida da informação, é possível afirmar que esses elementos
também apresentam vulnerabilidades. Isso porque um suborno, a corrupção, a omissão ou uma
ação proposital podem gerar incidentes de segurança da informação, ou seja, pessoas e processos
também apresentam vulnerabilidades.

https://univirtus.uninter.com/ava/web/roa/

11/24

05/05/2022 22:56

UNINTER

Tanto indivíduos quanto empresas são vulneráveis a roubos de dados e a ataques que podem
comprometer dados, corromper arquivos e provocar a queda de sistemas. A indústria da
computação procura atender essas necessidades com suas organizações, trabalhando para
melhorar a segurança computacional. Por exemplo, a iniciativa de computação confiável proposta
pelo presidente da Microsoft, Bill Gates, é um esforço para concentrar a prioridade das empresas no
fornecimento de aplicações confiáveis, disponíveis e seguras (Deitel; Deitel; Choffnes, 2017).
Para o professor Carlos Alberto Maziero (2019), uma vulnerabilidade é um defeito ou problema
presente na especificação, implementação, configuração ou operação de um software ou sistema,
que possa ser explorado para violar as suas propriedades de segurança. Dentre alguns exemplos de
vulnerabilidades, vale destacar:
um erro de programação no serviço de compartilhamento de arquivos, que permita a usuários
externos o acesso a outros arquivos do computador local, além daqueles compartilhados;
uma conta de usuário sem senha, ou com uma senha predefinida pelo fabricante, que permita
a usuários não autorizados acessarem o sistema;
a ausência de quotas de disco, permitindo a um único usuário alocar todo o espaço em disco
para si e assim impedir os demais usuários de usarem o sistema (Maziero, 2019).
Em sua versão 2.404, o sistema operacional Windows 10 lançou o kernel data protect –
proteção de dados do kernel (KDP), uma nova tecnologia que evita ataques de corrupção de dados,
protegendo partes do kernel e drivers do Windows por meio da segurança baseada em virtualização
(VBS). A KDP é um conjunto de interfaces de programação de aplicativos (APIs) que permitem
marcar algumas memórias do kernel como somente para leitura, impedindo que invasores
modifiquem a memória protegida. Por exemplo, invasores usam drivers de dispositivos assinados,
mas vulneráveis, para atacar estruturas de dados de políticas e instalar um driver mal-intencionado
não assinado. A KDP atenua esses ataques, garantindo que as estruturas de dados da política não
possam ser violadas (Microsoft, 2020).

TEMA 3 – CRIPTOGRAFIA
O termo criptografia tem sua origem no grego kryptós (escondido, oculto, secreto) e gráphos
(grafia, escrita). É a arte ou a ciência de escrever em cifra ou em código. Assim, a criptografia foi
criada para codificar informações, por meio da formulação de um conjunto de técnicas que permitem
https://univirtus.uninter.com/ava/web/roa/

12/24

05/05/2022 22:56

UNINTER

tornar incompreensível uma mensagem originalmente escrita com clareza, de forma a permitir que
somente as pessoas autorizadas (seu remetente e seu destinatário) a decifrem e compreendam,
com acesso ao seu conteúdo (Maziero, 2019).
Conceitualmente, segundo Maziero (2019), a criptografia faz parte de um escopo mais amplo de
conhecimento, que envolve:
Criptografia: conjunto de técnicas para codificar/decodificar informações, ocultando seu
conteúdo de pessoas não autorizadas a acessá-las.
Criptanálise: conjunto de técnicas usadas para “quebrar” uma criptografia, expondo a
informação ocultada por ela.
Criptologia: área geral, englobando criptografia e criptanálise.
Criptossistema: conjunto de algoritmos/mecanismos para realizar um tipo específico de
criptografia.
As técnicas criptográficas são extensivamente usadas na segurança de sistemas, para garantir
a confidencialidade e integridade dos dados. Além disso, elas desempenham um papel importante
na autenticação de usuários e recursos (Maziero, 2019). Pistelli ([S.d.]) apresenta que a criptologia é
uma ciência muito antiga, já presente no sistema de escrita hieroglífica dos egípcios, há quase 4 mil
anos. Ela “também foi usada na antiga Roma, onde os soldados simplesmente substituíam umas
letras por outras, tornando assim, impossível para os inimigos ler as mensagens, pois somente o
remetente e o destinatário possuíam o código capaz de decifrar o conteúdo das mensagens” (Paiva;
López, 2002). “Desde então vem sendo muito utilizada, principalmente para fins militares e
diplomáticos [...]. Sua utilização durante a Segunda Guerra, e a consequentemente quebra dos
códigos alemão e japonês, foi fundamental para o sucesso dos Aliados” (Pistelli, [S.d.], p. 1).

3.1 OBJETIVOS DA CRIPTOGRAFIA
“O uso da criptografia tem como objetivo garantir que uma mensagem ou informação só será
lida e compreendida pelo destinatário autorizado para isso” (Mota, 2006, p. 44).
Os objetivos do uso da criptografia são quatro, conforme a seguir descritos:
1. Confidencialidade: deve-se assegurar, por meio de encriptação dos dados, que só os
receptores autorizados tenham acesso às informações.
https://univirtus.uninter.com/ava/web/roa/

13/24

05/05/2022 22:56

UNINTER

2. Integridade: deve-se assegurar, por meio de assinatura digital, que a informação não
seja alterada durante o seu processo de transporte da informação.
3. Autenticação: o remetente e o receptor devem poder confirmar as identidades uns dos
outros, assim como a origem e o destino da informação, por meio de assinatura digital e
certificados.
4. Não recusa: o criador/remetente do documento deve poder assiná-lo de forma digital,
limitando legalmente a sua responsabilidade, por meio de assinatura digital e certificados.

3.2 TIPOS DE CRIPTOGRAFIA
Existem dois tipos básicos de criptografia: a criptografia simétrica e a criptografia assimétrica.
Para Cavalcante (2019), a criptografia simétrica ou de chave secreta foi o primeiro tipo de
criptografia criado. Funciona transformando um texto em uma mensagem cifrada, mediante definição
de uma chave secreta, que será utilizada, posteriormente, para descriptografar a mensagem,
tornando-a novamente um texto simples (Cavalcante, 2019). Os algoritmos simétricos usam chaves
simétricas e um algoritmo de bloco, como DES, Desx, Idea, RC2, RC4, Blowfish, para criptografar e
descriptografar dados. Ela tem por:
ÖVantagem – Rapidez na criptografia e decriptografia das informações.
ÖDesvantagem – A chave secreta deve ser transmitida ou comunicada para o receptor, tornando-a
mais vulnerável a roubo.
[...]
A Criptografia Assimétrica, [...] também conhecida como de chave pública, utiliza duas chaves,
uma para cifrar o texto ou mensagem, e outra para decifrar. Pode ser empregada para assinatura
digital e autenticação. É possível combinar a criptografia simétrica com a assimétrica, somando a
segurança com a rapidez.
Vantagens - mais segura que a criptografia simétrica, por não precisar comunicar o receptor a
chave necessária para decriptografar a mensagem e, pode ser utilizada em assinatura digital
Desvantagem - costuma ser mais lenta do que a criptografia simétrica (Celestino, 2005, p. 30-31).

Já a assinatura digital é um código, incluído na mensagem ou no texto, que identifica o
remetente de uma mensagem. A mensagem ou texto é criptografado(a) com uma chave privada,

https://univirtus.uninter.com/ava/web/roa/

14/24

05/05/2022 22:56

UNINTER

criando uma espécie de assinatura. Para essa mensagem ser descriptografada, é utilizada uma
chave pública.

3.3 PUBLIC KEY INFRASTRUCTURE (PKI)
A UFRGS ([20--]) define que a public key infrastructure (PKI) se refere a um processo que utiliza
chaves públicas e certificados digitais para garantir a segurança do sistema e confirmar a identidade
de seus usuários. Rodrigues (2009) apresenta o seguinte exemplo:
uma empresa pode usar a PKI para controlar o acesso a sua rede de computadores. No futuro, as
empresas poderiam usar a PKI para controlar o acesso a tudo, desde a entrada nos prédios até a
obtenção de mercadorias.
A PKI permite que pessoas e empresas realizem negócios em particular. Os funcionários podem
enviar e-mails pela Internet com segurança, sem se preocupar com a sua interceptação por um
concorrente. As empresas podem construir sites privativos, enviando informações somente para
clientes conhecidos.
A PKI baseia-se em um sistema de confiança, no qual duas partes (pessoas ou computadores)
confiam mutuamente em uma CA (Autoridade Certificadora) para verificar e confirmar a identidade
de ambas as partes.
Por exemplo, a maioria das pessoas e empresas confia na validade de uma carteira de habilitação
de motorista ou em um passaporte. Isto ocorre porque elas confiam na forma pela qual o governo
emite estes documentos. Entretanto, uma caderneta de estudante é normalmente aceita como
prova de sua identificação apenas para a escola que a emite. O mesmo vale para os Certificados
Digitais.
Com a PKI, ambas as partes de uma transação (seja ela um banco on-line e seus clientes ou um
empregador e seus funcionários) concordam em confiar na CA que emite seus Certificados
Digitais.
Normalmente, o aplicativo de software que utiliza seu Certificado Digital tem algum mecanismo
para confiar nas CAs. Por exemplo, um navegador contém uma lista das CAs em que confia.
Quando é apresentado ao navegador um Certificado Digital (por exemplo, de um shopping on-line
realizando comércio seguro), ele consulta a CA que emitiu o Certificado Digital. Se a CA estiver na
lista de CAs confiáveis, o navegador aceita a identidade do site da Web e exibe a página da Web.
Entretanto, se a CA não estiver na lista de CAs confiáveis, o navegador exibe uma mensagem de
aviso que lhe pergunta se você deseja confiar na nova CA. Geralmente seu navegador lhe dá
opções para confiar permanente ou temporariamente na CA ou não confiar em absoluto. Como
usuário, você tem controle sobre em qual(is) CA(s) deseja confiar, porém o gerenciamento da
confiança é feito pelo aplicativo de software (neste exemplo, pelo navegador). (Rodrigues, 2009)
https://univirtus.uninter.com/ava/web/roa/

15/24

05/05/2022 22:56

UNINTER

TEMA 4 – AUTENTICAÇÃO, GERENCIAMENTO E CONTROLE DE
ACESSO
“Você não pode confiar em um código que você mesmo não tenha criado inteiramente (em
especial, códigos de empresas que empregam pessoas como eu)”, diz Thompson (1983, citado por
Deitel; Deitel; Choffnes, 2017).
Segurança de computadores aborda a questão da prevenção do acesso não autorizado a recursos
e informações mantidos em computadores. Sistemas de computador devem fornecer mecanismos
para gerenciar ameaças à segurança originadas tanto externamente ao computador (via conexão
de rede), quanto internamente (via usuários e softwares mal-intencionados). Segurança de
computador comumente abrange garantir a privacidade e a integridade de dados sensíveis,
restringir a utilização de recursos de computação e oferecer proteção contra tentativas de
incapacitar o sistema. Proteção abrange mecanismos que protegem recursos como hardware e
serviços de sistemas operacionais contra ataques. A segurança está se tomando rapidamente um
dos tópicos mais ricos e desafiadores da computação; a segurança do sistema operacional está no
âmago de um sistema de computação seguro. (Ribeiro, 2005, p. 153)

4.1 AUTENTICAÇÃO
Para Ribeiro (2005, p. 157-159, grifos nossos),
Identificar usuários e as ações que eles têm permissão de realizar é vital para manter a segurança
de um sistema de computador. Um usuário pode ser identificado por:
• Uma característica exclusiva da pessoa (impressões digitais, impressões vocais, varredura de
retina e assinaturas) [algo que o usuário é];
• Propriedades de um item (crachás, carteiras de identidade, chaves e cartões inteligentes) [algo
que o usuário tem]; e
• Conhecimento do usuário (senhas, números de identificação pessoal (PINs) e combinações de
travas) [algo que o usuário sabe].
[...]
O esquema de autenticação mais comum é uma simples proteção por senha, onde o usuário
escolhe e memoriza um código secreto e o registra no sistema para obter admissão a um recurso
ou sistema. A maioria dos sistemas suprime a exibição da senha na tela, substituindo seu texto por
caracteres mascaradores (que apresentam caracteres fictícios – quase sempre asteriscos — no
lugar dos da senha) ou ocultando a entrada da senha.

https://univirtus.uninter.com/ava/web/roa/

16/24

05/05/2022 22:56

UNINTER

A proteção por senha introduz diversos pontos fracos em um sistema seguro. Usuários tendem a
escolher senhas fáceis de lembrar, como o nome de um cônjuge ou de um animal de estimação.
Alguém que tenha obtido informações pessoais do usuário poderia tentar o acesso ao sistema
(login) várias vezes, usando senhas correspondentes às características do usuário; várias
tentativas repetidas podem resultar em uma violação da segurança. Alguns sistemas antigos
limitavam o usuário a senhas curtas; esses eram facilmente comprometidos simplesmente pela
tentativa de todas as senhas possíveis – uma técnica conhecida por quebra por força bruta.
A maioria dos sistemas de hoje exige senhas mais longas que incluem caracteres alfabéticos e
numéricos para frustrar as tentativas de invasão. Alguns sistemas até mesmo proíbem a utilização
de palavras do dicionário como valores de senhas. Contudo, senhas longas não melhoram
necessariamente a segurança de um sistema; se elas forem difíceis de lembrar os usuários ficarão
mais inclinados a anotá-las, facilitando a obtenção da senha por um intruso.
A invasão das defesas de um sistema operacional não precisa resultar necessariamente em um
comprometimento significativo da segurança. Por exemplo, suponha que um intruso consiga obter
acesso à lista mestra de senhas de um sistema. Se o arquivo de senhas estivesse armazenado
em texto comum, essa invasão permitiria ao intruso o acesso a qualquer informação do sistema,
assumindo a identidade de qualquer usuário. Para reduzir a efetividade de um arquivo de senhas
roubado, muitos sistemas operacionais criptografam o arquivo de senhas ou armazenam apenas
valores de hash para cada senha. Nesse caso, uma cópia do arquivo de senhas é de pouca
utilidade, a menos que o intruso possa decriptá-las. Para frustrar ainda mais as tentativas de obter
senhas, vários sistemas empregam o salpicamento de senha; uma técnica que insere caracteres
em várias posições da senha antes de criptografá-la [...]. Uma pequena quantidade de
salpicamento pode alterar significativamente um texto cifrado, mesmo quando se estiver utilizando
uma cifra fraca, como uma cifra de substituição (codificação base 64). O salpicamento pode evitar
que intrusos obtenham uma chave criptográfica com base em padrões produzidos por senhas
comuns após a criptografia.
[...]
Usuários são incentivados a trocar suas senhas frequentemente; mesmo que um intruso obtenha
uma senha, ela pode ser trocada antes que algum dano real seja causado. Alguns sistemas
exigem que os usuários escolham novas senhas periodicamente. Infelizmente, alguns usuários
reutilizarão duas ou três senhas ciclicamente, o que reduz a segurança geral. Como resposta,
vários sistemas de autenticação proíbem a reutilização das senhas escolhidas mais recentemente
por um usuário.
Uma defesa simples contra a quebra por força bruta e tentativas repetidas de entrar a senha é
limitar o número de tentativas de acesso ao sistema que podem ser iniciadas em um certo período
de tempo de um único terminal ou estação de trabalho (ou de uma única conta). É claro que as
pessoas cometem erros ao tentarem obter acesso ao sistema, mas não é razoável que alguém
que saiba a senha correta tenha de fazer dezenas, centenas ou milhares de tentativas. Portanto,
https://univirtus.uninter.com/ava/web/roa/

17/24

05/05/2022 22:56

UNINTER

um sistema pode permitir três ou quatro tentativas e, então, desconectar o terminal durante vários
segundos ou minutos. Após um período de espera, o terminal pode ser reconectado. (Ribeiro,
2005, p. 156-158, grifos nossos)

4.2 CONTROLE DE ACESSO
Na qualidade de gerenciador de recursos, o sistema operacional deve se defender
cuidadosamente contra utilizações não intencionais e maliciosas de recursos de computação.
Consequentemente, os sistemas operacionais são projetados para proteger serviços de sistema
operacional e informações sensíveis contra usuários e/ou softwares que obtiveram acesso aos
recursos do computador. Direitos de acesso protegem recursos e serviços do sistema contra
usuários potencialmente perigosos, restringindo ou limitando as ações que podem ser executadas
no recurso. Esses direitos normalmente são gerenciados por listas de controle de acesso ou listas
de capacidades.
[...]
Uma lista de controle de acesso armazena os mesmos dados que uma matriz de controle de
acesso, mas mantém um registro somente das entradas que especificam um direito de acesso. A
lista de controle de acesso de um sistema pode ser baseada nas linhas (os sujeitos) ou nas
colunas (os objetos) de uma matriz. Para cada objeto de um sistema operacional, uma lista de
controle de acesso contém entradas para cada sujeito e os privilégios associados àquele sujeito
em relação àquele objeto. Quando um sujeito tenta acessar um objeto, o sistema procura pela lista
de controle de acesso para aquele objeto para identificar os privilégios daquele sujeito.
O problema desse método está na ineficiência com a qual o sistema operacional determina os
privilégios de usuário para determinado objeto. A lista de controle de acesso para cada objeto
contém uma entrada para cada sujeito com privilégios para aquele objeto – uma lista
potencialmente grande. Toda vez que um objeto for acessado, o sistema deve pesquisar a lista de
sujeitos para encontrar os privilégios adequados. Quando se usam listas de controle de acesso, é
difícil determinar quais direitos de acesso pertencem a um certo domínio de proteção; é preciso
pesquisar a lista de acesso para cada objeto, procurando entradas relativas àquele objeto
particular. (Ribeiro, 2005, p. 161-164, grifos do original)

TEMA 5 – GERENCIAMENTO E PROTEÇÃO DE USUÁRIOS
A chave para a segurança do sistema operacional é controlar o acesso a dados e recursos
internos. Direitos de acesso definem como vários sujeitos podem acessar vários objetos. Sujeitos
podem ser usuários, processos, programas ou outras entidades. Objetos são recursos como
hardware, software e dados; podem ser objetos físicos como discos, processadores ou memória
principal. Também podem ser objetos abstratos como estruturas de dados, processos ou serviços.
https://univirtus.uninter.com/ava/web/roa/

18/24

05/05/2022 22:56

UNINTER

Sujeitos também podem ser objetos do sistema; um sujeito pode ter direitos de acesso a um outro.
Sujeitos são entidades ativas; objetos são entidades passivas. À medida que um sistema executa,
sua população de sujeitos e objetos tende a mudar. A maneira pela qual um sujeito pode ter
acesso a um objeto é denominada privilégio e pode incluir leitura, escrita e impressão.
Objetos devem ser protegidos contra sujeitos. Caso fosse permitido que um processo tivesse
acesso a todos os recursos de um sistema, um usuário poderia, inadvertida ou malintencionadamente, comprometer a segurança do sistema ou causar a queda de outros
programas. Para impedir que tais eventos ocorram, cada sujeito deve obter autorização para
acessar objetos dentro de um sistema.
Um domínio de proteção é uma coleção de direitos de acesso. Cada direito de acesso de um
domínio de proteção é representado como um par ordenado com campos para o nome do objeto e
seus privilégios correspondentes. Um domínio de proteção é exclusivo de um sujeito. Por exemplo,
se um usuário puder ler e escrever para o arquivo example.txt, o par ordenado correspondente
para o direito de acesso desse usuário poderá ser representado por <example.txt/ {read, write}>.
Os direitos de acesso mais comuns são ler, escrever e executar. Alguns sujeitos também podem
conceder direitos de acesso a outros sujeitos. Na maioria dos sistemas de computação, o
administrador possui todos os direitos de acesso e é responsável pelo gerenciamento dos direitos
de outros usuários.
Direitos de acesso podem ser copiados, transferidos ou propagados de um domínio para outro.
Copiar um direito de acesso implica simplesmente conceder um direito de um usuário a outro
usuário. Quando um direito de acesso é transferido do sujeito A para o sujeito B, o direito de
acesso do sujeito A é revogado quando a transferência for concluída. Propagar um direito de
acesso é similar a copiar um direito de acesso; contudo, além de compartilhar o direito de acesso
original, ambos os sujeitos também podem copiar o direito para outros sujeitos.
Quando um sujeito não precisa mais do acesso a um objeto, os direitos de acesso podem ser
revogados. Nesse caso surgem várias questões: a revogação deve ser imediata ou tardia? A
revogação deve ser aplicada a todos os objetos ou apenas a alguns? A revogação deve ser
aplicada a sujeitos específicos ou a todo domínio? A revogação deve ser permanente ou
temporária? Cada implementação de gerenciamento de direitos de acesso aborda a revogação de
maneira diferente. (Ribeiro, 2005, p. 161-162, grifos do original)

5.1 GERÊNCIA DE PROTEÇÃO
A gerência de proteção de dados e usuários é outra importante tarefa de gestão de recursos.
Para Maziero (2019), “com computadores conectados em rede e compartilhados por vários usuários,
é importante definir claramente os recursos que cada usuário pode acessar, as formas de acesso
permitidas (leitura, escrita etc.) e garantir que essas definições sejam cumpridas”. Por exemplo, a
https://univirtus.uninter.com/ava/web/roa/

19/24

05/05/2022 22:56

UNINTER

proteção contra os ataques de negação de serviço (DoS, de denial of service[2]), comuns na
internet. É responsabilidade do sistema operacional do servidor detectar e impedir ataques como
esses, em que todos os recursos do sistema são monopolizados por um único usuário.
Ainda para Maziero (2019), para proteger os recursos do sistema contra acessos indevidos, é
necessário:
a. “definir usuários e grupos de usuários”;
b. “identificar os usuários que se conectam ao sistema”, mediante procedimentos de
autenticação;
c. “definir e aplicar regras de controle de acesso aos recursos”, relacionando todos os
usuários, recursos e formas de acesso e aplicando essas regras por meio de procedimentos
de autorização;
d. “registrar o uso dos recursos pelos usuários, para fins de auditoria e contabilização”.
Assim, um sistema operacional visa abstrair o acesso e gerenciar os recursos de hardware,
provendo aos aplicativos um ambiente de execução abstrato, no qual o acesso aos recursos se faz
através de interfaces simples, independentes das características e detalhes de baixo nível, e no qual
os conﬂitos no uso do hardware são minimizados (Maziero, 2019).
O controle de identidade é imprescindível para a segurança da informação e dos sistemas e
requer um tratamento especial. Diferentemente do ambiente natural, no mundo digital a simulação
de perfis ou identidades é algo relativamente simples, exigindo muito dos dispositivos e técnicas de
controle, pois são esses controles que garantirão a autorização e a autenticidade das operações,
além do não repúdio. Além dessa garantia, tais controles também têm que resistir ao roubo de
identidades, evitando que agentes ou usuários mal-intencionados possam simular ou passar-se por
alguém devidamente autorizado e, assim, realizar operações fraudulentas.
Os controles de acesso geralmente operam em conjunto com os controles de verificação para
estabelecer a devida autorização e garantir a autenticidade das operações. A maioria dos sistemas
baseia-se no conjunto identificação (ID) e senha (password). Porém, para muitas operações
críticas e o uso de informações sensíveis, esses controles não são suficientes.

https://univirtus.uninter.com/ava/web/roa/

20/24

05/05/2022 22:56

UNINTER

“Controles biométricos, certificados digitais e assinaturas eletrônicas complementam esses
controles, e cada vez mais é necessário o uso de técnicas e mecanismos que garantam a identidade
dos agentes”, mas que, ao mesmo tempo, permitam a “independência do ambiente, a flexibilidade e
a interatividade com diversas tecnologias e funcionalidades, além de um desempenho elevado”, em
um mundo extremamente veloz e cada vez mais conectado. O processo de identidade e autorização
é parte importante da proteção, especialmente no que diz respeito à autenticação do usuário remoto
– aquele que pleiteia o acesso à rede, aos recursos computacionais e à informação estando fora do
perímetro de segurança da organização (Paulo, 2020).
O processo de identificação, segundo Paulo (2020), precisa ser completado com verificação,
com base em processos de autenticação já apresentados:
algo que o indivíduo sabe: sua identidade (por meio de personal identification number – PIN) e
as suas senhas;
algo que o indivíduo possui: um token, uma chave criptográfica ou física ou um smart card;
algo que o indivíduo é: biometria estática, como a digital ou a íris;
algo que o indivíduo faz: biometria dinâmica, como por padrão de voz, caligrafia e taxa de
digitação.

FINALIZANDO
Nesta aula, foram apresentados os conteúdos que complementam a fundamentação teórica de
sistemas operacionais, com ênfase em gerência e proteção de usuários, com os conceitos e
definições de segurança apresentados no primeiro tema. No segundo tema, os riscos, as ameaças e
as vulnerabilidades dos sistemas operacionais foram analisados e definidos individualmente,
enfatizando a importância de manter os sistemas seguros. No tema seguinte, foi abrangida a
criptografia, assim como os seus objetivos e tipos, com destaque para o item 3.3, que descreve a
PKI. Na sequência, foram definidas e apresentadas a autenticação, o gerenciamento e o controle de
acesso, para, por fim, serem analisados o gerenciamento e a proteção de usuários.
Ao confiarmos o armazenamento e o desenvolvimento de informações nos arquivos ou mesmo
a segurança de acesso a um ambiente restrito, utilizando uma fechadura eletrônica, é fundamental
que lembremos que há um sistema operacional responsável por garantir a segurança desses
arquivos, pois, se houver algum código malicioso não tratado, criminosos podem se valer dessa
https://univirtus.uninter.com/ava/web/roa/

21/24

05/05/2022 22:56

UNINTER

vulnerabilidade e conseguir o acesso total e irrestrito ao sistema, abrindo facilmente a fechadura.
Portanto, o conhecimento das características dos sistemas operacionais é fundamental para o bom
funcionamento de todas as atividades desenvolvidas pelos computadores.
Em paralelo à leitura do texto desta aula, é muito importante que sejam consultadas as
referências indicadas e as atividades práticas sejam realizadas, pois a gestão da TI, que envolve
pessoas, empresas e indústrias, tem como principal aliado o sistema operacional e as ferramentas
aqui apresentadas.
Indicada em todos os tópicos, a especialização em sistemas operacionais específicos de
diferentes fabricantes, cada um com suas características, vantagens e desvantagens, permite aos
gestores a melhor e mais adequada escolha a cada situação de uso, obedecendo aos padrões e
normas internacionais, proporcionando o uso mais eficiente dos recursos e obtendo melhores
resultados.
Aproveite e bons estudos!

REFERÊNCIAS
ABNT – Associação Brasileira de Normas Técnicas. ABNT NBR ISO/IEC 27002:2013:
Tecnologia da informação – Técnicas de segurança – Código de prática para controles de segurança
da informação. Rio de Janeiro, 2013.
CELESTINO, P. Redes virtuais privadas. 90 f. Dissertação (Mestrado em Automação) –
Universidade

de

Taubaté,

Taubaté,

2005.

Disponível

em:

<http://livros01.livrosgratis.com.br/cp012541.pdf>. Acesso em: 31 out. 2020.
DEITEL, P. J.; DEITEL, H. M.; CHOFFNES, D. R. Sistemas operacionais. 3. ed. São Paulo:
Pearson, 2017.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: Editora UFPR, 2019.
MICHAELIS dicionário brasileiro da língua portuguesa. São Paulo: Editora Melhoramentos,
2015. Disponível em: <https://michaelis.uol.com.br/>. Acesso em: 31 out. 2020.

https://univirtus.uninter.com/ava/web/roa/

22/24

05/05/2022 22:56

UNINTER

MICROSOFT. Introducing Kernel Data Protection, a new platform security technology for
preventing

data

corruption.

Security,

8

jul.

2020.

Disponível

em:

<https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-newplatform-security-technology-for-preventing-data-corruption/>. Acesso em: 31 out. 2020.
MOTA, R. P. B. Extensões ao protocolo de comunicação EPCGlobal para tags classe 1
utilizando autenticação com criptografia de baixo custo para segurança em identificação por
radiofrequência. 91 f. Dissertação (Mestrado em Ciência da Computação) – Centro de Ciências
Exatas e de Tecnologia, Universidade Federal de São Carlos, São Carlos, 2006. Disponível em:
<https://repositorio.ufscar.br/bitstream/handle/ufscar/312/DissRPBM.pdf>. Acesso em: 31 out. 2020.
PAIVA, M. A. L.; LÓPEZ, V. C. O documento, a firma e o notário eletrônico. Jus.com.br, jan.
2002. Disponível em: <https://jus.com.br/artigos/2504>. Acesso em: 31 out. 2020.
PAULO, L. G. Segurança em sistemas de informação. [S.l], 2020.
PISTELLI,

D.

Criptografia.

[S.l.]:

Geek

Brasil,

[S.d.].

Disponível

em:

<http://www.josevalter.com.br/download/seguranca/Criptografia.pdf>. Acesso em: 31 out. 2020.
RIBEIRO, R. Sistemas operacionais: apostila. [S.l.]: [S.n.], ago. 2005. Disponível em:
<http://brunotoledoifmg.com/SO/Apostilas/Apostila%20Sistemas%20Operacionais.pdf>. Acesso em:
1 nov. 2020.
RODRIGUES, T. P. Entendendo PKI. Thiago Pereira Rodrigues Technology Blog, 12 ago.
2009.

Disponível

em:

<https://thiagoprodrigues.wordpress.com/2009/08/12/entendendo-pki/>.

Acesso em: 1 nov. 2020.
TREND

MICRO.

Ramsomware.

[S.l.],

[20--].

Disponível

em:

<https://www.trendmicro.com/vinfo/us/security/definition/ransomware>. Acesso em: 30 out. 2020.
UFRGS – Universidade Federal do Rio Grande do Sul. Certificado digital da UFRGS:
instalação.

Porto

Alegre,

[20--].

Disponível

em:

<http://www.ufrgs.br/tri/cpd/servicos/seguranca/certificado-digital-da-ufrgs-instalacao>. Acesso em: 1
nov. 2020.
ZANLUCA, A. Aumento de ataques cibernéticos alertam para a necessidade de se ter cuidados
com a proteção. Entreverbos, 24 jun. 2020. Disponível em: <https://www.entreverbos.com.br/singlehttps://univirtus.uninter.com/ava/web/roa/

23/24

05/05/2022 22:56

UNINTER

post/2020/06/24/Aumento-de-ataques-cibernéticos-alertam-para-a-necessidade-de-se-ter-cuidadoscom-a-proteção>. Acesso em: 30 out. 2020.

[1] “O ransomware é um tipo de malware (software malicioso) que impede ou limita o acesso
dos usuários ao sistema, bloqueando a tela do sistema ou bloqueando os arquivos dos usuários, a
menos que um resgate seja pago. As famílias mais modernas de ransomware, coletivamente
categorizadas como crypto-ransomware, criptografam certos tipos de arquivos em sistemas
infectados e obrigam os usuários a pagar pelo seu resgate por meio de certos métodos de
pagamento on-line, para obterem uma chave de descriptografia” (Trend Micro, [20--], tradução
nossa).
[2] Formas de ataque virtual que consistem na utilização de diversas técnicas para forçar um
servidor de rede a dedicar seus recursos para atender um determinado usuário, em detrimento dos
demais. Por exemplo, ao abrir milhares de conexões simultâneas em um servidor de e-mail, um
atacante pode reservar para si todos os recursos do servidor (processos, conexões de rede,
memória e processador), fazendo com que os demais usuários não sejam mais atendidos.

https://univirtus.uninter.com/ava/web/roa/

24/24



05/05/2022 22:57

UNINTER

SISTEMAS OPERACIONAIS
AULA 1

Prof. André Roberto Guerra
https://univirtus.uninter.com/ava/web/roa/

1/29

05/05/2022 22:57

UNINTER

CONVERSA INICIAL
Computadores são dispositivos eletrônicos criados para auxiliar nas tarefas do cotidiano das
pessoas. São máquinas incríveis, com grande poder de processamento e capacidade de
armazenamento. Os denominados sistemas de computação são compostos basicamente pelo
hardware (dispositivos físicos) e software (tarefas e rotinas previamente programadas) de forma
dependente, ou seja, só funcionam juntos, sendo praticamente inúteis sozinhos.
Essa interdependência é inicialmente comprovada pela necessidade de gerenciar os
componentes do hardware para funcionar corretamente, pois, quando ligados, os circuitos
eletrônicos ficam disponíveis para receber instruções ou tarefas, mas, se não forem enviadas,
tornam-se apenas uma peça decorativa.
Os sistemas computacionais eram a princípio grandes mainframes ou desktops, mas
atualmente, com o advento da internet das coisas (internet of things – IoT), eles estão presentes em
quase todos os dispositivos que utilizamos, como smartphones, tablets, smartwatches, smartTVs,
consoles de jogos, entre outros. Mesmo tão presentes no cotidiano das pessoas, poucos sabem
que, para que todos esses equipamentos nos auxiliem nas tarefas a que se propõem, são
necessárias rotinas de gestão e controle, implementadas em software e denominadas sistemas
operacionais.
Eles são responsáveis pela inicialização do hardware pelo kernel, e também pelo controle e
gestão segura dos dispositivos, dos processadores (CPU), das memórias e da entrada e saída de
dados. Também é responsável pela gestão e pelo controle do armazenamento e do uso de arquivos,
escalonamento de tarefas e gerenciamento de processos e recursos. Em síntese, é um grande
gestor das atividades do computador que interage com o usuário.

https://univirtus.uninter.com/ava/web/roa/

2/29

05/05/2022 22:57

UNINTER

É importante conhecer e entender essas tarefas de gestão e seus conceitos relacionados para
compreendermos o que é necessário para escolher, instalar, configurar e administrar sistemas
operacionais, desde a inicialização até a utilização pelo usuário final.
Nesta disciplina, além de desenvolver as competências necessárias para essas atividades,
apresentaremos e definiremos diversas outras rotinas. O conteúdo previsto contempla inicialmente
os conceitos e as definições de sistema operacional, numa visão geral, com um breve histórico e
evolução, apresentando seus objetivos e funções. Também apresentaremos sua classificação pela
arquitetura e pelos tipos e exemplos de sistemas operacionais.
Seguindo a definição de gestão apresentada, nesta disciplina veremos a gerência:
De processador e de processos;
De memória;
De dispositivos de entrada e saída;
De arquivos;
De proteção de usuários.
E os temas desta aula são:
1. Conceitos e definições de sistema operacional – visão geral;
2. Histórico e evolução;
3. Objetivos e funções;
4. Arquitetura e classificação;
5. Tipos e exemplos.
Aproveite o conteúdo e bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES INICIAIS – VISÃO GERAL
Segundo Tanenbaum e Bos (2016), sistema operacional é um programa que, do ponto de
vista do programador, acrescenta uma variedade de novas instruções e características acima e além
do que o nível ISA fornece. Normalmente, o sistema operacional é implementado, em grande parte,
em software, mas não há nenhuma razão teórica para não ser colocado em hardware, como
acontece com os microprogramas (quando estão presentes). Para abreviar, chamamos o nível que
https://univirtus.uninter.com/ava/web/roa/

3/29

05/05/2022 22:57

UNINTER

ele implementa de operating system machine (OSM), ou seja, “nível de máquina de sistema
operacional”.
Stallings (2017) define sistema operacional como um programa que gerencia os recursos do
computador, fornece serviços para os programadores e estabelece uma ordem de execução de
outros programas. É essencial certo conhecimento sobre sistemas operacionais para entender os
mecanismos pelos quais a CPU controla o computador – em particular, o efeito das interrupções e
o gerenciamento da hierarquia de memória.
Sistema operacional é o software que controla a execução de programas num processador e
gerencia os recursos do computador. Diversas funções desempenhadas pelo sistema
operacional, incluindo as duas mais relevantes para estudar a arquitetura e organização de
computadores – escalonamento de processos e gerenciamento de memória –, só podem ser
executadas de modo rápido e eficiente se ele dispuser de um suporte adequado do hardware do
processador.
Quase todos os processadores dispõem desse suporte, em maior ou menor extensão, incluindo
hardware de gerenciamento de memória virtual e de gerenciamento de processos. Isso inclui
registradores de propósito especial e áreas de armazenamento temporário, além de um conjunto de
circuitos para tarefas básicas de gerenciamento de recursos.
assim, um sistema de computação é constituído basicamente de dois elementos
interdependentes: o hardware e o software. O primeiro é basicamente composto de circuitos
eletrônicos internos: CPU (processador), memórias (primárias e secundárias), portas de
comunicação (entrada/saída), entre outros, como os periféricos externos (teclado, mouse, monitor,
câmera, microfone, dispositivos USB etc.). O segundo, por sua vez, é composto basicamente de
duas categorias:
1. Software de aplicação, representado por programas destinados ao usuário do sistema, que
constitui a razão final de seu uso (exemplo: editores de texto, multimídia players, editores de
imagem, jogos etc.);
2. Software de sistema, que está entre os aplicativos e o hardware. Trata-se de uma camada de
software multifacetada e complexa, denominada genericamente de sistema operacional, como
ilustra a Figura 1.

https://univirtus.uninter.com/ava/web/roa/

4/29

05/05/2022 22:57

UNINTER

Figura 1 – Sistema operacional

Fonte: I000S_Pixels; Hani Suwaryo; Crystal Eye Studio; Marisha; Den Rozhnovsky; Weera.OTP; DND_Project;
Nerthuz/Shutterstock.

A Figura 1 apresenta o sistema operacional como uma fronteira, uma interface entre o hardware
e os aplicativos. É ele que gerencia e orienta a fantástica transformação de pulsos elétricos do
hardware (representados pelos binários 0 e 1) nas mais diversas aplicações.
São essenciais para o funcionamento de todos os sistemas de computação, desde os
smartphones aos supercomputadores. Mesmo sendo muitos os sistemas operacionais existentes,
eles têm e seguem as mesmas regras e princípios. Devido à sua complexidade e ao seu tamanho, o
aprendizado de sistemas operacionais é tido como algo reservado a especialistas ou hackers,
contudo, é na verdade essencial para todos os profissionais de computação, pois as ferramentas
implementadas nos algoritmos dos sistemas operacionais afetam diretamente o comportamento e o
desempenho das aplicações. São também responsáveis pelos serviços de rede e pela segurança do
sistema e dos utilizadores.

TEMA 2 – HISTÓRIA E EVOLUÇÃO

https://univirtus.uninter.com/ava/web/roa/

5/29

05/05/2022 22:57

UNINTER

A primeira geração de computadores – também chamada de Geração 0 – foi a geração dos
computadores mecânicos, acionados por engrenagens e manivelas, dependendo totalmente do
usuário – o operador do sistema. Todas as tarefas eram manuais, e ainda não havia recursos para
automatizá-las eletronicamente.
Descrever a história e a evolução dos sistemas operacionais e dos computadores é muito
conveniente pois, até a 3ª geração dos computadores (1965-1980), descrita pelo cientista Robert
Noyce na integração de circuitos – o chip –, os computadores dependiam exclusivamente do
conhecimento e da habilidade de seus operadores – os usuários. Foi somente na 3ª geração que os
sistemas operacionais iniciaram seu desenvolvimento, como descreveremos aqui.
Os computadores têm sua história descrita e apresentada em 6 gerações. As 3 primeiras são de
computadores sem sistemas operacionais. Eram as seguintes:
0. Mecânicos (1642-1945);
1. Válvulas (1945-1955);
2. Transistores (1955-1965).
As 3 gerações seguintes são as de computadores com sistemas operacionais:
3. Integração (1965-1980);
4. Muita integração (1980-?);
5. Computadores invisíveis (atualmente).

2.1 GERAÇÃO 0 (MECÂNICOS) (1642-1945): MÁQUINAS SEM SISTEMA
OPERACIONAL
Surgiram no século XVII e eram compostos exclusivamente de elementos mecânicos, com
grande rigidez nos programas a executar. Hoje são chamadas de máquina dedicadas. As Figuras 2,
3 e 4 ilustram alguns exemplos dessa geração:

Figura 2 – Calculadora de Pascal (1642)

https://univirtus.uninter.com/ava/web/roa/

6/29

05/05/2022 22:57

UNINTER

Crédito: © CC-20/Edal Anton Lefterov.

Figura 3 – Máquina diferencial Babbage (1823)

Crédito: © CC-20/GFDL CC-BY-SA.

Figura 4 – Máquina Hollerith (1886)

https://univirtus.uninter.com/ava/web/roa/

7/29

05/05/2022 22:57

UNINTER

Crédito: © CC-20/Adam Schuster.

A geração dos mecânicos tem como marco histórico a máquina de Turing.
Colossus: o primeiro computador, mas ainda considerado mecânico, foi criado em 1946 por
Allan Turing, semelhante a um autômato finito, com memória ilimitada e irrestrita. Era capaz de
fazer tudo que um computador real faz, entretanto não resolvia certos problemas. O modelo de
Turing usava uma fita infinita como memória, tendo uma cabeça de fita que podia se mover, ler e
escrever símbolos.
Inicialmente, a fita continha apenas a entrada, e todo o restante estava em branco. Para
armazenar informação, escrevia sobre a fita, e para ler informação escrita, movia a cabeça para a
posição em que a informação era escrita, continuando a computar até produzir uma saída. As saídas
“aceite” e “rejeite” eram obtidas entrando em estados designados de aceitação e rejeição. Se não
entrasse em estado de aceitação ou rejeição, continuava para sempre, sem parar.

2.2 GERAÇÃO 1 (VÁLVULAS) (1945-1955): COMPUTADORES ELETRÔNICOS,
AINDA SEM SISTEMA OPERACIONAL
Essa é a primeira geração de computadores modernos. As válvulas necessitavam de muito
tempo para aquecer e consumiam muita energia elétrica. Eram grandes, porém frágeis, sua
manutenção era cara, e sua programação, feita com a ligação de fios ou cartões. Seus circuitos
eram interligados por quilômetros de fios instalados manualmente, atingindo velocidades na ordem
de milissegundos (1/1.000).

https://univirtus.uninter.com/ava/web/roa/

8/29

05/05/2022 22:57

UNINTER

John Mauchley (1907-1980) e Presper Eckert (1919-1995) construíram o Eniac em 1946, o 1º
computador eletrônico.

Figura 5 – Eniac

Crédito: Everett Historical/Shutterstock.

Ele tinha 18 mil válvulas e 1,5 mil relés, pesava 30 toneladas e tinha 20 registradores.
Consumia 140 quilowatts, e sua programação era feita em 6 mil chaves (Figura 6).

Figura 6 – Operação do Eniac

Crédito: © CC-20/U.S. Army Photo.

O matemático John von Neumann (1903-1957) foi colaborador do projeto Eniac, cujo
aperfeiçoamento foi o IAS, referência ao local onde foi desenvolvido – o Institute for Advanced
Studies, da universidade de Princeton. Credita-se a von Newmann a definição de uma arquitetura de
computadores com programa armazenado, utilizado até hoje. A Figura 7 ilustra essa definição:
https://univirtus.uninter.com/ava/web/roa/

9/29

05/05/2022 22:57

UNINTER

Figura 7 – Arquitetura de von Neumann

Fonte: Guerra, 2020.

Ele é considerado o “pai” do computador, pois em sua arquitetura utiliza aritmética binária e a
organização em quatro unidades:
1. Memória;
2. Unidade aritmética e lógica;
3. Unidade de controle;
4. Parte de E/S.
A arquitetura de von Neumann apresenta computadores de programa armazenado,
armazenando dados e programas na memória, e com ciclo de instrução repetitivo, executando cada
instrução com base numa sequência de etapas programadas. As características básicas do IAS o
apresentam como fundamental no estudo de arquitetura de computadores. Suas especificações
continuam válidas até hoje e têm memória com mil posições, denominadas palavras, cada uma com
valor de 40 bits. Seu dados e suas instruções são representadas em binários e gravadas (memória);
21 instruções de 20 bits, com 2 campos de 8 bits (código de operação); e outro com 12 bits
(endereço) para localizar cada uma das mil palavras, com endereços de 000 a 999.

2.3 GERAÇÃO 2 – TRANSISTORES (1955-1965): OS PRIMEIROS PROJETOS
DE SISTEMA OPERACIONAL
John Bardeen (1908-1991), Walter Brattain (1902-1987) e William Shockley (1910-1989),
funcionários da AT&T, criaram o transistor. Com as mesmas funções das válvulas, mas com custo
menor, consumem menos energia, são mais rápidos e confiáveis, sendo utilizados até hoje.
https://univirtus.uninter.com/ava/web/roa/

10/29

05/05/2022 22:57

UNINTER

Nessa geração foram criados os barramentos, um conjunto de fios paralelos usados para
conectar os componentes de um computador. Trata-se de uma ruptura importante em relação à
arquitetura da máquina IAS, centrada na memória e, desde então, foi adotada pela maioria dos
computadores de pequeno porte.
Foi apenas em 1953 que se iniciou o desenvolvimento do primeiro sistema operacional – por
sua simplicidade, chamado de monitor –, desenvolvido pelos usuários do computador IBM 701, do
Centro de Pesquisas da General Motors, para tentar automatizar tarefas até então manuais.
Posteriormente, esse sistema seria reescrito para um computador IBM 704, pelo grupo de usuários
da IBM (Weizer, 1981).
Em 1961, o pesquisador Fernando Corbató, do Massachusetts Institute of Technology (MIT),
com seu grupo de pesquisa, anunciou o desenvolvimento do compatible time-sharing system
(CTSS), o primeiro sistema operacional com compartilhamento de tempo (Corbató; Daggett; Daley,
1962).

2.4 GERAÇÃO 3 – INTEGRAÇÃO (1965-1980): INÍCIO DOS SISTEMAS
OPERACIONAIS
Essa foi a geração das “famílias de computadores”: mesmo tipo de máquina, com diferentes
capacidades

e

preços.

Tinham

uma

unidade

de

controle

com

microprogramação

e

multiprogramação, e vários programas compartilhavam a memória e dividiam CPU.
Com alta capacidade de processamento, utilizavam 32 bits e instrução de 250 nanossegundos,
com memória de 16 Mbytes. Sua memória principal
era orientada a byte, com um conjunto de programas gerenciadores de recursos
de hardware – o sistema operacional.
Essa geração tornou-se muito importante pois, além do sistema operacional, integrou os
circuitos pelo chip. Em 1968, Robert Noyce e Gordon Moore fundaram a Intel Corporation, criadora
do chip de memória de 1 KB e da lei de Moore: a integração de transistores em circuito integrado
dobra a cada 24 meses, mantendo-se os custos.
Em 1965, a IBM lançou o OS/360, um sistema operacional avançado, com compartilhamento de
tempo e um excelente suporte a discos. No mesmo ano, um projeto conjunto entre MIT, General
https://univirtus.uninter.com/ava/web/roa/

11/29

05/05/2022 22:57

UNINTER

Electric (GE) e Bell Labs deﬁniu o multiplexed information and computing service (Multics), que por
décadas inﬂuenciou vários outros sistemas operacionais.
Em 1969, Ken Thompson e Dennis Ritchie, pesquisadores da Bell Labs, desenvolveram a
primeira versão do Unix.

2.5 GERAÇÃO 4 – MUITA INTEGRAÇÃO (1980-?): POPULARIZAÇÃO DOS
COMPUTADORES E DOS SISTEMAS OPERACIONAIS
Marcian Hoff Junior, engenheiro da Intel, criou o Intel 4004, um microprocessador de 4 bits e
108 KHz, que tinha 2.300 transistores, velocidade de 60 mil operações/s e preço inicial de US$ 200.
Desde 1980, a miniaturização dos componentes internos e os avanços se relacionaram à escala de
integração dos circuitos integrados. A partir daqui, os sistemas operacionais ganharam destaque e
tiveram sua importância reconhecida. É nessa geração que famosas empresas foram fundadas e
conceitos foram criados. Acompanhe.
O primeiro destaque é o lançamento do sistema operacional da empresa Microsoft, o MS-DOS,
em 1981. Três anos após, em 1984, a Apple lançou o Mac OS 1.0, desenvolvido para os
computadores da linha Macintosh, o primeiro sistema operacional a ter uma interface gráﬁca
incorporada ao sistema. No ano seguinte, a Microsoft lançou o aplicativo com interface gráﬁca MSWindows 1.0.
Em 1987, Andrew S. Tanenbaum, professor de computação e autor de vários best-sellers,
desenvolveu o Minix, um sistema operacional didático simpliﬁcado, baseado na API do Unix. No
mesmo ano, a IBM e a Microsoft apresentaram a primeira versão de um sistema multitarefa
destinado a substituir o MS-DOS e o Windows: o OS/2. A parceria foi rompida em seguida, e a IBM
deu sequência ao OS/2, enquanto a Microsoft investiu no Windows.

2.6 GERAÇÃO 5 (ATUAL): COMPUTADORES INVISÍVEIS
Tanenbaum e Bos (2016) definem nossa atual geração como a geração dos computadores
invisíveis. Foi dado esse nome porque antigamente se falava que, no futuro (que é hoje), os
computadores estariam por toda parte, embutidos nos mais diversos locais, executando inusitadas
funções, como abertura de portas, acendimento de luzes, enfim, escondidos nos componentes
(invisíveis).
https://univirtus.uninter.com/ava/web/roa/

12/29

05/05/2022 22:57

UNINTER

Em 1991, um estudante de graduação em ciência da computação, Linus Torvalds (aluno de
Tanenbaum), utilizou o Minix como base para iniciar o desenvolvimento do Linux.

Figura 8 – Logotipo do Linux

Fonte: Rose Carson/Shutterstock.

A Microsoft só retornou em 1993, com o lançamento do Windows NT, o primeiro sistema 32 bits
da empresa. No mesmo ano, houve o lançamento dos Unix de código aberto – FreeBSD e NetBSD
–, e a Apple lançou o Newton OS, considerado o primeiro sistema operacional móvel, com gestão de
energia e suporte para tela de toque.
Nos anos seguintes, muitos novos sistemas operacionais surgiram. Listamos alguns a seguir:
1995: Windows 95;
1996: Windows NT 4.0; Mac OS 7.6 (first officially-named Mac OS);
1998: Windows 98; Novell NetWare 5;
2000: Windows Millennium Edition; Windows 2000;
2001: Windows XP; Mac OS X Cheetah (v. 10.0) – o novo SO da Apple, com arquitetura
distinta de suas versões anteriores, derivada da família Unix BSD;
2006: Windows Vista;
2007: iPhone OS 1 – lançamento do sistema operacional iOS, derivado do sistema operacional
Darwin;
2008: Android 1.0 – SO baseado em Linux para dispositivos móveis;

https://univirtus.uninter.com/ava/web/roa/

13/29

05/05/2022 22:57

UNINTER

2009: Windows 7;
2011: Solaris 11 11/11;
2012: Windows 8; Windows Phone 8;
2013: Windows CE 8.0; BlackBerry 10;
2015: Windows 10;
2017: Windows 10 Mobile Fall Creators Update;
2018: Windows Server 2019; iOS 13.1 – iPadOS 13.1;
2019: macOS Catalina (v10.15);
2020: Linux 5.6; NetBSD 9.0; Android 11.
Apresentamos o registro histórico de apenas alguns destaques. Sugerimos que você consulte a
bibliografia para conhecer muitas outras datas e sistemas operacionais.

TEMA 3 – OBJETIVOS E FUNÇÕES
Agora veremos os objetivos básicos do sistema operacional, como ele é estruturado para
alcançá-los e quais desafios ele deve resolver.
Existe uma grande distância entre circuitos eletrônicos, dispositivos de hardware e os
programas aplicativos em software. Os circuitos são complexos, acessados por interfaces de baixo
nível (geralmente usando as portas de entrada/saída do processador), e muitas vezes suas
características e seu comportamento dependem da tecnologia usada em sua construção (Maziero,
2019).
Por exemplo, a forma de acessar dados em disco (HD ou SSD) via hardware de baixo nível
(Sata III) é muito diferente do acesso a dados semelhantes em cartão de memória ou leitores de
discos óticos (DVD ou blu-ray). Toda essa grande diversidade de hardware pode tornar-se uma
grande dificuldade para quem o utiliza (como desenvolvedores de aplicativo). Então é desejável que
todas essas características e diferenças tecnológicas sejam abstraídas e se tornem invisíveis aos
aplicativos e aos utilizadores do sistema computacional.
É aqui que entra em cena o sistema operacional. Trata-se de uma camada de software que
opera entre o hardware e os aplicativos, como vimos no Tema 1 e conforme a Figura 10. É um
software de estrutura ampla e complexa que incorpora aspectos de baixo nível (como drivers de
https://univirtus.uninter.com/ava/web/roa/

14/29

05/05/2022 22:57

UNINTER

dispositivos e gerência de memória física) e de alto nível (como softwares utilitários e interface
gráﬁca).

Figura 10 – Estrutura típica de sistema operacional (Android)

Fonte: Guerra, 2020.

Stallings (2017) descreve que o sistema operacional é um programa que controla a execução
de aplicativos e age como interface entre o usuário e o hardware do computador. Tem
basicamente dois objetivos:
1. Conveniência: um sistema operacional visa tornar mais conveniente o uso do computador;
2. Eficiência: um sistema operacional permite uma utilização mais eficiente dos recursos do
sistema.
Os objetivos básicos de um sistema operacional, descritos por Maziero (2019), podem ser
sintetizados em duas palavras-chave: abstração e gerência. Vejamos em detalhes seus principais
aspectos.
https://univirtus.uninter.com/ava/web/roa/

15/29

05/05/2022 22:57

UNINTER

Abstração de recursos: acessar os recursos de hardware de um sistema de computação pode
ser uma tarefa complexa, devido às características especíﬁcas de cada dispositivo físico e à
complexidade de suas interfaces. Assim, o sistema operacional deve deﬁnir interfaces abstratas
para os recursos do hardware, visando atender os seguintes objetivos:
Prover interfaces de acesso mais simples que as de baixo nível, para simpliﬁcar a
construção de aplicativos. Por exemplo: para ler dados de um disco rígido, um programador
de aplicação usa o conceito de arquivo, que implementa uma visão abstrata do disco rígido,
acessível por operações como open, read e close. Se tivesse que acessar o disco diretamente,
seria necessário manipular portas de entrada/saída e registradores com comandos para o
controlador de disco (sem falar na diﬁculdade de localizar os dados desejados dentro do
disco);
Tornar os aplicativos independentes do hardware. Ao deﬁnir uma interface abstrata de
acesso a um dispositivo de hardware, o sistema operacional desacopla o hardware dos
aplicativos e permite que ambos evoluam de forma mais autônoma. Por exemplo, o código de
um editor de textos não deve depender da tecnologia de discos utilizada no sistema;
Deﬁnir interfaces de acesso homogêneas para dispositivos com tecnologias distintas.
Com suas abstrações, o sistema operacional permite aos aplicativos usar a mesma interface
para dispositivos diversos. Por exemplo, um aplicativo acessa dados em disco por meio de
arquivos e diretórios, sem precisar se preocupar com a estrutura real de armazenamento dos
dados, que podem estar num disquete, num disco Sata, numa máquina fotográﬁca digital
conectada à porta USB, num CD ou mesmo num disco remoto, compartilhado pela rede.
O hardware e o software usados para fornecer aplicações aos usuários podem ser vistos sob a
forma de uma organização hierárquica (ou em camadas), conforme a Figura 11.

Figura 11 – Camadas e visões de um sistema de computação

https://univirtus.uninter.com/ava/web/roa/

16/29

05/05/2022 22:57

UNINTER

Fonte: Stallings, 2017.

O usuário final – que vai utilizar essas aplicações – geralmente não se interessa pela arquitetura
do computador nem pelos detalhes do hardware. Ele vê o sistema de computação como uma
aplicação, pois os aplicativos são a última camada entre o sistema e o usuário, trazendo assim a
interface entre eles.
Os softwares de aplicação (apps) são desenvolvidos numa linguagem de programação por um
analista/desenvolvedor. Se fossem escritos usando o conjunto de instruções do processador e, além
disso, tivessem também que controlar o hardware do computador, a tarefa de desenvolver
programas seria extremamente complexa, quase impossível.
Para facilitar essa tarefa, existe um conjunto de programas de sistema. Alguns desses
programas são conhecidos como utilitários, que implementam funções usadas frequentemente e
criam programas, gerenciam arquivos e controlam dispositivos de E/S. Um programador usa esses
recursos para desenvolver uma aplicação que, ao ser executada, invoca os utilitários para
desempenhar certas funções.
O software de sistema mais importante é o sistema operacional, que esconde os detalhes do
hardware do programador, fornecendo uma interface conveniente para o uso do sistema. Ele age
como um mediador, facilitando o acesso e o uso de aplicativos e serviços para o programador. O
sistema operacional tipicamente fornece serviços para as seguintes atividades, que descrevem
algumas de suas funções:
Criação de programas: o sistema operacional apresenta uma variedade de recursos e
serviços para auxiliar o programador a desenvolver programas, como editores e depuradores.

https://univirtus.uninter.com/ava/web/roa/

17/29

05/05/2022 22:57

UNINTER

Esses serviços tipicamente são oferecidos na forma de programas utilitários, que na verdade
não são parte do sistema operacional, mas podem ser acessados por ele;
Execução de programas: várias tarefas precisam ser cumpridas para um programa ser
executado. Instruções e dados devem ser carregados na memória principal. Dispositivos de
E/S e arquivos precisam ser inicializados, e outros recursos devem ser preparados. O sistema
operacional cumpre todas essas tarefas para o usuário;
Acesso a dispositivos de E/S: cada dispositivo de E/S tem seu próprio conjunto peculiar de
instruções ou sinais de controle para operação. O sistema operacional cuida dos detalhes do
uso de cada dispositivo, de modo que o programador possa pensar apenas em termos de
operações simples de leitura e de escrita;
Acesso controlado aos arquivos: no caso de arquivos, o controle deve incluir não apenas
um entendimento sobre a natureza do dispositivo de E/S (unidade de disco ou de fita), mas
também sobre o formato dos arquivos no meio de armazenamento. Mais uma vez, o sistema
operacional cuida dos detalhes. Além disso, no caso de sistemas usados simultaneamente por
vários usuários, ele fornece mecanismos de proteção para controlar o acesso aos arquivos;
Acesso ao sistema: no caso de sistemas compartilhados ou públicos, o sistema operacional
controla o acesso ao sistema como um todo e a recursos específicos também. A função de
acesso deve proteger o sistema contra o uso não autorizado, tanto para recursos quanto para
dados de usuários, e resolver conflitos em caso de contenção de um recurso;
Detecção e reação aos erros: diversos erros podem ocorrer durante a operação de um
sistema de computação, incluindo erros de hardware internos e externos, como erro de
memória e falha, ou mau funcionamento de dispositivo, além de vários erros de software, como
overflow em operação aritmética, tentativa de endereçar uma área de memória não permitida e
a impossibilidade de o sistema operacional atender à requisição de uma aplicação. Em cada
caso, o sistema operacional deve reagir no sentido de eliminar a condição de erro, com o
menor impacto possível sobre as aplicações em execução. Essa reação pode variar, desde
terminar a execução do programa que causou o erro até tentar executar novamente a
operação ou, simplesmente, relatar a ocorrência do erro à aplicação;
Monitoração: um bom sistema operacional mantém estatísticas de uso de vários recursos e
monitora parâmetros de desempenho, como o tempo de resposta. Em qualquer sistema, essa
informação é útil para antecipar a necessidade de futuros melhoramentos e para a sintonia do

https://univirtus.uninter.com/ava/web/roa/

18/29

05/05/2022 22:57

UNINTER

sistema, aumentando seu desempenho. Num sistema multiusuário, essa informação também
pode ser usada para tarifação, pela utilização de recursos.

3.1 SISTEMA OPERACIONAL COMO GERENTE DE RECURSOS – UM
OBJETIVO E UMA FUNÇÃO
Os aplicativos utilizam o hardware para atingir seus objetivos e tarefas, como criar, editar e
imprimir documentos, tocar músicas, exibir vídeos e imagens, ler e armazenar arquivos de dados e
informações, conectar-se à internet, entre outros. Num sistema com várias atividades simultâneas
(multitarefas), podem ocorrer conﬂitos na utilização do hardware, quando duas ou mais tarefas
precisam dos mesmos recursos para ser executadas. Uma das funções do sistema operacional é
deﬁnir políticas para gerenciar o uso dos recursos de hardware pelos aplicativos e resolver eventuais
disputas e conﬂitos.
O sistema operacional é o responsável por gerenciar o uso desses recursos. Portanto, é o
sistema operacional que controla o processamento, o armazenamento e a transferência de dados,
pois, gerenciando os recursos do computador, o sistema detém o controle das suas funções básicas.
Esse controle é exercido de maneira curiosa. Normalmente, pensamos no mecanismo de
controle como algo externo ao que é controlado ou, pelo menos, como algo que é uma parte distinta
e separada do que é controlado (por exemplo, um sistema de aquecimento residencial é controlado
por um termostato, que é completamente distinto do sistema de geração de calor e do aparato de
distribuição de calor). Não é o caso do sistema operacional que, como mecanismo de controle, é
incomum em dois aspectos:
O sistema operacional é um software como outro qualquer, sendo executado pelo processador,
e o sistema operacional frequentemente renuncia ao controle do processador para, em seguida,
obter o controle novamente; nada mais é do que um programa de computador. Semelhante a outros
softwares, ele contém instruções para o processador; a diferença-chave está na intenção do
programa.
O sistema operacional direciona o processador no uso dos recursos do sistema, assim como na
execução de outros programas. Mas, para que o processador execute outros programas, ele deve
interromper a execução do sistema operacional. Dessa maneira, ele libera o controle ao

https://univirtus.uninter.com/ava/web/roa/

19/29

05/05/2022 22:57

UNINTER

processador, para que ele possa executar algum trabalho “útil”, e então retoma o controle por tempo
suficiente para preparar o processador e executar uma próxima tarefa.
A Figura 12 apresenta os principais recursos gerenciados pelo sistema operacional:

Figura 12 – Camadas e visões de um sistema de computação

Fonte: Stallings, 2017.

Uma parte do sistema operacional reside na memória principal (RAM). Essa parte inclui o
núcleo (kernel), que contém as funções mais usadas pelo sistema operacional, além de outras
partes do sistema operacional em uso naquele momento. Outros dados e programas de usuário
ocupam o restante da memória principal (RAM). Então, a gestão da memória é feita com a alocação
controlada, em conjunto, pelo sistema operacional e pelo hardware de gerenciamento de memória
da CPU.
A gestão de recursos (dispositivos) de E/S é outra tarefa do sistema operacional, que decide
quando um dispositivo de E/S pode (ou não) ser usado pelo programa em execução, controlando o
acesso e o uso de arquivos.
A seguir, apresentamos exemplos de gestão de recursos do hardware.
A concorrência pela utilização do tempo de CPU (que futuramente estudaremos) é essencial
para que ocorra um grande número de tarefas pelo mesmo computador, que normalmente tem mais
tarefas a processar do que a quantidade de processadores disponíveis, complementando o conceito
de redução da ociosidade da CPU. O gerenciamento de recursos é fundamental para balancear sua
utilização, com distribuição justa entre os aplicativos e para que cada um deles seja executado na
velocidade adequada, cumprindo suas funções sem prejudicar as demais. No caso de um sistema
de computação com múltiplos processadores, essa decisão se estende a todos eles.
https://univirtus.uninter.com/ava/web/roa/

20/29

05/05/2022 22:57

UNINTER

Essa função é a gerência do processador – também conhecida como gerência de
processos, de tarefas ou de atividades –, que visa distribuir a capacidade de processamento de
forma justa entre as aplicações, evitando que uma aplicação monopolize esse recurso, respeitando,
assim, as prioridades definidas pelos usuários. O sistema operacional provê a ilusão de que existe
um processador independente para cada tarefa, o que facilita o trabalho dos programadores de
aplicações e permite construir sistemas mais interativos. Também faz parte da gerência de
atividades fornecer abstrações para sincronizar atividades interdependentes e prover formas de
comunicação entre elas.
O mesmo ocorre com a memória RAM, que também deve ser distribuída de forma justa entre as
aplicações. Aqui é descrita então a gerência de memória, cujo objetivo é fornecer a cada aplicação
uma área de memória própria, independente e isolada das demais aplicações, inclusive do sistema
operacional. O isolamento das áreas de memória das aplicações melhora a estabilidade e
segurança do sistema como um todo, pois impede aplicações com erros (ou aplicações maliciosas)
de interferir no funcionamento das demais aplicações. Além disso, caso a memória RAM existente
seja insuficiente para as aplicações, o sistema operacional pode aumentá-la de forma transparente
às aplicações, usando o espaço disponível num meio de armazenamento secundário (como um
disco rígido). Uma importante abstração construída pela gerência de memória (com o auxílio do
hardware) é a noção de memória virtual, que desvincula os endereços de memória vistos por cada
aplicação dos endereços acessados pelo processador na memória RAM. Com isso, uma aplicação
pode ser carregada em qualquer posição livre da memória, sem que seu programador se preocupe
com os endereços de memória em que ela irá executar.
A gerência de dispositivos, por sua vez, recebe destaque, pois cada periférico do computador
tem suas particularidades; assim, o procedimento de interação com uma placa de rede é
completamente diferente da interação com um disco rígido Sata. Todavia, existem muitos problemas
e abordagens em comum para o acesso aos periféricos. Por exemplo, é possível criar uma
abstração única para a maioria dos dispositivos de armazenamento, como cartão de memória, SSD,
CD-ROMs etc., na forma de um vetor de blocos de dados.
A função da gerência de dispositivos (também conhecida como gerência de entrada/saída) é
implementar a interação com cada dispositivo por meio de drivers e criar modelos abstratos que
permitam agrupar vários dispositivos similares sob a mesma interface de acesso. Outro recurso em
que o acesso deve ser mutuamente exclusivo (apenas um aplicativo por vez) é a impressão. O
https://univirtus.uninter.com/ava/web/roa/

21/29

05/05/2022 22:57

UNINTER

sistema operacional resolve essa questão utilizando o recurso de spooling (que estudaremos
futuramente), além de deﬁnir uma ﬁla de trabalhos a imprimir (print jobs), normalmente executados
de forma sequencial (first in, first out).
A gerência de arquivos é construída sobre a gerência de dispositivos e visa criar arquivos e
diretórios, definindo sua interface de acesso e as regras para seu uso. É importante observar que os
conceitos abstratos de arquivo e diretório são tão importantes e difundidos que muitos sistemas
operacionais costumam usá-los para permitir o acesso a recursos que nada têm a ver com
armazenamento. Exemplos disso são as conexões de rede (nos sistemas Unix e Windows, cada
socket TCP é visto como um descritor de arquivo, com o qual pode-se ler ou escrever dados) e as
informações internas do sistema operacional (como o diretório Proc do Unix).
A gerência de proteção de dados e usuários é outra importante tarefa de gestão de recursos.
Com computadores conectados em rede e compartilhados por vários usuários, é importante definir
claramente os recursos que cada usuário pode acessar, as formas de acesso permitidas (leitura,
escrita etc.), além de garantir que essas definições sejam cumpridas. Por exemplo, a proteção
contra os ataques de negação de serviço (denial of service – DoS[1]), comuns na internet. É
responsabilidade do sistema operacional do servidor detectar e impedir ataques como esses, em
que todos os recursos do sistema são monopolizados por um único usuário.
Para proteger os recursos do sistema contra acessos indevidos, é necessário:
Definir usuários e grupos de usuários;
Identificar os usuários que se conectam ao sistema por procedimentos de autenticação;
Definir e aplicar regras de controle de acesso aos recursos, relacionando todos os usuários,
recursos e formas de acesso, aplicando essas regras por procedimentos de autorização;
Registrar o uso dos recursos pelos usuários, para fins de auditoria e contabilização.
Assim, um sistema operacional visa abstrair o acesso e gerenciar os recursos de hardware,
provendo aos aplicativos um ambiente de execução abstrato, no qual o acesso aos recursos se faz
por interfaces simples, independentes das características e detalhes de baixo nível, minimizando os
conﬂitos no uso do hardware (Maziero, 2019).
As principais funções dos sistemas operacionais estão diretamente ligadas aos objetivos, pois,
para cumprir os objetivos de abstração e gerência, eles devem atuar em várias frentes. Cada um
https://univirtus.uninter.com/ava/web/roa/

22/29

05/05/2022 22:57

UNINTER

dos recursos do sistema tem suas particularidades, que impõem exigências específicas para
gerenciá-los e abstraí-los. Essas são as principais funcionalidades implementadas por um sistema
operacional típico.
Além dessas funcionalidades básicas oferecidas pela maioria dos sistemas operacionais, várias
outras se agregam aos sistemas modernos, para cobrir aspectos complementares, como a interface
gráfica, suporte de rede, fluxos multimídia, fontes de energia etc.
As funcionalidades do sistema operacional geralmente são interdependentes: por exemplo, a
gerência do processador depende de aspectos da gerência de memória, assim como a gerência de
memória depende da gerência de dispositivos e da gerência de proteção.

TEMA 4 – ARQUITETURA: CLASSIFICAÇÃO
É essencial conhecer as diferenças entre as arquiteturas dos sistemas operacionais para
escolher o mais adequado a cada situação. Algumas características básicas diferenciam os vários
tipos de sistemas operacionais, que
são classificados, segundo a arquitetura, quanto ao tempo de resposta e à entrada de dados
em sistema operacional, em lote (batch), interativos, tempo real e híbridos.
Essas características envolvem dois aspectos independentes. O primeiro especifica se o
sistema de computação é interativo ou é se um sistema de processamento em lotes (batch). Num
sistema interativo, o programador/usuário interage diretamente com o computador, normalmente
com um teclado e um monitor de vídeo, para requisitar a execução de tarefas (jobs) ou efetuar
transações. Além disso, ele pode, dependendo da natureza da aplicação, comunicar-se com o
computador durante a execução de uma tarefa.
Num sistema de processamento em lotes (batch), ocorre o oposto. O programa de um usuário é
agrupado com programas de outros usuários, e esse lote de programas é submetido à execução por
um operador de computador. Quando a execução do programa termina, os resultados são
impressos para ser entregues ao usuário. Hoje em dia são raros os sistemas que fazem
processamento exclusivamente em lotes, no entanto, é útil examiná-los brevemente para
entendermos melhor os sistemas operacionais atuais.

https://univirtus.uninter.com/ava/web/roa/

23/29

05/05/2022 22:57

UNINTER

O batch não exige interação com o usuário. A entrada de dados é feita por um dispositivo,
geralmente arquivos em disco, processamento de cálculos, compilações, ordenações e backups. Os
sistemas interativos – também conhecidos como sistemas de tempo compartilhado – geralmente
permitem a interação com usuário por meio de terminais, vídeo, teclado e mouse.
Com os sistemas de processamento em tempo real, o tempo de resposta é o fator principal do
sistema, utilizado em monitoramentos, controle de tráfego aéreo, de usinas nucleares etc. Os
sistemas híbridos são uma combinação de sistema batch com sistemas interativos.
Quanto à execução de tarefas, os sistemas operacionais são classificados como sistemas
monotarefa, multitarefa e multiprocessamento. Trata-se de outro aspecto independente, que
especifica se o sistema de computação emprega multiprogramação ou não.
A multiprogramação é uma tentativa de deixar o processador ocupado o maior tempo possível,
mantendo-o trabalhando em mais de um programa de cada vez. Diversos programas são
simultaneamente carregados na memória, e o tempo do processador é dividido entre eles. A
alternativa para esse tipo é um sistema de monoprogramação (uniprogramação), que executa
apenas um programa de cada vez.
Os sistemas monotarefa executam uma única aplicação de cada vez; já nos sistemas
multitarefa

várias

tarefas

concorrem

pelos

recursos

de

processamento.

Os

sistemas

multiprocessados têm duas ou mais CPUs interligadas, trabalhando em conjunto e fortemente ou
fracamente acopladas.
Os sistemas com multiprocessadores fortemente acoplados têm duas ou mais CPUs, que
compartilham uma única memória e são controladas por um único sistema operacional. Os
fracamente acoplados têm duas ou mais CPUs, cada uma com sua memória, sendo controladas
por sistemas operacionais independentes.
Quanto à estrutura, os sistemas operacionais são classificados basicamente como monolíticos,
em camadas, máquinas virtuais e cliente servidor.
Os

sistemas

operacionais

ainda

são

classificados

como

sistemas

operacionais

de

computadores de grande porte, servidores, computadores pessoais e sistemas operacionais
embarcados. Os embarcados são sistemas que controlam dispositivos móveis ou que não são
computadores, como micro-ondas, geladeiras, PDAs etc.
https://univirtus.uninter.com/ava/web/roa/

24/29

05/05/2022 22:57

UNINTER

Os sistemas operacionais modernos se dividem em várias camadas, e cada uma prova
serviços à camada superior mais próxima, protegendo a camada mais inferior, o núcleo do sistema
(ou kernel) do sistema operacional.
Os recursos do kernel são acessados por chamadas de sistema (system calls) de forma
protegida para não danificar o sistema. As instruções que têm o poder de comprometer o sistema
são conhecidas como instruções privilegiadas (modo kernel), enquanto as instruções não
privilegiadas não oferecem perigo.
Chamadas de sistema são os comandos de acesso às funções do sistema operacional e podem
ser divididos em chamadas: para gerenciar processos, para sinalização, para gerenciar arquivos,
manipular diretórios, proteger e gerenciar o tempo.

TEMA 5 – TIPOS E EXEMPLOS
Já classificados e denominados, os sistemas operacionais passam então a dividir-se em grupos
especializados, sendo mais indicados a certas demandas e menos a outras. A seguir, apresentamos
alguns tipos de sistemas operacionais. Muitos se encaixam em mais de um deles. Vejamos:
Batch (de lote): os sistemas operacionais mais antigos trabalhavam “por lote”, ou seja, todos
os programas a executar eram colocados numa fila, com seus dados e demais informações
para a execução. O processador recebia os programas e os processava sem interagir com os
usuários, o que permitia um alto grau de utilização do sistema. Atualmente, esse conceito se
aplica a sistemas que processam tarefas sem interação direta com os usuários, como os
sistemas de processamento de transações bancárias. Além disso, o termo “em lote” também é
usado para designar um conjunto de comandos que deve ser executado em sequência, sem
interferência do usuário. Exemplos: os clássicos IBM OS/360 e o VAX/VMS, entre outros;
De rede: um sistema operacional de rede deve ter suporte à operação em rede, ou seja, a
capacidade de oferecer às aplicações locais recursos localizados em outros computadores
conectados à rede, como arquivos e impressoras. Ele também deve disponibilizar seus
recursos locais aos demais computadores de forma controlada. A maioria dos sistemas
operacionais atuais oferece esse tipo de funcionalidade, dispensando exemplos;
Distribuído: num sistema operacional distribuído, os recursos de cada computador estão
disponíveis a todos que estejam conectados à rede, de forma transparente aos usuários. Ao
https://univirtus.uninter.com/ava/web/roa/

25/29

05/05/2022 22:57

UNINTER

lançar uma aplicação, o usuário interage com sua interface, mas não sabe onde está
executando ou armazenando seus arquivos: o sistema é quem decide, de forma transparente
ao usuário. Sistemas operacionais distribuídos já existem há muito tempo (como o Amoeba)
(Tanenbaum et al., 1991); recentemente, os ambientes de computação em nuvem têm
implementado esse conceito. Numa aplicação cloud (nuvem), o usuário interage com a
interface da aplicação num computador ou telefone, mas não tem uma visão clara das
máquinas em que seus dados estão sendo processados e armazenados. Exemplo: AWS
(Amazon Web Services) e Docker;
Multiusuário: um sistema operacional multiusuário deve suportar a identificação do “dono” de
cada recurso dentro do sistema (arquivos, processos, áreas de memória, conexões de rede) e
impor regras de controle de acesso para impedir o uso desses recursos por usuários não
autorizados. Essa funcionalidade é fundamental para a segurança dos sistemas operacionais
de rede e distribuídos. Grande parte dos sistemas atuais são multiusuários;
Servidor: um sistema operacional servidor deve permitir a gestão eficiente de muitos recursos
(disco, memória, processadores), impondo prioridades e limites sobre o uso dos recursos pelos
usuários e seus aplicativos. Normalmente um sistema operacional servidor também tem
suporte à rede e aos multiusuários. Exemplos: Windows Server 2019 e Oracle Linux Server;
Desktop: um sistema operacional “de mesa” é voltado ao atendimento do usuário doméstico
ou corporativo para atividades corriqueiras, como editar textos e gráficos, e reproduzir mídia.
Suas principais características são a interface gráfica, o suporte à interatividade e a operação
em rede. Exemplos de desktops: Windows 10, Linux e macOS X;
Móvel: um sistema operacional móvel é usado em equipamentos de uso pessoal compactos,
como smartphones e tablets. Nesse contexto, as principais prioridades são a gestão eficiente
da energia (bateria), a conectividade nos diversos tipos de rede (wi-fi, GSM, bluetooth, NFC
etc.) e a interação com uma grande variedade de sensores (GPS, giroscópio, luminosidade,
tela de toque, leitor de digitais etc.). Android e iOS são exemplos dessa categoria;
Embarcado: um sistema operacional é dito embarcado (embutido ou embedded) quando é
construído para operar sobre um hardware com poucos recursos de processamento,
armazenamento e energia. Aplicações típicas desse tipo de sistema aparecem em sistemas de
automação e controladores automotivos, equipamentos eletrônicos de uso doméstico (leitores
de DVD, TVs, micro-ondas, centrais de alarme etc.). Muitas vezes um sistema operacional
embarcado se apresenta na forma de uma biblioteca a ser ligada ao programa da aplicação
https://univirtus.uninter.com/ava/web/roa/

26/29

05/05/2022 22:57

UNINTER

durante sua compilação. LynxOS, TinyOS, Contiki e VxWorks são exemplos de sistemas
operacionais embarcados;
Tempo real: são sistemas em que o tempo é essencial. Ao contrário da ideia usual, um
sistema operacional de tempo real não precisa ser necessariamente ultrarrápido; sua
característica essencial é ter um comportamento temporal previsível, ou seja, seu tempo de
resposta deve ser previsível no melhor e no pior caso de operação. A estrutura interna de um
sistema operacional de tempo real deve ser construída de forma a minimizar esperas e
latências imprevisíveis, como tempos de acesso a disco e sincronizações excessivas.
Exemplos de sistemas operacionais de tempo real incluem o QNX, RT-Linux e VxWorks.
Muitos sistemas embarcados têm características de tempo real, e vice-versa. Existem sistemas
de tempo real críticos (hard real-time systems), nos quais a perda de um prazo pelo sistema pode
perturbar seriamente o sistema físico sob seu controle, com graves consequências humanas,
econômicas ou ambientais. Exemplos desse tipo de sistema são o controle de funcionamento de
uma turbina de avião ou um freio ABS.
Por outro lado, nos sistemas de tempo real não críticos (soft real-time systems), a perda de um
prazo é perceptível e degrada o serviço prestado, sem maiores consequências. Exemplos desse tipo
de sistema são os softwares de reprodução de mídia: em caso de atrasos, podem ocorrer falhas na
música que está sendo tocada.

FINALIZANDO
Nesta aula apresentamos os conteúdos iniciais de sistemas operacionais. No Tema 1,
enfatizamos os conceitos e as definições por uma visão geral; no Tema 2, o histórico e a evolução
dos sistemas operacionais, utilizando uma linha do tempo em paralelo à história e à evolução dos
computadores, descritas em suas gerações, visualizando as gerações das máquinas e seus
sistemas operacionais em cada período da história.
No Tema 3, vimos os objetivos, funções e princípios fundamentais que estabelecem as
atividades desenvolvidas pelos sistemas operacionais. O destaque desse tema é o item 3.1, que
descreve o sistema operacional como gerente de recursos, seu principal objetivo e função, pois ele é
responsável por gerenciar o uso dos recursos computacionais. As principais atividades de gestão

https://univirtus.uninter.com/ava/web/roa/

27/29

05/05/2022 22:57

UNINTER

foram descritas nesse tema e servirão como base para entendermos os temas das aulas seguintes,
quando estudarmos os processos (tarefas) de gestão.
Na sequência, definimos e apresentamos a classificação e a arquitetura dos sistemas
operacionais para, em seguida, finalizar o conteúdo introdutório com a apresentação de tipos e
exemplos atuais, permitindo o conhecimento suficiente para a escolha correta de sistemas
operacionais adequados às necessidades de cada situação do cotidiano, nos mais diversos
ambientes.
Enfim, compreender esses conceitos é o princípio para entender as atividades desenvolvidas
pelos sistemas computacionais. Assim, futuramente ampliaremos nosso conhecimento com os
conceitos das principais atividades de gerência feitas pelos sistemas operacionais, individualmente
apresentadas e descritas.

REFERÊNCIAS
ARPACI-DUSSEAU, R.; ARPACI-DUSSEAU, A. Operating systems: three easy pieces.
Madison: Arpaci-Dusseau Books, 2014.
CORBATÓ, F.; DAGGETT, M.; DALEY, R. An experimental time-sharing system. In:
PROCEEDINGS OF THE SPRING JOINT COMPUTER CONFERENCE, 1., New York. Anais… New
York: ACM, 1962.
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. Rio de Janeiro:
LTC, 2007.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: UFPR, 2019.
SILBERSCHATZ, A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.
SILBERSCHATZ, A.; GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro: Campus, 2016.
STALLINGS, W. Operating systems: internals and design principles. 9. ed. London: Pearson,
2017.
https://univirtus.uninter.com/ava/web/roa/

28/29

05/05/2022 22:57

UNINTER

TANENBAUM, A. S.; BOS, H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.
TANENBAUM, A. S. et al. The Amoeba distributed operating system – a status report.
Computer Communications, v. 14, p. 324-335, jul. 1991.
TANENBAUM, A. S.; WOODHULL, A. S. Sistemas operacionais: projeto e implementação. 3.
ed. Porto Alegre: Bookman, 2008.
WEIZER, N. A history of operating systems. Datamation, [S.l.], p. 119-126, jan. 1981.

[1] Formas de ataque virtual que utilizam diversas técnicas para forçar um servidor de rede a
dedicar seus recursos para atender um determinado usuário em detrimento dos demais. Por
exemplo, ao abrir milhares de conexões simultâneas num servidor de e-mail, um atacante pode
reservar para si todos os recursos do servidor (processos, conexões de rede, memória e
processador), fazendo com que os demais usuários não sejam mais atendidos.

https://univirtus.uninter.com/ava/web/roa/

29/29




-------------------------------------------------------------------------------------
Python

Lógica de computador

Já reparou que as condições que utilizámos até agora têm sido muito simples, para não dizer bastante primitivas? As condições que utilizamos na vida real são muito mais complexas. Vejamos esta frase:

Se tivermos algum tempo livre, e o tempo estiver bom, vamos dar um passeio.

Utilizámos a conjunção and, o que significa que ir dar um passeio depende do cumprimento simultâneo destas duas condições. Na linguagem da lógica, tal ligação de condições é chamada uma conjunção. E agora outro exemplo:

Se estiveres no centro comercial ou eu estiver no centro comercial, um de nós vai comprar um presente para a mãe.

A aparência da palavra or significa que a compra depende de pelo menos uma destas condições. Em lógica, tal composto é chamado uma disjunção.

É evidente que o Python deve ter operadores para construir conjunções e disjunções. Sem eles, o poder expressivo da linguagem ficaria substancialmente enfraquecido. Eles são chamados operadores lógicos.

and

Um operador de conjunção lógica em Python é a palavra and. É um operador binário com uma prioridade que é inferior à expressa pelos operadores de comparação. Permite-nos codificar condições complexas sem o uso de parêntesis como esta:

counter > 0 and value == 100

O resultado fornecido pelo operador and pode ser determinado com base na tabela da verdade.

Se considerarmos a conjunção de A e B, o conjunto de valores possíveis de argumentos e valores correspondentes da conjunção parece ser o seguinte:

Argumento A	Argumento B	A e B
False	False	False
False	True	False
True	False	False
True	True	True

or
Um operador de disjunção é a palavra or. É um operador binário com uma prioridade inferior a and ( assim como + comparado com *). A sua tabela de verdade é a seguinte:


Argumento A	Argumento B	A ou B
False	False	False
False	True	True
True	False	True
True	True	True

not
Além disso, há outro operador que pode ser aplicado para construir condições. É um operador unário que executa uma negação lógica. O seu funcionamento é simples: transforma a verdade em falsidade e a falsidade em verdade.

Este operador é escrito como a palavra not, e a sua prioridade é muito alta: a mesma que o unário + e -. A sua tabela de verdade é simples:

Argumento	not Argumento
False	True
True	False

Expressões lógicas
Vamos criar uma variável chamada var e atribuir 1 a ela. As seguintes condições são equivalentes em pares:

# Example 1:
print(var > 0)
print(not (var <= 0))


# Example 2:
print(var != 0)
print(not (var == 0))


Pode estar familiarizado com as leis de De Morgan. Dizem que:

A negação de uma conjunção é a disjunção das negações.

A negação de uma disjunção é a conjunção das negações.


Vamos escrever a mesma coisa usando Python:

not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)


Note-se como os parêntesis foram utilizados para codificar as expressões - colocámo-los lá para melhorar a legibilidade.

Devemos acrescentar que nenhum destes operadores de dois argumentos pode ser utilizado sob a forma abreviada conhecida como op=. Vale a pena recordar esta exceção.

Valores lógicos vs. bits únicos
Os operadores lógicos tomam os seus argumentos como um todo, independentemente da quantidade de bits que contenham. Os operadores só estão conscientes do valor: zero (quando todos os bits são redefinidos) significa False; não zero (quando pelo menos um bit está definido) significa True.

O resultado das suas operações é um destes valores: False ou True. Isto significa que este snippet irá atribuir o valor True à variável j se i não for zero; caso contrário, será False.

i = 1
j = not not i


Operadores bitwise
No entanto, existem quatro operadores que lhe permitem manipular bits únicos de dados. São chamados operadores bitwise.

Abrangem todas as operações que mencionámos anteriormente no contexto lógico, e um operador adicional. Este é o operador xor (como em exclusivo ou), e é denotado como ^ (acento circunflexo).

Aqui estão todos eles:

& (e comercial) - conjunção bitwise;
| (barra) - disjunção bitwise;
~ (til) - negação bitwise;
^ (acento circunflexo) - bitwise exclusive ou (xor).

Operações bitwise (&, |, e ^)
Argumento A	Argumento B	A & B	 A | B	A ^ B
0	0	0	0	0
0	1	0	1	1
1	0	0	1	1
1	1	1	1	0

Operações bitwise (~)
Argumento	~ Argumento
0	1
1	0

Vamos facilitar as coisas:

& requer exatamente dois 1para fornecer 1 como resultado;
| requer pelo menos um 1 para fornecer 1 como resultado;
^ requer exatamente um 1 para fornecer 1 como resultado.

Acrescentemos uma observação importante: os argumentos destes operadores devem ser inteiros; não devemos utilizar floats aqui.

A diferença no funcionamento dos operadores lógicos e de bit é importante: os operadores lógicos não penetram no nível de bits do seu argumento. Eles só estão interessados no valor inteiro final.

Os operadores bitwise são mais rigorosos: lidam com cada bit separadamente. Se assumirmos que a variável inteira ocupa 64 bits (o que é comum nos sistemas informáticos modernos), podemos imaginar a operação bitwise como uma avaliação de 64 vezes do operador lógico para cada par de bits dos argumentos. Esta analogia é obviamente imperfeita, pois no mundo real todas estas 64 operações são realizadas ao mesmo tempo (simultaneamente).


Prev Next



----------------------------------------
python

print(type('hello'))
print(type(1))
print(type(1.64))
print(type(True))

<class 'str'>
<class 'int'>
<class 'float'>
<class 'bool'>


-----------------------------
login automatico autologin debian xfce

vi /etc/lightdm/lightdm.conf
procurar autologin-user=
mudar para
autologin-user=professor
descomentar

abrir app automaticamnto no xfce

configurações
sessão e inicialização
inicio automatico de aplicativos:

Fazer um atalho do firefox na area de trabalho:
Clicar no atalho com o botao direito do mouse e escolher propriedades
Escolher aba lancador
copiar a janela comando

Voltar para:

abrir app automaticamnto no xfce

configurações
sessão e inicialização
inicio automatico de aplicativos:

Clicar em + (adicionar app) colar o comando do atalho ali.
Dar o nome
Colar o comando
Reinicie e teste




Firefox pagina inicial:
Inicio
Pagina inicial do firefox


----------------------------------------------------------------------
A função print() - os argumentos de keyword
O Python oferece outro mecanismo para a passagem de argumentos, que pode ser útil quando se quer convencer a print() função a alterar um pouco o seu comportamento.

Não o vamos explicar em profundidade neste momento. Planeamos fazê-lo quando falarmos de funções. Por agora, queremos simplesmente mostrar-lhe como funciona. Sinta-se à vontade para o utilizar nos seus próprios programas.

O mecanismo é chamado argumentos de keyword. O nome deriva do facto de o significado destes argumentos ser retirado não da sua localização (posição) mas da palavra especial (keyword) utilizada para os identificar.

A função print() tem dois argumentos de keyword que pode usar para os seus propósitos. O primeiro deles é nomeado end.

Na janela do editor pode ver um exemplo muito simples da utilização de um argumento de keyword.

Para a sua utilização, é necessário conhecer algumas regras:

um argumento de keyword consiste em três elementos: uma keyword identificando o argumento (end aqui); um sinal de igual (=); e um valor atribuído a esse argumento;
qualquer argumento de keyword tem de ser colocado após o último argumento posicional (isto é muito importante)

No nosso exemplo, fizemos uso do end argumento de keyword, e definimo-lo para uma string contendo um espaço.

Execute o código para ver como ele funciona.

A consola deve agora mostrar o seguinte texto:

My name is Python. Monty Python.
output

Como pode ver, o argumento de keyword end determina os carateres que a função print() envia para o output, uma vez que atinge o final dos seus argumentos posicionais.

O comportamento padrão reflete a situação em que o argumento de keyword end é implicitamente usado da seguinte maneira: end="\n".

A função print() - os argumentos de keyword
E agora é tempo de tentar algo mais difícil.

Se olhar cuidadosamente, verá que utilizámos o argumento end , mas a string atribuída a ele está vazia (não contém nenhum caratere).

O que vai acontecer agora? Execute o programa no editor para descobrir.

Como o argumento end foi definido para nada, a função print() também não produz nenhum output, uma vez que os seus argumentos posicionais foram esgotados.

A consola deve agora mostrar o seguinte texto:

My name is Monty Python.
output

Nota: não foram enviadas newlines para o output.

A string atribuída ao argumento de keyword end pode ter qualquer comprimento. Experimente-a se quiser.

A função print() - os argumentos de keyword
Já dissemos anteriormente que a função print() separa os seus argumentos de output com espaços. Este comportamento também pode ser alterado.

O argumento de keyword que pode fazer isto é chamado sep (como separador).

Veja o código no editor, e execute-o.

O argumento sep fornece os seguintes resultados:

My-name-is-Monty-Python.
output

A função print() agora utiliza um traço, em vez de um espaço, para separar os argumentos de output.

Nota: o valor do argumento sep também pode ser uma string vazia. Experimente você mesmo.


 
 Sandbox
Code
print("My", "name", "is", "Monty", "Python.", sep="-")
print("My", "name", "is", "Monty", "Python.", sep="-")


Console 
My-name-is-Monty-Python.


-----------------------------------------------
LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop continue em loops;
modificar e atualizar o código existente;
refletir situações da vida real em código informático.
Cenário
A sua tarefa aqui é ainda mais especial do que antes: deve redesenhar o comedor de vogais (feio) do laboratório anterior (3.1.2.10) e criar um comedor de vogais (bonito) melhor e mais aperfeiçoado! Escreva um programa que use:

um loop for ;
o conceito de execução condicional (if-elif-else)
a declaração continue .
O seu programa deve:

pedir ao utilizador para introduzir uma palavra;
usar user_word = user_word.upper() para converter a palavra introduzida pelo utilizador em maiúsculas; falaremos sobre os chamados métodos de strings e o método upper() muito em breve - não se preocupe;
usar execução condicional e a declaração continue para “comer” as seguintes vogais A, E, I, O, U da palavra introduzida;
atribuir as letras não comidas à variável word_without_vowels e imprimir a variável para o ecrã.
Veja o código no editor. Criámos word_without_vowels e atribuimos-lhe uma string vazia. Utilize a operação de concatenação para pedir ao Python que combine as letras selecionadas numa string mais longa durante os loops subsequentes, e atribua-a à variável word_without_vowels .

Teste o seu programa com os dados que lhe fornecemos.


Dados de teste
Input de amostra: Gregory

Output esperado:

GRGRY
Input de amostra: abstemious

Output esperado:

BSTMS
Input de amostra: IOUEA

Output esperado:

 

 
 Sandbox
Code
word_without_vowels = ""

# Prompt the user to enter a word
# and assign it to the user_word variable.


for letter in user_word:
# Complete the body of the loop.

# Print the word assigned to word_without_vowels.
        word_without_vowels = letter

Console 
# Prompt the user to enter a word
# and assign it to the user_word variable.
word_without_vowels = ""
user_word = input("Digite uma palavra:")
user_word = user_word.upper()


for letter in user_word:
    if letter == "A":
        continue
    elif letter =="E":
        continue
    elif letter =="I":
        continue
    elif letter =="O":
        continue
    elif letter =="U":
        continue
    else:
        print(letter)
        word_without_vowels += letter
print(word_without_vowels)
print("Fim de programa!")

-----------------------------------
windows update nao funciona nao atualiza mais 

net stop WuAuServ

procurar na pasta windows:
pasta software distribuition
renomear essa pasta para SD.OLD

net start WuAuServ
----------------------------------
verificar registro windows 7
scanreg
----------------------------------
arquivos corrompidos windows 7
sfc /scannow
-----------------------------------------------------------------------------
Rio, 19/05/2022 22:20h
Exercício feito:

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Muito fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop for ;
refletir situações da vida real em código informático.
Cenário
Sabe o que é o Mississippi? Bem, é o nome de um dos estados e rios dos Estados Unidos. O rio Mississippi tem cerca de 3.765 quilómetros de comprimento, o que o torna o segundo rio mais longo dos Estados Unidos (o mais longo sendo o rio Missouri). É tão longo que uma única gota de água precisa de 90 dias para percorrer toda a sua extensão!

A palavra Mississippi é também usada para um propósito ligeiramente diferente: contar mississippily.

Se não está familiarizado com a frase, estamos aqui para lhe explicar o seu significado: é usado para contar segundos.

A ideia por detrás disto é que adicionar a palavra Mississippi a um número ao contar segundos em voz alta faz com que soem mais perto do tempo do relógio, e por isso "um Mississippi, dois Mississippi, três Mississippi" levará aproximadamente três segundos de tempo real! É frequentemente utilizado por crianças que brincam às escondidas para garantir que o buscador faz uma contagem honesta.


A sua tarefa aqui é muito simples: escreva um programa que utilize um loop for para “contar mississippily” até cinco. Tendo contado até cinco, o programa deve imprimir para o ecrã a mensagem final "Ready or not, here I come!"

Use o esqueleto que fornecemos no editor.

INFORMAÇÃO EXTRA

Observe que o código no editor contém dois elementos que podem não estar totalmente claros para si neste momento: a declaração import time , e o método sleep() . Vamos falar sobre eles em breve.

Por enquanto, gostaríamos apenas que soubesse que importámos o módulo time e usámos o método sleep() para suspender a execução de cada função print() subsequente dentro do loop for por um segundo, para que a mensagem enviada para a consola se assemelhe a uma contagem real. Não se preocupe - em breve aprenderá mais sobre módulos e métodos.

Output esperado
1 Mississippi
2 Mississippi
3 Mississippi
4 Mississippi
5 Mississippi


import time
for i in range(1, 6):
    print(i, "Mississippi")
    time.sleep(1)

# Write a for loop that counts to five.
    # Body of the loop - print the loop iteration number and the word "Mississippi".
    # Body of the loop - use: time.sleep(1)

# Write a print function with the final message.
-----------------------------------------------------------------------------
Rio, 19/05/2022 21:44h
Exercício feito:

'''
LAB

Tempo estimado
15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop while ;
refletir situações da vida real em código informático.
Cenário
Um mágico júnior escolheu um número secreto.
Ele escondeu-o numa variável chamada secret_number.
Ele quer que todos os que executam o seu programa joguem o jogo do
Adivinhe o número secreto, e adivinhe que número escolheu para eles.
Aqueles que não adivinharem o número ficarão presos num loop infinito para
sempre!
Infelizmente, ele não sabe como completar o código.

A sua tarefa é ajudar o mágico a completar o código no editor,
de modo a que o código:

peça ao utilizador para introduzir um número inteiro;
utilize um loop while ;
verifique se o número introduzido pelo utilizador é o
mesmo que o número escolhido pelo mágico.

Se o número escolhido pelo utilizador for diferente do número secreto do mágico,
o utilizador deve ver a mensagem "Ha ha! You're stuck in my loop!" e ser solicitado a introduzir
novamente um número. Se o número introduzido pelo utilizador corresponder ao número escolhido pelo
mágico, o número deve ser impresso no ecrã, e o mágico deve dizer as seguintes
palavras: "Well done, muggle! You are free now."

The magician is counting on you! Não o dececione.


INFORMAÇÃO EXTRA

A propósito, olha para a função print() . A forma como a utilizámos aqui chama-se impressão multi-linha.
Pode usar aspas triplas para imprimir strings em várias linhas a fim de tornar o texto mais fácil de ler,
ou criar um desenho especial baseado em texto. Experimente-o.
'''

secret_number = 1305
print(
"""
+================================+
| Welcome to my game, muggle!    |
| Enter an integer number        |
| and guess what number I've     |
| picked for you.                |
| So, what is the secret number? |
+================================+
""")
number = int(input("Enter a number: "))
while number != secret_number:
    print("Ha ha! You're stuck in my loop!")
    number = int(input("Enter a number: "))
else:
    print("Well done, muggle! You are free now.")
------------------------------------------------------------------------------
'''
Rio, 18/05/2022 7:43h

Código final perfeito funcionando até com o ano:1900

Familiarizar o aluno a:

a utilização do loop if-elif-else ;
encontrar a correta implementação de regras definidas verbalmente;
testar código utilizando input e output de amostra.
Cenário

Como certamente sabe, devido a algumas razões astronómicas, os anos podem ser bissextos ou comuns. Os primeiros têm 366 dias de duração, enquanto os segundos têm 365 dias de duração.

Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

se o número do ano não for divisível por quatro, é um ano comum;
caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;
caso contrário, se o número do ano não for divisível por 400, é um ano comum;
caso contrário, é um ano bissexto.
Veja o código no editor - lê apenas um número de ano, e precisa de ser completado com as instruções de implementação do teste que acabámos de descrever.

O código deve fazer output de uma de duas mensagens possíveis, que são Leap year ou Common year, dependendo do valor inserido.

Seria bom verificar se o ano introduzido cai na era Gregoriana, e faz output de um aviso caso contrário: Not within the Gregorian calendar period. Dica: use os operadores != e % .

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste

Input de amostra: 2000
Output esperado: Leap year
Input de amostra: 2015
Output esperado: Common year
Input de amostra: 1999
Output esperado: Common year
Input de amostra: 1996
Output esperado: Leap year
Input de amostra: 1580
Output esperado: Not within the Gregorian calendar period

'''

# Entrar ano a ser consultado:
'''
se o número do ano não for divisível por quatro, é um ano comum;
caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;
caso contrário, se o número do ano não for divisível por 400, é um ano comum;
caso contrário, é um ano bissexto.
Veja o código no editor - lê apenas um número de ano, e precisa de ser completado com as instruções de implementação do teste que acabámos de descrever.
if year <= 1582:
    print(year, "Not within the Gregorian calendar period.")
'''
year = int(input("Enter a year: "))
year_4 = year % 4
year_100 = year % 100
year_400 = year % 400

if year <= 1582: 
    print(year, "Not within the Gregorian calendar period.")
    
elif year_4 != 0: #1900%4==0 false
    print(year, "Common year.")

elif year_100 != 0: #1900%100==0 false
    print(year, "Leap year.")

elif year_400 != 0:#1900%400==300 true
    print(year, "Common year.")

else:#year_400 = 0 1900%400==300 false
    print(year, "Leap year.")

-----------------------------------------------------------------------------
Exercicio:

LAB

Tempo estimado
10-25 minutos

Nível de dificuldade
Fácil/Médio

Objetivos
Familiarizar o aluno a:

a utilização do loop if-elif-else ;
encontrar a correta implementação de regras definidas verbalmente;
testar código utilizando input e output de amostra.
Cenário
Como certamente sabe, devido a algumas razões astronómicas, os anos podem ser bissextos ou comuns. Os primeiros têm 366 dias de duração, enquanto os segundos têm 365 dias de duração.

Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

se o número do ano não for divisível por quatro, é um ano comum;
caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;
caso contrário, se o número do ano não for divisível por 400, é um ano comum;
caso contrário, é um ano bissexto.
Veja o código no editor - lê apenas um número de ano, e precisa de ser completado com as instruções de implementação do teste que acabámos de descrever.

O código deve fazer output de uma de duas mensagens possíveis, que são Leap year ou Common year, dependendo do valor inserido.

Seria bom verificar se o ano introduzido cai na era Gregoriana, e faz output de um aviso caso contrário: Not within the Gregorian calendar period. Dica: use os operadores != e % .

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste
Input de amostra: 2000

Output esperado: Leap year

Input de amostra: 2015

Output esperado: Common year

Input de amostra: 1999

Output esperado: Common year

Input de amostra: 1996

Output esperado: Leap year

Input de amostra: 1580

Output esperado: Not within the Gregorian calendar period


Perfeito:

year = int(input("Enter a year: "))

#Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

#se o número do ano não for divisível por quatro, é um ano comum;........................0 
#caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;........!=0
#caso contrário, se o número do ano não for divisível por 400, é um ano comum;...........0
#caso contrário, é um ano bissexto.

# Entrar ano a ser consultado:
year_4 = year % 4
year_100 = year % 100
year_400 = year % 400

# Checar se ano é bisexto ou comum:
#se o número do ano não for divisível por quatro, é um ano comum;

# Para ser bissexto:
#year_4   == 0
#year_100 == !=0
#year_400 == 0

# Para ser comum:
#year_4   == 1

if year <= 1582:
    print(year, "Not within the Gregorian calendar period.")

elif year_4 == 0:
    print(year, "Leap year.")

elif year_4 != 0:
    print(year, "Common year.")

elif year_100 != 0:
    print(year, "Common year.")

elif year_400 != 0:
    print(year, "Common year.")

else:
    print(year, "Leap year.")


-------------------------------------------------------
Perfeito!

income = float(input("Enter the annual income: "))

#taxa fixa
trelief = 556.02
#taxa acima 85528
uptax = 14839.02
#taxa diferença acima 85528
updiftax = 0.32
#limite taxado acima
uprend = 85528
# taxa nao superior 
downtax = 0.18


if income < uprend:
    tax = income * downtax - trelief

else:
    income2 = (income - uprend) * updiftax
    tax = income2 + uptax
    tax = round(tax, 0)


if tax <= 0:
    tax = 0
    print("The tax is:", tax, "thalers")
    
else:
    tax >= 0
    tax = round(tax, 0)
    print("The tax is:", tax, "thalers")
--------------------------------------------------------
Funcionando 2

income = float(input("Enter the annual income: "))

#taxa fixa
trelief = 556.02
#taxa acima 85528
uptax = 14839.02
#taxa diferença acima 85528
updiftax = 0.32
#limite taxado acima
uprend = 85528
# taxa nao superior 
downtax = 0.18


if income < uprend:
    tax = income * downtax - trelief

    if tax <= 0:
       tax = 0
                
       if tax >= 0:
          tax = round(tax, 0)
          print("The tax is:", tax, "thalers")

else:
    income2 = (income - uprend) * updiftax
    tax = income2 + uptax
    tax = round(tax, 0)
    print("The tax is:", tax, "thalers")


--------------------------------------------------
Funcionando:

income = float(input("Enter the annual income: "))

#taxa fixa
trelief = 556.02
#taxa acima 85528
uptax = 14839.02
#taxa diferença acima 85528
updiftax = 0.32
#limite taxado acima
uprend = 85528
# taxa nao superior 
downtax = 0.18


if income < uprend:
    tax = income * downtax - trelief
    tax2 = tax

    if tax2 <= 0:
        tax2 = 0
                
        if tax2 >= 0:
            tax = round(tax, 0)
            print("The tax is:", tax2, "thalers")

else:
    income2 = (income - uprend) * updiftax
    tax2 = income2 + uptax
    tax2 = round(tax2, 0)
    print("The tax is:", tax2, "thalers")
----------------------------------------------------------------
income = float(input("Enter the annual income: "))

#taxa fixa
trelief = 556.02
#taxa acima 85528
uptax = 14839.02
#taxa diferença acima 85528
updiftax = 0.32
#limite taxado acima
uprend = 85528
# taxa nao superior 
downtax = 0.18


if income < uprend:
    tax = income * downtax - trelief
    tax = round(tax, 0)
    print("The tax is:", tax, "thalers")
else:
    income - uprend * updiftax

income = float(input("Enter the annual income: "))

#
# Write your code here.
#
trelief = 556.02
tax = income * 0.18 - trelief
tax = round(tax, 0)
print("The tax is:", tax, "thalers")

--------------------------------------------------------------------------------------------------------------------------
identificar hardware memoria ram tipo ddr linux debian
sudo dmidecode | grep DDR
sudo dmidecode --type 17
-----------------------------------------------------------------------------------------------------------------------------
python replicação replicacao

Replicação
O sinal * (asterisco), quando aplicado a uma string e número (ou um número e string, visto permanecer comutativo nesta posição) torna-se um operador de replicação:

string * number
number * string


Replica a string o mesmo número de vezes especificado pelo número.

Por exemplo:

"James" * 3 dá "JamesJamesJames"
3 * "an" dá "ananan"
5 * "2" (ou "2" * 5) dá "22222" (não 10!)

LEMBRE-SE

Um número menor ou igual a zero produz uma string vazia.


Este programa simples "desenha" um retângulo, fazendo uso de um antigo operador (+) num novo papel:

print("+" + 10 * "-" + "+")
print(("|" + " " * 10 + "|\n") * 5, end="")
print("+" + 10 * "-" + "+")


Note a forma como utilizámos os parêntesis na segunda linha do código.

Tente praticar para criar outras formas ou a sua própria obra de arte!

-------------------------------------------------------------------------
programas python exemplos para praticar:

# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))

# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2

# Print the result
print("The larger number is:", larger_number)


O snippet acima deve ser claro - ele lê dois valores inteiros, compara-os e descobre qual é o maior.
---------------------------------------------------------------------------------------------------
# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1

# We check if the second number is larger than current largest_number
# and update largest_number if needed.
if number2 > largest_number:
    largest_number = number2

# We check if the third number is larger than current largest_number
# and update largest_number if needed.
if number3 > largest_number:
    largest_number = number3

# Print the result
print("The largest number is:", largest_number)
--------------------------------------------------------------------------------------------------
# Read three numbers.
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# Check which one of the numbers is the greatest
# and pass it to the largest_number variable.

largest_number = max(number1, number2, number3)

# Print the result.
print("The largest number is:", largest_number)

--------------------------------------------------------------------------------------------------
nome = input("Nome:")
email = input("E-mail:")

from datetime import date
today = date.today()

# dd/mm/YY
dataformat1 = today.strftime("%d/%m/%Y")
current_year = date.today().year

# prints

arquivo = open('arq01.txt','a')
arquivo.write('\n')
arquivo.write(nome)
arquivo.write('\n')
arquivo.write(email)
arquivo.write('\n')
arquivo.write(dataformat1)
arquivo.write('\n')
arquivo.close()



-------------------------------------------------------
nome = input("Entre com seu nome:")
year_nasc = int(input("Ano de nascimento:"))

from datetime import date
today = date.today()

# dd/mm/YY
dataformat1 = today.strftime("%d/%m/%Y")
current_year = date.today().year

print(nome)
print(year_nasc)
#calculo da idade
idade = current_year - year_nasc
msg1 = "Primeiros passos com python."

# prints
print("Rio de Janeiro,",dataformat1,"\n")
print("Hello, World!","\n")
print(msg1,"\n")
print(nome,"tem",
idade,"anos. Nasceu em",year_nasc,".","\n")
-----------------------------------------------------------
input("Entre com seu nome:")
nome = input()
input("Ano de nascimento:")
year_nasc = input()

print("Nome: ", nome)
print("Ano: ", year_nasc)


#print(year_nasc)
from datetime import date
today = date.today()

# dd/mm/YY
dataformat1 = today.strftime("%d/%m/%Y")
current_year = date.today().year
# variaveis

print(nome)
print(year_nasc)
#nome = "Alexandre Rangel de Oliveira"
#ano_nasc = 1965

#nome2 = "Patricia Gomes Santos dos Santos"
#ano_nasc2 = 1972

#calculo da idade
idade = current_year - year_nasc
#idade2 = current_year - ano_nasc2
msg1 = "Primeiros passos com python."

# prints
print("Rio de Janeiro,",dataformat1,"\n")
print("Hello, World!","\n")
print(msg1,"\n")
print(nome,"tem",
idade,"anos. Nasceu em",ano_nasc,".","\n")
print(nome2,"tem",idade2,"anos. Nasceu em",ano_nasc2,".")



-----------------------------------------
# programa em python
from datetime import date
today = date.today()

# dd/mm/YY
dataformat1 = today.strftime("%d/%m/%Y")
current_year = date.today().year
# variaveis
nome = "Alexandre Rangel de Oliveira"
ano_nasc = 1965

nome2 = "Patricia Gomes Santos dos Santos"
ano_nasc2 = 1972

#calculo da idade
idade = current_year - ano_nasc
idade2 = current_year - ano_nasc2
msg1 = "Primeiros passos com python."

# prints
print("Rio de Janeiro,",dataformat1,"\n")
print("Hello, World!","\n")
print(msg1,"\n")
print(nome,"tem",idade,"anos. Nasceu em",ano_nasc,".","\n")
print(nome2,"tem",idade2,"anos. Nasceu em",ano_nasc2,".")

---------------------------------------
from datetime import date

today = date.today()
print("Today's date:", today)

from datetime import date

today = date.today()

# dd/mm/YY
d1 = today.strftime("%d/%m/%Y")
print("d1 =", d1)

# Textual month, day and year	
d2 = today.strftime("%B %d, %Y")
print("d2 =", d2)

# mm/dd/y
d3 = today.strftime("%m/%d/%y")
print("d3 =", d3)

# Month abbreviation, day and year	
d4 = today.strftime("%b-%d-%Y")
print("d4 =", d4)
------------------------------------------------------------------------------------------------
vivo
protocolo 08/05/2022
090520225404351
----------------------------------------------------------------------------------------------------
09/05/2022 Curso de Phython

Inventor do Phython: Gido Van Rossum

Inteiros: números octais e hexadecimais
Há duas convenções adicionais em Python que são desconhecidas no mundo da matemática. A primeira permite-nos utilizar números numa representação octal.

Se um número inteiro for precedido por um 0O ou 0o prefixo (zero-o), ele será tratado como um valor octal. Isto significa que o número deve conter apenas dígitos retirados do intervalo [0..7].

0o123 é um número octal com um valor (decimal) igual a 83.

A classe print() faz a conversão automaticamente. Experimente isto:

print(0o123)

A segunda convenção permite-nos utilizar números hexadecimais. Estes números devem ser precedidos pelo prefixo 0x ou 0X (zero-x).

0x123 é um número hexadecimal com um valor (decimal) igual a 291. A função print() também pode gerir estes valores. Experimente isto:

print(0x123)

Floats

Agora é altura de falar de outro tipo, que foi concebido para representar e armazenar os números que (como diria um matemático) têm uma fração decimal não vazia.

São os números que têm (ou podem ter) uma parte fracionada após o ponto decimal, e embora tal definição seja muito pobre, é certamente suficiente para o que desejamos discutir.

Sempre que utilizamos um termo como dois e meio ou menos zero ponto quatro, pensamos em números que o computador considera números de floating-point:

2.5
-0.4

Nota: dois e meio parece normal quando se escreve num programa, embora se a sua língua materna preferir usar uma vírgula em vez de um ponto no número, deve assegurar-se de que o seu número não contém quaisquer vírgulas.

O Python não aceitará isso, ou (em casos muito raros mas possíveis) pode interpretar mal as suas intenções, uma vez que a própria vírgula tem o seu significado reservado em Python.

Se quiser usar apenas um valor de dois e meio, deve escrevê-lo como mostrado acima. Nota mais uma vez - há um ponto entre 2 e 5 - não uma vírgula.

Como provavelmente pode imaginar, o valor de zero ponto quatro pode ser escrito em Python como:

0.4

Mas não se esqueça desta regra simples - pode omitir o zero quando é o único dígito em frente ou após o ponto decimal.

Em essência, pode escrever o valor 0.4 como:

.4

Por exemplo: o valor de 4.0 pode ser escrito como:

4.

Isto não mudará nem o seu tipo nem o seu valor.

Ints vs. floats
O ponto decimal é essencialmente importante no reconhecimento de números de floating-point em Python.

Veja estes dois números:

4
4.0

Pode pensar que eles são exatamente os mesmos, mas o Python vê-os de uma forma completamente diferente.

4 é um número inteiro, enquanto que 4.0 é um número floating-point.

O ponto é o que faz um float.


Por outro lado, não são apenas os pontos que fazem um float. Também pode utilizar a letra e.

Quando quiser usar números muito grandes ou muito pequenos, pode usar notação científica.

Tome, por exemplo, a velocidade da luz, expressa em metros por segundo. Escrito diretamente, ficaria assim: 300000000.

Para evitar escrever tantos zeros, os livros de física utilizam uma forma abreviada, que provavelmente já viu: 3 x 108.

Lê-se: três vezes dez à potência de oito.

Em Python, o mesmo efeito é conseguido de uma forma ligeiramente diferente - veja:

3E8

A letra E (também pode utilizar a letra minúscula e - vem da palavra expoente) é um registo conciso da frase vezes dez à potência de.

Nota:

o expoente (o valor após o E) deve ser um número inteiro;
a base (o valor à frente do E) pode ser um inteiro.
Prev Next

Codificação de floats
Vejamos como esta convenção é utilizada para registar números que são muito pequenos (no sentido do seu valor absoluto, que está próximo de zero).

Uma constante física chamada constante de Planck (e denotada com um h), de acordo com os manuais escolares, tem o valor de: 6.62607 x 10-34.

Se quiser utilizá-la num programa, deve escrevê-la desta forma:

6.62607E-34

Nota: o facto de ter escolhido uma das formas possíveis de codificação de valores float não significa que o Python o apresente da mesma forma.

O Python pode, por vezes, escolher uma notação diferente da sua.

Por exemplo, digamos que decidiu usar o seguinte float literal:

0.0000000000000000000001

Quando executa este literal através do Python:

print(0.0000000000000000000001)


este é o resultado:

1e-22
output

O Python escolhe sempre a forma mais económica de apresentação do número, e deve ter isto em consideração ao criar literais.

Prev Next

Codificação de floats
Vejamos como esta convenção é utilizada para registar números que são muito pequenos (no sentido do seu valor absoluto, que está próximo de zero).

Uma constante física chamada constante de Planck (e denotada com um h), de acordo com os manuais escolares, tem o valor de: 6.62607 x 10-34.

Se quiser utilizá-la num programa, deve escrevê-la desta forma:

6.62607E-34

Nota: o facto de ter escolhido uma das formas possíveis de codificação de valores float não significa que o Python o apresente da mesma forma.

O Python pode, por vezes, escolher uma notação diferente da sua.


Por exemplo, digamos que decidiu usar o seguinte float literal:

0.0000000000000000000001

Quando executa este literal através do Python:

print(0.0000000000000000000001)


este é o resultado:

1e-22
output

O Python escolhe sempre a forma mais económica de apresentação do número, e deve ter isto em consideração ao criar literais.

Strings
Strings são utilizadas quando é necessário processar texto (como nomes de todos os tipos, endereços, romances, etc.), não números.

Já sabe um pouco sobre elas. Por exemplo, que as strings precisam de aspas da mesma forma que floats precisam de pontos.

Esta é uma string muito típica: "I am a string."


No entanto, há um senão. O senão é como codificar uma aspa dentro de uma string que já está delimitada por aspas.

Vamos supor que queremos imprimir uma mensagem muito simples dizendo:

I like "Monty Python"

Como fazemos isto sem gerar um erro? Existem duas soluções possíveis.


A primeira baseia-se no conceito que já conhecemos do caratere de escape, que como se deve lembrar é representado pela barra invertida. A barra invertida também pode escapar às aspas. Uma aspa precedida por uma barra invertida muda o seu significado - não é um delimitador, mas apenas uma aspa. Isto funcionará como pretendido:

print("I like \"Monty Python\"")


Nota: existem duas aspas escapadas dentro da string - consegue vê-las?

A segunda solução pode ser um pouco surpreendente. O Python pode utilizar uma apóstrofe em vez de uma aspa. Qualquer um destes carateres pode delimitar strings, mas deve ser consistente.

Se abrir uma string com uma aspa, tem de fechá-la com uma aspa.

Se começar uma string com uma apóstrofe, tem de a acabar com uma apóstrofe.

Este exemplo também funcionará:

print('I like "Monty Python"')


Nota: não precisa de fazer nenhum escape aqui.

Codificar strings
Agora, a questão seguinte é: como incorporar uma apóstrofe numa string colocada entre apóstrofes?

Já deve saber a resposta, ou, para ser mais preciso, as duas respostas possíveis.

Tente imprimir uma string contendo a seguinte mensagem:

I'm Monty Python.

Sabe como fazê-lo? Clique em Verifique em baixo para ver se estava certo:

Verifique
print('I\'m Monty Python.')

ou

print("I'm Monty Python.")
Como pode ver, a barra invertida é uma ferramenta muito poderosa - pode escapar não só às aspas, mas também às apóstrofes.

Já o mostrámos, mas queremos enfatizar mais uma vez este fenómeno - uma string pode estar vazia - pode não conter quaisquer carateres.

Uma string vazia ainda assim permanece uma string:

''
""

Valores Booleanos
Para concluir com os literais de Python, existem mais dois.

Não são tão óbvios como os anteriores, uma vez que são usados para representar um valor muito abstrato - truthfulness (veracidade).

Cada vez que pergunta ao Python se um número é maior que outro, a pergunta resulta na criação de alguns dados específicos - um valor Booleano.

O nome vem de George Boole (1815-1864), autor da obra fundamental, As Leis do Pensamento, que contém a definição de álgebra Booleana - uma parte da álgebra que faz uso de apenas dois valores distintos: True e False, denotado como 1 e 0.


Um programador escreve um programa, e o programa faz perguntas. O Python executa o programa, e fornece as respostas. O programa deve ser capaz de reagir de acordo com as respostas recebidas.

Felizmente, os computadores conhecem apenas dois tipos de respostas:

Sim, isto é verdade;
Não, isto é falso.
Nunca obterá uma resposta como: Não sei ou Provavelmente sim, mas não sei ao certo.


O Python, então, é um réptil binário.

Estes dois valores Booleanos têm denotações rigorosas em Python:

True
False

Não se pode mudar nada - é preciso tomar estes símbolos tal como eles são, incluindo case-sensitivity.


Desafio: Qual será o output do seguinte snippet de código?

print(True > False)
print(True < False)


Execute o código na Sandbox para verificar. Consegue explicar o resultado?


Prev
-------------------------------------------
converter binario em decimal python
print(0b1010)

converter decimal para binario
print(bin(22))

converter hexadecimal para decimal
h = int("0x1234", 16)
print(h)
4660
--------------------------------------
Key takeaways
1. Os literais são notações para representar alguns valores fixos em código. O Python tem vários tipos de literais - por exemplo, um literal pode ser um número (literais numéricos, por exemplo, 123), ou uma string (literais de string, por exemplo, “Eu sou um literal.“).

2. O sistema binário é um sistema de números que emprega 2 como base. Portanto, um número binário é composto apenas por 0s e 1s, por exemplo, 1010 é 10 em decimal.

Os sistemas de numeração octal e hexadecimal, do mesmo modo, empregam 8 e 16 como suas bases, respetivamente. O sistema hexadecimal utiliza os números decimais e seis letras extra.
3. Inteiros (ou simplesmente ints) são um dos tipos numéricos suportados pelo Python. São números escritos sem um componente fracionário, por exemplo, 256, ou -1 (inteiros negativos).

4. Números de floating-point (ou simplesmente floats) são outro dos tipos numéricos suportados pelo Python. São números que contêm (ou são capazes de conter) um componente fracionário, por exemplo 1.27.

5. Para codificar uma apóstrofe ou uma aspa dentro de uma string, pode usar o caratere de escape, por exemplo, 'I\'m happy.', ou abrir e fechar a string utilizando um conjunto de símbolos opostos aos que deseja codificar, por exemplo "I'm happy." codificar uma apóstrofe, e 'He said "Python", not "typhoon"' para codificar umas aspas (duplas).

6. Valores booleanos são os dois objetos constantes True e False usado para representar valores de verdade (em contextos numéricos 1 é True, enquanto 0 é False.

EXTRA

Há mais um literal especial que é usado em Python: o literal None . Este literal é um chamado NoneType objeto, e é utilizado para representar a ausência de um valor. Em breve, contar-lhe-emos mais sobre isso.

Exercício 1

Que tipos de literais são os dois exemplos seguintes?

"Hello ", "007"

Verifique
Exercício 2

Que tipos de literais são os quatro exemplos seguintes?

"1.5", 2.0, 528, False

Verifique
Exercício 3

Qual é o valor decimal do seguinte número binário?

1011

Verifique
É 11, porque (2**0) + (2**1) + (2**3) = 11

Python como uma calculadora
Agora, vamos mostrar-lhe um lado completamente novo da função print(). Já sabe que a função é capaz de lhe mostrar os valores dos literais que lhe são transmitidos pelos argumentos.

Na verdade, pode fazer algo mais. Dê uma vista de olhos no snippet:

print(2+2)


Digite novamente o código no editor e execute-o. Consegue adivinhar o output?

Deve ver o número quatro. Sinta-se à vontade para experimentar com outros operadores.

Sem levar isto demasiado a sério, acabou de descobrir que o Python pode ser usado como calculadora. Não é muito útil, e definitivamente não é de bolso, mas é uma calculadora.

Levando-o mais a sério, estamos agora a entrar na província dos operadores e das expressões.


Operadores básicos
Um operador é um símbolo da linguagem de programação, que é capaz de operar sobre os valores.

Por exemplo, tal como na aritmética, o sinal + (mais) é o operador que é capaz de adicionar dois números, dando o resultado da adição.

Mas nem todos os operadores Python são tão óbvios como o sinal de mais, por isso vamos analisar alguns dos operadores disponíveis em Python, e explicaremos que regras regem a sua utilização, e como interpretar as operações que realizam.

Começaremos pelos operadores que estão associados às operações aritméticas mais amplamente reconhecidas:

+, -, *, /, //, %, **


A ordem do seu aparecimento não é acidental. Falaremos mais sobre o assunto depois de termos passado por todos eles.

Lembre-se: Os dados e os operadores, quando ligados entre si, formam expressões. A expressão mais simples é um literal em si.






Operadores básicos

Um operador é um símbolo da linguagem de programação, que é capaz de operar sobre os valores.

Por exemplo, tal como na aritmética, o sinal + (mais) é o operador que é capaz de adicionar dois números, dando o resultado da adição.

Mas nem todos os operadores Python são tão óbvios como o sinal de mais, por isso vamos analisar alguns dos operadores disponíveis em Python, e explicaremos que regras regem a sua utilização, e como interpretar as operações que realizam.

Começaremos pelos operadores que estão associados às operações aritméticas mais amplamente reconhecidas:

+, -, *, /, //, %, **


A ordem do seu aparecimento não é acidental. Falaremos mais sobre o assunto depois de termos passado por todos eles.

Lembre-se: Os dados e os operadores, quando ligados entre si, formam expressões. A expressão mais simples é um literal em si.


 
 Sandbox
Code
print(0b1000011)
Console 
67

Operadores aritméticos: exponenciação

Um sinal ** (duplo asterisco) é um operador de exponenciação (potência). O seu argumento esquerdo é a base, o seu direito, o expoente.

A matemática clássica prefere a notação com sobrescrito, tal como esta: 23. Os editores de texto puro não aceitam isso, por isso o Python usa ** ao invés, por exemplo, 2 ** 3.

Dê uma vista de olhos aos nossos exemplos na janela do editor.


Nota: rodeámos os asteriscos duplos com espaços nos nossos exemplos. Não é obrigatório, mas melhora a legibilidade do código.

Os exemplos mostram uma característica muito importante de praticamente todos os operadores numéricos de Python.

Execute o código e veja cuidadosamente os resultados que produz. Consegue ver alguma regularidade aqui?


Lembre-se: É possível formular as seguintes regras com base neste resultado:

quando ambos os argumentos ** são inteiros, o resultado é também um inteiro;
quando pelo menos um argumento ** é um float, o resultado é também um float.
Esta é uma distinção importante a lembrar.


Operadores aritméticos: multiplicação
Um sinal * (asterisco) é um operador de multiplicação.

Execute o código abaixo e verifique se a nossa regra de inteiro vs. float ainda está a funcionar.

print(2 * 3)
print(2 * 3.)
print(2. * 3)
print(2. * 3.)


Operadores aritméticos: divisão
O sinal / (barra) é um operador de divisão.

O valor em frente da barra é um dividendo, o valor por detrás da barra, um divisor.

Execute o código abaixo e analise os resultados.

print(6 / 3)
print(6 / 3.)
print(6. / 3)
print(6. / 3.)


Deve ver que existe uma exceção à regra.

O resultado produzido pelo operador da divisão é sempre um float, independentemente de o resultado parecer ou não ser um float à primeira vista: 1 / 2, ou se se parecer com um inteiro puro: 2 / 1.

Isto é um problema? Sim, é. Acontece por vezes que é realmente necessária uma divisão que forneça um valor inteiro, não um float.

Felizmente, o Python pode ajudá-lo com isso.

Operadores aritméticos: divisão inteira
Um sinal // (dupla barra) é um operador de divisão inteira. Difere do operador padrão / em dois detalhes:

o seu resultado não tem a parte fracionada - está ausente (para inteiros), ou é sempre igual a zero (para floats); isto significa que os resultados são sempre arredondados;
está em conformidade com a regra inteiro vs. float.
Execute o exemplo abaixo e veja os resultados:

print(6 // 3)
print(6 // 3.)
print(6. // 3)
print(6. // 3.)


Como se pode ver, a divisão inteiro por inteiro dá um resultado inteiro. Todos os outros casos produzem floats.


Vamos fazer alguns testes mais avançados.

Veja o seguinte snippet:

print(6 // 4)
print(6. // 4)


Imagine que usámos / em vez de // - consegue prever os resultados?

Sim, seria 1.5 em ambos os casos. Isso é claro.

Mas que resultados devemos esperar com // divisão?

Execute o código e veja por si mesmo.


O que obtemos são dois uns - um inteiro e um float.

O resultado da divisão inteira é sempre arredondado para o valor inteiro mais próximo, que é inferior ao resultado real (não arredondado).

Isto é muito importante: o arredondamento vai sempre para o número inteiro menor.


Veja o código abaixo e tente prever os resultados mais uma vez:

print(-6 // 4)
print(6. // -4)


Nota: alguns dos valores são negativos. Isto irá obviamente afetar o resultado. Mas como?

O resultado são dois dois negativos. O resultado real (não arredondado) é -1.5 em ambos os casos. No entanto, os resultados são sujeitos a arredondamento. O arredondamento vai para o menor valor inteiro, e o menor valor inteiro é -2, logo: -2 e -2.0.

NOTA

A divisão inteira também pode ser chamada floor division. Definitivamente, no futuro, deparar-se-á com este termo.


Operadores: remainder (modulo)
O próximo operador é bastante peculiar, visto não ter equivalente entre os operadores aritméticos tradicionais.

A sua representação gráfica em Python é o sinal % (percentagem), o que pode parecer um pouco confuso.

Tente pensar nisto como uma barra (operador de divisão) acompanhada por dois pequenos círculos engraçados.

O resultado do operador é um remainder (resto) deixado após a divisão inteira.

Por outras palavras, é o valor que sobrou depois de dividir um valor por outro para produzir um quociente inteiro.

Nota: o operador às vezes é chamado modulo noutras linguagens de programação.

Dê uma vista de olhos no snippet - tente prever o seu resultado e, em seguida, execute-o:

print(14 % 4)


Como pode ver, o resultado é dois. Esta é a razão:

14 // 4 dá 3 → este é o quociente inteiro;
3 * 4 dá 12 → como resultado da multiplicação de quocientes e divisores;
14 - 12 dá 2 → este é o resto.

Este exemplo é um pouco mais complicado:

print(12 % 4.5)


Qual é o resultado?

Verifique

Operadores: como não dividir
Como provavelmente sabe, a divisão por zero não funciona.

Não tente:

executar uma divisão por zero;
executar uma divisão inteira por zero;
encontrar um remainder de uma divisão por zero.


Operadores: adição
O operador de adição é o sinal + (mais), que está totalmente de acordo com os padrões matemáticos.

Novamente, dê uma vista de olhos no snippet do programa em baixo:

print(-4 + 4)
print(-4. + 8)


O resultado não deve ser nada surpreendente. Execute o código para o verificar.


O operador de subtração, operadores unários e binários
O operador de subtração é obviamente o sinal - (menos), embora deva notar que este operador também tem outro significado - ele pode alterar o sinal de um número.

Esta é uma grande oportunidade para apresentar uma distinção muito importante entre operadores unários e binários.

Em aplicações de subtração, o operador menos espera dois argumentos: o da esquerda (um minuendo em termos aritméticos) e o da direita (um subtraendo).

Por esta razão, o operador de subtração é considerado um dos operadores binários, assim como os operadores de adição, multiplicação e divisão.

Mas o operador menos pode ser usado de uma forma diferente (unária) - veja a última linha do snippet em baixo:

print(-4 - 4)
print(4. - 8)
print(-1.1)


A propósito: há também um operador + unário. Pode utilizá-lo assim:

print(+2)


O operador preserva o sinal de seu único argumento - o correto.

Embora tal construção seja sintaticamente correta, a sua utilização não faz muito sentido, e seria difícil encontrar uma boa razão para o fazer.

Dê uma vista de olhos no snippet acima - consegue adivinhar o seu output?


Os operadores e as suas prioridades
Até agora, temos tratado cada operador como se não tivesse qualquer ligação com os outros. Obviamente, uma situação tão ideal e simples é uma raridade na programação real.

Além disso, encontrará muito frequentemente mais do que um operador numa só expressão, e então esta presunção já não é tão óbvia.

Considere a seguinte expressão:

2 + 3 * 5

Provavelmente lembra-se da escola que as multiplicações precedem as adições.

Deve certamente lembrar-se que primeiro deve multiplicar 3 por 5 e, mantendo o 15 na sua memória, depois adicioná-los a 2, obtendo assim o resultado de 17.

O fenómeno que leva alguns operadores a agir antes de outros é conhecido como a hierarquia de prioridades.

O Python define com precisão as prioridades de todos os operadores, e assume que os operadores de maior (mais alta) prioridade realizam as suas operações antes dos operadores de menor prioridade.

Portanto, se sabe que * tem uma prioridade maior do que +, o cálculo do resultado final deve ser óbvio.


Os operadores e as suas ligações
A ligação do operador determina a ordem dos cálculos efetuados por alguns operadores com igual prioridade, colocados lado a lado numa só expressão.

A maioria dos operadores de Python têm ligação do lado esquerdo, o que significa que o cálculo da expressão é realizado da esquerda para a direita.

Este exemplo simples mostrar-lhe-á como funciona. Veja:

print(9 % 6 % 2)


Há duas formas possíveis de avaliar esta expressão:

da esquerda para a direita: primeiro 9 % 6 dá 3e, em seguida, 3 % 2 dá 1;
da direita para a esquerda: primeiro 6 % 2 dá 0e, em seguida, 9 % 0 causa um erro fatal.

Execute o exemplo e veja o que obtém.

O resultado deve ser 1. Este operador tem ligação do lado esquerdo. Mas há uma exceção interessante.

Operadores e seus bindings: exponenciação
Repita a experiência, mas agora com exponenciação.

Use este snippet de código:

print(2 ** 2 ** 3)


Os dois resultados possíveis são:

2 ** 2 → 4; 4 ** 3 → 64
2 ** 3 → 8; 2 ** 8 → 256

Execute o código. O que vê?

O resultado mostra claramente que o operador de exponenciação utiliza a ligação do lado direito.

Lista de prioridades
Uma vez que é novo nos operadores Python, não queremos apresentar neste momento a lista completa de prioridades dos operadores.

Em vez disso, vamos mostrar-lhe a sua forma truncada, e vamos expandi-la de forma consistente à medida que introduzimos novos operadores.

Veja a tabela abaixo:

Prioridade	Operador	
1	+, -	unário
2	**	
3	*, /, //, %	
4	+, -	binário

Nota: enumerámos os operadores por ordem das prioridades mais altas (1) até às mais baixas (4).


Tente trabalhar com a seguinte expressão:

print(2 * 3 % 5)


Ambos os operadores (* e %) têm a mesma prioridade, pelo que o resultado só pode ser adivinhado quando se conhece a direção de ligação. Como pensa? Qual é o resultado?

Verifique
1


Operadores e parêntesis
Claro, é sempre permitido utilizar parêntesis, o que pode alterar a ordem natural de um cálculo.

De acordo com as regras aritméticas, as subexpressões entre parêntesis são sempre calculadas em primeiro lugar.

Pode-se usar tantos parêntesis quantos forem necessários, e são frequentemente usados para melhorar a legibilidade de uma expressão, mesmo que não alterem a ordem das operações.

Um exemplo de uma expressão com vários parêntesis é este:

print((5 * ((25 % 13) + 100) / (2 * 13)) // 2)


Tente calcular o valor que é impresso para a consola. Qual é o resultado da função print() ?

Verifique
10.0

Key takeaways
1. Uma expressão é uma combinação de valores (ou variáveis, operadores, chamadas a funções - em breve aprenderá sobre elas) que avalia a um valor, por exemplo, 1 + 2.

2. Os operadores são símbolos especiais ou keywords capazes de operar sobre os valores e realizar operações (matemáticas), por exemplo, o * operador multiplica dois valores: x * y.

3. Operadores aritméticos em Python: + (adição), - (subtração), * (multiplicação), / (divisão clássica - devolve sempre um float), % (módulo - divide o operando esquerdo pelo operando direito e devolve o resto da operação, por exemplo, 5 % 2 = 1), ** (exponenciação - operando esquerdo elevado à potência do operando direito, por exemplo, 2 ** 3 = 2 * 2 * 2 = 8), // (divisão por piso/inteiro - devolve um número resultante da divisão, mas arredondado para baixo para o número inteiro mais próximo, por exemplo 3 // 2.0 = 1.0)

4. Um operador unário é um operador com apenas um operando, por exemplo, -1, ou +3.

5. Um operador binário é um operador com dois operandos, por exemplo, 4 + 5, ou 12 % 5.

6. Alguns operadores atuam antes de outros - a hierarquia de prioridades:

unário + e - têm a prioridade mais alta
depois: **, depois: *, /, e %e, depois, a prioridade mais baixa: binário + e -.
7. Subexpressões entre parêntesis são sempre calculadas em primeiro lugar, por exemplo, 15 - 1 * (5 * (1 + 2)) = 0.

8. O operador de exponenciação utiliza ligação do lado direito, por exemplo 2 ** 2 ** 3 = 256.




Exercício 1

Qual é o output do seguinte snippet?

print((2 ** 4), (2 * 4.), (2 * 4))


Verifique
16 8.0 8

Exercício 2

Qual é o output do seguinte snippet?

print((-2 / 4), (2 / 4), (2 // 4), (-2 // 4))


Verifique
-0.5 0.5 0 -1

Exercício 3

Qual é o output do seguinte snippet?

print((2 % -4), (2 % 4), (2 ** 3 ** 2))


Verifique
-2 2 512

O que são variáveis?
Parece bastante óbvio que o Python deveria permitir-lhe codificar literais transportando valores de número e texto.

Já sabe que pode fazer algumas operações aritméticas com estes números: adicionar, subtrair, etc. Fá-lo-á muitas vezes.

Mas é uma questão bastante normal de perguntar como armazenar os resultados destas operações, a fim de os utilizar noutras operações, e assim por diante.

Como guardar os resultados intermediários, e utilizá-los novamente para produzir os resultados subsequentes?

O Python irá ajudá-lo nisso. Oferece "caixas" especiais (em inglês, containers) para esse fim, e estas caixas são chamadas variáveis - o próprio nome sugere que o conteúdo destes containers pode ser variado em (quase) qualquer forma.

O que tem cada variável Python?

um nome;
um valor (o conteúdo do container)
Comecemos com as questões relacionadas com o nome de uma variável.

As variáveis não aparecem automaticamente num programa. Como programador, deve decidir quantas e quais as variáveis a utilizar nos seus programas.

Deve também nomeá-las.


Se quiser dar um nome a uma variável, deve seguir algumas regras estritas:

o nome da variável deve ser composto por letras maiúsculas ou minúsculas, dígitos e o caratere _ (underscore)
o nome da variável deve começar com uma letra;
o caratere underscore é uma letra;
letras maiúsculas e minúsculas são tratadas como diferentes (um pouco diferente do que no mundo real - Alice e ALICE são os mesmos nomes próprios, mas em Python são dois nomes de variáveis diferentes, e consequentemente, duas variáveis diferentes);
o nome da variável não deve ser nenhuma das palavras reservadas de Python (as keywords - explicaremos mais sobre isto em breve).
O conceito de variáveis como uma caixa


Nomes de variável corretos e incorretos
Note-se que as mesmas restrições se aplicam a nomes de funções.

O Python não impõe restrições ao comprimento dos nomes de variáveis, mas isto não significa que um nome de variável longo seja sempre melhor do que um curto.

Aqui estão alguns nomes de variáveis corretos, mas nem sempre convenientes:

MyVariable, i, t34, Exchange_Rate, counter, days_to_christmas, TheNameIsSoLongThatYouWillMakeMistakesWithIt, _.


Além disso, o Python permite-lhe utilizar não só letras latinas mas também carateres específicos de línguas que utilizam outros alfabetos.

Estes nomes de variáveis também estão corretos:

Adiós_Señora, sûr_la_mer, Einbahnstraße, переменная.

E agora alguns nomes incorretos:

10t (não começa com uma letra), Exchange Rate (contém um espaço)


NOTA

O PEP 8 — Style Guide for Python Code recomenda a seguinte convenção de nomenclatura para variáveis e funções em Python:

os nomes de variáveis devem ser minúsculas, com palavras separadas por underscores para melhorar a legibilidade (por exemplo, var, my_variable)
os nomes de funções seguem a mesma convenção que os nomes de variáveis (por exemplo, fun, my_function)
também é possível utilizar um caso misto (por exemplo, myVariable), mas apenas em contextos onde esse já é o estilo predominante, para manter a retrocompatibilidade com a convenção adotada.

Keywords
Dê uma vista de olhos na lista de palavras que desempenham um papel muito especial em todos os programa Python.

['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']

São chamadas keywords ou (mais precisamente) reserved keywords. (keywords reservadas) São reservadas porque não deve utilizá-las como nomes: nem para as suas variáveis, nem para as suas funções, nem para quaisquer outras entidades nomeadas que queira criar.

O significado da palavra reservada é predefinido, e não deve ser alterado de forma alguma.

Felizmente, devido ao facto do Python ser sensível a maiúsculas e minúsculas, pode modificar qualquer uma destas palavras alterando qualquer letra como maiúscula ou minúscula, criando assim uma nova palavra que já não está reservada.

Por exemplo - não pode nomear a sua variável desta forma:

import

Não se deve ter uma variável assim nomeada - é proibido. Mas, em vez disso, pode fazer isto:

Import

Estas palavras podem ser um mistério para si agora, mas em breve aprenderá o seu significado.



Criar variáveis
O que se pode colocar dentro de uma variável?

Qualquer coisa.

Pode utilizar uma variável para armazenar qualquer valor de qualquer um dos tipos já apresentados, e muitos mais dos que ainda não lhe mostrámos.

O valor de uma variável é o que lhe foi atribuído. Pode variar com a frequência que precisar ou desejar. Pode ser um inteiro num momento, e um float um momento a seguir, acabando por se tornar uma string.

Falemos agora de duas coisas importantes - como as variáveis são criadas, e como colocar valores dentro delas (ou melhor - como dar ou passar valores a elas).

LEMBRE-SE

Uma variável passa a existir como o resultado da atribuição de um valor a ela. Ao contrário de outras linguagens, não precisa de a declarar de nenhuma forma especial.

Se atribuir qualquer valor a uma variável inexistente, a variável será automaticamente criada. Não precisa de fazer mais nada.

A criação (ou de outra forma - a sua sintaxe) é extremamente simples: basta usar o nome da variável desejada, depois o sinal de igual (=) e o valor que se pretende colocar na variável.



O conceito de "pode colocar qualquer coisa dentro de uma variável".

Dê uma vista de olhos no snippet:

var = 1
print(var)


Consiste em duas instruções simples:

A primeira delas cria uma variável chamada var, e atribui um literal com um valor inteiro igual a 1.
A segunda imprime o valor da variável recentemente criada para a consola.

Nota: print() tem ainda outro lado - também pode tratar de variáveis. Sabe qual será o output do snippet?

Verifique
1

Utilização de variáveis
É-lhe permitido utilizar tantas declarações de variáveis quantas forem necessárias para atingir o seu objetivo, como esta:

var = 1
account_balance = 1000.0
client_name = 'John Doe'
print(var, account_balance, client_name)
print(var)


Não lhe é permitido utilizar uma variável que não existe (por outras palavras, uma variável à qual não foi atribuído um valor).

Este exemplo irá causar um erro:

var = 1
print(Var)


Tentámos usar uma variável chamada Var, que não tem qualquer valor (nota: var e Var são entidades diferentes, e não têm nada em comum no que diz respeito ao Python).


LEMBRE-SE

Pode utilizar a função print() e combinar texto e variáveis usando o operador + para fazer output de strings e variáveis, por exemplo:

var = "3.8.5"
print("Python version: " + var)


Consegue adivinhar o output do snippet acima?

Verifique
Python version: 3.8.5


Atribuição de um novo valor a uma variável já existente
Como se atribui um novo valor a uma variável já criada? Da mesma forma. Basta usar o sinal de igualdade.

O sinal de igualdade é, de facto, um operador de atribuição. Embora isto possa parecer estranho, o operador tem uma sintaxe simples e uma interpretação inequívoca.

Atribui o valor do seu argumento direito para a esquerda, enquanto que o argumento direito pode ser uma expressão arbitrariamente complexa envolvendo literais, operadores e variáveis já definidas.

Veja o código abaixo:

var = 1
print(var)
var = var + 1
print(var)


O código envia duas linhas para a consola:

1
2
output


A primeira linha do snippet cria uma nova variável chamada var e atribui 1 a ela.



A declaração diz: atribui um valor de 1 a uma variável chamada var.

Podemos dizê-lo duma forma mais curta: atribui 1 até var.

Alguns preferem ler uma declaração como esta: var torna-se 1.

A terceira linha atribui a mesma variável com o novo valor retirado da própria variável, somado com 1. Ao ver um registo como este, um matemático provavelmente protestaria - nenhum valor pode ser igual a si mesmo mais um. Isto é uma contradição. Mas o Python trata o sinal = não como igual a, mas como atribuir um valor.

Então, como se lê um tal registo no programa?

Tome o valor atual da variável var, adicione-lhe 1 e armazene o resultado na variável var.

Na verdade, o valor da variável var foi incrementado por um, o que nada tem a ver com a comparação da variável com qualquer valor.


Sabe qual será o output do seguinte snippet?

var = 100
var = 200 + 300
print(var)


Verifique
500 - porquê? Bem, primeiro, a variável var é criada e é-lhe atribuído um valor de 100. Depois, é atribuído um novo valor à mesma variável: o resultado da adição de 200 a 300, que é 500.

Resolução de problemas matemáticos simples
Agora deverá ser capaz de construir um programa curto que resolva problemas matemáticos simples, como o teorema de Pitágoras:

O quadrado da hipotenusa é igual à soma dos quadrados dos catetos.

O código seguinte avalia o comprimento da hipotenusa (ou seja, o lado mais longo de um triângulo retângulo, o oposto ao ângulo reto) usando o teorema de Pitágoras:

a = 3.0
b = 4.0
c = (a ** 2 + b ** 2) ** 0.5
print("c =", c)


Nota: precisamos de fazer uso do operador ** para avaliar a raiz quadrada como:

√(x) = x(½)

e

c = √a2 + b2

Consegue adivinhar o output do código?

Verifique abaixo e execute o código no editor para confirmar as suas previsões.

Verifique
c = 5.0

a = 3.0
b = 4.0
c = (a ** 2 + b ** 2) ** 0.5
print("c =", c)











 
 
 
 
 Sandbox
Code



Console 





Exercício 1

Que tipos de literais são os dois exemplos seguintes?

"Hello ", "007"

Verifique
Ambos são strings/literais de strings.


Exercício 2

Que tipos de literais são os quatro exemplos seguintes?

"1.5", 2.0, 528, False

Verifique
O primeiro é uma string, o segundo é um literal numérico (um float), o terceiro é um literal numérico (um inteiro), e o quarto é um literal booleano.


Exercício 3

Qual é o valor decimal do seguinte número binário?

1011

Verifique
É 11, porque (2**0) + (2**1) + (2**3) = 11


Prev Next
--------------------------------------------------------------------------------------------------------------------
Python Essentials 1:
Módulo 2
Tipos de dados, variáveis, operações básicas de input-output, operadores básicos

Neste módulo, aprenderá:

como escrever e executar programas simples de Python;
o que são literais, operadores, e expressões Python;
o que são as variáveis e quais as regras que as regem;
como realizar operações básicas de input e output.

Hello, World!
É tempo de começar a escrever algum código Python real e funcional. Vai ser muito simples por enquanto.

Como vamos mostrar-lhe alguns conceitos e termos fundamentais, estes snippets de código não serão sérios ou complexos.

Execute o código na janela do editor à direita. Se tudo correr bem aqui, verá a linha de texto na janela da consola.

Em alternativa, lançe o IDLE, crie um novo source file Python, preencha-o com este código, nomeie o ficheiro e guarde-o. Agora execute-o. Se tudo correr bem, verá o texto contido dentro das aspas na janela da consola IDLE. O código que executou deve parecer familiar. Viu algo muito semelhante quando o conduzimos através da criação do ambiente IDLE.

Agora vamos passar algum tempo a mostrar e a explicar-lhe o que está realmente a ver, e porque é que se parece com isto.

Como pode ver, o primeiro programa consiste nas seguintes partes:

a palavra print;
um parêntesis de abertura;
umas aspas;
uma linha de texto: Hello, World!;
outras aspas;
um parêntesis de fecho.
Cada um dos itens acima desempenha um papel muito importante no código.

A função print()
Veja a linha de código abaixo:

print("Hello, World!")


A palavra print que se pode ver aqui é um nome de função. Isso não significa que, onde quer que a palavra apareça, é sempre um nome de função. O significado da palavra vem do contexto em que a palavra foi usada.

Provavelmente já encontrou o termo função muitas vezes antes, durante as aulas de matemática. Provavelmente também pode listar vários nomes de funções matemáticas, como seno ou log.

As funções Python, no entanto, são mais flexíveis e podem conter mais conteúdo do que as suas irmãs matemáticas.

Uma função (neste contexto) é uma parte separada do código do computador capaz de:

causar um qualquer efeito (por exemplo, enviar texto para o terminal, criar um ficheiro, desenhar uma imagem, reproduzir um som, etc.); isto é algo completamente inédito no mundo da matemática;
avaliar um valor (por exemplo, a raiz quadrada de um valor ou o comprimento de um dado texto) e devolvê-lo como o resultado da função; é isto que faz as funções Python serem os parentes dos conceitos matemáticos.
Além disso, muitas das funções Python podem fazer as duas coisas acima juntamente.


De onde vêm as funções?

Podem vir do próprio Python; a função print é uma deste tipo; tal função é um valor acrescentado recebido juntamente com o Python e o seu ambiente (é incorporada); não é necessário fazer nada de especial (por exemplo, perguntar a alguém por qualquer coisa) se quiser fazer uso dela;
podem ser provenientes de um ou mais dos add-ons de Python chamados módulos; alguns dos módulos vêm com Python, outros podem requerer instalação separada - seja qual for o caso, todos eles precisam de estar explicitamente ligados ao seu código (mostrar-lhe-emos como fazê-lo em breve);
pode escrevê-los você mesmo, colocando tantas funções quantas quiser e precisar dentro do seu programa para o tornar mais simples, mais claro e mais elegante.
O nome da função deve ser significativo (o nome da função print é evidente por si mesmo).

Claro que, se vai fazer uso de qualquer função já existente, não tem influência no seu nome, mas quando começar a escrever as suas próprias funções, deve considerar cuidadosamente a sua escolha de nomes.

A função print()
Como dissemos antes, uma função pode ter:

um efeito;
um resultado.
Há também uma terceira, muito importante, componente de função - o(s) argumento(s).

As funções matemáticas normalmente aceitam um argumento, por exemplo, sen(x) toma um x, que é a medida de um ângulo.

As funções de Python, por outro lado, são mais versáteis. Dependendo das necessidades individuais, elas podem aceitar qualquer número de argumentos - tantos quantos forem necessários para desempenhar as suas tarefas. Nota: qualquer número inclui zero - algumas funções de Python não precisam de qualquer argumento.

print("Hello, World!")


Apesar do número de argumentos necessários/fornecidos, as funções Python exigem fortemente a presença de um par de parêntesis - de abertura e de fecho, respetivamente.


Se quiser entregar um ou mais argumentos a uma função, coloque-os dentro dos parêntesis. Se for utilizar uma função que não aceita qualquer argumento, ainda assim tem de ter os parêntesis.

Nota: para distinguir palavras comuns de nomes de funções, coloque um par de parêntesis vazios após os seus nomes, mesmo que a função correspondente queira um ou mais argumentos. Esta é uma convenção padrão.

A função de que estamos a falar aqui é print().

A função print() no nosso exemplo tem algum argumento?

Claro que sim, mas o que são eles?

A função print()
O único argumento entregue à função print() neste exemplo é uma string:

print("Hello, World!")


Como pode ver, a string é delimitada com aspas - de facto, as aspas fazem a string - cortam uma parte do código e atribuem-lhe um significado diferente.

Pode imaginar que as aspas dizem algo como: o texto entre nós não é código. Não se destina a ser executado, e deve tomá-lo como está.

Quase tudo o que colocar dentro das aspas será tomado literalmente, não como código, mas como dados. Tente jogar com esta string em particular - modificá-la, introduzir algum conteúdo novo, apagar algum do conteúdo existente.


Há mais do que uma maneira de especificar uma string dentro do código Python, mas por agora, esta é suficiente.


O conceito da string 'Hello, World!'


Até agora, aprendeu sobre duas partes importantes do código: a função e a string. Falámos sobre elas em termos de sintaxe, mas agora é altura de os discutir em termos de semântica.

A função print()
O nome da função (print neste caso) juntamente com os parêntesis e o(s) argumento(s), formam a invocação da função.

Discutiremos isto com mais profundidade em breve, mas devemos dar-lhe umas luzes de momento.

print("Hello, World!")



O que acontece quando o Python encontra uma invocação como esta abaixo?

function_name(argument)




Vamos ver:

Primeiro, o Python verifica se o nome especificado é legal (navega nos seus dados internos a fim de encontrar uma função existente com o mesmo nome; se esta pesquisa falhar, o Python aborta o código);
segundo, o Python verifica se os requisitos da função para o número de argumentos lhe permitem invocar a função desta forma (por exemplo, se uma função específica exigir exatamente dois argumentos, qualquer invocação que apresente apenas um argumento será considerada errada, e abortará a execução do código);
terceiro, o Python deixa o seu código por um momento e salta para a função que pretende invocar; claro, também leva o(s) seu(s) argumento(s) e passa-o(s) para a função;
quarto, a função executa o seu código, causa o efeito desejado (se houver um), avalia o(s) resultado(s) desejado(s) (se existir(em)) e termina a sua tarefa;
finalmente, o Python regressa ao seu código (ao local imediatamente após a invocação) e retoma a sua execução.

LAB

Tempo estimado
5-10 minutos

Nível de dificuldade
Muito fácil

Objetivos
familiarizar-se com a função print() e as suas capacidades de formatação;
experimentar com código Python.
Cenário
O comando print() , que é uma das diretivas mais fáceis em Python, imprime simplesmente uma linha para o ecrã.

No seu primeiro lab:

use a função print() para imprimir a linha Hello, Python! para o ecrã. Use aspas duplas à volta da string;
tendo feito isso, utilize a função print() novamente, mas desta vez imprima o seu primeiro nome;
remova as aspas duplas e execute o seu código. Veja a reação do Python. Que tipo de erro é lançado?
depois, retire os parêntesis, volte a colocar as aspas duplas, e execute novamente o seu código. Que tipo de erro é lançado desta vez?
experimente o máximo que puder. Altere aspas duplas com aspas simples, use várias funções print() na mesma linha e, em seguida, em linhas diferentes. Veja o que acontece.

A função print()
Três questões importantes têm de ser respondidas assim que possível:

1. Qual é o efeito que a função print() causa?

O efeito é muito útil e muito espetacular. A função:

toma os seus argumentos (pode aceitar mais do que um argumento e pode também aceitar menos do que um argumento)
converte-os numa forma legível para o ser humano, se necessário (como pode suspeitar, as strings não requerem esta ação, uma vez que a string já é legível)
e envia os dados resultantes para o dispositivo de output (normalmente a consola); por outras palavras, qualquer coisa que coloque na função print() aparecerá no ecrã.
Não admira, então, que a partir de agora utilize print() muito intensivamente para ver os resultados das suas operações e avaliações.


2. Que argumentos print() espera?

Quaisquer. Mostrar-lhe-emos em breve que print() é capaz de operar com virtualmente todos os tipos de dados oferecidos pelo Python. Strings, números, carateres, valores lógicos, objetos - qualquer um destes pode ser passado com sucesso para print().


3. Que valor é devolvido pela função print() ?

Nenhum. O seu efeito é suficiente.

A função print() - instruções
Já viu um programa de computador que contém uma invocação de função. Uma invocação de função é um dos muitos tipos possíveis de instruções Python.

É claro que qualquer programa complexo contém geralmente muito mais instruções do que uma. A questão é: como se acoplam mais do que uma instrução no código Python?

A sintaxe de Python é bastante específica nesta área. Ao contrário da maioria das linguagens de programação, o Python requer que não haja mais do que uma instrução numa linha.

Uma linha pode estar vazia (ou seja, pode não conter qualquer instrução) mas não deve conter duas, três ou mais instruções. Isto é estritamente proibido.

Nota: o Python faz uma exceção a esta regra - permite que uma instrução se espalhe por mais do que uma linha (o que pode ser útil quando o seu código contém construções complexas).

Vamos expandir um pouco o código, pode vê-lo no editor. Execute-o e anote o que vê na consola.

A sua consola Python deve agora ter este aspeto:

The itsy bitsy spider climbed up the waterspout.
Down came the rain and washed the spider out.
output

Esta é uma boa oportunidade para fazer algumas observações:

o programa invoca a função print() duas vezes, e pode ver duas linhas separadas na consola - isto significa que print() começa o seu output a partir de uma nova linha cada vez que inicia a sua execução; pode alterar este comportamento, mas também pode utilizá-lo em seu proveito;
cada invocação print() contém uma string diferente, uma vez que o seu argumento e o conteúdo da consola a refletem - isto significa que as instruções no código são executadas pela mesma ordem em que foram colocadas no source file; nenhuma instrução seguinte é executada até que a anterior esteja concluída (há algumas exceções a esta regra, mas pode ignorá-las por agora)

print("The itsy bitsy spider climbed up the waterspout.")
print("Down came the rain and washed the spider out.")

A função print() - instruções
Mudámos um pouco o exemplo - acrescentámos uma invocação de função vazia print() . Chamamos-lhe vazia porque não apresentámos quaisquer argumentos para a função.

Pode vê-lo na janela do editor. Execute o código.

O que acontece?

Se tudo correr bem, deverá ver algo como isto:

The itsy bitsy spider climbed up the waterspout.

Down came the rain and washed the spider out.
output

Como pode ver, a invocação vazia print() não é tão vazia como se poderia esperar - produz uma linha vazia, ou (esta interpretação também é correta) o seu output é apenas uma newline.

print("The itsy bitsy spider climbed up the waterspout.")
print()
print("Down came the rain and washed the spider out.")

A função print() - os carateres de escape e de newline
Modificámos novamente o código. Olhe com atenção.

Há duas mudanças muito subtis - inserimos um estranho par de carateres dentro da rima. Têm este aspeto: \n.


Curiosamente, enquanto se pode ver dois carateres, o Python vê um.

A barra invertida (\) tem um significado muito especial quando usado dentro de strings - a isto chama-se o caratere de escape.

A palavra escape deve ser entendida especificamente - significa que a série de carateres na string escapa por um momento (um momento muito curto) para introduzir uma inclusão especial.

Por outras palavras, a barra invertida não significa nada em si, mas é apenas uma espécie de anúncio de que o próximo caratere após a barra invertida também tem um significado diferente.

A letra n colocada após a barra invertida vem da palavra newline (nova linha).

Tanto a barra invertida como o n formam um símbolo especial chamado um caratere de newline, que incita a consola a iniciar uma nova linha de output.
Execute o código. A sua consola deve agora ter este aspeto:

The itsy bitsy spider
climbed up the waterspout.

Down came the rain
and washed the spider out.
output

Como pode ver, duas newlines aparecem na canção de embalar, nos locais onde as \n foram usadas.

print("The itsy bitsy spider\nclimbed up the waterspout.")
print()
print("Down came the rain\nand washed the spider out.")

A função print() - os carateres de escape e de newline
Esta convenção tem duas consequências importantes:

1. Se quiser colocar apenas uma barra invertida dentro de uma string, não se esqueça da sua natureza de escape - tem de a duplicar, por exemplo, uma tal invocação causará um erro:

print("\")


enquanto esta não o fará:

print("\\")


2. Nem todos os pares de escape (a barra invertida acoplada a outro caratere) significam algo.

print("The itsy bitsy spider\nclimbed up the waterspout.")
print()
print("Down came the rain\nand washed the spider out.")

A função print() - utilizar múltiplos argumentos
Até agora, testámos o comportamento da função print() sem argumentos, e com um argumento. Também vale a pena tentar alimentar a função print() com mais do que um argumento.

Olhe para a janela do editor. Isto é o que vamos testar agora:

print("The itsy bitsy spider" , "climbed up" , "the waterspout.")


Há uma invocação da função print() , mas contém três argumentos. Todos eles são strings.

Os argumentos são separados por vírgulas. Cercamo-los de espaços para os tornar mais visíveis, mas não é realmente necessário, e não o faremos mais.

Neste caso, as vírgulas que separam os argumentos desempenham um papel completamente diferente da vírgula dentro da string. A primeira é uma parte da sintaxe de Python, a segunda destina-se a ser mostrada na consola.

Se voltar a olhar para o código, verá que não há espaços dentro das strings.

Execute o código e veja o que acontece.

A consola deve agora mostrar o seguinte texto:

The itsy bitsy spider climbed up the waterspout.
output

Os espaços, removidos das strings, apareceram novamente. Pode explicar porquê?

Duas conclusões emergem deste exemplo:

a função print() invocada com mais do que um argumento faz output de todos eles numa só linha;
a função print() coloca um espaço entre os argumentos de output, por sua própria iniciativa.

print("The itsy bitsy spider" , "climbed up" , "the waterspout.")


A função print() - a forma posicional de passar os argumentos
Agora que sabe um pouco sobre print() costumes da função, vamos mostrar-lhe como alterá-los.

Deverá ser capaz de prever o output sem correr o código no editor.

A forma como estamos a passar os argumentos para a função print() é a mais comum em Python, e é chamada a forma posicional (este nome vem do facto de o significado do argumento ser ditado pela sua posição, por exemplo, o segundo argumento será produzido após o primeiro, e não o contrário).

Execute o código e verifique se o output corresponde às suas previsões.

print("My name is", "Python.")
print("Monty Python.")

A função print() - os argumentos de keyword

O Python oferece outro mecanismo para a passagem de argumentos, que pode ser útil quando se quer convencer a print() função a alterar um pouco o seu comportamento.

Não o vamos explicar em profundidade neste momento. Planeamos fazê-lo quando falarmos de funções. Por agora, queremos simplesmente mostrar-lhe como funciona. Sinta-se à vontade para o utilizar nos seus próprios programas.

O mecanismo é chamado argumentos de keyword. O nome deriva do facto de o significado destes argumentos ser retirado não da sua localização (posição) mas da palavra especial (keyword) utilizada para os identificar.

A função print() tem dois argumentos de keyword que pode usar para os seus propósitos. O primeiro deles é nomeado end.

Na janela do editor pode ver um exemplo muito simples da utilização de um argumento de keyword.

Para a sua utilização, é necessário conhecer algumas regras:

um argumento de keyword consiste em três elementos: uma keyword identificando o argumento (end aqui); um sinal de igual (=); e um valor atribuído a esse argumento;
qualquer argumento de keyword tem de ser colocado após o último argumento posicional (isto é muito importante)

No nosso exemplo, fizemos uso do end argumento de keyword, e definimo-lo para uma string contendo um espaço.

Execute o código para ver como ele funciona.

A consola deve agora mostrar o seguinte texto:

My name is Python. Monty Python.
output

Como pode ver, o argumento de keyword end determina os carateres que a função print() envia para o output, uma vez que atinge o final dos seus argumentos posicionais.

O comportamento padrão reflete a situação em que o argumento de keyword end é implicitamente usado da seguinte maneira: end="\n".

print("My name is", "Python.", end=" ")
print("Monty Python.")

A função print() - os argumentos de keyword
E agora é tempo de tentar algo mais difícil.

Se olhar cuidadosamente, verá que utilizámos o argumento end , mas a string atribuída a ele está vazia (não contém nenhum caratere).

O que vai acontecer agora? Execute o programa no editor para descobrir.

Como o argumento end foi definido para nada, a função print() também não produz nenhum output, uma vez que os seus argumentos posicionais foram esgotados.

A consola deve agora mostrar o seguinte texto:

My name is Monty Python.
output

Nota: não foram enviadas newlines para o output.

A string atribuída ao argumento de keyword end pode ter qualquer comprimento. Experimente-a se quiser.

print("My name is ", end="")
print("Monty Python.")

A função print() - os argumentos de keyword
Já dissemos anteriormente que a função print() separa os seus argumentos de output com espaços. Este comportamento também pode ser alterado.

O argumento de keyword que pode fazer isto é chamado sep (como separador).

Veja o código no editor, e execute-o.

O argumento sep fornece os seguintes resultados:

My-name-is-Monty-Python.
output

A função print() agora utiliza um traço, em vez de um espaço, para separar os argumentos de output.

Nota: o valor do argumento sep também pode ser uma string vazia. Experimente você mesmo.

print("My", "name", "is", "Monty", "Python.", sep="-")

A função print() - os argumentos de keyword
Ambos os argumentos de keyword podem ser misturados numa só invocação, tal como aqui na janela do editor.

O exemplo não faz muito sentido, mas apresenta visivelmente as interações entre end e sep.

Consegue prever o output?

Execute o código e veja se corresponde às suas previsões.

Agora que compreende a função print() , está pronto a considerar como armazenar e processar dados em Python.

Sem print(), não seria capaz de ver nenhum resultado.

print("My", "name", "is", sep="_", end="*")
print("Monty", "Python.", sep="*", end="*\n")

LAB

Tempo estimado
5-10 minutos

Nível de dificuldade
Muito fácil

Objetivos
familiarizar-se com a função print() e as suas capacidades de formatação;
experimentar com código Python.
Cenário
Modifique a primeira linha de código no editor, usando as keywords sep e end , para corresponder ao output esperado. Use as duas print() funções no editor.

Não mude nada na segunda invocação print() .

Output esperado
Programming***Essentials***in...Python
output

print("Programming","Essentials","in")
print("Python")

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Fácil

Objetivos
experimentar com o código Python existente;
descobrir e corrigir erros básicos de sintaxe;
familiarizar-se com a função print() e os seus recursos de formatação.
Cenário
Encorajamo-lo vivamente a brincar com o código que escrevemos para si, e a fazer algumas (talvez mesmo destrutivas) alterações. Sinta-se livre para modificar qualquer parte do código, mas há uma condição - aprenda com os seus erros e tire as suas próprias conclusões.

Tente:

minimizar o número de invocações da função print() inserindo a sequência \n nas strings
fazer a seta duas vezes maior (mas mantendo as proporções)
duplicar a seta, colocando ambas as setas lado a lado; nota: uma string pode ser multiplicada usando o seguinte truque: "string" * 2 produzirá "stringstring" (brevemente, falaremos mais sobre o assunto)
retire qualquer uma das aspas, e veja cuidadosamente a resposta do Python; preste atenção ao local onde o Python vê um erro - é este o local onde o erro realmente existe?
faça o mesmo com alguns dos parêntesis;
altere qualquer uma das print palavras por outra coisa, diferindo apenas no caso (por exemplo, Print) - o que acontece agora?
substitua algumas das aspas por apóstrofes; observe cuidadosamente o que acontece.

print("    *")
print("   * *")
print("  *   *")
print(" *     *")
print("***   ***")
print("  *   *")
print("  *   *")
print("  *****")

Key takeaways
1. A função print() é uma função incorporada. Imprime/faz output de uma mensagem especificada para a janela do ecrã/consola.

2. As funções incorporadas, ao contrário das funções definidas pelo utilizador, estão sempre disponíveis e não têm de ser importadas. O Python 3.8 vem com 69 funções incorporadas. Pode encontrar a sua lista completa fornecida em ordem alfabética na Biblioteca Padrão Python.

3. Para chamar uma função (este processo é conhecido como invocação de função ou chamada de função), é necessário usar o nome da função seguido de parêntesis. Pode passar argumentos para uma função, colocando-os dentro dos parêntesis. Deve separar os argumentos com uma vírgula, por exemplo, print("Hello,", "world!"). Uma função “vazia” print() faz output de uma linha vazia para o ecrã.

4. As strings de Python são delimitadas com aspas, por exemplo, "I am a string" (aspas duplas), ou 'I am a string, too' (aspas simples).

5. Os programas de computador são coleções de instruções. Uma instrução é um comando para executar uma tarefa específica quando executada, por exemplo, para imprimir uma determinada mensagem no ecrã.

6. Em strings de Python a barra invertida (\) é um caratere especial que anuncia que o próximo caratere tem um significado diferente, por exemplo \n (the newline character) starts a new output line.

7. Os argumentos posicionais são aqueles cujo significado é ditado pela sua posição, por exemplo, o segundo argumento é apresentado após o primeiro, o terceiro é apresentado após o segundo, etc.

8. Os argumentos de keyword são aqueles cujo significado não é ditado pela sua localização, mas por uma palavra especial (keyword) utilizada para os identificar.

9. Os loops end e sep podem ser usados para formatar o output da função print() . O parâmetro sep especifica o separador entre os argumentos de output (por exemplo, o parâmetro print("H", "E", "L", "L", "O", sep="-"), enquanto o parâmetro end especifica o que imprimir no final da declaração print.









--------------------------------------------------------------------------------------------------------------------
Python Essentials 1:
Módulo 3
Valores Booleanos, Execução Condicional, Loops, Listas e Processamento de Lista, Operações Lógicas e Bitwise

Neste módulo, serão abordados os seguintes tópicos:

o tipo de dados Booleano;
operadores relacionais;
tomar decisões em Python (if, if-else, if-elif, else)
como repetir a execução de código utilizando loops (while, for)
como executar operações lógicas e bitwise em Python;
listas em Python (construção, indexação e slicing; manipulação de conteúdo)
como classificar uma lista usando algoritmos de bubble-sort;
listas multidimensionais e suas aplicações.

Perguntas e respostas
Um programador escreve um programa e o programa faz perguntas.

Um computador executa o programa e fornece as respostas. O programa deve ser capaz de reagir de acordo com as respostas recebidas.

Felizmente, os computadores conhecem apenas dois tipos de respostas:

sim, isto é verdade;
não, isto é falso.
Nunca obterá uma resposta como Deixe-me pensar...., Não sei, ou Provavelmente sim, mas não tenho a certeza.

Para fazer perguntas, o Python utiliza um conjunto de operadores muito especiais. Vamos analisá-los um após outro, ilustrando os seus efeitos em alguns exemplos simples.


Comparação: operador de igualdade
Pergunta: são dois valores iguais?

Para fazer esta pergunta, utiliza o operador == (igual igual).

Não se esqueça desta importante distinção:

= é um operador de atribuição, por exemplo, a = b atribui a com o valor de b;
== é a questão são estes valores iguais?; a == b compara a e b.
É um operador binário com ligação do lado esquerdo. Precisa de dois argumentos e verifica se são iguais.

Igualdade: o operador igual a (==)
A função == (igual a) compara os valores de dois operandos. Se forem iguais, o resultado da comparação é True. Se eles não forem iguais, o resultado da comparação é False.

Veja a comparação de igualdade abaixo - qual é o resultado desta operação?

var == 0


Note que não podemos encontrar a resposta se não soubermos qual o valor atualmente armazenado na variável var.

Se a variável tiver sido alterada muitas vezes durante a execução do seu programa, ou o seu valor inicial for inserido a partir da consola, a resposta a esta pergunta pode ser dada apenas pelo Python, e apenas em runtime.

Agora imagine um programador que sofre de insónias, e que tem de contar ovelhas pretas e brancas separadamente enquanto houver exatamente o dobro das ovelhas pretas do que das brancas.

A questão será a seguinte:

black_sheep == 2 * white_sheep


Devido à baixa prioridade do operador == , a questão deve ser tratada como equivalente a esta:

black_sheep == (2 * white_sheep)


Então, vamos praticar a sua compreensão do operador == - consegue adivinhar o output do código abaixo?

var = 0  # Assigning 0 to var
print(var == 0)

var = 1  # Assigning 1 to var
print(var == 0)


Execute o código e verifique se estava certo.

Desigualdade: o operador não igual a (!=)
A função != (não igual) também compara os valores de dois operandos. Aqui está a diferença: se eles forem iguais, o resultado da comparação é False. Se eles não forem iguais, o resultado da comparação é True.

Agora dê uma vista de olhos na comparação de desigualdade em baixo - consegue adivinhar o resultado desta operação?

var = 0  # Assigning 0 to var
print(var != 0)

var = 1  # Assigning 1 to var
print(var != 0)


Execute o código e verifique se estava certo.

Operadores de comparação: maior que
Pode também fazer uma pergunta de comparação usando o operador > (maior que).

Se quiser saber se há mais ovelhas pretas do que brancas, pode escrevê-lo da seguinte forma:

black_sheep > white_sheep  # Greater than


True confirma-o; False nega-o.


Operadores de comparação: maior que ou igual a
O operador maior que tem outra variante especial, não estrita, mas é denotada de forma diferente da notação aritmética clássica: >= (maior que ou igual a)

Existem dois sinais subsequentes, não um.

Ambos os operadores (estritos e não-estritos), bem como os outros dois discutidos na próxima secção, são operadores binários com ligação à esquerda, e a sua prioridade é maior do que a mostrada por == e !=.

Se quisermos descobrir se temos ou não de usar um chapéu quente, fazemos a seguinte pergunta:

centigrade_outside ≥ 0.0  # Greater than or equal to


Operadores de comparação: menor que ou igual a
Como já deve ter adivinhado, os operadores utilizados neste caso são: o < (less than) operator and its non-strict sibling: <= (menor que ou igual a).

Veja este exemplo simples:

current_velocity_mph < 85  # Less than
current_velocity_mph ≤ 85  # Less than or equal to


Vamos verificar se existe o risco de ser multado pela polícia rodoviária (a primeira pergunta é rigorosa, a segunda não).


Fazer uso das respostas
O que pode fazer com a resposta (ou seja, o resultado de uma operação de comparação) que obtém do computador?

Há pelo menos duas possibilidades: primeiro, pode memorizá-la (armazená-la numa variável) e utilizá-la mais tarde. Como se faz isso? Bem, utilizaria uma variável arbitrária como esta:

answer = number_of_lions >= number_of_lionesses


O conteúdo da variável dar-lhe-á a resposta à pergunta feita.


A segunda possibilidade é mais conveniente e muito mais comum: pode usar a resposta que obtém para tomar uma decisão sobre o futuro do programa.

Precisa de uma instrução especial para este fim, e discutiremos isso muito em breve.

Agora precisamos de atualizar a nossa tabela de prioridades e colocar todos os novos operadores na mesma. Agora parece-se com o seguinte:

Prioridade	Operador	
1	+, -	unário
2	**	
3	*, /, //, %	
4	+, -	binário
5	<, <=, >, >=	
6	==, !=	

Tempo estimado
5-10 minutos

Nível de dificuldade
Muito fácil

Objetivos
familiarizar-se com a função input() ;
familiarizar-se com os operadores de comparação em Python.
Cenário
Usando um dos operadores de comparação em Python, escreva um programa simples de duas linhas que toma o parâmetro n como input, que é um inteiro, e imprime False Se n for menor que 100, e True Se n for maior ou igual que 100.

Não crie blocos if nenhuns (vamos falar deles muito em breve). Teste o seu código utilizando os dados que lhe fornecemos.

Dados de teste

Input de amostra: 55

Output esperado: False

Input de amostra: 99

Output esperado: False

Input de amostra: 100

Output esperado: True

Input de amostra: 101

Output esperado: True

Input de amostra: -5

Output esperado: False

Input de amostra: +123

Output esperado: True

Condições e execução condicional
Já sabe como fazer perguntas ao Python, mas ainda não sabe como fazer um uso razoável das respostas. Tem de ter um mecanismo que lhe permita fazer algo se uma condição for cumprida, e não o fazer se não o for.

É como na vida real: faz-se ou não certas coisas quando uma condição específica é cumprida ou não, por exemplo, vai-se passear se o tempo estiver bom, ou fica-se em casa se estiver a chover e a fazer frio.

Para tomar tais decisões, o Python oferece uma instrução especial. Devido à sua natureza e à sua aplicação, chama-se instrução condicional (ou declaração condicional).

Existem várias variantes da mesma. Vamos começar com a mais simples, aumentando a dificuldade lentamente.

A primeira forma de uma declaração condicional, que pode ver abaixo, é escrita de forma muito informal mas figurativa:

if true_or_not:
    do_this_if_true


Esta declaração condicional consiste nos seguintes elementos, estritamente necessários, apenas nesta e nesta ordem:

a keyword if ;
um ou mais espaços em branco;
uma expressão (uma pergunta ou uma resposta) cujo valor será interpretado unicamente em termos de True (quando o seu valor é diferente de zero) e False (quando é igual a zero);
um dois pontos seguido de uma newline;
uma instrução indentada ou conjunto de instruções (pelo menos uma instrução é absolutamente necessária); a indentação pode ser conseguida de duas maneiras - inserindo um determinado número de espaços (a recomendação é utilizar quatro espaços de indentação), ou utilizando o caratere tab; nota: se houver mais de uma instrução na parte indentada, a indentação deve ser a mesma em todas as linhas; mesmo que possa parecer a mesma se usar tabs misturados com espaços, é importante fazer todas as indentações exatamente iguais - o Python 3 não permite a mistura de espaços e tabs para indentação.


Como funciona essa declaração?

Se a expressão true_or_not representa a verdade (ou seja, o seu valor não é igual a zero), a(s) declaração(ões) indentada(s) será(ão) executada(s);
se a expressão true_or_not não representa a verdade (ou seja, o seu valor é igual a zero), a(s) declaração(ões) indentada(s) será(ão) omitida(s) (ignoradas), e a próxima instrução executada será a que se segue ao nível da indentação original.

Na vida real, expressamos frequentemente um desejo:

se o tempo estiver bom, vamos dar um passeio

depois, vamos almoçar


Como se pode ver, almoçar não é uma atividade condicional e não depende do tempo.

Sabendo que condições influenciam o nosso comportamento, e assumindo que temos as funções sem parâmetros go_for_a_walk() e have_lunch(), podemos escrever o seguinte snippet:

if the_weather_is_good:
    go_for_a_walk()
have_lunch()


Prev Next

Execução condicional: a declaração if .
Se um certo programador de Python insonioso acabar por adormecer enquanto conta 120 ovelhas, e se este procedimento de indução do sono pudesse ser implementado como uma função especial chamada sleep_and_dream(), todo o código assumiria a seguinte forma:

if sheep_counter >= 120: # Evaluate a test expression
    sleep_and_dream() # Execute if test expression is True
	

Pode lê-lo como: se sheep_counter é maior que ou igual a 120, então, adormecer e sonhar (ou seja, executar a função sleep_and_dream .)

Dissemos que as declarações executadas condicionalmente têm de ser indentadas. Isto cria uma estrutura muito legível, demonstrando claramente todos os caminhos de execução possíveis no código.

Dê uma vista de olhos no seguinte código:

if sheep_counter >= 120:
    make_a_bed()
    take_a_shower()
    sleep_and_dream()
feed_the_sheepdogs()


Como pode ver, fazer a cama, tomar um banho, e adormecer e sonhar, são todos executados condicionalmente - quando se sheep_counter atinge o limite desejado.

Alimentar os cães de ovelha, no entanto, é sempre feito (ou seja, a função feed_the_sheepdogs() não é indentada e não pertence ao bloco if , o que significa que é sempre executada.)

Agora, vamos discutir outra variante da declaração condicional, que também lhe permite executar uma ação adicional quando a condição não for cumprida.


Execução condicional: a declaração if-else .
Começámos com uma frase simples, que diz: Se o tempo estiver bom, vamos dar um passeio.

Nota - não há uma palavra sobre o que irá acontecer se o tempo estiver mau. Nós apenas sabemos que não vamos para o exterior, mas o que poderíamos fazer em vez disso não é conhecido. Podemos querer planear algo em caso de mau tempo, também.

Podemos dizer, por exemplo: Se o tempo estiver bom, vamos dar uma caminhada, caso contrário, vamos a um teatro.

Agora sabemos o que iremos fazer se as condições forem cumpridas, e sabemos o que iremos fazer se nem tudo correr à nossa maneira. Por outras palavras, temos um “Plano B”.

O Python permite-nos expressar estes planos alternativos. Isto é feito com uma segunda forma, ligeiramente mais complexa, da declaração condicional, a declaração if-else:

if true_or_false_condition:
    perform_if_condition_true
else:
    perform_if_condition_false


Assim, há uma nova palavra: else - Esta é uma keyword.

A parte do código que começa com else diz o que fazer se a condição especificada para o if não for cumprida (observe os dois pontos após a palavra).

A execução if-else é feita da seguinte forma:

se a condição for avaliada comoTrue (o seu valor não é igual a zero), a declaração perform_if_condition_true é executada, e a declaração condicional chega ao fim;
se a condição for avaliada como False (o seu valor é igual a zero), a declaração perform_if_condition_false é executada, e a declaração condicional chega ao fim.

A declaração if-else : execução mais condicional
Ao utilizar esta forma de declaração condicional, podemos descrever os nossos planos da seguinte forma:

if the_weather_is_good:
    go_for_a_walk()
else:
    go_to_a_theater()
have_lunch()


Se o tempo estiver bom, vamos dar uma volta. Caso contrário, iremos a uma peça de teatro. Não importa se o tempo estiver bom ou mau, almoçaremos depois (depois do passeio ou depois de irmos ao teatro).

Tudo o que dissemos sobre a indentação funciona da mesma forma dentro do ramo else:

if the_weather_is_good:
    go_for_a_walk()
    have_fun()
else:
    go_to_a_theater()
    enjoy_the_movie()
have_lunch()


Declarações if-else nested
Agora vamos discutir dois casos especiais da declaração condicional.

Primeiro, considere o caso em que a instrução colocada após a if é outra if.

Leia o que temos planeado para este domingo. Se o tempo estiver bom, vamos dar uma volta. Se encontrarmos um bom restaurante, almoçaremos lá. Caso contrário, comemos uma sandes. Se o tempo estiver mau, vamos ao teatro. Se não houver bilhetes, iremos às compras no centro comercial mais próximo.

Vamos escrever o mesmo em Python. Considere cuidadosamente o código aqui:

if the_weather_is_good:
    if nice_restaurant_is_found:
        have_lunch()
    else:
        eat_a_sandwich()
else:
    if tickets_are_available:
        go_to_the_theater()
    else:
        go_shopping()



Aqui estão dois pontos importantes:

este uso da declaração if é conhecido como nesting; lembre-se que cada else refere-se ao if que se situa ao mesmo nível de indentação; é preciso saber isto para determinar como os ifs e elses se emparelham;

considere como a indentação melhora a legibilidade, e torna o código mais fácil de compreender e rastrear.

A declaração elif .

O segundo caso especial introduz outra nova keyword de Python: elif. Como provavelmente suspeitará, é uma forma mais curta de else if.

elif é usado para verificar mais do que uma condição, e para parar quando a primeira afirmação que é verdadeira é encontrada.

O nosso próximo exemplo assemelha-se a nesting, mas as semelhanças são muito ligeiras. Mais uma vez, vamos mudar os nossos planos e expressá-los como se segue: Se o tempo estiver bom, iremos dar um passeio, caso contrário, se conseguirmos bilhetes, iremos ao teatro, caso contrário, se houver mesas livres no restaurante, iremos almoçar; se tudo o resto falhar, regressaremos a casa e jogaremos xadrez.

Já reparou quantas vezes utilizámos as palavras caso contrário? Esta é a fase em que a keyword elif desempenha o seu papel.

Vamos escrever o mesmo cenário usando Python:

if the_weather_is_good:
    go_for_a_walk()
elif tickets_are_available:
    go_to_the_theater()
elif table_is_available:
    go_for_lunch()
else:
    play_chess_at_home()
    
    Análise de amostras de código
Agora vamos mostrar-lhe alguns programas simples mas completos. Não os explicaremos em detalhe, porque consideramos os comentários (e os nomes das variáveis) dentro do código guias suficientes.

Todos os programas resolvem o mesmo problema - eles encontram o maior de vários números e imprimem-no.

Exemplo 1:

Vamos começar com o caso mais simples - como identificar o maior de dois números:

# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))

# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2

# Print the result
print("The larger number is:", larger_number)


O snippet acima deve ser claro - ele lê dois valores inteiros, compara-os e descobre qual é o maior.

Exemplo 2:

Agora vamos mostrar-lhe um facto intrigante. O Python tem uma característica interessante, veja o código abaixo:

# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))

# Choose the larger number
if number1 > number2: larger_number = number1
else: larger_number = number2

# Print the result
print("The larger number is:", larger_number)


Nota: se algum dos ramos if-elif-else contiver apenas uma instrução, pode codificá-la de uma forma mais abrangente (não precisa de fazer uma linha indentada após a keyword, mas apenas continuar a linha após os dois pontos).

Este estilo, contudo, pode ser enganador, e não o vamos utilizar nos nossos futuros programas, mas vale definitivamente a pena saber se quiser ler e compreender os programas de outra pessoa.

Não há outras diferenças no código.

Exemplo 3:

É altura de complicar o código - vamos encontrar o maior de três números. Será que vai ampliar o código? Um pouco.

Assumimos que o primeiro valor é o maior. Em seguida, verificamos essa hipótese com os dois valores restantes.

Veja o código abaixo:

# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1

# We check if the second number is larger than current largest_number
# and update largest_number if needed.
if number2 > largest_number:
    largest_number = number2

# We check if the third number is larger than current largest_number
# and update largest_number if needed.
if number3 > largest_number:
    largest_number = number3

# Print the result
print("The largest number is:", largest_number)


Este método é significativamente mais simples do que tentar encontrar o maior número ao mesmo tempo, comparando todos os pares de números possíveis (ou seja, o primeiro com o segundo, o segundo com o terceiro, o terceiro com o primeiro). Tente reconstruir o código por si mesmo.

Pseudo-código e introdução aos loops
Deverá agora ser capaz de escrever um programa que encontre o maior de quatro, cinco, seis, ou mesmo dez números.

Já conhece o esquema, pelo que alargar a dimensão do problema não será particularmente complexo.

Mas o que acontece se lhe pedirmos para escrever um programa que encontre o maior de duzentos números? Consegue imaginar o código?

Vai precisar de duzentas variáveis. Se duzentas variáveis não for suficientemente mau, tente imaginar a procura do maior de um milhão de números.

Imagine um código que contém 199 declarações condicionais e duzentas invocações da função input() . Felizmente, não precisa de lidar com isso. Há uma abordagem mais simples.


O conceito dos números


Vamos ignorar os requisitos da sintaxe Python por agora, e tentar analisar o problema sem pensar na programação real. Por outras palavras, vamos tentar escrever o algoritmo, e quando estivermos satisfeitos com ele, vamos implementá-lo.

Neste caso, utilizaremos uma espécie de notação que não é uma linguagem de programação real (não pode ser compilada nem executada), mas que é formalizada, concisa e legível. Chama-se pseudo-código.

Vejamos o nosso pseudo-código abaixo:

largest_number = -999999999
number = int(input())
if number == -1:
    print(largest_number)
    exit()
if number > largest_number:
    largest_number = number
# Go to line 02


O que está a acontecer nele?

Em primeiro lugar, podemos simplificar o programa se, logo no início do código, atribuirmos a variável largest_number com um valor que será menor do que qualquer um dos números introduzidos. Vamos usar -999999999 para esse fim.

Em segundo lugar, assumimos que o nosso algoritmo não saberá antecipadamente quantos números serão entregues ao programa. Esperamos que o utilizador introduza quantos números quiser - o algoritmo funcionará bem com cem e com mil números. Como é que fazemos isso?



Fazemos um acordo com o utilizador: quando o valor -1 é introduzido, será um sinal de que não há mais dados e que o programa deve terminar o seu trabalho.

Caso contrário, se o valor introduzido não for igual a -1, o programa irá ler outro número, e assim por diante.

O truque baseia-se no pressuposto de que qualquer parte do código pode ser executada mais do que uma vez - precisamente, tantas vezes quantas forem necessárias.

A execução de uma determinada parte do código mais do que uma vez é chamada um loop. O significado deste termo é provavelmente óbvio para si.

Linhas 02 através 08 fazem um loop. Passaremos por eles tantas vezes quantas forem necessárias para rever todos os valores introduzidos.

Pode usar uma estrutura semelhante num programa escrito em Python? Sim, pode.


Informação Extra

O Python vem muitas vezes com muitas funções incorporadas que farão o trabalho por si. Por exemplo, para encontrar o maior número de todos, pode usar uma função integrada Python chamada max(). Pode utilizá-la com múltiplos argumentos. Analise o código abaixo:

# Read three numbers.
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))

# Check which one of the numbers is the greatest
# and pass it to the largest_number variable.

largest_number = max(number1, number2, number3)

# Print the result.
print("The largest number is:", largest_number)


Da mesma forma, pode usar a função min() para devolver o menor número. Pode reconstruir o código acima e fazer experiências com ele na Sandbox.

Vamos falar sobre estas (e muitas outras) funções em breve. Por enquanto, o nosso foco será colocado na execução condicional e nos loops para lhe permitir ganhar mais confiança na programação e ensinar-lhe as competências que lhe permitirão compreender e aplicar plenamente os dois conceitos no seu código. Portanto, por agora, não vamos por atalhos.

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Fácil

Objetivos
familiarizar-se com a função input() ;
familiarizar-se com operadores de comparação em Python;
familiarizar-se com o conceito de execução condicional.
Cenário
O Spathiphyllum, mais vulgarmente conhecido como o lírio de paz ou a planta de vela branca, é uma das mais populares plantas de interior, capaz de filtrar toxinas nocivas do ar. Algumas das toxinas que neutraliza incluem o benzeno, o formaldeído e o amoníaco.

Imagine que o seu programa de computador adora estas plantas. Sempre que recebe um input na forma da palavra Spathiphyllum, involuntariamente grita para a consola a seguinte string: "Spathiphyllum is the best plant ever!"


Escreve um programa que utilize o conceito de execução condicional, toma uma string como entrada, e:

imprime a frase "Yes - Spathiphyllum is the best plant ever!" para o ecrã, se a cadeia de caracteres inseridos é "Spathiphyllum" (upper-case)
Impressões "No, I want a big Spathiphyllum!" se a cadeia de caracteres inseridos é "spathiphyllum" (lower-case)
Impressões "Spathiphyllum! Not [input]!" caso contrário. Nota: [input] é a string tomada como input.

Teste o seu código utilizando os dados que lhe fornecemos. E arranje também um Spathiphyllum!


Dados de Teste
Input de amostra: spathiphyllum

Output esperado: No, I want a big Spathiphyllum!

Input de amostra: pelargonium

Output esperado: Spathiphyllum! Not pelargonium!

Input de amostra: Spathiphyllum

Output esperado: Yes - Spathiphyllum is the best plant ever!

LAB

Tempo estimado
10-20 minutos

Nível de dificuldade
Fácil/Médio

Objetivos
Familiarizar o aluno a:

utilizar a instrução if-else para ramificar o caminho de controlo;
construir um programa completo que resolva problemas simples da vida real.
Cenário
Era uma vez uma terra - uma terra de leite e mel, habitada por pessoas felizes e prósperas. As pessoas pagavam impostos, claro - a sua felicidade tinha limites. O imposto mais importante, denominado Imposto sobre o Rendimento das Pessoas Singulares (IRS ou, em inglês, PIT), tinha de ser pago uma vez por ano, e foi avaliado utilizando a seguinte regra:

se o rendimento do cidadão não fosse superior a 85.528 thalers, o imposto era igual a 18% do rendimento menos 556 thalers e 2 cêntimos (este era o chamado desagravamento fiscal (em inglês, tax relief))
se o rendimento fosse superior a este montante, o imposto seria igual a 14.839 thalers e 2 cêntimos, mais 32% do excedente acima de 85.528 thalers.
A sua tarefa é escrever uma calculadora de impostos.

Deve aceitar um valor de floating-point: o rendimento.
A seguir, deve imprimir o imposto calculado, arredondado a thalers completos. Há uma função chamada round() que lhe fará o arredondamento por si - encontrá-la-á no código esqueleto no editor.
Nota: este país feliz nunca devolve dinheiro aos seus cidadãos. Se o imposto calculado for inferior a zero, significa apenas que não há qualquer imposto (o imposto é igual a zero). Tenha isto em consideração durante os seus cálculos.

Veja o código no editor - lê apenas um valor de input e faz output de um resultado, pelo que necessita de o completar com alguns cálculos inteligentes.

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste
Input de amostra: 10000

Output esperado: The tax is: 1244.0 thalers

Input de amostra: 100000

Output esperado: The tax is: 19470.0 thalers

Input de amostra: 1000

Output esperado: The tax is: 0.0 thalers

Input de amostra: -100

Output esperado: The tax is: 0.0 thalers

income = float(input("Enter the annual income: "))

#
# Write your code here.
#

tax = round(tax, 0)
print("The tax is:", tax, "thalers")

LAB

Tempo estimado
10-25 minutos

Nível de dificuldade
Fácil/Médio

Objetivos
Familiarizar o aluno a:

a utilização do loop if-elif-else ;
encontrar a correta implementação de regras definidas verbalmente;
testar código utilizando input e output de amostra.

Cenário

Como certamente sabe, devido a algumas razões astronómicas, os anos podem ser bissextos ou comuns. Os primeiros têm 366 dias de duração, enquanto os segundos têm 365 dias de duração.

Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

se o número do ano não for divisível por quatro, é um ano comum;
caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;
caso contrário, se o número do ano não for divisível por 400, é um ano comum;
caso contrário, é um ano bissexto.

Veja o código no editor - lê apenas um número de ano, e precisa de ser completado com as instruções de implementação do teste que acabámos de descrever.

O código deve fazer output de uma de duas mensagens possíveis, que são Leap year ou Common year, dependendo do valor inserido.

Seria bom verificar se o ano introduzido cai na era Gregoriana, e faz output de um aviso caso contrário: Not within the Gregorian calendar period. Dica: use os operadores != e % .

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste
Input de amostra: 2000

Output esperado: Leap year

Input de amostra: 2015

Output esperado: Common year

Input de amostra: 1999

Output esperado: Common year

Input de amostra: 1996

Output esperado: Leap year

Input de amostra: 1580

Output esperado: Not within the Gregorian calendar period

year = int(input("Enter a year: "))

#
# Write your code here.
#	

Key takeaways

1. Os operadores de comparação (ou os chamados relacionais) são usados para comparar valores. A tabela abaixo ilustra como os operadores de comparação funcionam, assumindo que x = 0, y = 1, e z = 0:

Operador	Descrição	Exemplo
==	retorna se os valores dos operandos forem iguais, eFalse caso contrário	
x == y  # False
x == z  # True

!=	retorna Truese os valores dos operandos não forem iguais, eFalse caso contrário	
x != y  # True
x != z  # False

>	Truese o valor do operando esquerdo for maior que o valor do operando direito, eFalse caso contrário	
x > y  # False
y > z  # True

<	Truese o valor do operando esquerdo for inferior ao valor do operando direito, eFalse caso contrário	
x < y  # True
y < z  # False

≥	Truese o valor do operando esquerdo for maior ou igual ao valor do operando direito, eFalse caso contrário	
x >= y  # False
x >= z  # True
y >= z  # True

≤	Truese o valor do operando esquerdo for inferior ou igual ao valor do operando direito, eFalse caso contrário	
x <= y  # True
x <= z  # True
y <= z  # False

2. Quando quiser executar algum código apenas se uma determinada condição for cumprida, pode usar uma declaração condicional:

uma únicaif declaração, por exemplo:

x = 10

if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.


uma série de if declarações, por exemplo:

x = 10

if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.

if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.

if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.
    

Cada ifdeclaração é testada separadamente.




uma if-elsedeclaração, por exemplo:

x = 10

if x < 10:  # Condition
    print("x is less than 10")  # Executed if the condition is True.

else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.


uma série de if declarações seguidas por um else, por exemplo:

x = 10

if x > 5:  # True
    print("x > 5")

if x > 8:  # True
    print("x > 8")

if x > 10:  # False
    print("x > 10")

else:
    print("else will be executed")


Cada if é testado separadamente. O corpo de else é executado se o último if for False.

A if-elif-elsedeclaração, por exemplo:

x = 10

if x == 10:  # True
    print("x == 10")

if x > 15:  # False
    print("x > 15")

elif x > 10:  # False
    print("x > 10")

elif x > 5:  # True
    print("x > 5")

else:
    print("else will not be executed")


Se a condição if for False, o programa verifica as condições dos elif blocos subsequentes - o primeiro elif bloco que True é executado. Se todas as condições forem False, o else bloco será executado.

Declarações condicionais nested, por exemplo:

x = 10

if x > 5:  # True
    if x == 6:  # False
        print("nested: x == 6")
    elif x == 10:  # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")
Key takeaways: continuação

Exercício 1

Qual é o output do seguinte snippet?

x = 5
y = 10
z = 8

print(x > y)
print(y > z)


Verifique
False
True
output


Exercício 2

Qual é o output do seguinte snippet?

x, y, z = 5, 10, 8

print(x > z)
print((y - 5) == x)


Verifique
False
True
output


Exercício 3

Qual é o output do seguinte snippet?

x, y, z = 5, 10, 8
x, y, z = z, y, x

print(x > z)
print((y - 5) == x)


Verifique
True
False
output


Exercício 4

Qual é o output do seguinte snippet?

x = 10

if x == 10:
    print(x == 10)
if x > 5:
    print(x > 5)
if x < 10:
    print(x < 10)
else:
    print("else")


Verifique
True
True
else
output

Fazer loop ao seu código com while
Concorda com a declaração apresentada abaixo?

while there is something to do
    do it


Note-se que este registo também declara que se não houver nada a fazer, nada acontecerá.

Em geral, em Python, um loop pode ser representado da seguinte forma:

while conditional_expression:
    instruction


Se notar algumas semelhanças com a instrução if, não há problema. De facto, a diferença sintática é apenas uma: usa-se a palavra while em vez da palavra if.

A diferença semântica é mais importante: quando a condição é cumprida, if executa as suas declarações apenas uma vez; while repete a execução enquanto a condição se avalie a True.

Nota: todas as regras relativas à indentação são aplicáveis também aqui. Vamos mostrar-lhe isso em breve.

Veja o algoritmo abaixo:

while conditional_expression:
    instruction_one
    instruction_two
    instruction_three
    :
    :
    instruction_n


Agora é importante lembrar que:

se quiser executar mais do que uma declaração dentro de um while, deve (como com if) indentar todas as instruções da mesma forma;
uma instrução ou conjunto de instruções executadas no interior do loop while é chamada corpo do loop;
se a condição é False (igual a zero) logo que é testada pela primeira vez, o corpo não é executado nem uma vez (note-se a analogia de não ter de fazer nada se não houver nada a fazer);
o corpo deve ser capaz de alterar o valor da condição, porque se a condição estiver True no início, o corpo pode correr continuamente até ao infinito - repare que fazer uma coisa normalmente diminui o número de coisas a fazer).

Um loop infinito
Um loop infinito, também chamado endless loop, é uma sequência de instruções num programa que se repete indefinidamente (loop interminável).

Eis um exemplo de um loop que não é capaz de terminar a sua execução:

while True:
    print("I'm stuck inside a loop.")


Este loop será infinitamente imprimido "I'm stuck inside a loop." no ecrã.

NOTA

Se quiser obter a melhor experiência de aprendizagem ao ver como se comporta um loop infinito, lance o IDLE, crie um New File, copie-cole o código acima, guarde o seu ficheiro, e execute o programa. O que irá ver é a sequência interminável de strings "I'm stuck inside a loop." impressas na janela da consola do Python. Para terminar o seu programa, basta premir Ctrl-C (ou Ctrl-Break em alguns computadores). Isto causará a chamada exceção KeyboardInterrupt e deixa o seu programa sair do loop. Falaremos sobre isso mais tarde no curso.

Voltemos ao esboço do algoritmo que lhe mostrámos recentemente. Vamos mostrar-lhe como utilizar este loop recentemente aprendido para encontrar o maior número a partir de um grande conjunto de dados introduzidos.

Analise o programa com cuidado. Veja onde o loop começa (linha 8). Localize o corpo do loop e descubra como é que o corpo sai:

# Store the current largest number here.
largest_number = -999999999

# Input the first value.
number = int(input("Enter a number or type -1 to stop: "))

# If the number is not equal to -1, continue.
while number != -1:
    # Is number larger than largest_number?
    if number > largest_number:
        # Yes, update largest_number.
        largest_number = number
    # Input the next number.
    number = int(input("Enter a number or type -1 to stop: "))

# Print the largest number.
print("The largest number is:", largest_number)


Verifique como este código implementa o algoritmo que lhe mostrámos anteriormente.

Os loops loop while : mais exemplos

Vejamos outro exemplo empregando o loop while . Siga os comentários para descobrir a ideia e a solução.

# A program that reads a sequence of numbers
# and counts how many numbers are even and how many are odd.
# The program terminates when zero is entered.

odd_numbers = 0
even_numbers = 0

# Read the first number.
number = int(input("Enter a number or type 0 to stop: "))

# 0 terminates execution.
while number != 0:
    # Check if the number is odd.
    if number % 2 == 1:
        # Increase the odd_numbers counter.
        odd_numbers += 1
    else:
        # Increase the even_numbers counter.
        even_numbers += 1
    # Read the next number.
    number = int(input("Enter a number or type 0 to stop: "))

# Print results.
print("Odd numbers count:", odd_numbers)
print("Even numbers count:", even_numbers)


Certas expressões podem ser simplificadas sem alterar o comportamento do programa.

Tente lembrar-se de como o Python interpreta a verdade de uma condição e observe que estas duas formas são equivalentes:

while number != 0: e while number:.

A condição que verifica se um número é ímpar também pode ser codificada nestas formas equivalentes:

if number % 2 == 1: e if number % 2:.
******************************************************************************************
Usar uma variável counter para sair de um loop
Veja o snippet abaixo:

counter = 5
while counter != 0:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)


Este código destina-se a imprimir a string "Inside the loop." e o valor armazenado na variável counter durante um determinado loop exatamente cinco vezes. Uma vez que a condição não foi atendida (a variável counter atingiu 0), o loop é encerrado, e a mensagem "Outside the loop." bem como o valor armazenado em counter é impresso.

Mas há uma coisa que pode ser escrita de forma mais compacta - a condição do loop while .

Consegue ver a diferença?

counter = 5
while counter:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)


É mais compacto do que anteriormente? Um pouco. É mais legível? Isso é discutível.

LEMBRE-SE

Não se sinta obrigado a codificar os seus programas de uma forma que seja sempre a mais curta e a mais compacta. A legibilidade pode ser um fator mais importante. Mantenha o seu código preparado para um novo programador.
***************************************************************************************************
LAB

Tempo estimado
15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop while ;
refletir situações da vida real em código informático.
Cenário
Um mágico júnior escolheu um número secreto. Ele escondeu-o numa variável chamada secret_number. Ele quer que todos os que executam o seu programa joguem o jogo do Adivinhe o número secreto, e adivinhe que número escolheu para eles. Aqueles que não adivinharem o número ficarão presos num loop infinito para sempre! Infelizmente, ele não sabe como completar o código.

A sua tarefa é ajudar o mágico a completar o código no editor, de modo a que o código:

peça ao utilizador para introduzir um número inteiro;
utilize um loop while ;
verifique se o número introduzido pelo utilizador é o mesmo que o número escolhido pelo mágico. Se o número escolhido pelo utilizador for diferente do número secreto do mágico, o utilizador deve ver a mensagem "Ha ha! You're stuck in my loop!" e ser solicitado a introduzir novamente um número. Se o número introduzido pelo utilizador corresponder ao número escolhido pelo mágico, o número deve ser impresso no ecrã, e o mágico deve dizer as seguintes palavras: "Well done, muggle! You are free now."

The magician is counting on you! Não o dececione.


INFORMAÇÃO EXTRA

A propósito, olha para a função print() . A forma como a utilizámos aqui chama-se impressão multi-linha. Pode usar aspas triplas para imprimir strings em várias linhas a fim de tornar o texto mais fácil de ler, ou criar um desenho especial baseado em texto. Experimente-o.



secret_number = 777

print(
"""
+================================+
| Welcome to my game, muggle!    |
| Enter an integer number        |
| and guess what number I've     |
| picked for you.                |
| So, what is the secret number? |
+================================+
""")

***********************************************************************************
Fazer loop ao seu código com for
Outro tipo de loop disponível em Python vem da observação de que por vezes é mais importante contar as "voltas" do loop do que verificar as condições.

Imagine que o corpo de um loop precisa de ser executado exatamente cem vezes. Se desejar utilizar o loop while para o fazer, pode ser assim:

i = 0
while i < 100:
    # do_something()
    i += 1


Seria bom se alguém pudesse fazer esta contagem aborrecida por si. Isso é possível?

Claro que é - há um loop especial para estes tipos de tarefas, e é chamado for.

Na verdade, o loop for foi concebido para realizar tarefas mais complicadas - pode "navegar" por grandes coleções de dados item por item. Mostraremos como fazê-lo em breve, mas neste momento vamos apresentar uma variante mais simples da sua aplicação.

Dê uma vista de olhos no snippet:

for i in range(100):
    # do_something()
    pass


Existem alguns novos elementos. Deixe-nos falar sobre eles:

a keyword for abre o loop for ; nota - não há nenhuma condição depois; não é preciso pensar nas condições, uma vez que são verificadas internamente, sem qualquer intervenção;
qualquer variável após a keyword for é a variável de controlo do loop; conta as voltas do loop, e fá-lo automaticamente;
a keyword in introduz um elemento de sintaxe que descreve a gama de valores possíveis que estão a ser atribuídos à variável de controlo;
a função range() (esta é uma função muito especial) é responsável por gerar todos os valores desejados da variável de controlo; no nosso exemplo, a função irá criar (podemos mesmo dizer que irá alimentar o loop com) valores subsequentes a partir do conjunto seguinte: 0, 1, 2 .. 97, 98, 99; nota: neste caso, a função range() começa o seu trabalho a partir do 0 e termina um passo (um número inteiro) antes do valor do seu argumento;
note a keyword pass dentro do corpo do loop - não faz nada; é uma instrução vazia - colocamo-la aqui porque a for sintaxe do laço exige pelo menos uma instrução dentro do corpo (a propósito - if, elif, else e while expressam a mesma coisa)
Os nossos próximos exemplos serão um pouco mais modestos no número de repetições do loop.



Veja o snippet abaixo. Consegue prever o seu output?

for i in range(10):
    print("The value of i is currently", i)


Execute o código para verificar se estava certo.

Nota:

o loop foi executado dez vezes (é o argumento da função range() )
o valor da última variável de controlo é 9 (não 10, visto começar a partir de 0, não a partir de 1)
A função range() pode ser equipada com dois argumentos, e não apenas um:

for i in range(2, 8):
    print("The value of i is currently", i)


Neste caso, o primeiro argumento determina o (primeiro) valor inicial da variável de controlo.

O último argumento mostra o primeiro valor que a variável de controlo não será atribuída.

Nota: a função range() aceita apenas inteiros como seus argumentos, e gera sequências de inteiros.

Consegue adivinhar o output do programa? Execute-o para verificar se também estava certo agora.

O primeiro valor mostrado é 2 (retirado do primeiro argumento range().)

O último é 7 (embora o range()segundo argumento seja 8).

********************************************************************************************************

Mais sobre o loop for e a range() função com três argumentos
A função range() também pode aceitar três argumentos - dê uma vista de olhos ao código no editor.

O terceiro argumento é um incremento - é um valor acrescentado para controlar a variável em cada volta do loop (como se pode suspeitar, o valor por defeito do incremento é 1).

Consegue dizer-nos quantas linhas irão aparecer na consola, e que valores irão conter?

Execute o programa para saber se estava certo.


Deve ser capaz de ver as seguintes linhas na janela da consola:

The value of i is currently 2
The value of i is currently 5
output


Sabe porquê? O primeiro argumento passado para a função range() diz-nos qual o número inicial da sequência (logo, 2 no output). O segundo argumento informa à função onde parar a sequência (a função gera números até ao número indicado pelo segundo argumento, mas não o inclui). Finalmente, o terceiro argumento indica a etapa, que na realidade significa a diferença entre cada número na sequência de números gerados pela função.

2 (número inicial) → 5 (2 incremento de 3 é igual a 5 - o número está dentro do intervalo de 2 a 8) → 8 (5 incremento de 3 é igual a 8 - o número não está dentro do intervalo de 2 a 8, porque o parâmetro stop não está incluído na sequência de números gerados pela função.)

Nota: se o conjunto gerado pela função range() está vazio, o loop não irá executar de todo o seu corpo.

Tal como aqui - não haverá output:

for i in range(1, 1):
    print("The value of i is currently", i)

for i in range(2, 8, 3):
    print("The value of i is currently", i)

***********************************************************************************************    
    
    LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Muito fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop for ;
refletir situações da vida real em código informático.
Cenário
Sabe o que é o Mississippi? Bem, é o nome de um dos estados e rios dos Estados Unidos. O rio Mississippi tem cerca de 3.765 quilómetros de comprimento, o que o torna o segundo rio mais longo dos Estados Unidos (o mais longo sendo o rio Missouri). É tão longo que uma única gota de água precisa de 90 dias para percorrer toda a sua extensão!

A palavra Mississippi é também usada para um propósito ligeiramente diferente: contar mississippily.

Se não está familiarizado com a frase, estamos aqui para lhe explicar o seu significado: é usado para contar segundos.

A ideia por detrás disto é que adicionar a palavra Mississippi a um número ao contar segundos em voz alta faz com que soem mais perto do tempo do relógio, e por isso "um Mississippi, dois Mississippi, três Mississippi" levará aproximadamente três segundos de tempo real! É frequentemente utilizado por crianças que brincam às escondidas para garantir que o buscador faz uma contagem honesta.


A sua tarefa aqui é muito simples: escreva um programa que utilize um loop for para “contar mississippily” até cinco. Tendo contado até cinco, o programa deve imprimir para o ecrã a mensagem final "Ready or not, here I come!"

Use o esqueleto que fornecemos no editor.

INFORMAÇÃO EXTRA

Observe que o código no editor contém dois elementos que podem não estar totalmente claros para si neste momento: a declaração import time , e o método sleep() . Vamos falar sobre eles em breve.

Por enquanto, gostaríamos apenas que soubesse que importámos o módulo time e usámos o método sleep() para suspender a execução de cada função print() subsequente dentro do loop for por um segundo, para que a mensagem enviada para a consola se assemelhe a uma contagem real. Não se preocupe - em breve aprenderá mais sobre módulos e métodos.

Output esperado
1 Mississippi
2 Mississippi
3 Mississippi
4 Mississippi
5 Mississippi

import time

# Write a for loop that counts to five.
    # Body of the loop - print the loop iteration number and the word "Mississippi".
    # Body of the loop - use: time.sleep(1)

# Write a print function with the final message.

**********************************************************************************************************

Os loops break e declarações continue .

Até agora, temos tratado o corpo do loop como uma sequência indivisível e inseparável de instruções que são executadas completamente a cada volta do loop. No entanto, como programador, poderá ser confrontado com as seguintes escolhas:

parece que é desnecessário continuar o loop como um todo; deve abster-se de continuar a execução do corpo do loop e continuar;
parece que é necessário iniciar a próxima volta do loop sem completar a execução da volta atual.
O Python fornece duas instruções especiais para a execução de ambas estas tarefas. Digamos, por uma questão de precisão, que a sua existência na linguagem não é necessária - um programador experiente é capaz de codificar qualquer algoritmo sem estas instruções. Tais adições, que não melhoram o poder expressivo da linguagem, mas apenas simplificam o trabalho do programador, são por vezes chamadas de doces sintáticos, ou açúcar sintático.

Estas duas instruções são:

break - sai imediatamente do loop, e termina incondicionalmente a operação do loop; o programa começa a executar a instrução mais próxima após o corpo do loop;
continue - comporta-se como se o programa tivesse subitamente chegado ao fim do corpo; inicia-se a volta seguinte e a expressão da condição é testada imediatamente.
Ambas as palavras são keywords.

Agora vamos mostrar-lhe dois exemplos simples para ilustrar como as duas instruções funcionam. Veja o código no editor. Execute o programa e analise o output. Modifique o código e experimente.


# break - example

print("The break instruction:")
for i in range(1, 6):
    if i == 3:
        break
    print("Inside the loop.", i)
print("Outside the loop.")


# continue - example

print("\nThe continue instruction:")
for i in range(1, 6):
    if i == 3:
        continue
    print("Inside the loop.", i)
print("Outside the loop.")

****************************************************************

Os loops break e declarações continue : mais exemplos

Voltemos ao nosso programa que reconhece o maior entre os números introduzidos. Iremos convertê-lo duas vezes, utilizando as instruções break e continue .

Analise o código, e julgue se e como utilizaria qualquer um deles.

A variante break vai aqui:

largest_number = -99999999
counter = 0

while True:
    number = int(input("Enter a number or type -1 to end program: "))
    if number == -1:
        break
    counter += 1
    if number > largest_number:
        largest_number = number

if counter != 0:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")


Execute-a, teste-a e experimente com ela.



E agora a variante continue :

largest_number = -99999999
counter = 0

number = int(input("Enter a number or type -1 to end program: "))

while number != -1:
    if number == -1:
        continue
    counter += 1

    if number > largest_number:
        largest_number = number
    number = int(input("Enter a number or type -1 to end program: "))

if counter:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")


Olhe cuidadosamente, o utilizador introduz o primeiro número antes de o programa entrar no loop while . O número subsequente é inserido quando o programa já está em loop.

Novamente - execute o programa, teste-o e experimente com ele.

*********************************************************************************
LAB

Tempo estimado
10-20 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop break em loops;
refletir situações da vida real em código informático.
Cenário
O comando break é utilizada para sair/terminar um loop.

Crie um programa que use um loop while e pede continuamente ao utilizador para introduzir uma palavra, a menos que o utilizador introduza "chupacabra" como a palavra secreta de saída, caso em que a mensagem "You've successfully left the loop." deve ser impressa para o ecrã, e o loop deve terminar.

Não imprima nenhuma das palavras introduzidas pelo utilizador. Utilize o conceito de execução condicional e a break declaração.

 
 Sandbox
Code

*******************************************************************

LAB

Tempo estimado
10-20 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop continue em loops;
refletir situações da vida real em código informático.
Cenário
O comando continue é utilizada para saltar o bloco atual e avançar para a próxima iteração, sem executar as declarações dentro do loop.

Pode ser utilizada tanto com os loops while e for .

A sua tarefa aqui é muito especial: tem de conceber um vowel eater (comedor de vogais)! Escreva um programa que use:

um loop for ;
o conceito de execução condicional (if-elif-else)
a declaração continue .
O seu programa deve:

pedir ao utilizador para introduzir uma palavra;
usar user_word = user_word.upper() para converter a palavra introduzida pelo utilizador em maiúsculas; falaremos sobre os chamados métodos de strings e o método upper() muito em breve - não se preocupe;
usar execução condicional e a declaração continue para “comer” as seguintes vogais A, E, I, O, U da palavra introduzida;
imprimir as letras não comidas para o ecrã, cada uma delas numa linha separada.
Teste o seu programa com os dados que lhe fornecemos.


Dados de teste
Input de amostra: Gregory

Output esperado:

G
R
G
R
Y
Input de amostra: abstemious

Output esperado:

B
S
T
M
S
Input de amostra: IOUEA

Output esperado:

# Prompt the user to enter a word
# and assign it to the user_word variable.

for letter in user_word:
    # Complete the body of the for loop.
    
**************************************************

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop continue em loops;
modificar e atualizar o código existente;
refletir situações da vida real em código informático.
Cenário
A sua tarefa aqui é ainda mais especial do que antes: deve redesenhar o comedor de vogais (feio) do laboratório anterior (3.1.2.10) e criar um comedor de vogais (bonito) melhor e mais aperfeiçoado! Escreva um programa que use:

um loop for ;
o conceito de execução condicional (if-elif-else)
a declaração continue .
O seu programa deve:

pedir ao utilizador para introduzir uma palavra;
usar user_word = user_word.upper() para converter a palavra introduzida pelo utilizador em maiúsculas; falaremos sobre os chamados métodos de strings e o método upper() muito em breve - não se preocupe;
usar execução condicional e a declaração continue para “comer” as seguintes vogais A, E, I, O, U da palavra introduzida;
atribuir as letras não comidas à variável word_without_vowels e imprimir a variável para o ecrã.
Veja o código no editor. Criámos word_without_vowels e atribuimos-lhe uma string vazia. Utilize a operação de concatenação para pedir ao Python que combine as letras selecionadas numa string mais longa durante os loops subsequentes, e atribua-a à variável word_without_vowels .

Teste o seu programa com os dados que lhe fornecemos.


Dados de teste
Input de amostra: Gregory

Output esperado:

GRGRY
Input de amostra: abstemious

Output esperado:

BSTMS
Input de amostra: IOUEA

Output esperado:

word_without_vowels = ""

# Prompt the user to enter a word
# and assign it to the user_word variable.


for letter in user_word:
    # Complete the body of the loop.

# Print the word assigned to word_without_vowels.

LAB

Tempo estimado
10-25 minutos

Nível de dificuldade
Fácil/Médio

Objetivos
Familiarizar o aluno a:

a utilização do loop if-elif-else ;
encontrar a correta implementação de regras definidas verbalmente;
testar código utilizando input e output de amostra.
Cenário
Como certamente sabe, devido a algumas razões astronómicas, os anos podem ser bissextos ou comuns. Os primeiros têm 366 dias de duração, enquanto os segundos têm 365 dias de duração.

Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

se o número do ano não for divisível por quatro, é um ano comum;
caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;
caso contrário, se o número do ano não for divisível por 400, é um ano comum;
caso contrário, é um ano bissexto.
Veja o código no editor - lê apenas um número de ano, e precisa de ser completado com as instruções de implementação do teste que acabámos de descrever.

O código deve fazer output de uma de duas mensagens possíveis, que são Leap year ou Common year, dependendo do valor inserido.

Seria bom verificar se o ano introduzido cai na era Gregoriana, e faz output de um aviso caso contrário: Not within the Gregorian calendar period. Dica: use os operadores != e % .

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste
Input de amostra: 2000

Output esperado: Leap year

Input de amostra: 2015

Output esperado: Common year

Input de amostra: 1999

Output esperado: Common year

Input de amostra: 1996

Output esperado: Leap year

Input de amostra: 1580

Output esperado: Not within the Gregorian calendar period


Perfeito:

year = int(input("Enter a year: "))

#Desde a introdução do calendário gregoriano (em 1582), a seguinte regra é utilizada para determinar o tipo de ano:

#se o número do ano não for divisível por quatro, é um ano comum;........................0 
#caso contrário, se o número do ano não for divisível por 100, é um ano bissexto;........!=0
#caso contrário, se o número do ano não for divisível por 400, é um ano comum;...........0
#caso contrário, é um ano bissexto.

# Entrar ano a ser consultado:
year_4 = year % 4
year_100 = year % 100
year_400 = year % 400

# Checar se ano é bisexto ou comum:
#se o número do ano não for divisível por quatro, é um ano comum;

# Para ser bissexto:
#year_4   == 0
#year_100 == !=0
#year_400 == 0

# Para ser comum:
#year_4   == 1

if year <= 1582:
    print(year, "Not within the Gregorian calendar period.")

elif year_4 == 0:
    print(year, "Leap year.")

elif year_4 != 0:
    print(year, "Common year.")

elif year_100 != 0:
    print(year, "Common year.")

elif year_400 != 0:
    print(year, "Common year.")

else:
    print(year, "Leap year.")

Key takeaways

1. Os operadores de comparação (ou os chamados relacionais) são usados para comparar valores. A tabela abaixo ilustra como os operadores de comparação funcionam, assumindo que x = 0, y = 1, e z = 0:

Operador	Descrição	Exemplo
==	retorna se os valores dos operandos forem iguais, eFalse caso contrário	
x == y  # False
x == z  # True

!=	retorna Truese os valores dos operandos não forem iguais, eFalse caso contrário	
x != y  # True
x != z  # False

>	Truese o valor do operando esquerdo for maior que o valor do operando direito, eFalse caso contrário	
x > y  # False
y > z  # True

<	Truese o valor do operando esquerdo for inferior ao valor do operando direito, eFalse caso contrário	
x < y  # True
y < z  # False

≥	Truese o valor do operando esquerdo for maior ou igual ao valor do operando direito, eFalse caso contrário	
x >= y  # False
x >= z  # True
y >= z  # True

≤	Truese o valor do operando esquerdo for inferior ou igual ao valor do operando direito, eFalse caso contrário	
x <= y  # True
x <= z  # True
y <= z  # False

2. Quando quiser executar algum código apenas se uma determinada condição for cumprida, pode usar uma declaração condicional:

uma únicaif declaração, por exemplo:

x = 10

if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.


uma série de if declarações, por exemplo:

x = 10

if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.

if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.

if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.
    

Cada ifdeclaração é testada separadamente.




uma if-elsedeclaração, por exemplo:

x = 10

if x < 10:  # Condition
    print("x is less than 10")  # Executed if the condition is True.

else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.


uma série de if declarações seguidas por um else, por exemplo:

x = 10

if x > 5:  # True
    print("x > 5")

if x > 8:  # True
    print("x > 8")

if x > 10:  # False
    print("x > 10")

else:
    print("else will be executed")


Cada if é testado separadamente. O corpo de else é executado se o último if for False.

A if-elif-elsedeclaração, por exemplo:

x = 10

if x == 10:  # True
    print("x == 10")

if x > 15:  # False
    print("x > 15")

elif x > 10:  # False
    print("x > 10")

elif x > 5:  # True
    print("x > 5")

else:
    print("else will not be executed")


Se a condição if for False, o programa verifica as condições dos elif blocos subsequentes - o primeiro elif bloco que True é executado. Se todas as condições forem False, o else bloco será executado.

Declarações condicionais nested, por exemplo:

x = 10

if x > 5:  # True
    if x == 6:  # False
        print("nested: x == 6")
    elif x == 10:  # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")

Key takeaways: continuação

Exercício 1

Qual é o output do seguinte snippet?

x = 5
y = 10
z = 8

print(x > y)
print(y > z)


Verifique
Exercício 2

Qual é o output do seguinte snippet?

x, y, z = 5, 10, 8

print(x > z)
print((y - 5) == x)


Verifique
False
True
output


Exercício 3

Qual é o output do seguinte snippet?

x, y, z = 5, 10, 8
x, y, z = z, y, x

print(x > z)
print((y - 5) == x)


Verifique
Exercício 4

Qual é o output do seguinte snippet?

x = 10

if x == 10:
    print(x == 10)
if x > 5:
    print(x > 5)
if x < 10:
    print(x < 10)
else:
    print("else")


Verifique
True
True
else
output




Exercício 5

Qual é o output do seguinte snippet?

x = "1"

if x == 1:
    print("one")
elif x == "1":
    if int(x) > 1:
        print("two")
    elif int(x) < 1:
        print("three")
    else:
        print("four")
if int(x) == 1:
    print("five")
else:
    print("six")


Verifique
four
five
output


Exercício 6

Qual é o output do seguinte snippet?

x = 1
y = 1.0
z = "1"

if x == y:
    print("one")
if y == int(z):
    print("two")
elif x == y:
    print("three")
else:
    print("four")


Verifique
one
two

Fazer loop ao seu código com while
Concorda com a declaração apresentada abaixo?

while there is something to do
    do it


Note-se que este registo também declara que se não houver nada a fazer, nada acontecerá.

Em geral, em Python, um loop pode ser representado da seguinte forma:

while conditional_expression:
    instruction


Se notar algumas semelhanças com a instrução if, não há problema. De facto, a diferença sintática é apenas uma: usa-se a palavra while em vez da palavra if.

A diferença semântica é mais importante: quando a condição é cumprida, if executa as suas declarações apenas uma vez; while repete a execução enquanto a condição se avalie a True.

Nota: todas as regras relativas à indentação são aplicáveis também aqui. Vamos mostrar-lhe isso em breve.

Veja o algoritmo abaixo:

while conditional_expression:
    instruction_one
    instruction_two
    instruction_three
    :
    :
    instruction_n


Agora é importante lembrar que:

se quiser executar mais do que uma declaração dentro de um while, deve (como com if) indentar todas as instruções da mesma forma;
uma instrução ou conjunto de instruções executadas no interior do loop while é chamada corpo do loop;
se a condição é False (igual a zero) logo que é testada pela primeira vez, o corpo não é executado nem uma vez (note-se a analogia de não ter de fazer nada se não houver nada a fazer);
o corpo deve ser capaz de alterar o valor da condição, porque se a condição estiver True no início, o corpo pode correr continuamente até ao infinito - repare que fazer uma coisa normalmente diminui o número de coisas a fazer).

Um loop infinito
Um loop infinito, também chamado endless loop, é uma sequência de instruções num programa que se repete indefinidamente (loop interminável).

Eis um exemplo de um loop que não é capaz de terminar a sua execução:

while True:
    print("I'm stuck inside a loop.")


Este loop será infinitamente imprimido "I'm stuck inside a loop." no ecrã.

NOTA

Se quiser obter a melhor experiência de aprendizagem ao ver como se comporta um loop infinito, lance o IDLE, crie um New File, copie-cole o código acima, guarde o seu ficheiro, e execute o programa. O que irá ver é a sequência interminável de strings "I'm stuck inside a loop." impressas na janela da consola do Python. Para terminar o seu programa, basta premir Ctrl-C (ou Ctrl-Break em alguns computadores). Isto causará a chamada exceção KeyboardInterrupt e deixa o seu programa sair do loop. Falaremos sobre isso mais tarde no curso.

Voltemos ao esboço do algoritmo que lhe mostrámos recentemente. Vamos mostrar-lhe como utilizar este loop recentemente aprendido para encontrar o maior número a partir de um grande conjunto de dados introduzidos.

Analise o programa com cuidado. Veja onde o loop começa (linha 8). Localize o corpo do loop e descubra como é que o corpo sai:

# Store the current largest number here.
largest_number = -999999999

# Input the first value.
number = int(input("Enter a number or type -1 to stop: "))

# If the number is not equal to -1, continue.
while number != -1:
    # Is number larger than largest_number?
    if number > largest_number:
        # Yes, update largest_number.
        largest_number = number
    # Input the next number.
    number = int(input("Enter a number or type -1 to stop: "))

# Print the largest number.
print("The largest number is:", largest_number)


Verifique como este código implementa o algoritmo que lhe mostrámos anteriormente.

Os loops loop while : mais exemplos

Vejamos outro exemplo empregando o loop while . Siga os comentários para descobrir a ideia e a solução.

# A program that reads a sequence of numbers
# and counts how many numbers are even and how many are odd.
# The program terminates when zero is entered.

odd_numbers = 0
even_numbers = 0

# Read the first number.
number = int(input("Enter a number or type 0 to stop: "))

# 0 terminates execution.
while number != 0:
    # Check if the number is odd.
    if number % 2 == 1:
        # Increase the odd_numbers counter.
        odd_numbers += 1
    else:
        # Increase the even_numbers counter.
        even_numbers += 1
    # Read the next number.
    number = int(input("Enter a number or type 0 to stop: "))

# Print results.
print("Odd numbers count:", odd_numbers)
print("Even numbers count:", even_numbers)


Certas expressões podem ser simplificadas sem alterar o comportamento do programa.

Tente lembrar-se de como o Python interpreta a verdade de uma condição e observe que estas duas formas são equivalentes:

while number != 0: e while number:.

A condição que verifica se um número é ímpar também pode ser codificada nestas formas equivalentes:

if number % 2 == 1: e if number % 2:.


Usar uma variável counter para sair de um loop
Veja o snippet abaixo:

counter = 5
while counter != 0:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)


Este código destina-se a imprimir a string "Inside the loop." e o valor armazenado na variável counter durante um determinado loop exatamente cinco vezes. Uma vez que a condição não foi atendida (a variável counter atingiu 0), o loop é encerrado, e a mensagem "Outside the loop." bem como o valor armazenado em counter é impresso.

Mas há uma coisa que pode ser escrita de forma mais compacta - a condição do loop while .

Consegue ver a diferença?

counter = 5
while counter:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)


É mais compacto do que anteriormente? Um pouco. É mais legível? Isso é discutível.

LEMBRE-SE

Não se sinta obrigado a codificar os seus programas de uma forma que seja sempre a mais curta e a mais compacta. A legibilidade pode ser um fator mais importante. Mantenha o seu código preparado para um novo programador.

LAB

Tempo estimado
15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop while ;
refletir situações da vida real em código informático.
Cenário
Um mágico júnior escolheu um número secreto. Ele escondeu-o numa variável chamada secret_number. Ele quer que todos os que executam o seu programa joguem o jogo do Adivinhe o número secreto, e adivinhe que número escolheu para eles. Aqueles que não adivinharem o número ficarão presos num loop infinito para sempre! Infelizmente, ele não sabe como completar o código.

A sua tarefa é ajudar o mágico a completar o código no editor, de modo a que o código:

peça ao utilizador para introduzir um número inteiro;
utilize um loop while ;
verifique se o número introduzido pelo utilizador é o mesmo que o número escolhido pelo mágico. Se o número escolhido pelo utilizador for diferente do número secreto do mágico, o utilizador deve ver a mensagem "Ha ha! You're stuck in my loop!" e ser solicitado a introduzir novamente um número. Se o número introduzido pelo utilizador corresponder ao número escolhido pelo mágico, o número deve ser impresso no ecrã, e o mágico deve dizer as seguintes palavras: "Well done, muggle! You are free now."
The magician is counting on you! Não o dececione.


INFORMAÇÃO EXTRA

A propósito, olha para a função print() . A forma como a utilizámos aqui chama-se impressão multi-linha. Pode usar aspas triplas para imprimir strings em várias linhas a fim de tornar o texto mais fácil de ler, ou criar um desenho especial baseado em texto. Experimente-o.

secret_number = 777

print(
"""
+================================+
| Welcome to my game, muggle!    |
| Enter an integer number        |
| and guess what number I've     |
| picked for you.                |
| So, what is the secret number? |
+================================+
""")


Fazer loop ao seu código com for
Outro tipo de loop disponível em Python vem da observação de que por vezes é mais importante contar as "voltas" do loop do que verificar as condições.

Imagine que o corpo de um loop precisa de ser executado exatamente cem vezes. Se desejar utilizar o loop while para o fazer, pode ser assim:

i = 0
while i < 100:
    # do_something()
    i += 1


Seria bom se alguém pudesse fazer esta contagem aborrecida por si. Isso é possível?

Claro que é - há um loop especial para estes tipos de tarefas, e é chamado for.

Na verdade, o loop for foi concebido para realizar tarefas mais complicadas - pode "navegar" por grandes coleções de dados item por item. Mostraremos como fazê-lo em breve, mas neste momento vamos apresentar uma variante mais simples da sua aplicação.

Dê uma vista de olhos no snippet:

for i in range(100):
    # do_something()
    pass


Existem alguns novos elementos. Deixe-nos falar sobre eles:

a keyword for abre o loop for ; nota - não há nenhuma condição depois; não é preciso pensar nas condições, uma vez que são verificadas internamente, sem qualquer intervenção;
qualquer variável após a keyword for é a variável de controlo do loop; conta as voltas do loop, e fá-lo automaticamente;
a keyword in introduz um elemento de sintaxe que descreve a gama de valores possíveis que estão a ser atribuídos à variável de controlo;
a função range() (esta é uma função muito especial) é responsável por gerar todos os valores desejados da variável de controlo; no nosso exemplo, a função irá criar (podemos mesmo dizer que irá alimentar o loop com) valores subsequentes a partir do conjunto seguinte: 0, 1, 2 .. 97, 98, 99; nota: neste caso, a função range() começa o seu trabalho a partir do 0 e termina um passo (um número inteiro) antes do valor do seu argumento;
note a keyword pass dentro do corpo do loop - não faz nada; é uma instrução vazia - colocamo-la aqui porque a for sintaxe do laço exige pelo menos uma instrução dentro do corpo (a propósito - if, elif, else e while expressam a mesma coisa)
Os nossos próximos exemplos serão um pouco mais modestos no número de repetições do loop.



Veja o snippet abaixo. Consegue prever o seu output?

for i in range(10):
    print("The value of i is currently", i)


Execute o código para verificar se estava certo.

Nota:

o loop foi executado dez vezes (é o argumento da função range() )
o valor da última variável de controlo é 9 (não 10, visto começar a partir de 0, não a partir de 1)
A função range() pode ser equipada com dois argumentos, e não apenas um:

for i in range(2, 8):
    print("The value of i is currently", i)


Neste caso, o primeiro argumento determina o (primeiro) valor inicial da variável de controlo.

O último argumento mostra o primeiro valor que a variável de controlo não será atribuída.

Nota: a função range() aceita apenas inteiros como seus argumentos, e gera sequências de inteiros.

Consegue adivinhar o output do programa? Execute-o para verificar se também estava certo agora.

O primeiro valor mostrado é 2 (retirado do primeiro argumento range().)

O último é 7 (embora o range()segundo argumento seja 8).

Mais sobre o loop for e a range() função com três argumentos
A função range() também pode aceitar três argumentos - dê uma vista de olhos ao código no editor.

O terceiro argumento é um incremento - é um valor acrescentado para controlar a variável em cada volta do loop (como se pode suspeitar, o valor por defeito do incremento é 1).

Consegue dizer-nos quantas linhas irão aparecer na consola, e que valores irão conter?

Execute o programa para saber se estava certo.


Deve ser capaz de ver as seguintes linhas na janela da consola:

The value of i is currently 2
The value of i is currently 5
output


Sabe porquê? O primeiro argumento passado para a função range() diz-nos qual o número inicial da sequência (logo, 2 no output). O segundo argumento informa à função onde parar a sequência (a função gera números até ao número indicado pelo segundo argumento, mas não o inclui). Finalmente, o terceiro argumento indica a etapa, que na realidade significa a diferença entre cada número na sequência de números gerados pela função.

2 (número inicial) → 5 (2 incremento de 3 é igual a 5 - o número está dentro do intervalo de 2 a 8) → 8 (5 incremento de 3 é igual a 8 - o número não está dentro do intervalo de 2 a 8, porque o parâmetro stop não está incluído na sequência de números gerados pela função.)

Nota: se o conjunto gerado pela função range() está vazio, o loop não irá executar de todo o seu corpo.

Tal como aqui - não haverá output:

for i in range(1, 1):
    print("The value of i is currently", i)


Nota: o conjunto gerado pelo range() tem de estar ordenado por ordem crescente. Não há como forçar o range() a criar um conjunto de uma forma diferente quando a função range() aceita exatamente dois argumentos. Isto significa que o segundo argumento de range()deve ser maior que o primeiro.

Logo, também não haverá output aqui:

for i in range(2, 1):
    print("The value of i is currently", i)


Vamos dar uma vista de olhos num programa curto, cuja tarefa é escrever algumas das primeiras potências de dois:

power = 1
for expo in range(16):
    print("2 to the power of", expo, "is", power)
    power *= 2


A expo variável é usada como uma variável de controlo para o loop, e indica o valor atual do expoente. A exponenciação em si é substituída pela multiplicação por dois. Uma vez que 20 é igual a 1, então 2 x; 1 é igual a 21, 2 x; 21 é igual a 22, e assim por diante. Qual é o maior expoente para o qual o nosso programa ainda imprime o resultado?

Execute o código e verifique se o output corresponde às suas expetativas.

for i in range(2, 8, 3):
    print("The value of i is currently", i)

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Muito fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop for ;
refletir situações da vida real em código informático.
Cenário
Sabe o que é o Mississippi? Bem, é o nome de um dos estados e rios dos Estados Unidos. O rio Mississippi tem cerca de 3.765 quilómetros de comprimento, o que o torna o segundo rio mais longo dos Estados Unidos (o mais longo sendo o rio Missouri). É tão longo que uma única gota de água precisa de 90 dias para percorrer toda a sua extensão!

A palavra Mississippi é também usada para um propósito ligeiramente diferente: contar mississippily.

Se não está familiarizado com a frase, estamos aqui para lhe explicar o seu significado: é usado para contar segundos.

A ideia por detrás disto é que adicionar a palavra Mississippi a um número ao contar segundos em voz alta faz com que soem mais perto do tempo do relógio, e por isso "um Mississippi, dois Mississippi, três Mississippi" levará aproximadamente três segundos de tempo real! É frequentemente utilizado por crianças que brincam às escondidas para garantir que o buscador faz uma contagem honesta.


A sua tarefa aqui é muito simples: escreva um programa que utilize um loop for para “contar mississippily” até cinco. Tendo contado até cinco, o programa deve imprimir para o ecrã a mensagem final "Ready or not, here I come!"

Use o esqueleto que fornecemos no editor.

INFORMAÇÃO EXTRA

Observe que o código no editor contém dois elementos que podem não estar totalmente claros para si neste momento: a declaração import time , e o método sleep() . Vamos falar sobre eles em breve.

Por enquanto, gostaríamos apenas que soubesse que importámos o módulo time e usámos o método sleep() para suspender a execução de cada função print() subsequente dentro do loop for por um segundo, para que a mensagem enviada para a consola se assemelhe a uma contagem real. Não se preocupe - em breve aprenderá mais sobre módulos e métodos.

Output esperado
1 Mississippi
2 Mississippi
3 Mississippi
4 Mississippi
5 Mississippi

 
 Sandbox
Code
import time

# Write a for loop that counts to five.
# Body of the loop - print the loop iteration number and the word "Mississippi".
# Body of the loop - use: time.sleep(1)

# Write a print function with the final message.

Os loops break e declarações continue .
Até agora, temos tratado o corpo do loop como uma sequência indivisível e inseparável de instruções que são executadas completamente a cada volta do loop. No entanto, como programador, poderá ser confrontado com as seguintes escolhas:

parece que é desnecessário continuar o loop como um todo; deve abster-se de continuar a execução do corpo do loop e continuar;
parece que é necessário iniciar a próxima volta do loop sem completar a execução da volta atual.
O Python fornece duas instruções especiais para a execução de ambas estas tarefas. Digamos, por uma questão de precisão, que a sua existência na linguagem não é necessária - um programador experiente é capaz de codificar qualquer algoritmo sem estas instruções. Tais adições, que não melhoram o poder expressivo da linguagem, mas apenas simplificam o trabalho do programador, são por vezes chamadas de doces sintáticos, ou açúcar sintático.

Estas duas instruções são:

break - sai imediatamente do loop, e termina incondicionalmente a operação do loop; o programa começa a executar a instrução mais próxima após o corpo do loop;
continue - comporta-se como se o programa tivesse subitamente chegado ao fim do corpo; inicia-se a volta seguinte e a expressão da condição é testada imediatamente.
Ambas as palavras são keywords.

Agora vamos mostrar-lhe dois exemplos simples para ilustrar como as duas instruções funcionam. Veja o código no editor. Execute o programa e analise o output. Modifique o código e experimente.

# break - example

print("The break instruction:")
for i in range(1, 6):
    if i == 3:
        break
    print("Inside the loop.", i)
print("Outside the loop.")


# continue - example

print("\nThe continue instruction:")
for i in range(1, 6):
    if i == 3:
        continue
    print("Inside the loop.", i)
print("Outside the loop.")

Os loops break e declarações continue : mais exemplos
Voltemos ao nosso programa que reconhece o maior entre os números introduzidos. Iremos convertê-lo duas vezes, utilizando as instruções break e continue .

Analise o código, e julgue se e como utilizaria qualquer um deles.

A variante break vai aqui:

largest_number = -99999999
counter = 0

while True:
    number = int(input("Enter a number or type -1 to end program: "))
    if number == -1:
        break
    counter += 1
    if number > largest_number:
        largest_number = number

if counter != 0:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")


Execute-a, teste-a e experimente com ela.

E agora a variante continue :

largest_number = -99999999
counter = 0

number = int(input("Enter a number or type -1 to end program: "))

while number != -1:
    if number == -1:
        continue
    counter += 1

    if number > largest_number:
        largest_number = number
    number = int(input("Enter a number or type -1 to end program: "))

if counter:
    print("The largest number is", largest_number)
else:
    print("You haven't entered any number.")


Olhe cuidadosamente, o utilizador introduz o primeiro número antes de o programa entrar no loop while . O número subsequente é inserido quando o programa já está em loop.

Novamente - execute o programa, teste-o e experimente com ele.

LAB

Tempo estimado
10-20 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop break em loops;
refletir situações da vida real em código informático.
Cenário
O comando break é utilizada para sair/terminar um loop.

Crie um programa que use um loop while e pede continuamente ao utilizador para introduzir uma palavra, a menos que o utilizador introduza "chupacabra" como a palavra secreta de saída, caso em que a mensagem "You've successfully left the loop." deve ser impressa para o ecrã, e o loop deve terminar.

Não imprima nenhuma das palavras introduzidas pelo utilizador. Utilize o conceito de execução condicional e a break declaração.

 
 Sandbox
Code

LAB

Tempo estimado
10-20 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop continue em loops;
refletir situações da vida real em código informático.
Cenário
O comando continue é utilizada para saltar o bloco atual e avançar para a próxima iteração, sem executar as declarações dentro do loop.

Pode ser utilizada tanto com os loops while e for .

A sua tarefa aqui é muito especial: tem de conceber um vowel eater (comedor de vogais)! Escreva um programa que use:

um loop for ;
o conceito de execução condicional (if-elif-else)
a declaração continue .
O seu programa deve:

pedir ao utilizador para introduzir uma palavra;
usar user_word = user_word.upper() para converter a palavra introduzida pelo utilizador em maiúsculas; falaremos sobre os chamados métodos de strings e o método upper() muito em breve - não se preocupe;
usar execução condicional e a declaração continue para “comer” as seguintes vogais A, E, I, O, U da palavra introduzida;
imprimir as letras não comidas para o ecrã, cada uma delas numa linha separada.
Teste o seu programa com os dados que lhe fornecemos.


Dados de teste
Input de amostra: Gregory

Output esperado:

G
R
G
R
Y
Input de amostra: abstemious

Output esperado:

B
S
T
M
S
Input de amostra: IOUEA

Output esperado:

# Prompt the user to enter a word
# and assign it to the user_word variable.

for letter in user_word:
    # Complete the body of the for loop.

LAB

Tempo estimado
5-15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a utilização do loop continue em loops;
modificar e atualizar o código existente;
refletir situações da vida real em código informático.
Cenário
A sua tarefa aqui é ainda mais especial do que antes: deve redesenhar o comedor de vogais (feio) do laboratório anterior (3.1.2.10) e criar um comedor de vogais (bonito) melhor e mais aperfeiçoado! Escreva um programa que use:

um loop for ;
o conceito de execução condicional (if-elif-else)
a declaração continue .
O seu programa deve:

pedir ao utilizador para introduzir uma palavra;
usar user_word = user_word.upper() para converter a palavra introduzida pelo utilizador em maiúsculas; falaremos sobre os chamados métodos de strings e o método upper() muito em breve - não se preocupe;
usar execução condicional e a declaração continue para “comer” as seguintes vogais A, E, I, O, U da palavra introduzida;
atribuir as letras não comidas à variável word_without_vowels e imprimir a variável para o ecrã.
Veja o código no editor. Criámos word_without_vowels e atribuimos-lhe uma string vazia. Utilize a operação de concatenação para pedir ao Python que combine as letras selecionadas numa string mais longa durante os loops subsequentes, e atribua-a à variável word_without_vowels .

Teste o seu programa com os dados que lhe fornecemos.


Dados de teste
Input de amostra: Gregory

Output esperado:

GRGRY

word_without_vowels = ""

# Prompt the user to enter a word
# and assign it to the user_word variable.


for letter in user_word:
    # Complete the body of the loop.

# Print the word assigned to word_without_vowels.

Os loops while e o ramo else .
Ambos os loops, while e for, têm uma característica interessante (e raramente usada).

Vamos mostrar-lhe como funciona - tente julgar por si próprio se é utilizável e se pode viver sem ela ou não.

Por outras palavras, tente convencer-se se a característica é valiosa e útil, ou se é apenas açúcar sintático.

Veja o snippet no editor. Há algo estranho no final - a keyword else .

Como pode ter suspeitado, os loops podem ter o ramo else também, como if.

O ramo do loop else é sempre executado uma vez, independentemente de o loop ter entrado no seu corpo ou não.

Consegue adivinhar o output? Execute o programa para verificar se estava certo.

Modifique um pouco o anippet para que o loop não tenha hipótese de executar o seu corpo nem mesmo uma vez:

i = 5
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)


A condição whileé False no início - consegue vê-la?

Execute e teste o programa, e verifique se o ramo else foi executado ou não.

i = 1
while i < 5:
    print(i)
    i += 1
else:
    print("else:", i)

Os loops for e o ramo else .
for os loops comportam-se de forma um pouco diferente - dê uma vista de olhos ao snippet no editor e execute-o.

O output pode ser um pouco surpreendente.

A variável i retém o seu último valor.


Modifique um pouco o código para levar a cabo mais uma experiência.

i = 111
for i in range(2, 1):
    print(i)
else:
    print("else:", i)


Consegue adivinhar o output?

O corpo do loop não será executado aqui. Nota: atribuímos a variável i antes do loop.

Execute o programa e verifique o seu output.

Quando o corpo do loop não é executado, a variável de controlo retém o valor que tinha antes do loop.

Nota: se a variável de controlo não existir antes do início do loop, não existirá quando a execução atingir o ramo else .

O que acha desta variante de else?


Agora vamos falar-lhe de alguns outros tipos de variáveis. As nossas variáveis atuais só podem armazenar um valor de cada vez, mas há variáveis que podem fazer muito mais - podem armazenar tantos valores quantos você quiser.

for i in range(5):
    print(i)
else:
    print("else:", i)

LAB

Tempo estimado
20-30 minutos

Nível de dificuldade
Médio

Objetivos
Familiarizar o aluno a:

a utilização do loop while ;
encontrar a correta implementação de regras definidas verbalmente;
refletir situações da vida real em código informático.
Cenário
Leia esta história: um rapaz e o seu pai, um programador de computador, estão a brincar com blocos de madeira. Eles estão a construir uma pirâmide.

A sua pirâmide é um pouco estranha, pois na realidade é uma parede em forma de pirâmide - é plana. A pirâmide é empilhada de acordo com um princípio simples: cada camada inferior contém mais um bloco do que a camada superior.

A figura ilustra a regra utilizada pelos construtores:



A sua tarefa é escrever um programa que leia o número de blocos que os construtores têm, e que produza a altura da pirâmide que pode ser construída utilizando estes blocos.

Nota: a altura é medida pelo número de camadas completamente preenchidas - se os construtores não tiverem um número suficiente de blocos e não conseguirem completar a camada seguinte, terminam o seu trabalho imediatamente.

Teste o seu código utilizando os dados por nós fornecidos.


Dados de teste

Input de amostra: 6

Output esperado: The height of the pyramid: 3

Input de amostra: 20

Output esperado: The height of the pyramid: 5

Input de amostra: 1000

Output esperado: The height of the pyramid: 44

Input de amostra: 2

Output esperado: The height of the pyramid: 1


 
 Sandbox
Code
blocks = int(input("Enter the number of blocks: "))

#
# Write your code here.
#

print("The height of the pyramid:", height)
blocks = int(input("Enter the number of blocks: "))


blocks = int(input("Enter the number of blocks: "))

#
# Write your code here.
#	

print("The height of the pyramid:", height)


LAB

Tempo estimado
20 minutos

Nível de dificuldade
Médio

Objetivos
Familiarizar o aluno a:

a utilização do loop while ;
a conversão de loops definidos verbalmente em código Python real.
Cenário
Em 1937, um matemático alemão chamado Lothar Collatz formulou uma hipótese intrigante (ainda não provada) que pode ser descrita da seguinte forma:

tomar qualquer número inteiro não-negativo e não-nulo e nomeá-lo c0;
se for par, avalie um novo c0 como c0 ÷ 2;
caso contrário, se for ímpar, avalie um novo c0 como 3 × c0 + 1;
Se c0 ≠ 1, saltar para o ponto 2.
A hipótese diz que, independentemente do valor inicial de c0, irá sempre para 1.

É claro que é uma tarefa extremamente complexa utilizar um computador para provar a hipótese de qualquer número natural (pode até requerer inteligência artificial), mas pode usar o Python para verificar alguns números individuais. Talvez até encontre o que possa refutar a hipótese.


Escreva um programa que leia um número natural e execute os passos acima indicados, desde que c0 permaneça diferente de 1. Também queremos que conte os passos necessários para alcançar o objetivo. O seu código deve fazer output de todos os valores intermédios de c0, também.

Dica: a parte mais importante do problema é como transformar a ideia de Collatz num loop while - esta é a chave para o sucesso.

Teste o seu código utilizando os dados por nós fornecidos.

Dados de teste

Input de amostra: 15

Output esperado:

46
23
70
35
106
53
160
80
40
20
10
5
16
8
4
2
1
steps = 17
Input de amostra: 16

Output esperado:

8
4
2
1
steps = 4
Input de amostra: 1023

Output esperado:

3070
1535
4606
2303
6910
3455
10366
5183
15550
7775
23326
11663
34990
17495
52486
26243
78730
39365
118096
59048
29524
14762
7381
22144
11072
5536
2768
1384
692
346
173
520
260
130
65
196
98
49
148
74
37
112
56
28
14
7
22
11
34
17
52
26
13
40
20
10
5
16
8
4
2
1
steps = 62

Key takeaways

1. Existem dois tipos de loops em Python: while e for:

o loop while executa uma declaração ou um conjunto de declarações, desde que uma condição booleana especificada seja verdadeira, por exemplo:

# Example 1
while True:
    print("Stuck in an infinite loop.")

# Example 2
counter = 5
while counter > 2:
    print(counter)
    counter -= 1


o loop for executa um conjunto de declarações várias vezes; é usado para iterar sobre uma sequência (por exemplo, uma lista, um dicionário, um tuple, ou um conjunto - aprenderá sobre eles em breve) ou outros objetos que são iteráveis (por exemplo, strings). Pode utilizar o loop for para iterar sobre uma sequência de números usando a função range . Veja os exemplos em baixo:

# Example 1
word = "Python"
for letter in word:
    print(letter, end="*")

# Example 2
for i in range(1, 10):
    if i % 2 == 0:
        print(i)


2. Pode utilizar as declarações break e continue para alterar o fluxo de um loop:

Utilize break para sair de um loop, por exemplo:

text = "OpenEDG Python Institute"
for letter in text:
    if letter == "P":
        break
    print(letter, end="")


Utilize continue para ignorar a iteração atual e continuar com a próxima iteração, por exemplo:

text = "pyxpyxpyx"
for letter in text:
    if letter == "x":
        continue
    print(letter, end="")





3. Os loops while e for também podem ter uma cláusula else em Python. A cláusula else executa-se após o loop terminar a sua execução, desde que não tenha sido terminado por break, por exemplo.:

n = 0

while n != 3:
    print(n)
    n += 1
else:
    print(n, "else")

print()

for i in range(0, 3):
    print(i)
else:
    print(i, "else")


4. O objeto da exceção range() gera uma sequência de números. Aceita números inteiros e devolve objetos de range. A sintaxe de range() parece como se segue: range(start, stop, step), onde:

start é um parâmetro opcional que especifica o número inicial da sequência (0 por padrão)
stop é um parâmetro opcional que especifica o fim da sequência gerada (não está incluído),
e step é um parâmetro opcional que especifica a diferença entre os números na sequência (1 por padrão.)
Código de exemplo:

for i in range(3):
    print(i, end=" ")  # Outputs: 0 1 2

for i in range(6, 1, -2):
    print(i, end=" ")  # Outputs: 6, 4, 2

Principais takeaways: continuação
Exercício 1

Crie um loop for que conta de 0 a 10, e imprime os números ímpares no ecrã. Use o esqueleto abaixo:

for i in range(1, 11):
    # Line of code.
        # Line of code.


Verifique
Solução de amostra:
for i in range(0, 11):
    if i % 2 != 0:
        print(i)


Exercício 2

Crie um loop while que conta de 0 a 10, e imprime os números ímpares no ecrã. Use o esqueleto abaixo:

x = 1
while x < 11:
    # Line of code.
        # Line of code.
    # Line of code.


Verifique
Solução de amostra:
x = 1
while x < 11:
    if x % 2 != 0:
        print(x)
    x += 1


Exercício 3

Crie um programa com um loop for e uma declaração break . O programa deve iterar sobre os caracteres de um endereço de e-mail, sair do loop quando chegar ao símbolo @ , e imprimir a parte antes de @ numa linha. Use o esqueleto abaixo:

for ch in "john.smith@pythoninstitute.org":
    if ch == "@":
        # Line of code.
    # Line of code.


Verifique
Solução de amostra:
for ch in "john.smith@pythoninstitute.org":
    if ch == "@":
        break
    print(ch, end="")


Exercício 4

Crie um programa com um loop for e uma declaração continue . O programa deve iterar sobre uma string de dígitos, substituir cada 0 com xe imprimir a string modificada no ecrã. Use o esqueleto abaixo:

for digit in "0165031806510":
    if digit == "0":
        # Line of code.
        # Line of code.
    # Line of code.


Verifique
Solução de amostra:
for digit in "0165031806510":
    if digit == "0":
        print("x", end="")
        continue
    print(digit, end="")




Exercício 5

Qual é o output do seguinte código?

n = 3

while n > 0:
    print(n + 1)
    n -= 1
else:
    print(n)


Verifique
4
3
2
0

Exercício 6

Qual é o output do seguinte código?

n = range(4)

for num in n:
    print(num - 1)
else:
    print(num)


Verifique
Exercício 7

Qual é o output do seguinte código?

for i in range(0, 6, 3):
    print(i)


Verifique
0
3

Lógica de computador
Já reparou que as condições que utilizámos até agora têm sido muito simples, para não dizer bastante primitivas? As condições que utilizamos na vida real são muito mais complexas. Vejamos esta frase:

Se tivermos algum tempo livre, e o tempo estiver bom, vamos dar um passeio.


Utilizámos a conjunção and, o que significa que ir dar um passeio depende do cumprimento simultâneo destas duas condições. Na linguagem da lógica, tal ligação de condições é chamada uma conjunção. E agora outro exemplo:

Se estiveres no centro comercial ou eu estiver no centro comercial, um de nós vai comprar um presente para a mãe.


A aparência da palavra or significa que a compra depende de pelo menos uma destas condições. Em lógica, tal composto é chamado uma disjunção.

É evidente que o Python deve ter operadores para construir conjunções e disjunções. Sem eles, o poder expressivo da linguagem ficaria substancialmente enfraquecido. Eles são chamados operadores lógicos.

and
Um operador de conjunção lógica em Python é a palavra and. É um operador binário com uma prioridade que é inferior à expressa pelos operadores de comparação. Permite-nos codificar condições complexas sem o uso de parêntesis como esta:

counter > 0 and value == 100


O resultado fornecido pelo operador and pode ser determinado com base na tabela da verdade.

Se considerarmos a conjunção de A e B, o conjunto de valores possíveis de argumentos e valores correspondentes da conjunção parece ser o seguinte:


Argumento A	Argumento B	A e B
False	False	False
False	True	False
True	False	False
True	True	True

or
Um operador de disjunção é a palavra or. É um operador binário com uma prioridade inferior a and ( assim como + comparado com *). A sua tabela de verdade é a seguinte:


Argumento A	Argumento B	A ou B
False	False	False
False	True	True
True	False	True
True	True	True

not
Além disso, há outro operador que pode ser aplicado para construir condições. É um operador unário que executa uma negação lógica. O seu funcionamento é simples: transforma a verdade em falsidade e a falsidade em verdade.

Este operador é escrito como a palavra not, e a sua prioridade é muito alta: a mesma que o unário + e -. A sua tabela de verdade é simples:


Argumento	not Argumento
False	True
True	False

Expressões lógicas
Vamos criar uma variável chamada var e atribuir 1 a ela. As seguintes condições são equivalentes em pares:

# Example 1:
print(var > 0)
print(not (var <= 0))


# Example 2:
print(var != 0)
print(not (var == 0))


Pode estar familiarizado com as leis de De Morgan. Dizem que:

A negação de uma conjunção é a disjunção das negações.

A negação de uma disjunção é a conjunção das negações.


Vamos escrever a mesma coisa usando Python:

not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)


Note-se como os parêntesis foram utilizados para codificar as expressões - colocámo-los lá para melhorar a legibilidade.

Devemos acrescentar que nenhum destes operadores de dois argumentos pode ser utilizado sob a forma abreviada conhecida como op=. Vale a pena recordar esta exceção.

Valores lógicos vs. bits únicos
Os operadores lógicos tomam os seus argumentos como um todo, independentemente da quantidade de bits que contenham. Os operadores só estão conscientes do valor: zero (quando todos os bits são redefinidos) significa False; não zero (quando pelo menos um bit está definido) significa True.

O resultado das suas operações é um destes valores: False ou True. Isto significa que este snippet irá atribuir o valor True à variável j se i não for zero; caso contrário, será False.

i = 1
j = not not i


Operadores bitwise
No entanto, existem quatro operadores que lhe permitem manipular bits únicos de dados. São chamados operadores bitwise.

Abrangem todas as operações que mencionámos anteriormente no contexto lógico, e um operador adicional. Este é o operador xor (como em exclusivo ou), e é denotado como ^ (acento circunflexo).

Aqui estão todos eles:

& (e comercial) - conjunção bitwise;
| (barra) - disjunção bitwise;
~ (til) - negação bitwise;
^ (acento circunflexo) - bitwise exclusive ou (xor).

Operações bitwise (&, |, e ^)
Argumento A	Argumento B	A & B	 A | B	A ^ B
0	0	0	0	0
0	1	0	1	1
1	0	0	1	1
1	1	1	1	0

Operações bitwise (~)
Argumento	~ Argumento
0	1
1	0

Vamos facilitar as coisas:

& requer exatamente dois 1para fornecer 1 como resultado;
| requer pelo menos um 1 para fornecer 1 como resultado;
^ requer exatamente um 1 para fornecer 1 como resultado.

Acrescentemos uma observação importante: os argumentos destes operadores devem ser inteiros; não devemos utilizar floats aqui.

A diferença no funcionamento dos operadores lógicos e de bit é importante: os operadores lógicos não penetram no nível de bits do seu argumento. Eles só estão interessados no valor inteiro final.

Os operadores bitwise são mais rigorosos: lidam com cada bit separadamente. Se assumirmos que a variável inteira ocupa 64 bits (o que é comum nos sistemas informáticos modernos), podemos imaginar a operação bitwise como uma avaliação de 64 vezes do operador lógico para cada par de bits dos argumentos. Esta analogia é obviamente imperfeita, pois no mundo real todas estas 64 operações são realizadas ao mesmo tempo (simultaneamente).


Operações lógicas versus bit: continuação
Vamos agora mostrar-lhe um exemplo da diferença de funcionamento entre as operações lógicas e as operações de bit. Vamos assumir que as seguintes atribuições foram realizadas:

i = 15
j = 22


Se assumirmos que os números inteiros são armazenados com 32 bits, a imagem bitwise das duas variáveis será a seguinte:

i: 00000000000000000000000000001111
j: 00000000000000000000000000010110

A atribuição é dada:

log = i and j


Estamos a lidar aqui com uma conjunção lógica. Vamos traçar o curso dos cálculos. Ambas as variáveis i e j não são zeros, por isso serão consideradas para representar True. Consultando a tabela da verdade para o operador and , podemos ver que o resultado será True. Nenhuma outra operação é realizada.

log: True

Agora a operação bitwise - aqui está ela:

bit = i & j


O operador & operará com cada par de bits correspondentes separadamente, produzindo os valores dos bits relevantes do resultado. Portanto, o resultado será o seguinte:

i	00000000000000000000000000001111
j	00000000000000000000000000010110
bit = i & j	00000000000000000000000000000110
Estes bits correspondem ao valor inteiro de seis.



Vejamos agora os operadores de negação. Primeiro, o lógico:

logneg = not i


A variável logneg será definida como False - nada mais precisa de ser feito.

A negação bitwise é assim:

bitneg = ~i


Pode ser um pouco surpreendente: o valor da variável bitneg é -16. Isto pode parecer estranho, mas não é de todo. Se desejar saber mais, deve verificar o sistema de numeração binária e as regras que regem os números complementares de dois.

i	00000000000000000000000000001111
bitneg = ~i	11111111111111111111111111110000
Cada um destes operadores de dois argumentos pode ser utilizado de forma abreviada. Estes são os exemplos das suas notações equivalentes:

x = x & y	x &= y
x = x | y	x |= y
x = x ^ y	x ^= y

Prev Next

Como lidamos com bits individuais?
Vamos agora mostrar-lhe aquilo para que pode utilizar os operadores bitwise. Imagine que é um programador obrigado a escrever uma parte importante de um sistema operativo. Foi informado de que tem permissão para usar uma variável atribuída da seguinte maneira:

flag_register = 0x1234


A variável armazena as informações sobre vários aspectos da operação do sistema. Cada bit da variável armazena um valor yes/no. Também lhe foi dito que apenas um destes bits é seu - o terceiro (lembre-se que os bits são numerados a partir do zero, e o bit número zero é o mais baixo, enquanto o mais alto é o número 31). Os bits restantes não podem ser alterados, porque se destinam a armazenar outros dados. Aqui está o seu bit marcado pela letra x:

flag_register = 0000000000000000000000000000x000


Pode ser confrontado com as seguintes tarefas:

1. Verifique o estado do seu bit - quer descobrir o valor do seu bit; comparar a variável inteira com zero não fará nada, porque os bits restantes podem ter valores completamente imprevisíveis, mas pode usar a seguinte propriedade de conjunção:

x & 1 = x
x & 0 = 0


Se aplicar a & operação à flag_register variável juntamente com a seguinte imagem de bit:

00000000000000000000000000001000

(observe o 1 na posição do seu bit) como resultado, obtém uma das seguintes strings de bit:

00000000000000000000000000001000 se o seu bit foi definido para 1
00000000000000000000000000000000 se o seu bit foi redefinido para 0
Tal sequência de zeros e uns, cuja tarefa é agarrar o valor ou alterar os bits selecionados, é chamada de bit mask.

Vamos criar uma bit mask para detetar o estado do seu bit. Deve apontar para o terceiro bit. Esse bit tem o peso de 23 = 8. Uma mask adequada poderia ser criada através da seguinte declaração:

the_mask = 8



Também pode fazer uma sequência de instruções dependendo do estado do seu bit i aqui está:

if flag_register & the_mask:
    # My bit is set.
else:
    # My bit is reset.


2. Redefina o seu bit - atribua um zero ao bit enquanto todos os outros bits devem permanecer inalterados; utilizemos a mesma propriedade de conjunção como antes, mas utilizemos uma mask ligeiramente diferente - exatamente como em baixo:

11111111111111111111111111110111


Observe que a mask foi criada como resultado da negação de todos os bits de the_mask variável. Redefinir o bit é simples, e parece-se com isto (escolha o que mais gostar):

flag_register = flag_register & ~the_mask
flag_register &= ~the_mask



3. Defina o seu bit - atribua um 1 ao seu bit, enquanto todos os bits restantes devem permanecer inalterados; use a seguinte propriedade de disjunção:

x | 1 = 1
x | 0 = x


Agora está pronto para definir o seu bit com uma das seguintes instruções:

flag_register = flag_register | the_mask
flag_register |= the_mask


4. Negue o seu bit - substitua um 1 com um 0 e um 0 com um 1. Pode utilizar uma propriedade interessante do xor operador:

x ^ 1 = ~x
x ^ 0 = x


e negue o seu bit com as seguintes instruções:

flag_register = flag_register ^ the_mask
flag_register ^= the_mask


Prev Next

Shifting binário à esquerda e shifting binário à direita
O Python oferece mais uma operação relacionada a bits individuais: shifting (deslocamento). Isto é aplicado apenas a valores inteiros, e não se deve utilizar floats como argumentos.

Você já aplica esta operação com alguma frequência, e bastante inconscientemente. De que forma multiplica qualquer número por dez? Dê uma vista de olhos:

12345 × 10 = 123450


Como se pode ver, multiplicar por dez é, de facto, um shifting de todos os dígitos para a esquerda, preenchendo a lacuna resultante com zero.

Divisão por dez? Dê uma vista de olhos:

12340 ÷ 10 = 1234


Dividir por dez não é mais do que um shifting dos dígitos para a direita

O mesmo tipo de operação é realizado pelo computador, mas com uma diferença: como dois é a base para números binários (não 10), o shifting de um valor um bit para a esquerda corresponde assim a multiplicá-lo por dois; respetivamente, o shifting um bit para a direita é o mesmo que dividí-lo por dois (repare que o bit mais à direita é perdido).

Os operadores shift em Python são um par de dígrafos: << e >>, sugerindo claramente em que direção a mudança irá ocorrer.

value << bits
value >> bits


O argumento à esquerda destes operadores é um valor inteiro cujos bits são deslocados. O argumento à direita determina o tamanho do shifting.

Isto demonstra que esta operação não é certamente comutativa.

A prioridade destes operadores é muito alta. Vê-los-á na tabela de prioridades atualizada, que lhe mostraremos no final desta secção.

Dê uma vista de olhos nas mudanças na janela do editor.

A invocação print() final produz o seguinte output:

17 68 8
output

Nota:

17 >> 1 → 17 // 2 (17 divido por baixo por 2 à potência de 1) → 8 (shifting para a direita por um bit é o mesmo que a divisão inteira por dois)
17 << 2 → 17 * 4 17 multiplicado por 2 à potência de 2) → 68 (shifting para a esquerda por dois bits é o mesmo que a multiplicação de inteiros por quatro)

E aqui está a tabela de prioridades atualizada, contendo todos os operadores introduzidos até agora:

Prioridade	Operador	
1	~, +, -	unário
2	**	
3	*, /, //, %	
4	+, -	binário
5	<<, >>	
6	<, <=, >, >=	
7	==, !=	
8	&	
9	|	
10	=, +=, -=, *=, /=, %=, &=, ^=, |=, >>=, <<=	

Console 

var = 17
var_right = var >> 1
var_left = var << 2
print(var, var_left, var_right)

Key takeaways

1. O Python suporta os seguintes operadores lógicos:

and → se ambos os operandos forem verdadeiros, a condição é verdadeira, por exemplo, (True and True) é True,
or → se algum dos operandos for verdadeiro, a condição é verdadeira, por exemplo, (True or False) é True,
not → retorna falso se o resultado for verdadeiro, e retorna verdadeiro se o resultado for falso, por exemplo, not True é False.
2. Pode utilizar operadores bitwise para manipular bits únicos de dados. Os seguintes dados de amostra:

x = 15, que é 0000 1111 em binário,
y = 16, que é 0001 0000 em binário.
serão utilizados para ilustrar o significado de operadores bitwise em Python. Analise os exemplos em baixo:

& faz um bitwise and, por exemplo, x & y = 0, que é 0000 0000 em binário,
| faz um bitwise ou, por exemplo, x | y = 31, que é 0001 1111 em binário,
˜  faz um bitwise não, por exemplo, ˜ x = 240*, que é 1111 0000 em binário,
^ faz um bitwise xor, por exemplo, x ^ y = 31, que é 0001 1111 em binário,
>> faz um bitwise right shift, por exemplo, y >> 1 = 8, que é 0000 1000 em binário,
<< faz um bitwise left shift, por exemplo, y << 3 = , que é 1000 0000 em binário,

* -16 (decimal do complemento assinado de 2) — leia mais sobre a Two's complement operation (operação de complemento de dois).



Exercício 1

Qual é o output do seguinte snippet?

x = 1
y = 0

z = ((x == y) and (x == y)) or not(x == y)
print(not(z))


Verifique
Exercício 2

Qual é o output do seguinte snippet?

x = 4
y = 1

a = x & y
b = x | y
c = ~x  # tricky!
d = x ^ 5
e = x >> 2
f = x << 2

print(a, b, c, d, e, f)


Verifique

0 5 -5 1 1 16

Prev

Porque precisamos de listas?
Pode acontecer que tenha de ler, armazenar, processar e, finalmente, imprimir dezenas, talvez centenas, talvez até milhares de números. E então, o quê? É necessário criar uma variável em separado para cada valor? É necessário passar várias horas a escrever declarações como as abaixo?

var1 = int(input())
var2 = int(input())
var3 = int(input())
var4 = int(input())
var5 = int(input())
var6 = int(input())
:
:


Se pensa que esta não é uma tarefa complicada, então pegue num pedaço de papel e escreva um programa que:

leia cinco números,
que os imprima por ordem do mais pequeno ao maior (este tipo de processamento chama-se triagem).
Deve chegar à conclusão de que não tem sequer papel suficiente para completar a tarefa.

Até agora, aprendeu a declarar variáveis que são capazes de armazenar exatamente um determinado valor de cada vez. Tais variáveis são por vezes chamadas escalares, por analogia com a matemática. Todas as variáveis que utilizou até agora são, na verdade, escalares.

Pense no quão conveniente seria declarar uma variável que pudesse armazenar mais do que um valor. Por exemplo, cem, ou mil, ou até dez mil. Seria ainda uma e a mesma variável, mas muito ampla e espaçosa. Parece apelativa? Talvez, mas como lidaria com um recipiente cheio de valores diferentes? Como escolheria apenas aquele de que necessita?


E se pudesse simplesmente numerá-los? E depois dizer: dá-me o valor número 2; atribui o valor número 15; aumenta o valor número 10000.

Vamos mostrar-lhe como declarar tais variáveis multi-valores. Vamos fazer isto com o exemplo que acabámos de sugerir. Vamos escrever um programa que ordena uma sequência de números. Não seremos particularmente ambiciosos - vamos assumir que existem exatamente cinco números.

Vamos criar uma variável chamada numbers; é atribuída não apenas com um número, mas é preenchida com uma lista constituída por cinco valores (nota: a lista começa com um parêntesis reto aberto e termina com um parêntesis reto fechado; o espaço entre os parêntesis é preenchido com cinco números separados por vírgulas).

numbers = [10, 5, 7, 2, 1]


Digamos a mesma coisa usando terminologia adequada: numbers é uma lista constituída por cinco valores, todos eles números. Podemos também dizer que esta declaração cria uma lista de comprimento igual a cinco (visto existir cinco elementos no seu interior).

Os elementos dentro de uma lista podem ter tipos diferentes. Alguns deles podem ser inteiros, outros floats, e outros ainda podem ser listas.

O Python adotou uma convenção, afirmando que os elementos numa lista são sempre numerados a partir do zero. Isto significa que o artigo armazenado no início da lista terá o número zero. Uma vez que existem cinco elementos na nossa lista, ao último deles é atribuído o número quatro. Não esqueça isto.

Rapidamente se acostumará a isto, e tornar-se-á uma segunda natureza.

Antes de avançarmos na nossa discussão, temos de referir o seguinte: a nossa lista é uma coleção de elementos, mas cada elemento é um escalar.

Indexar listas

Como se altera o valor de um elemento escolhido na lista?

Vamos atribuir um novo valor de 111 ao primeiro elemento na lista. Fazemo-lo assim:

numbers = [10, 5, 7, 2, 1]
print("Original list content:", numbers)  # Printing original list content.

numbers[0] = 111
print("New list content: ", numbers)  # Current list content.


E agora queremos que o valor do quinto elemento seja copiado para o segundo elemento - consegue adivinhar como o fazer?

numbers = [10, 5, 7, 2, 1]
print("Original list content:", numbers)  # Printing original list content.

numbers[0] = 111
print("\nPrevious list content:", numbers)  # Printing previous list content.

numbers[1] = numbers[4]  # Copying value of the fifth element to the second.
print("New list content:", numbers)  # Printing current list content.


O valor dentro dos parêntesis que seleciona um elemento da lista é chamado um index, enquanto a operação de selecionar um elemento da lista é conhecida como indexing (indexação).

Vamos utilizar a função print() para imprimir o conteúdo da lista cada vez que fazemos as alterações. Isto ajudar-nos-á a seguir cada passo com mais cuidado e a ver o que se passa após uma determinada modificação da lista.

Nota: todos os índices usados até agora são literais. Os seus valores são fixados em runtime, mas qualquer expressão também pode ser o index. Isto oferece muitas possibilidades.


 
 Sandbox
Code
numbers = [10, 5, 7, 2, 1]
print("List content:", numbers) # Printing original list content.



Console 

Aceder ao conteúdo da lista
Cada um dos elementos da lista pode ser acedido separadamente. Por exemplo, pode ser impresso:

print(numbers[0]) # Accessing the list's first element.


Assumindo que todas as operações anteriores tenham sido concluídas com sucesso, o snippet enviará 111 para a consola.

Como pode ver no editor, a lista também pode ser impressa como um todo - tal como aqui:

print(numbers)  # Printing the whole list.


Como provavelmente já notou antes, o Python decora o output de uma forma que sugere que todos os valores apresentados formam uma lista. O output do exemplo acima é o seguinte:

[111, 1, 7, 2, 1]
output


O método len() .
O comprimento de uma lista pode variar durante a execução. Novos elementos podem ser acrescentados à lista, enquanto outros podem ser retirados da mesma. Isto significa que a lista é uma entidade muito dinâmica.

Se quiser verificar o comprimento atual da lista, pode usar uma função chamada len() (o seu nome vem de length (comprimento)).

A função toma o nome da lista como argumento, e devolve o número de elementos atualmente armazenados dentro da lista (por outras palavras - o comprimento da lista).

Veja a última linha de código no editor, execute o programa e verifique que valor irá imprimir para a consola. Consegue adivinhar?



 
 Sandbox
Code
numbers = [10, 5, 7, 2, 1]
print("Original list content:", numbers) # Printing original list content.

numbers[0] = 111
print("\nPrevious list content:", numbers) # Printing previous list content.

numbers[1] = numbers[4] # Copying value of the fifth element to the second.
print("Previous list content:", numbers) # Printing previous list content.

print("\nList length:", len(numbers)) # Printing the list's length.
numbers = [10, 5, 7, 2, 1]

Remover elementos de uma lista

Qualquer elemento da lista pode ser removido a qualquer momento - isto é feito com uma instrução chamada del (delete). Nota: é uma instrução, não uma função.

É preciso apontar o elemento a ser removido - desaparecerá da lista, e o comprimento da lista será reduzido em um.

Olhe para o snippet abaixo. Consegue adivinhar que output irá produzir? Execute o programa no editor e verifique.

del numbers[1]
print(len(numbers))
print(numbers)


Não se pode aceder a um elemento que não existe - não se pode obter o seu valor nem atribuir-lhe um valor. Ambas estas instruções irão agora causar erros de runtime:

print(numbers[4])
numbers[4] = 1


Adicione o snippet acima após a última linha de código no editor, execute o programa e verifique o que acontece.

Nota: retirámos um dos elementos da lista - agora só há quatro elementos na lista. Isto significa que o elemento número quatro não existe.


 
 Sandbox
Code
numbers = [10, 5, 7, 2, 1]
print("Original list content:", numbers) # Printing original list content.

numbers[0] = 111
print("\nPrevious list content:", numbers) # Printing previous list content.

numbers[1] = numbers[4] # Copying value of the fifth element to the second.
print("Previous list content:", numbers) # Printing previous list content.

print("\nList's length:", len(numbers)) # Printing previous list length.

###

del numbers[1] # Removing the second element from the list.
print("New list's length:", len(numbers)) # Printing new list length.
print("\nNew list content:", numbers) # Printing current list content.

###
###

Índices negativos são legais
Pode parecer estranho, mas os índices negativos são legais, e podem ser muito úteis.

Um elemento com um index igual a -1 é o último na lista.

print(numbers[-1])


O snippet de exemplo terá como output 1. Execute o programa e verifique.


Da mesma forma, o elemento com um index igual a -2 é o penúltimo na lista.

print(numbers[-2])


O snippet de exemplo terá como output 2.

O último elemento acessível da nossa lista é numbers[-4] (o primeiro) - não tente ir mais longe!

numbers = [111, 7, 2, 1]
print(numbers[-1])
print(numbers[-2])

LAB

Tempo estimado
5 minutos

Nível de dificuldade
Muito fácil

Objetivos
Familiarizar o aluno a:

utilizar instruções básicas relacionadas com listas;
criar e modificar listas.
Cenário
Houve uma vez um chapéu. O chapéu não continha nenhum coelho, mas uma lista de cinco números: 1, 2, 3, 4, e 5.

A sua tarefa é:

escrever uma linha de código que peça ao utilizador para substituir o número médio na lista por um número inteiro introduzido pelo utilizador (Passo 1)
escrever uma linha de código que remova o último elemento da lista (Passo 2)
escrever uma linha de código que imprima o comprimento da lista existente (Passo 3).
Pronto para este desafio?


 
 Sandbox
Code
hat_list = [1, 2, 3, 4, 5] # This is an existing list of numbers hidden in the hat.

# Step 1: write a line of code that prompts the user
# to replace the middle number with an integer number entered by the user.

# Step 2: write a line of code that removes the last element from the list.

# Step 3: write a line of code that prints the length of the existing list.

print(hat_list)
hat_list = [1, 2, 3, 4, 5]  # This is an existing list of numbers hidden in the hat.

Funções vs. métodos
Um método é um tipo específico de função - comporta-se como uma função e parece uma função, mas difere na forma como atua, e no seu estilo de invocação.

Uma função não pertence a nenhum dado - recebe dados, pode criar novos dados e (geralmente) produz um resultado.

Um método faz todas estas coisas, mas também é capaz de alterar o estado de uma entidade selecionada.

Um método é propriedade dos dados para os quais trabalha, enquanto uma função é propriedade de todo o código.


Isto também significa que a invocação de um método requer alguma especificação dos dados a partir dos quais o método é invocado.

Pode parecer intrigante aqui, mas lidaremos com isso em profundidade quando nos aprofundarmos na programação orientada ao objeto.

Em geral, uma invocação de função típica pode parecer-se com isto:

result = function(arg)


A função toma um argumento, faz algo, e devolve um resultado.



Um método típico de invocação é geralmente semelhante a este:

result = data.method(arg)


Nota: o nome do método é precedido do nome dos dados que possuem o método. Em seguida, adiciona-se um ponto, seguido do nome do método, e um par de parêntesis que encerra os argumentos.

O método comportar-se-á como uma função, mas pode fazer algo mais - pode alterar o estado interno dos dados a partir dos quais foi invocado.

Pode perguntar: porque estamos a falar de métodos e não de listas?

Esta é uma questão essencial neste momento, pois vamos mostrar-lhe como adicionar novos elementos a uma lista existente. Isto pode ser feito com métodos pertencentes a todas as listas, e não por funções.

Adicionar elementos a uma lista: append() e insert()
Um novo elemento pode ser colado no fim da lista existente:

list.append(value)


Tal operação é realizada por um método chamado append(). Toma o valor do seu argumento e coloca-o no final da lista que possui o método.

O comprimento da lista aumenta então em um.

O método insert() é um pouco mais inteligente - pode acrescentar um novo elemento em qualquer lugar da lista, e não apenas no final.

list.insert(location, value)


São necessários dois argumentos:

o primeiro mostra a localização necessária do elemento a ser inserido; nota: todos os elementos existentes que ocupam locais à direita do novo elemento (incluindo o que se encontra na posição indicada) são deslocados para a direita, a fim de criar espaço para o novo elemento;
o segundo é o elemento a ser inserido.
Veja o código no editor. Veja como utilizamos os append() e insert() métodos. Preste atenção ao que acontece após a utilização insert(): o primeiro elemento é agora o segundo, o segundo o terceiro, e assim por diante.
Adicione o seguinte snippet após a última linha de código no editor:

numbers.insert(1, 333)


Imprima o conteúdo da lista final para o ecrã e veja o que acontece. O snippet acima do snippet insere 333 na lista, tornando-o no segundo elemento. O anterior segundo elemento torna-se o terceiro, o terceiro o quarto, e assim por diante.


 
 Sandbox
Code
numbers = [111, 7, 2, 1]
print(len(numbers))
print(numbers)

###

numbers.append(4)

print(len(numbers))
print(numbers)

###

numbers.insert(0, 222)
print(len(numbers))
print(numbers)

#
numbers = [111, 7, 2, 1]


Adicionar elementos a uma lista: continuação
Pode iniciar a vida de uma lista tornando-a vazia (isto é feito com um par de parêntesis retos vazio) e depois adicionando-lhe novos elementos conforme necessário.

Veja o snippet no editor. Tente adivinhar o seu output após a execução do loop for . Execute o programa para verificar se estava certo.

Será uma sequência de números inteiros consecutivos a partir de 1 (depois adiciona-se um a todos os valores anexados) até 5.


Modificámos um pouco o snippet:

my_list = []  # Creating an empty list.

for i in range(5):
    my_list.insert(0, i + 1)

print(my_list)


O que acontecerá agora? Execute o programa e verifique se desta vez também estava certo.


Deve obter a mesma sequência, mas em ordem inversa (este é o mérito de usar o método insert() ).
 
 Sandbox
Code
my_list = [] # Creating an empty list.

for i in range(5):
my_list.append(i + 1)

print(my_list)
my_list = []  # Creating an empty list.


Console 

Utilização de listas
O loop for tem uma variante muito especial que pode processar listas muito eficazmente - vejamos isso.

Vamos supor que deseja calcular a soma de todos os valores armazenados na lista my_list .

É necessária uma variável cuja soma será armazenada e à qual será inicialmente atribuído um valor de 0 - o seu nome será total. (Nota: não vamos nomeá-la sum visto o Python usar o mesmo nome para uma das suas funções internas - sum(). Utilizar o mesmo nome seria geralmente considerado uma má prática). Em seguida, acrescenta-lhe todos os elementos da lista utilizando o loop for . Veja o snippet no editor.

Vamos comentar este exemplo:

à lista é atribuída uma sequência de cinco valores inteiros;
a variável i toma os valores 0, 1, 2, 3, e 4, e depois indexa a lista, selecionando os elementos seguintes: o primeiro, o segundo, o terceiro, o quarto e o quinto;
cada um destes elementos é adicionado em conjunto pelo operador += à variável total , dando o resultado final no fim do loop;
observe a forma como a função len() foi utilizada - torna o código independente de quaisquer possíveis alterações no conteúdo da lista.

A segunda face do loop for .
Mas o loop for pode fazer muito mais. Pode ocultar todas as ações ligadas à indexação da lista, e entregar todos os elementos da lista de uma forma prática.

Este snippet modificado mostra como isto funciona:

my_list = [10, 1, 8, 3, 5]
total = 0

for i in my_list:
    total += i

print(total)


O que acontece aqui?

a instrução for especifica a variável usada para navegar na lista (i aqui) seguida pela keyword in e pelo nome da lista que está a ser processada (my_list aqui)
à variável i são atribuídos os valores de todos os elementos da lista subsequente, e o processo ocorre tantas vezes quantos os elementos da lista;
isto significa que se utiliza a variável i como uma cópia dos valores dos elementos, e não se precisa de utilizar índices;
a função len() também não é necessária aqui.

 
 Sandbox
Code
my_list = [10, 1, 8, 3, 5]
total = 0

for i in range(len(my_list)):
total += my_list[i]

print(total)
my_list = [10, 1, 8, 3, 5]


Console 

Listas em ação
Deixemos as listas de lado por um breve momento e vejamos uma questão intrigante.

Imagine que precisa de reorganizar os elementos de uma lista, ou seja, inverter a ordem dos elementos: o primeiro e o quinto, bem como o segundo e o quarto elementos serão trocados. O terceiro permanecerá intocado.


Pergunta: como se pode trocar os valores de duas variáveis?

Veja o snippet:

variable_1 = 1
variable_2 = 2

variable_2 = variable_1
variable_1 = variable_2


Se fizer algo como isto, perderá o valor previamente armazenado em variable_2. Alterar a ordem das atribuições não ajudará. É necessária uma terceira variável que sirva como armazenamento auxiliar.

É assim que se pode fazer:

variable_1 = 1
variable_2 = 2

auxiliary = variable_1
variable_1 = variable_2
variable_2 = auxiliary


O Python oferece uma forma mais conveniente de fazer a troca - veja:

variable_1 = 1
variable_2 = 2

variable_1, variable_2 = variable_2, variable_1


Claro, eficaz e elegante - não é?


 
 Sandbox
Code



Console 

Listas em ação
Agora pode facilmente trocar os elementos da lista para inverter a sua ordem:

my_list = [10, 1, 8, 3, 5]

my_list[0], my_list[4] = my_list[4], my_list[0]
my_list[1], my_list[3] = my_list[3], my_list[1]

print(my_list)


Execute o snippet. O seu output deve ter este aspeto:

[5, 3, 8, 1, 10]
output


Fica bem com cinco elementos.


Será ainda aceitável com uma lista contendo 100 elementos? Não, não será.

Pode utilizar o loop for para fazer a mesma coisa automaticamente, independentemente do comprimento da lista? Sim, pode.

Foi assim que o fizemos:

my_list = [10, 1, 8, 3, 5]
length = len(my_list)

for i in range(length // 2):
    my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]

print(my_list)


Nota:

nós atribuímos a variável length com o comprimento da lista atual (isto torna o nosso código um pouco mais claro e mais curto)
lançámos o loop for para correr através do seu corpo length // 2 vezes (isto funciona bem para listas com comprimentos pares e ímpares, porque quando a lista contém um número ímpar de elementos, o do meio permanece intocado)
trocamos o i-ésimo elemento (desde o início da lista) com o que tem um index igual a (length - i - 1) (do final da lista); no nosso exemplo, para i igual a 0 o ramo (lenght - i - 1) dá 4; para i igual a 1, dá 3 - Isto é exatamente o que precisávamos.
As listas são extremamente úteis, e irá encontrá-las com muita frequência.


 
 Sandbox
Code



Console 
LAB

Tempo estimado
10-15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

a criação e modificação de listas simples;
utilizar métodos para modificar listas.
Cenário
Os Beatles foram um dos grupos musicais mais populares dos anos 1960, e a banda mais best-seller da história. Algumas pessoas consideram-nas o ato mais influente da era do rock. De facto, foram incluídos na compilação da revista Time das 100 pessoas mais influentes do século XX.

A banda passou por muitas mudanças de formação, culminando em 1962 com o line-up de John Lennon, Paul McCartney, George Harrison, e Richard Starkey (mais conhecido como Ringo Starr).


Escreva um programa que reflita estas mudanças e lhe permita praticar com o conceito de listas. A sua tarefa é:

passo 1: criar uma lista vazia com o nome beatles;
passo 2: utilizar o método append() para adicionar os seguintes membros da banda à lista: John Lennon, Paul McCartney, e George Harrison;
passo 3: utilizar o loop for e o método append() para solicitar ao utilizador que adicione os seguintes membros da banda à lista: Stu Sutcliffe, e Pete Best;
passo 4: utilizar a instrução del para remover Stu Sutcliffe e Pete Best da lista;
passo 5: utilizar o método insert() para adicionar Ringo Starr ao início da lista.
A propósito, é fã dos Beatles? (Os Beatles são uma das bandas favoritas de Greg. Mas calma...quem é o Greg....?)


 
 Sandbox
Code
# step 1
print("Step 1:", beatles)

# step 2
print("Step 2:", beatles)

# step 3
print("Step 3:", beatles)

# step 4
print("Step 4:", beatles)

# step 5
print("Step 5:", beatles)


# testing list legth
print("The Fab", len(beatles))
# step 1


Console 

Key takeaways

1. A lista é um tipo de dados em Python usada para armazenar vários objetos. É uma coleção ordenada e mutável de ítens separados por vírgulas, entre parêntesis retos, por exemplo:

my_list = [1, None, True, "I am a string", 256, 0]


2. As listas podem ser indexadas e atualizadas, por exemplo:

my_list = [1, None, True, 'I am a string', 256, 0]
print(my_list[3])  # outputs: I am a string
print(my_list[-1])  # outputs: 0

my_list[1] = '?'
print(my_list)  # outputs: [1, '?', True, 'I am a string', 256, 0]

my_list.insert(0, "first")
my_list.append("last")
print(my_list)  # outputs: ['first', 1, '?', True, 'I am a string', 256, 0, 'last']


3. As listas podem ser nested, por exemplo:

my_list = [1, 'a', ["list", 64, [0, 1], False]]


Aprenderá mais sobre o nesting no módulo 3.1.7 - por enquanto, só queremos que esteja ciente de que algo como isto também é possível.

4. Os elementos da lista e as listas podem ser excluídos, por exemplo:

my_list = [1, 2, 3, 4]
del my_list[2]
print(my_list)  # outputs: [1, 2, 4]

del my_list  # deletes the whole list


Novamente, aprenderá mais sobre isto no módulo 3.1.6 - não se preocupe. Por enquanto, basta tentar experimentar o código acima e verificar como a sua alteração afeta o output.

5. As listas podem ser iteradas através da utilização do loop for , por exemplo:

my_list = ["white", "purple", "blue", "yellow", "green"]

for color in my_list:
    print(color)


6. A função len() pode ser usada para verificar o comprimento da lista, por exemplo:

my_list = ["white", "purple", "blue", "yellow", "green"]
print(len(my_list))  # outputs 5

del my_list[2]
print(len(my_list))  # outputs 4


7. Uma invocação de função típica parece-se com a seguinte: result = function(arg), enquanto uma invocação de método típica parece-se com isto:result = data.method(arg).




Exercício 1

Qual é o output do seguinte snippet?

lst = [1, 2, 3, 4, 5]
lst.insert(1, 6)
del lst[0]
lst.append(1)

print(lst)


Verifique
[6, 2, 3, 4, 5, 1]
Exercício 2

Qual é o output do seguinte snippet?

lst = [1, 2, 3, 4, 5]
lst_2 = []
add = 0

for number in lst:
    add += number
    lst_2.append(add)

print(lst_2)


Verifique
[1, 3, 6, 10, 15]
Exercício 3

O que acontece quando executa o seguinte snippet?

lst = []
del lst
print(lst)


Verifique
NameError: name 'lst' is not defined
Exercício 4

Qual é o output do seguinte snippet?

lst = [1, [2, 3], 4]
print(lst[1])
print(len(lst))


Verifique
[2, 3]
3

O bubble sort
Agora que pode efetivamente fazer malabarismos com os elementos das listas, é tempo de aprender a ordená-los. Muitos algoritmos de ordenação foram inventados até agora, que diferem muito na velocidade, bem como na complexidade. Vamos mostrar-lhe um algoritmo muito simples, fácil de compreender, mas infelizmente também não muito eficiente. É utilizado muito raramente, e certamente não para listas grandes e extensas.

Digamos que uma lista pode ser ordenada de duas maneiras:

crescente (ou mais precisamente - não decrescente) - se em cada par de elementos adjacentes, o primeiro elemento não for maior do que o segundo;
decrescente (ou mais precisamente - não crescente) - se em cada par de elementos adjacentes, o primeiro elemento não for inferior ao segundo.
Nas secções seguintes, ordenaremos a lista por ordem crescente, de modo a que os números sejam ordenados do mais pequeno para o maior.

Aqui está a lista:

8
10
6
2
4
Tentaremos usar a seguinte abordagem: tomaremos o primeiro e o segundo elementos e compará-los-emos; se determinarmos que estão na ordem errada (ou seja, o primeiro é maior que o segundo), trocá-los-emos; se a sua ordem for válida, não faremos nada. Um olhar sobre a nossa lista confirma esta última - os elementos 01 e 02 estão na ordem correta, como em 8 < 10.

Agora olhe para o segundo e o terceiro elementos. Estão nas posições erradas. Temos de os trocar:

8
6
10
2
4

Vamos mais longe, e olhemos para o terceiro e quarto elementos. Novamente, não é assim que deveria ser. Temos de os trocar:

8
6
2
10
4

Agora verificamos o quarto e o quinto elementos. Sim, eles também estão nas posições erradas. Outra troca ocorre:

8
6
2
4
10

A primeira passagem pela lista já está terminada. Ainda estamos longe de terminar o nosso trabalho, mas algo de curioso aconteceu entretanto. O maior elemento, 10, já foi para o final da lista. Note-se que este é o lugar desejado para ele. Todos os elementos restantes formam uma confusão pitoresca, mas este já está no lugar.



Agora, por um momento, tente imaginar a lista de uma forma ligeiramente diferente - nomeadamente, assim:

10
4
2
6
8

Olhe - 10 está no topo. Poderíamos dizer que flutuou do fundo para a superfície, tal como a bolha numa taça de champanhe. O método de classificação deriva o seu nome da mesma observação - chama-se um bubble sort (uma espécie de bolha).

Agora começamos com a segunda passagem através da lista. Olhamos para o primeiro e segundo elementos - é necessária uma troca:

6
8
2
4
10

Tempo para o segundo e terceiro elementos: temos de os trocar também:

6
2
8
4
10

Agora o terceiro e quarto elementos, e a segunda passagem está terminada, visto 8 já estar no lugar:

6
2
4
8
10

Começamos a próxima passagem imediatamente. Observe cuidadosamente o primeiro e o segundo elementos - é necessária outra troca:

2
6
4
8
10

Agora 6 precisa de ser posto no lugar. Trocamos o segundo e o terceiro elementos:

2
4
6
8
10

A lista já está ordenada. Não temos mais nada a fazer. Isto é exatamente o que queremos.

Como pode ver, a essência deste algoritmo é simples: comparamos os elementos adjacentes e, trocando alguns deles, atingimos o nosso objetivo

Vamos codificar em Python todas as ações realizadas durante uma única passagem através da lista, e depois vamos considerar quantas passagens realmente precisamos para a realizar. Ainda não explicámos isto até agora, e faremos isso um pouco mais tarde.


Classificar uma lista
Quantas passagens precisamos para ordenar a lista completa?

Resolvemos esta questão da seguinte forma: introduzimos outra variável; a sua tarefa é observar se foi feita alguma troca durante a passagem ou não; se não houver troca, então a lista já está ordenada, e nada mais tem de ser feito. Criamos uma variável chamada swapped, e atribuímos-lhe um valor de False , para indicar que não há trocas. Caso contrário, será atribuído True.

my_list = [8, 10, 6, 2, 4]  # list to sort

for i in range(len(my_list) - 1):  # we need (5 - 1) comparisons
    if my_list[i] > my_list[i + 1]:  # compare adjacent elements
        my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]  # If we end up here, we have to swap the elements.


Deverá ser capaz de ler e compreender este programa sem quaisquer problemas:

my_list = [8, 10, 6, 2, 4]  # list to sort
swapped = True  # It's a little fake, we need it to enter the while loop.

while swapped:
    swapped = False  # no swaps so far
    for i in range(len(my_list) - 1):
        if my_list[i] > my_list[i + 1]:
            swapped = True  # a swap occurred!
            my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]

print(my_list)


Execute o programa e teste-o.


 
 Sandbox
Code



Console 

O bubble sort - versão interativa
No editor pode ver um programa completo, enriquecido por uma conversa com o utilizador, e que permite ao utilizador introduzir e imprimir elementos da lista: O bubble sort - versão interativa final.

O Python, contudo, tem os seus próprios mecanismos de ordenação. Ninguém precisa de escrever a sua própria ordenação, uma vez que existe um número suficiente de ferramentas prontas a usar.

Explicámos-lhe este sistema de ordenação porque é importante aprender a processar o conteúdo de uma lista, e mostrar-lhe como a ordenação real pode funcionar.

Se quiser que o Python ordene a sua lista, pode fazê-lo desta forma:

my_list = [8, 10, 6, 2, 4]
my_list.sort()
print(my_list)


É tão simples quanto isso.

O output do snippet é o seguinte:

[2, 4, 6, 8, 10]
output


Como pode ver, todas as listas têm um método chamado sort(), que as classifica o mais rapidamente possível. Já aprendeu alguns dos métodos de lista antes, e vai aprender mais sobre outros muito em breve.


 
 Sandbox
Code
my_list = []
swapped = True
num = int(input("How many elements do you want to sort: "))

for i in range(num):
val = float(input("Enter a list element: "))
my_list.append(val)

while swapped:
swapped = False
for i in range(len(my_list) - 1):
if my_list[i] > my_list[i + 1]:
swapped = True
my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]

print("\nSorted:")
print(my_list)
my_list = []


Console 

Key takeaways

1. Pode utilizar a keyword sort() para ordenar elementos de uma lista, por exemplo:

lst = [5, 3, 1, 2, 4]
print(lst)

lst.sort()
print(lst)  # outputs: [1, 2, 3, 4, 5]


2. Há também um método de lista chamado reverse(), que pode utilizar para inverter a lista, por exemplo

lst = [5, 3, 1, 2, 4]
print(lst)

lst.reverse()
print(lst)  # outputs: [4, 2, 1, 3, 5]





Exercício 1

Qual é o output do seguinte snippet?

lst = ["D", "F", "A", "Z"]
lst.sort()

print(lst)


Verifique
['A', 'D', 'F', 'Z']

Exercício 2

Qual é o output do seguinte snippet?

a = 3
b = 1
c = 2

lst = [a, c, b]
lst.sort()

print(lst)


Verifique
[1, 2, 3]

Exercício 3

Qual é o output do seguinte snippet?

a = "A"
b = "B"
c = "C"
d = " "

lst = [a, b, c, d]
lst.reverse()

print(lst)


Verifique
[' ', 'C', 'B', 'A']


A vida interna das listas
Agora queremos mostrar-lhe uma característica importante, e muito surpreendente, das listas, que as distingue fortemente das variáveis comuns.

Queremos que o memorize - pode afetar os seus programas futuros, e causar graves problemas se esquecido ou negligenciado.

Veja o snippet no editor.

O programa:

cria uma lista de um elemento chamada list_1;
atribui-o a uma nova lista chamada list_2;
altera o único elemento de list_1;
imprime list_2.
A parte surpreendente é o facto de que o programa fará o output: [2], não [1], que parece ser a solução óbvia.


As listas (e muitas outras entidades complexas de Python) são armazenadas de formas diferentes das variáveis ordinárias (escalares).

Pode-se dizer que:

o nome de uma variável ordinária é o nome do seu conteúdo;
o nome de uma lista é o nome de um local de memória onde a lista é armazenada.
Leia estas duas linhas mais uma vez - a diferença é essencial para compreender aquilo de que vamos falar a seguir.

A atribuição: list_2 = list_1 copia o nome do array, não o seu conteúdo. Com efeito, os dois nomes (list_1 e list_2) identificam o mesmo local na memória do computador. Modificar um deles afeta o outro, e vice-versa.

Como se lida com isso?


 
 Sandbox
Code
list_1 = [1]
list_2 = list_1
list_1[0] = 2
print(list_2)
list_1 = [1]


Console 

Slices poderosas
Felizmente, a solução está ao seu alcance - o seu nome é slice.

Uma slice é um elemento da sintaxe Python que lhe permite fazer uma cópia completamente nova de uma lista ou partes de uma lista.

Na verdade, a slice copia o conteúdo da lista, não o seu nome.

Isto é exatamente o que necessita. Dê uma vista de olhos no snippet em baixo:

list_1 = [1]
list_2 = list_1[:]
list_1[0] = 2
print(list_2)


O seu output é [1].

Esta parte inconspícua do código descrito como [:] é capaz de produzir uma lista completamente nova.

Uma das formas mais gerais da slice tem o seguinte aspeto:

my_list[start:end]

Como pode ver, assemelha-se à indexação, mas os dois pontos no interior fazem uma grande diferença.

Uma slice desta forma faz uma nova lista (alvo), retirando elementos da source list - os elementos dos índices desde o início até end - 1.

Nota: não para end mas para end - 1. Um elemento com um índice igual a end é o primeiro elemento que não participa no slicing.

É possível utilizar valores negativos tanto para o início como para o fim (tal como na indexação).

Veja o snippet:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:3]
print(new_list)


A new_list lista terá end - start (3 - 1 = 2) elementos - aqueles com índices iguais a 1 e 2 (mas não 3).

O output do snippet é: [8, 6]


 
 Sandbox
Code
# Copying the entire list.
list_1 = [1]
list_2 = list_1[:]
list_1[0] = 2
print(list_2)

# Copying some part of the list.
my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:3]
print(new_list)
# Copying the entire list.


Console 

Slices - índices negativos
Veja o snippet em baixo:

my_list[start:end]


Para repetir:

start é o index do primeiro elemento incluído no slice;
end é o index do primeiro elemento não incluído no slice.

É assim que os índices negativos funcionam com o slice:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:-1]
print(new_list)


O output do snippet é:

[8, 6, 4]
output


Se o start especifica um elemento que se encontra mais longe do que o descrito pelo end (do ponto de vista inicial da lista), o slice estará vazio:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[-1:1]
print(new_list)


O output do snippet é:

[]
output


 
 Sandbox
Code



Console 

Slices: continuação
Se omitir o start no seu slice, assume-se que pretende obter um slice começando pelo elemento com index 0.

Por outras palavras, o slice desta forma:

my_list[:end]


é um equivalente mais compacto de:

my_list[0:end]


Veja o snippet em baixo:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[:3]
print(new_list)


É por isso que o seu output é: [10, 8, 6].

Da mesma forma, se omitir o end no seu slice, presume-se que deseja que o slice termine no elemento com o index len(my_list).

Por outras palavras, o slice desta forma:

my_list[start:]


é um equivalente mais compacto de:

my_list[start:len(my_list)]


Veja o snippet seguinte:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[3:]
print(new_list)


O seu output é, portanto: [4, 2].

 
 Sandbox
Code



Console 

Slices: continuação
Como já dissemos anteriormente, omitindo ambos start e end faz uma cópia de toda a lista:

my_list = [10, 8, 6, 4, 2]
new_list = my_list[:]
print(new_list)


O output do snippet é: [10, 8, 6, 4, 2].

A instrução anteriormente descrita del é capaz de apagar mais do que apenas um elemento de uma lista ao mesmo tempo - também pode apagar slices:

my_list = [10, 8, 6, 4, 2]
del my_list[1:3]
print(my_list)


Nota: neste caso, o slice não produz nenhuma lista nova!

O output do snippet é: [10, 4, 2].


A eliminação de todos os elementos de uma só vez também é possível:

my_list = [10, 8, 6, 4, 2]
del my_list[:]
print(my_list)


A lista fica vazia e o output é: [].


A remoção do slice do código muda dramaticamente o seu significado.

Veja:

my_list = [10, 8, 6, 4, 2]
del my_list
print(my_list)


A instrução del eliminará a lista em si, não o seu conteúdo.

A print() invocação da função a partir da última linha do código causará então um erro de runtime.


 
 Sandbox
Code



Console 

Os loops in e not in operadores
O Python oferece dois operadores muito poderosos, capazes de olhar através da lista a fim de verificar se um valor específico está ou não armazenado dentro da lista

Estes operadores são:

elem in my_list
elem not in my_list


O primeiro deles (in) verifica se um dado elemento (o seu argumento da esquerda) está atualmente armazenado algures dentro da lista (o argumento da direita) - o operador devolve True neste caso.

O segundo (not in) verifica se um dado elemento (o seu argumento da esquerda) está ausente numa lista - o operador devolve True neste caso.

Veja o código no editor. O snippet mostra ambos os operadores em ação. Consegue adivinhar o seu output? Execute o programa para verificar se estava certo.


 
 Sandbox
Code
my_list = [0, 3, 12, 8, 2]

print(5 in my_list)
print(5 not in my_list)
print(12 in my_list)
my_list = [0, 3, 12, 8, 2]


Console 

Listas - alguns programas simples
Agora queremos mostrar-lhe alguns programas simples que utilizam listas.

O primeiro deles tenta encontrar o maior valor na lista. Veja o código no editor.

O conceito é bastante simples - assumimos temporariamente que o primeiro elemento é o maior, e verificamos a hipótese contra todos os restantes elementos da lista.

O código fará o output 17 (como esperado).

O código pode ser reescrito para fazer uso da forma recentemente introduzida do for :

my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list:
    if i > largest:
        largest = i

print(largest)


O programa acima realiza uma comparação desnecessária, quando o primeiro elemento é comparado consigo mesmo, mas isto não é de todo um problema.

O código fará o output 17, também (nada invulgar).

Se precisar de poupar energia do computador, pode utilizar um slice:

my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list[1:]:
    if i > largest:
        largest = i

print(largest)


A questão é: qual destas duas ações consome mais recursos informáticos - apenas uma comparação, ou slicing de quase todos os elementos de uma lista?


 
 Sandbox
Code
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in range(1, len(my_list)):
if my_list[i] > largest:
largest = my_list[i]

print(largest)
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]


Console 

Listas - alguns programas simples
Agora vamos encontrar a localização de um dado elemento dentro de uma lista:

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
to_find = 5
found = False

for i in range(len(my_list)):
    found = my_list[i] == to_find
    if found:
        break

if found:
    print("Element found at index", i)
else:
    print("absent")


Nota:

o valor alvo é armazenado na variável to_find ;
o estado atual da pesquisa é armazenado na variável found (True/False)
quando found se torna True, o loop for é saído.
Vamos supor que escolheu os seguintes números na lotaria: 3, 7, 11, 42, 34, 49.

Os números que foram sorteados são: 5, 11, 9, 42, 3, 49.

A questão é: em quantos números é que acertou?

O programa dar-lhe-á a resposta:

drawn = [5, 11, 9, 42, 3, 49]
bets = [3, 7, 11, 42, 34, 49]
hits = 0

for number in bets:
    if number in drawn:
        hits += 1

print(hits)


Nota:

a keyword drawn armazena todos os números sorteados;
a lista bets armazena as suas apostas;
a variável hits conta os seus êxitos.
O output do programa é: 4.


 
 Sandbox
Code



Console 

LAB

Tempo estimado
10-15 minutos

Nível de dificuldade
Fácil

Objetivos
Familiarizar o aluno a:

indexação de lista;
utilizar os operadores in e not in .
Cenário
Imagine uma lista - não muito longa, não muito complicada, apenas uma simples lista contendo alguns números inteiros. Alguns desses números podem ser repetidos, e esta é a pista. Não queremos repetições. Queremos que sejam removidas.

A sua tarefa é escrever um programa que remova todas as repetições de números da lista. O objetivo é ter uma lista na qual todos os números não aparecem mais de uma vez.

Nota: suponha que a source list está codificada dentro do código - não tem de a introduzir a partir do teclado. É claro que pode melhorar o código e adicionar uma parte que pode realizar uma conversa com o utilizador e obter todos os dados a partir dele.

Dica: encorajamo-lo a criar uma nova lista como área de trabalho temporária - não precisa de atualizar a lista in situ.

Não fornecemos dados de teste, pois isso seria demasiado fácil. Pode usar o nosso esqueleto em vez disso.


 
 Sandbox
Code
my_list = [1, 2, 4, 4, 1, 4, 2, 6, 2, 9]
#
# Write your code here.
#
print("The list with unique elements only:")
print(my_list)
my_list = [1, 2, 4, 4, 1, 4, 2, 6, 2, 9]


Console 

Key takeaways

1. Se tiver uma lista l1, então a seguinte tarefa: l2 = l1 não faz uma cópia da lista l1 , mas faz com que as variáveis l1 e l2 apontem para uma e a mesma lista na memória. Por exemplo:

vehicles_one = ['car', 'bicycle', 'motor']
print(vehicles_one) # outputs: ['car', 'bicycle', 'motor']

vehicles_two = vehicles_one
del vehicles_one[0] # deletes 'car'
print(vehicles_two) # outputs: ['bicycle', 'motor']


2. Se quiser copiar uma lista ou parte da lista, pode fazê-lo executando slicing:

colors = ['red', 'green', 'orange']

copy_whole_colors = colors[:]  # copy the entire list
copy_part_colors = colors[0:2]  # copy part of the list


3. Também se podem utilizar índices negativos para executar slices. Por exemplo:

sample_list = ["A", "B", "C", "D", "E"]
new_list = sample_list[2:-1]
print(new_list)  # outputs: ['C', 'D']


4. O objeto da exceção start e end parâmetros são opcionais ao executar uma slice: list[start:end], por exemplo.:

my_list = [1, 2, 3, 4, 5]
slice_one = my_list[2: ]
slice_two = my_list[ :2]
slice_three = my_list[-2: ]

print(slice_one)  # outputs: [3, 4, 5]
print(slice_two)  # outputs: [1, 2]
print(slice_three)  # outputs: [4, 5]


5. Pode eliminar slices usando a instrução del :

my_list = [1, 2, 3, 4, 5]
del my_list[0:2]
print(my_list)  # outputs: [3, 4, 5]

del my_list[:]
print(my_list)  # deletes the list content, outputs: []


6. Pode testar se alguns itens existem numa lista ou não usando as keywords in e not in, por exemplo.:

my_list = ["A", "B", 1, 2]

print("A" in my_list)  # outputs: True
print("C" not in my_list)  # outputs: True
print(2 not in my_list)  # outputs: False





Exercício 1

Qual é o output do seguinte snippet?

list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2[0]

print(list_3)


Verifique
['C']

Exercício 2

Qual é o output do seguinte snippet?

list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2

print(list_3)


Verifique
['B', 'C']

Exercício 3

Qual é o output do seguinte snippet?

list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2[:]

print(list_3)


Verifique
[]

Exercício 4

Qual é o output do seguinte snippet?

list_1 = ["A", "B", "C"]
list_2 = list_1[:]
list_3 = list_2[:]

del list_1[0]
del list_2[0]

print(list_3)

Verifique
['A', 'B', 'C']

Exercício 5

Insira in ou not in em vez de ??? para que o código faça output do resultado esperado.

my_list = [1, 2, "in", True, "ABC"]

print(1 ??? my_list)  # outputs True
print("A" ??? my_list)  # outputs True
print(3 ??? my_list)  # outputs True
print(False ??? my_list)  # outputs False

Verifique
my_list = [1, 2, "in", True, "ABC"]

print(1 in my_list)  # outputs True
print("A" not in my_list)  # outputs True
print(3 not in my_list)  # outputs True
print(False in my_list)  # outputs False

Listas em listas
As listas podem consistir em escalares (nomeadamente números) e elementos de uma estrutura muito mais complexa (já viu exemplos como strings, booleanos, ou mesmo outras listas nas lições do Resumo da Secção anterior). Vamos analisar mais de perto o caso em que os elementos de uma lista são apenas listas.

Encontramos frequentemente tais arrays (matrizes) nas nossas vidas. Provavelmente o melhor exemplo disto é um tabuleiro de xadrez.

Um tabuleiro de xadrez é composto por linhas e colunas. Existem oito linhas (em inglês, rows) e oito colunas. Cada coluna é marcada com as letras de A a H. Cada linha é marcada com um número de um a oito.

A localização de cada campo é identificada por pares de letras-dígitos. Assim, sabemos que o canto inferior esquerdo do tabuleiro (o que tem a torre branca) é A1, enquanto que o canto oposto é H8.


Vamos assumir que somos capazes de utilizar os números selecionados para representar qualquer peça de xadrez. Podemos também assumir que cada linha do tabuleiro de xadrez é uma lista.

Veja o código abaixo:

row = []

for i in range(8):
    row.append(WHITE_PAWN)


Constrói uma lista contendo oito elementos que representam a segunda linha do tabuleiro de xadrez - a que está cheia de peões (suponha que WHITE_PAWN é um símbolo pré-definido que representa um peão branco).

O mesmo efeito pode ser alcançado através de uma compreensão de lista, a sintaxe especial utilizada por Python para preencher listas massivas.

Uma compreensão de lista é na realidade uma lista, mas criada durante a execução do programa, e não é descrita estaticamente.

Veja o snippet:

row = [WHITE_PAWN for i in range(8)]


A parte do código colocada dentro dos parêntesis retos especifica:

os dados a utilizar para preencher a lista (WHITE_PAWN)
a cláusula que especifica quantas vezes os dados ocorrem dentro da lista (for i in range(8))
Deixe-nos mostrar-lhe alguns outros exemplos de compreensão de lista:

Exemplo #1:

squares = [x ** 2 for x in range(10)]


O snippet produz uma lista de dez elementos preenchida com quadrados de dez números inteiros começando do zero (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)

Exemplo #2:

twos = [2 ** i for i in range(8)]


O snippet cria um array de oito elementos contendo as primeiras oito potências de dois (1, 2, 4, 8, 16, 32, 64, 128)

Exemplo #3:

odds = [x for x in squares if x % 2 != 0 ]


O snippet faz uma lista apenas com os elementos ímpares da lista squares .


 
 Sandbox
Code



Console 

Listas em listas: arrays bidimensionais
Vamos também assumir que um símbolo pré-definido chamado EMPTY designa um campo vazio no tabuleiro de xadrez.

Assim, se quisermos criar uma lista de listas representando todo o tabuleiro de xadrez, isso pode ser feito da seguinte forma:

board = []

for i in range(8):
    row = [EMPTY for i in range(8)]
    board.append(row)


Nota:

a parte interior do loop cria uma linha composta por oito elementos (cada um deles igual a EMPTY) e anexa-o à lista board ;
a parte externa repete-o oito vezes;
no total, a lista board consiste em 64 elementos (todos iguais a EMPTY)
Este modelo imita perfeitamente o verdadeiro tabuleiro de xadrez, que é de facto uma lista de oito elementos, sendo todos eles filas únicas. Vamos resumir as nossas observações:

os elementos das filas são campos, oito deles por fila;
os elementos do tabuleiro de xadrez são linhas, oito delas por tabuleiro de xadrez.
A variável board é agora um array bidimensional. Também é chamada, por analogia aos termos algébricos, uma matriz.


Como as compreensões de lista podem ser nested, podemos encurtar a criação do tabuleiro da seguinte forma:

board = [[EMPTY for i in range(8)] for j in range(8)]


A parte interior cria uma fila, e a parte exterior constrói uma lista de filas.


 
 Sandbox
Code



Console 

Listas em listas: arrays bidimensionais - continuação
O acesso ao campo selecionado do tabuleiro requer dois índices - o primeiro seleciona a linha; o segundo - o número do campo dentro da linha, que é de facto um número de coluna.

Dê uma vista de olhos no tabuleiro de xadrez. Cada campo contém um par de índices que devem ser dados para aceder ao conteúdo do campo:




Olhando para a figura mostrada acima, vamos colocar algumas peças de xadrez no tabuleiro. Primeiro, vamos adicionar todas as torres (em inglês, rooks):

board[0][0] = ROOK
board[0][7] = ROOK
board[7][0] = ROOK
board[7][7] = ROOK


Se quiser acrescentar um cavaleiro (knight) ao C4, faça-o da seguinte forma:

board[4][2] = KNIGHT


E agora um peão (pawn) para E5:

board[3][4] = PAWN


E agora - experimente o código no editor.

 
 Sandbox
Code
EMPTY = "-"
ROOK = "ROOK"
board = []

for i in range(8):
row = [EMPTY for i in range(8)]
board.append(row)

board[0][0] = ROOK
board[0][7] = ROOK
board[7][0] = ROOK
board[7][7] = ROOK

print(board)
EMPTY = "-"


Console 
Natureza multidimensional das listas: aplicações avançadas
Vamos aprofundar a natureza multidimensional das listas. Para encontrar qualquer elemento de uma lista bidimensional, é preciso utilizar duas coordenadas:

uma vertical (número da fila)
e uma horizontal (número da coluna).
Imagine que desenvolve uma peça de software para uma estação meteorológica automática. O dispositivo regista a temperatura do ar numa base horária e fá-lo ao longo de todo o mês. Isto dá-lhe um total de 24 & vezes; 31 = 744 valores. Vamos tentar criar uma lista capaz de armazenar todos estes resultados.

Primeiro, tem de decidir que tipo de dados serão adequados para esta aplicação. Neste caso, um float seria melhor, uma vez que este termómetro é capaz de medir a temperatura com uma precisão de 0,1 ℃.

De seguida, toma uma decisão arbitrária de que as filas registarão as leituras de hora em hora (por isso a fila terá 24 elementos) e que cada uma das filas será atribuída a um dia do mês (vamos supor que cada mês tem 31 dias, por isso precisa de 31 filas). Aqui está o par apropriado de compreensões (h é para hora, d para dia):

temps = [[0.0 for h in range(24)] for d in range(31)]


Toda a matriz está agora preenchida com zeros. Pode assumir que é atualizada automaticamente utilizando agentes especiais de hardware. O que tem de fazer é esperar que a matriz seja preenchida com medições.

Agora é altura de determinar a temperatura média mensal ao meio-dia. Some todas as 31 leituras registadas ao meio-dia e divida a soma por 31. Pode assumir que a temperatura à meia-noite é armazenada em primeiro lugar. Aqui está o código relevante:

temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

total = 0.0

for day in temps:
    total += day[11]

average = total / 31

print("Average temperature at noon:", average)


Nota: a variável day usada pelo loop for não é um escalar - cada passagem através da matriz temps atribui-a com as linhas subsequentes da matriz; portanto, é uma lista. Tem que ser indexado com 11 para aceder ao valor da temperatura medida ao meio-dia.

Agora encontre a temperatura mais alta durante todo o mês - veja o código:

temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

highest = -100.0

for day in temps:
    for temp in day:
        if temp > highest:
            highest = temp

print("The highest temperature was:", highest)


Nota:

a keyword day itera através de todas as linhas na matriz temps ;
a variável temp itera através de todas as medições efetuadas num dia.
Agora conte os dias em que a temperatura ao meio-dia era de pelo menos 20 ℃:

temps = [[0.0 for h in range(24)] for d in range(31)]
#
# The matrix is magically updated here.
#

hot_days = 0

for day in temps:
    if day[11] > 20.0:
        hot_days += 1

print(hot_days, "days were hot.")



 
 Sandbox
Code



Console 

Arrays tridimensionais
O Python não limita a profundidade da inclusão list-in-list. Aqui pode ver um exemplo de um array tridimensional:

Imagine um hotel. É um enorme hotel constituído por três edifícios, com 15 andares cada um. Há 20 quartos em cada andar. Para tal, é necessário um array que possa recolher e processar informações sobre os quartos ocupados/livres.

Primeiro passo - o tipo de elementos do array. Neste caso, um valor booleano (True/False) caberia.

Segundo passo - análise calma da situação. Resumir a informação disponível: três edifícios, 15 andares, 20 quartos.

Agora pode criar o array:

rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]


O primeiro index (0 através 2) seleciona um dos edifícios; o segundo (0 através 14) seleciona o andar, o terceiro (0 através 19) seleciona o número do quarto. Todos os quartos estão inicialmente livres.

Agora pode reservar um quarto para dois recém-casados: no segundo edifício, no décimo andar, quarto 14:

rooms[1][9][13] = True


e libertar o segundo quarto no quinto andar, localizado no primeiro edifício:

rooms[0][4][1] = False


Verifique se há vagas no 15º andar do terceiro edifício:

vacancy = 0

for room_number in range(20):
    if not rooms[2][14][room_number]:
        vacancy += 1


A variável vacancy contém 0 se todos os quartos estiverem ocupados, ou o número de quartos disponíveis, caso contrário.


Parabéns! Conseguiu chegar ao fim do módulo. Continue com o bom trabalho!


 
 Sandbox
Code
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]
rooms = [[[False for r in range(20)] for f in range(15)] for t in range(3)]


Console 

Key takeaways

1. A compreensão de lista permite-lhe criar novas listas a partir de listas existentes de uma forma concisa e elegante. A sintaxe de uma compreensão de lista é a seguinte:

[expression for element in list if conditional]


que é na verdade um equivalente ao seguinte código:

for element in list:
    if conditional:
        expression


Eis um exemplo de compreensão de uma lista - o código cria uma lista de cinco elementos preenchida com os primeiros cinco números naturais elevados à potência de 3:

cubed = [num ** 3 for num in range(5)]
print(cubed)  # outputs: [0, 1, 8, 27, 64]


2. Pode usar listas nested em Python para criar matrizes (ou seja, listas bidimensionais). Por exemplo:

Tabela - uma matriz bidimensional

# A four-column/four-row table - a two dimensional array (4x4)

table = [[":(", ":)", ":(", ":)"],
         [":)", ":(", ":)", ":)"],
         [":(", ":)", ":)", ":("],
         [":)", ":)", ":)", ":("]]

print(table)
print(table[0][0])  # outputs: ':('
print(table[0][3])  # outputs: ':)'




3. Pode fazer nest de quantas lists-in-lists quiser, e portanto criar listas n-dimensionais, por exemplo, três, quatro ou mesmo sessenta e quatro arrays dimensionais. Por exemplo:

Cubo - uma matriz tridimensional

# Cube - a three-dimensional array (3x3x3)

cube = [[[':(', 'x', 'x'],
         [':)', 'x', 'x'],
         [':(', 'x', 'x']],

        [[':)', 'x', 'x'],
         [':(', 'x', 'x'],
         [':)', 'x', 'x']],

        [[':(', 'x', 'x'],
         [':)', 'x', 'x'],
         [':)', 'x', 'x']]]

print(cube)
print(cube[0][0][0])  # outputs: ':('
print(cube[2][2][0])  # outputs: ':)'



Parabéns! Completou o Módulo 3.


Muito bem! Chegou ao fim do Módulo 3 e completou um marco importante na sua educação em programação Python. Aqui está um breve resumo dos objetivos que abordou e com os quais se familiarizou no Módulo 3:

Valores booleanos para comparar diferentes valores e controlar os caminhos de execução usando as instruções if e if-else ;
a utilização de loops (while e for) e como controlar o seu comportamento usando as instruções break e continue ;
a diferença entre as operações lógicas e as operações bitwise;
o conceito de listas e processamento de listas, incluindo a iteração fornecida pelo loop for , e slicing;
a ideia de arrays multidimensionais.

Está agora pronto para fazer o quiz do módulo e tentar o desafio final: Teste do módulo 3, que o ajudará a avaliar o que aprendeu até agora.




Conclusão do módulo - parabéns

-------------------------------------------------------------------------------------
uninter sistemas operacionais aula 1

SISTEMAS OPERACIONAIS

AULA 1

Prof. André Roberto Guerra

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 2/29
CONVERSA INICIAL
Computadores são dispositivos eletrônicos criados para auxiliar nas tarefas do cotidiano das
pessoas. São máquinas incríveis, com grande poder de processamento e capacidade de
armazenamento. Os denominados sistemas de computação são compostos basicamente pelo
hardware (dispositivos físicos) e software (tarefas e rotinas previamente programadas) de forma
dependente, ou seja, só funcionam juntos, sendo praticamente inúteis sozinhos.
Essa interdependência é inicialmente comprovada pela necessidade de gerenciar os
componentes do hardware para funcionar corretamente, pois, quando ligados, os circuitos
eletrônicos ficam disponíveis para receber instruções ou tarefas, mas, se não forem enviadas,
tornam-se apenas uma peça decorativa.
Os sistemas computacionais eram a princípio grandes mainframes ou desktops, mas
atualmente, com o advento da internet das coisas (internet of things – IoT), eles estão presentes em
quase todos os dispositivos que utilizamos, como smartphones, tablets, smartwatches, smartTVs,
consoles de jogos, entre outros. Mesmo tão presentes no cotidiano das pessoas, poucos sabem
que, para que todos esses equipamentos nos auxiliem nas tarefas a que se propõem, são
necessárias rotinas de gestão e controle, implementadas em software e denominadas sistemas
operacionais.
Eles são responsáveis pela inicialização do hardware pelo kernel, e também pelo controle e
gestão segura dos dispositivos, dos processadores (CPU), das memórias e da entrada e saída de
dados. Também é responsável pela gestão e pelo controle do armazenamento e do uso de arquivos,
escalonamento de tarefas e gerenciamento de processos e recursos. Em síntese, é um grande
gestor das atividades do computador que interage com o usuário.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 3/29
É importante conhecer e entender essas tarefas de gestão e seus conceitos relacionados para
compreendermos o que é necessário para escolher, instalar, configurar e administrar sistemas
operacionais, desde a inicialização até a utilização pelo usuário final.
Nesta disciplina, além de desenvolver as competências necessárias para essas atividades,
apresentaremos e definiremos diversas outras rotinas. O conteúdo previsto contempla inicialmente
os conceitos e as definições de sistema operacional, numa visão geral, com um breve histórico e
evolução, apresentando seus objetivos e funções. Também apresentaremos sua classificação pela
arquitetura e pelos tipos e exemplos de sistemas operacionais.
Seguindo a definição de gestão apresentada, nesta disciplina veremos a gerência:
De processador e de processos;
De memória;
De dispositivos de entrada e saída;
De arquivos;
De proteção de usuários.
E os temas desta aula são:
1. Conceitos e definições de sistema operacional – visão geral;
2. Histórico e evolução;
3. Objetivos e funções;
4. Arquitetura e classificação;
5. Tipos e exemplos.
Aproveite o conteúdo e bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES INICIAIS – VISÃO GERAL
Segundo Tanenbaum e Bos (2016), sistema operacional é um programa que, do ponto de
vista do programador, acrescenta uma variedade de novas instruções e características acima e além
do que o nível ISA fornece. Normalmente, o sistema operacional é implementado, em grande parte,
em software, mas não há nenhuma razão teórica para não ser colocado em hardware, como
acontece com os microprogramas (quando estão presentes). Para abreviar, chamamos o nível que

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 4/29
ele implementa de operating system machine (OSM), ou seja, “nível de máquina de sistema
operacional”.
Stallings (2017) define sistema operacional como um programa que gerencia os recursos do
computador, fornece serviços para os programadores e estabelece uma ordem de execução de
outros programas. É essencial certo conhecimento sobre sistemas operacionais para entender os
mecanismos pelos quais a CPU controla o computador – em particular, o efeito das interrupções e
o gerenciamento da hierarquia de memória.

Sistema operacional é o software que controla a execução de programas num processador e
gerencia os recursos do computador. Diversas funções desempenhadas pelo sistema
operacional, incluindo as duas mais relevantes para estudar a arquitetura e organização de
computadores – escalonamento de processos e gerenciamento de memória –, só podem ser
executadas de modo rápido e eficiente se ele dispuser de um suporte adequado do hardware do
processador.

Quase todos os processadores dispõem desse suporte, em maior ou menor extensão, incluindo
hardware de gerenciamento de memória virtual e de gerenciamento de processos. Isso inclui
registradores de propósito especial e áreas de armazenamento temporário, além de um conjunto de
circuitos para tarefas básicas de gerenciamento de recursos.
assim, um sistema de computação é constituído basicamente de dois elementos
interdependentes: o hardware e o software. O primeiro é basicamente composto de circuitos
eletrônicos internos: CPU (processador), memórias (primárias e secundárias), portas de
comunicação (entrada/saída), entre outros, como os periféricos externos (teclado, mouse, monitor,
câmera, microfone, dispositivos USB etc.). O segundo, por sua vez, é composto basicamente de
duas categorias:
1. Software de aplicação, representado por programas destinados ao usuário do sistema, que
constitui a razão final de seu uso (exemplo: editores de texto, multimídia players, editores de
imagem, jogos etc.);
2. Software de sistema, que está entre os aplicativos e o hardware. Trata-se de uma camada de
software multifacetada e complexa, denominada genericamente de sistema operacional, como
ilustra a Figura 1.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 5/29

Figura 1 – Sistema operacional

Fonte: I000S_Pixels; Hani Suwaryo; Crystal Eye Studio; Marisha; Den Rozhnovsky; Weera.OTP; DND_Project;

Nerthuz/Shutterstock.

A Figura 1 apresenta o sistema operacional como uma fronteira, uma interface entre o hardware
e os aplicativos. É ele que gerencia e orienta a fantástica transformação de pulsos elétricos do
hardware (representados pelos binários 0 e 1) nas mais diversas aplicações.
São essenciais para o funcionamento de todos os sistemas de computação, desde os
smartphones aos supercomputadores. Mesmo sendo muitos os sistemas operacionais existentes,
eles têm e seguem as mesmas regras e princípios. Devido à sua complexidade e ao seu tamanho, o
aprendizado de sistemas operacionais é tido como algo reservado a especialistas ou hackers,
contudo, é na verdade essencial para todos os profissionais de computação, pois as ferramentas
implementadas nos algoritmos dos sistemas operacionais afetam diretamente o comportamento e o
desempenho das aplicações. São também responsáveis pelos serviços de rede e pela segurança do
sistema e dos utilizadores.

TEMA 2 – HISTÓRIA E EVOLUÇÃO

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 6/29
A primeira geração de computadores – também chamada de Geração 0 – foi a geração dos
computadores mecânicos, acionados por engrenagens e manivelas, dependendo totalmente do
usuário – o operador do sistema. Todas as tarefas eram manuais, e ainda não havia recursos para
automatizá-las eletronicamente.
Descrever a história e a evolução dos sistemas operacionais e dos computadores é muito
conveniente pois, até a 3a geração dos computadores (1965-1980), descrita pelo cientista Robert
Noyce na integração de circuitos – o chip –, os computadores dependiam exclusivamente do
conhecimento e da habilidade de seus operadores – os usuários. Foi somente na 3a geração que os
sistemas operacionais iniciaram seu desenvolvimento, como descreveremos aqui.
Os computadores têm sua história descrita e apresentada em 6 gerações. As 3 primeiras são de
computadores sem sistemas operacionais. Eram as seguintes:
0. Mecânicos (1642-1945);
1. Válvulas (1945-1955);
2. Transistores (1955-1965).
As 3 gerações seguintes são as de computadores com sistemas operacionais:
3. Integração (1965-1980);
4. Muita integração (1980-?);
5. Computadores invisíveis (atualmente).

2.1 GERAÇÃO 0 (MECÂNICOS) (1642-1945): MÁQUINAS SEM SISTEMA
OPERACIONAL
Surgiram no século XVII e eram compostos exclusivamente de elementos mecânicos, com
grande rigidez nos programas a executar. Hoje são chamadas de máquina dedicadas. As Figuras 2,
3 e 4 ilustram alguns exemplos dessa geração:

Figura 2 – Calculadora de Pascal (1642)

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 7/29

Crédito: © CC-20/Edal Anton Lefterov.

Figura 3 – Máquina diferencial Babbage (1823)

Crédito: © CC-20/GFDL CC-BY-SA.

Figura 4 – Máquina Hollerith (1886)

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 8/29

Crédito: © CC-20/Adam Schuster.

A geração dos mecânicos tem como marco histórico a máquina de Turing.
Colossus: o primeiro computador, mas ainda considerado mecânico, foi criado em 1946 por
Allan Turing, semelhante a um autômato finito, com memória ilimitada e irrestrita. Era capaz de
fazer tudo que um computador real faz, entretanto não resolvia certos problemas. O modelo de
Turing usava uma fita infinita como memória, tendo uma cabeça de fita que podia se mover, ler e
escrever símbolos.
Inicialmente, a fita continha apenas a entrada, e todo o restante estava em branco. Para
armazenar informação, escrevia sobre a fita, e para ler informação escrita, movia a cabeça para a
posição em que a informação era escrita, continuando a computar até produzir uma saída. As saídas
“aceite” e “rejeite” eram obtidas entrando em estados designados de aceitação e rejeição. Se não
entrasse em estado de aceitação ou rejeição, continuava para sempre, sem parar.

2.2 GERAÇÃO 1 (VÁLVULAS) (1945-1955): COMPUTADORES ELETRÔNICOS,
AINDA SEM SISTEMA OPERACIONAL
Essa é a primeira geração de computadores modernos. As válvulas necessitavam de muito
tempo para aquecer e consumiam muita energia elétrica. Eram grandes, porém frágeis, sua
manutenção era cara, e sua programação, feita com a ligação de fios ou cartões. Seus circuitos
eram interligados por quilômetros de fios instalados manualmente, atingindo velocidades na ordem
de milissegundos (1/1.000).

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 9/29
John Mauchley (1907-1980) e Presper Eckert (1919-1995) construíram o Eniac em 1946, o 1o
computador eletrônico.

Figura 5 – Eniac

Crédito: Everett Historical/Shutterstock.

Ele tinha 18 mil válvulas e 1,5 mil relés, pesava 30 toneladas e tinha 20 registradores.
Consumia 140 quilowatts, e sua programação era feita em 6 mil chaves (Figura 6).

Figura 6 – Operação do Eniac

Crédito: © CC-20/U.S. Army Photo.

O matemático John von Neumann (1903-1957) foi colaborador do projeto Eniac, cujo
aperfeiçoamento foi o IAS, referência ao local onde foi desenvolvido – o Institute for Advanced
Studies, da universidade de Princeton. Credita-se a von Newmann a definição de uma arquitetura de
computadores com programa armazenado, utilizado até hoje. A Figura 7 ilustra essa definição:

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 10/29

Figura 7 – Arquitetura de von Neumann

Fonte: Guerra, 2020.

Ele é considerado o “pai” do computador, pois em sua arquitetura utiliza aritmética binária e a
organização em quatro unidades:
1. Memória;
2. Unidade aritmética e lógica;
3. Unidade de controle;
4. Parte de E/S.
A arquitetura de von Neumann apresenta computadores de programa armazenado,
armazenando dados e programas na memória, e com ciclo de instrução repetitivo, executando cada
instrução com base numa sequência de etapas programadas. As características básicas do IAS o
apresentam como fundamental no estudo de arquitetura de computadores. Suas especificações
continuam válidas até hoje e têm memória com mil posições, denominadas palavras, cada uma com
valor de 40 bits. Seu dados e suas instruções são representadas em binários e gravadas (memória);
21 instruções de 20 bits, com 2 campos de 8 bits (código de operação); e outro com 12 bits
(endereço) para localizar cada uma das mil palavras, com endereços de 000 a 999.

2.3 GERAÇÃO 2 – TRANSISTORES (1955-1965): OS PRIMEIROS PROJETOS
DE SISTEMA OPERACIONAL
John Bardeen (1908-1991), Walter Brattain (1902-1987) e William Shockley (1910-1989),
funcionários da AT&T, criaram o transistor. Com as mesmas funções das válvulas, mas com custo
menor, consumem menos energia, são mais rápidos e confiáveis, sendo utilizados até hoje.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 11/29
Nessa geração foram criados os barramentos, um conjunto de fios paralelos usados para
conectar os componentes de um computador. Trata-se de uma ruptura importante em relação à
arquitetura da máquina IAS, centrada na memória e, desde então, foi adotada pela maioria dos
computadores de pequeno porte.
Foi apenas em 1953 que se iniciou o desenvolvimento do primeiro sistema operacional – por
sua simplicidade, chamado de monitor –, desenvolvido pelos usuários do computador IBM 701, do
Centro de Pesquisas da General Motors, para tentar automatizar tarefas até então manuais.
Posteriormente, esse sistema seria reescrito para um computador IBM 704, pelo grupo de usuários
da IBM (Weizer, 1981).
Em 1961, o pesquisador Fernando Corbató, do Massachusetts Institute of Technology (MIT),
com seu grupo de pesquisa, anunciou o desenvolvimento do compatible time-sharing system
(CTSS), o primeiro sistema operacional com compartilhamento de tempo (Corbató; Daggett; Daley,
1962).

2.4 GERAÇÃO 3 – INTEGRAÇÃO (1965-1980): INÍCIO DOS SISTEMAS
OPERACIONAIS

Essa foi a geração das “famílias de computadores”: mesmo tipo de máquina, com diferentes
capacidades e preços. Tinham uma unidade de controle com microprogramação e
multiprogramação, e vários programas compartilhavam a memória e dividiam CPU.

Com alta capacidade de processamento, utilizavam 32 bits e instrução de 250 nanossegundos,
com memória de 16 Mbytes. Sua memória principal
era orientada a byte, com um conjunto de programas gerenciadores de recursos
de hardware – o sistema operacional.

Essa geração tornou-se muito importante pois, além do sistema operacional, integrou os
circuitos pelo chip. Em 1968, Robert Noyce e Gordon Moore fundaram a Intel Corporation, criadora
do chip de memória de 1 KB e da lei de Moore: a integração de transistores em circuito integrado
dobra a cada 24 meses, mantendo-se os custos.

Em 1965, a IBM lançou o OS/360, um sistema operacional avançado, com compartilhamento de
tempo e um excelente suporte a discos. No mesmo ano, um projeto conjunto entre MIT, General
Electric (GE) e Bell Labs definiu o multiplexed information and computing service (Multics), que por
décadas influenciou vários outros sistemas operacionais.

Em 1969, Ken Thompson e Dennis Ritchie, pesquisadores da Bell Labs, desenvolveram a
primeira versão do Unix.

2.5 GERAÇÃO 4 – MUITA INTEGRAÇÃO (1980-?): POPULARIZAÇÃO DOS
COMPUTADORES E DOS SISTEMAS OPERACIONAIS

Marcian Hoff Junior, engenheiro da Intel, criou o Intel 4004, um microprocessador de 4 bits e
108 KHz, que tinha 2.300 transistores, velocidade de 60 mil operações/s e preço inicial de US$ 200.
Desde 1980, a miniaturização dos componentes internos e os avanços se relacionaram à escala de
integração dos circuitos integrados. 

A partir daqui, os sistemas operacionais ganharam destaque e
tiveram sua importância reconhecida. É nessa geração que famosas empresas foram fundadas e
conceitos foram criados. Acompanhe.

O primeiro destaque é o lançamento do sistema operacional da empresa Microsoft, o MS-DOS,
em 1981. Três anos após, em 1984, a Apple lançou o Mac OS 1.0, desenvolvido para os
computadores da linha Macintosh, o primeiro sistema operacional a ter uma interface gráfica

incorporada ao sistema. No ano seguinte, a Microsoft lançou o aplicativo com interface gráfica MS-
Windows 1.0.

Em 1987, Andrew S. Tanenbaum, professor de computação e autor de vários best-sellers,
desenvolveu o Minix, um sistema operacional didático simplificado, baseado na API do Unix. No
mesmo ano, a IBM e a Microsoft apresentaram a primeira versão de um sistema multitarefa
destinado a substituir o MS-DOS e o Windows: o OS/2. A parceria foi rompida em seguida, e a IBM
deu sequência ao OS/2, enquanto a Microsoft investiu no Windows.

2.6 GERAÇÃO 5 (ATUAL): COMPUTADORES INVISÍVEIS
Tanenbaum e Bos (2016) definem nossa atual geração como a geração dos computadores
invisíveis. Foi dado esse nome porque antigamente se falava que, no futuro (que é hoje), os
computadores estariam por toda parte, embutidos nos mais diversos locais, executando inusitadas
funções, como abertura de portas, acendimento de luzes, enfim, escondidos nos componentes
(invisíveis).

Em 1991, um estudante de graduação em ciência da computação, Linus Torvalds (aluno de
Tanenbaum), utilizou o Minix como base para iniciar o desenvolvimento do Linux.

Figura 8 – Logotipo do Linux

Fonte: Rose Carson/Shutterstock.

A Microsoft só retornou em 1993, com o lançamento do Windows NT, o primeiro sistema 32 bits
da empresa. No mesmo ano, houve o lançamento dos Unix de código aberto – FreeBSD e NetBSD
–, e a Apple lançou o Newton OS, considerado o primeiro sistema operacional móvel, com gestão de
energia e suporte para tela de toque.
Nos anos seguintes, muitos novos sistemas operacionais surgiram. Listamos alguns a seguir:
1995: Windows 95;
1996: Windows NT 4.0; Mac OS 7.6 (first officially-named Mac OS);
1998: Windows 98; Novell NetWare 5;
2000: Windows Millennium Edition; Windows 2000;
2001: Windows XP; Mac OS X Cheetah (v. 10.0) – o novo SO da Apple, com arquitetura
distinta de suas versões anteriores, derivada da família Unix BSD;
2006: Windows Vista;
2007: iPhone OS 1 – lançamento do sistema operacional iOS, derivado do sistema operacional
Darwin;
2008: Android 1.0 – SO baseado em Linux para dispositivos móveis;

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 14/29
2009: Windows 7;
2011: Solaris 11 11/11;
2012: Windows 8; Windows Phone 8;
2013: Windows CE 8.0; BlackBerry 10;
2015: Windows 10;
2017: Windows 10 Mobile Fall Creators Update;
2018: Windows Server 2019; iOS 13.1 – iPadOS 13.1;
2019: macOS Catalina (v10.15);
2020: Linux 5.6; NetBSD 9.0; Android 11.
Apresentamos o registro histórico de apenas alguns destaques. Sugerimos que você consulte a
bibliografia para conhecer muitas outras datas e sistemas operacionais.

TEMA 3 – OBJETIVOS E FUNÇÕES
Agora veremos os objetivos básicos do sistema operacional, como ele é estruturado para
alcançá-los e quais desafios ele deve resolver.
Existe uma grande distância entre circuitos eletrônicos, dispositivos de hardware e os
programas aplicativos em software. Os circuitos são complexos, acessados por interfaces de baixo
nível (geralmente usando as portas de entrada/saída do processador), e muitas vezes suas
características e seu comportamento dependem da tecnologia usada em sua construção (Maziero,
2019).

Por exemplo, a forma de acessar dados em disco (HD ou SSD) via hardware de baixo nível
(Sata III) é muito diferente do acesso a dados semelhantes em cartão de memória ou leitores de
discos óticos (DVD ou blu-ray). Toda essa grande diversidade de hardware pode tornar-se uma
grande dificuldade para quem o utiliza (como desenvolvedores de aplicativo). Então é desejável que
todas essas características e diferenças tecnológicas sejam abstraídas e se tornem invisíveis aos
aplicativos e aos utilizadores do sistema computacional.

É aqui que entra em cena o sistema operacional. Trata-se de uma camada de software que
opera entre o hardware e os aplicativos, como vimos no Tema 1 e conforme a Figura 10. É um
software de estrutura ampla e complexa que incorpora aspectos de baixo nível (como drivers de
dispositivos e gerência de memória física) e de alto nível (como softwares utilitários e interface
gráfica).

Figura 10 – Estrutura típica de sistema operacional (Android)

Fonte: Guerra, 2020.

Stallings (2017) descreve que o sistema operacional é um programa que controla a execução
de aplicativos e age como interface entre o usuário e o hardware do computador. Tem
basicamente dois objetivos:
1. Conveniência: um sistema operacional visa tornar mais conveniente o uso do computador;
2. Eficiência: um sistema operacional permite uma utilização mais eficiente dos recursos do
sistema.
Os objetivos básicos de um sistema operacional, descritos por Maziero (2019), podem ser
sintetizados em duas palavras-chave: abstração e gerência. Vejamos em detalhes seus principais
aspectos.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 16/29
Abstração de recursos: acessar os recursos de hardware de um sistema de computação pode
ser uma tarefa complexa, devido às características específicas de cada dispositivo físico e à
complexidade de suas interfaces. Assim, o sistema operacional deve definir interfaces abstratas
para os recursos do hardware, visando atender os seguintes objetivos:
Prover interfaces de acesso mais simples que as de baixo nível, para simplificar a
construção de aplicativos. Por exemplo: para ler dados de um disco rígido, um programador
de aplicação usa o conceito de arquivo, que implementa uma visão abstrata do disco rígido,
acessível por operações como open, read e close. Se tivesse que acessar o disco diretamente,
seria necessário manipular portas de entrada/saída e registradores com comandos para o
controlador de disco (sem falar na dificuldade de localizar os dados desejados dentro do
disco);
Tornar os aplicativos independentes do hardware. Ao definir uma interface abstrata de
acesso a um dispositivo de hardware, o sistema operacional desacopla o hardware dos
aplicativos e permite que ambos evoluam de forma mais autônoma. Por exemplo, o código de
um editor de textos não deve depender da tecnologia de discos utilizada no sistema;
Definir interfaces de acesso homogêneas para dispositivos com tecnologias distintas.
Com suas abstrações, o sistema operacional permite aos aplicativos usar a mesma interface
para dispositivos diversos. Por exemplo, um aplicativo acessa dados em disco por meio de
arquivos e diretórios, sem precisar se preocupar com a estrutura real de armazenamento dos
dados, que podem estar num disquete, num disco Sata, numa máquina fotográfica digital
conectada à porta USB, num CD ou mesmo num disco remoto, compartilhado pela rede.
O hardware e o software usados para fornecer aplicações aos usuários podem ser vistos sob a
forma de uma organização hierárquica (ou em camadas), conforme a Figura 11.

Figura 11 – Camadas e visões de um sistema de computação

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 17/29

Fonte: Stallings, 2017.

O usuário final – que vai utilizar essas aplicações – geralmente não se interessa pela arquitetura
do computador nem pelos detalhes do hardware. Ele vê o sistema de computação como uma
aplicação, pois os aplicativos são a última camada entre o sistema e o usuário, trazendo assim a
interface entre eles.
Os softwares de aplicação (apps) são desenvolvidos numa linguagem de programação por um
analista/desenvolvedor. Se fossem escritos usando o conjunto de instruções do processador e, além
disso, tivessem também que controlar o hardware do computador, a tarefa de desenvolver
programas seria extremamente complexa, quase impossível.
Para facilitar essa tarefa, existe um conjunto de programas de sistema. Alguns desses
programas são conhecidos como utilitários, que implementam funções usadas frequentemente e
criam programas, gerenciam arquivos e controlam dispositivos de E/S. Um programador usa esses
recursos para desenvolver uma aplicação que, ao ser executada, invoca os utilitários para
desempenhar certas funções.
O software de sistema mais importante é o sistema operacional, que esconde os detalhes do
hardware do programador, fornecendo uma interface conveniente para o uso do sistema. Ele age
como um mediador, facilitando o acesso e o uso de aplicativos e serviços para o programador. O
sistema operacional tipicamente fornece serviços para as seguintes atividades, que descrevem
algumas de suas funções:
Criação de programas: o sistema operacional apresenta uma variedade de recursos e
serviços para auxiliar o programador a desenvolver programas, como editores e depuradores.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 18/29
Esses serviços tipicamente são oferecidos na forma de programas utilitários, que na verdade
não são parte do sistema operacional, mas podem ser acessados por ele;
Execução de programas: várias tarefas precisam ser cumpridas para um programa ser
executado. Instruções e dados devem ser carregados na memória principal. Dispositivos de
E/S e arquivos precisam ser inicializados, e outros recursos devem ser preparados. O sistema
operacional cumpre todas essas tarefas para o usuário;
Acesso a dispositivos de E/S: cada dispositivo de E/S tem seu próprio conjunto peculiar de
instruções ou sinais de controle para operação. O sistema operacional cuida dos detalhes do
uso de cada dispositivo, de modo que o programador possa pensar apenas em termos de
operações simples de leitura e de escrita;
Acesso controlado aos arquivos: no caso de arquivos, o controle deve incluir não apenas
um entendimento sobre a natureza do dispositivo de E/S (unidade de disco ou de fita), mas
também sobre o formato dos arquivos no meio de armazenamento. Mais uma vez, o sistema
operacional cuida dos detalhes. Além disso, no caso de sistemas usados simultaneamente por
vários usuários, ele fornece mecanismos de proteção para controlar o acesso aos arquivos;
Acesso ao sistema: no caso de sistemas compartilhados ou públicos, o sistema operacional
controla o acesso ao sistema como um todo e a recursos específicos também. A função de
acesso deve proteger o sistema contra o uso não autorizado, tanto para recursos quanto para
dados de usuários, e resolver conflitos em caso de contenção de um recurso;
Detecção e reação aos erros: diversos erros podem ocorrer durante a operação de um
sistema de computação, incluindo erros de hardware internos e externos, como erro de
memória e falha, ou mau funcionamento de dispositivo, além de vários erros de software, como
overflow em operação aritmética, tentativa de endereçar uma área de memória não permitida e
a impossibilidade de o sistema operacional atender à requisição de uma aplicação. Em cada
caso, o sistema operacional deve reagir no sentido de eliminar a condição de erro, com o
menor impacto possível sobre as aplicações em execução. Essa reação pode variar, desde
terminar a execução do programa que causou o erro até tentar executar novamente a
operação ou, simplesmente, relatar a ocorrência do erro à aplicação;
Monitoração: um bom sistema operacional mantém estatísticas de uso de vários recursos e
monitora parâmetros de desempenho, como o tempo de resposta. Em qualquer sistema, essa
informação é útil para antecipar a necessidade de futuros melhoramentos e para a sintonia do

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 19/29
sistema, aumentando seu desempenho. Num sistema multiusuário, essa informação também
pode ser usada para tarifação, pela utilização de recursos.

3.1 SISTEMA OPERACIONAL COMO GERENTE DE RECURSOS – UM
OBJETIVO E UMA FUNÇÃO
Os aplicativos utilizam o hardware para atingir seus objetivos e tarefas, como criar, editar e
imprimir documentos, tocar músicas, exibir vídeos e imagens, ler e armazenar arquivos de dados e
informações, conectar-se à internet, entre outros. Num sistema com várias atividades simultâneas
(multitarefas), podem ocorrer conflitos na utilização do hardware, quando duas ou mais tarefas
precisam dos mesmos recursos para ser executadas. Uma das funções do sistema operacional é
definir políticas para gerenciar o uso dos recursos de hardware pelos aplicativos e resolver eventuais
disputas e conflitos.
O sistema operacional é o responsável por gerenciar o uso desses recursos. Portanto, é o
sistema operacional que controla o processamento, o armazenamento e a transferência de dados,
pois, gerenciando os recursos do computador, o sistema detém o controle das suas funções básicas.
Esse controle é exercido de maneira curiosa. Normalmente, pensamos no mecanismo de
controle como algo externo ao que é controlado ou, pelo menos, como algo que é uma parte distinta
e separada do que é controlado (por exemplo, um sistema de aquecimento residencial é controlado
por um termostato, que é completamente distinto do sistema de geração de calor e do aparato de
distribuição de calor). Não é o caso do sistema operacional que, como mecanismo de controle, é
incomum em dois aspectos:
O sistema operacional é um software como outro qualquer, sendo executado pelo processador,
e o sistema operacional frequentemente renuncia ao controle do processador para, em seguida,
obter o controle novamente; nada mais é do que um programa de computador. Semelhante a outros
softwares, ele contém instruções para o processador; a diferença-chave está na intenção do
programa.
O sistema operacional direciona o processador no uso dos recursos do sistema, assim como na
execução de outros programas. Mas, para que o processador execute outros programas, ele deve
interromper a execução do sistema operacional. Dessa maneira, ele libera o controle ao

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 20/29
processador, para que ele possa executar algum trabalho “útil”, e então retoma o controle por tempo
suficiente para preparar o processador e executar uma próxima tarefa.
A Figura 12 apresenta os principais recursos gerenciados pelo sistema operacional:

Figura 12 – Camadas e visões de um sistema de computação

Fonte: Stallings, 2017.

Uma parte do sistema operacional reside na memória principal (RAM). Essa parte inclui o
núcleo (kernel), que contém as funções mais usadas pelo sistema operacional, além de outras
partes do sistema operacional em uso naquele momento. Outros dados e programas de usuário
ocupam o restante da memória principal (RAM). Então, a gestão da memória é feita com a alocação
controlada, em conjunto, pelo sistema operacional e pelo hardware de gerenciamento de memória
da CPU.
A gestão de recursos (dispositivos) de E/S é outra tarefa do sistema operacional, que decide
quando um dispositivo de E/S pode (ou não) ser usado pelo programa em execução, controlando o
acesso e o uso de arquivos.
A seguir, apresentamos exemplos de gestão de recursos do hardware.
A concorrência pela utilização do tempo de CPU (que futuramente estudaremos) é essencial
para que ocorra um grande número de tarefas pelo mesmo computador, que normalmente tem mais
tarefas a processar do que a quantidade de processadores disponíveis, complementando o conceito
de redução da ociosidade da CPU. O gerenciamento de recursos é fundamental para balancear sua
utilização, com distribuição justa entre os aplicativos e para que cada um deles seja executado na
velocidade adequada, cumprindo suas funções sem prejudicar as demais. No caso de um sistema
de computação com múltiplos processadores, essa decisão se estende a todos eles.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 21/29

Essa função é a gerência do processador – também conhecida como gerência de
processos, de tarefas ou de atividades –, que visa distribuir a capacidade de processamento de
forma justa entre as aplicações, evitando que uma aplicação monopolize esse recurso, respeitando,
assim, as prioridades definidas pelos usuários. 

O sistema operacional provê a ilusão de que existe
um processador independente para cada tarefa, o que facilita o trabalho dos programadores de
aplicações e permite construir sistemas mais interativos. Também faz parte da gerência de
atividades fornecer abstrações para sincronizar atividades interdependentes e prover formas de
comunicação entre elas.

O mesmo ocorre com a memória RAM, que também deve ser distribuída de forma justa entre as
aplicações. Aqui é descrita então a gerência de memória, cujo objetivo é fornecer a cada aplicação
uma área de memória própria, independente e isolada das demais aplicações, inclusive do sistema
operacional. 

O isolamento das áreas de memória das aplicações melhora a estabilidade e
segurança do sistema como um todo, pois impede aplicações com erros (ou aplicações maliciosas)
de interferir no funcionamento das demais aplicações. Além disso, caso a memória RAM existente
seja insuficiente para as aplicações, o sistema operacional pode aumentá-la de forma transparente
às aplicações, usando o espaço disponível num meio de armazenamento secundário (como um
disco rígido). 

Uma importante abstração construída pela gerência de memória (com o auxílio do
hardware) é a noção de memória virtual, que desvincula os endereços de memória vistos por cada
aplicação dos endereços acessados pelo processador na memória RAM. Com isso, uma aplicação
pode ser carregada em qualquer posição livre da memória, sem que seu programador se preocupe
com os endereços de memória em que ela irá executar.

A gerência de dispositivos, por sua vez, recebe destaque, pois cada periférico do computador
tem suas particularidades; assim, o procedimento de interação com uma placa de rede é
completamente diferente da interação com um disco rígido Sata. Todavia, existem muitos problemas
e abordagens em comum para o acesso aos periféricos. Por exemplo, é possível criar uma
abstração única para a maioria dos dispositivos de armazenamento, como cartão de memória, SSD,
CD-ROMs etc., na forma de um vetor de blocos de dados.

A função da gerência de dispositivos (também conhecida como gerência de entrada/saída) é
implementar a interação com cada dispositivo por meio de drivers e criar modelos abstratos que
permitam agrupar vários dispositivos similares sob a mesma interface de acesso. Outro recurso em
que o acesso deve ser mutuamente exclusivo (apenas um aplicativo por vez) é a impressão. O

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 22/29
sistema operacional resolve essa questão utilizando o recurso de spooling (que estudaremos
futuramente), além de definir uma fila de trabalhos a imprimir (print jobs), normalmente executados
de forma sequencial (first in, first out).
A gerência de arquivos é construída sobre a gerência de dispositivos e visa criar arquivos e
diretórios, definindo sua interface de acesso e as regras para seu uso. É importante observar que os
conceitos abstratos de arquivo e diretório são tão importantes e difundidos que muitos sistemas
operacionais costumam usá-los para permitir o acesso a recursos que nada têm a ver com
armazenamento. Exemplos disso são as conexões de rede (nos sistemas Unix e Windows, cada
socket TCP é visto como um descritor de arquivo, com o qual pode-se ler ou escrever dados) e as
informações internas do sistema operacional (como o diretório Proc do Unix).
A gerência de proteção de dados e usuários é outra importante tarefa de gestão de recursos.
Com computadores conectados em rede e compartilhados por vários usuários, é importante definir
claramente os recursos que cada usuário pode acessar, as formas de acesso permitidas (leitura,
escrita etc.), além de garantir que essas definições sejam cumpridas. Por exemplo, a proteção
contra os ataques de negação de serviço (denial of service – DoS ), comuns na internet. É
responsabilidade do sistema operacional do servidor detectar e impedir ataques como esses, em
que todos os recursos do sistema são monopolizados por um único usuário.
Para proteger os recursos do sistema contra acessos indevidos, é necessário:
Definir usuários e grupos de usuários;
Identificar os usuários que se conectam ao sistema por procedimentos de autenticação;
Definir e aplicar regras de controle de acesso aos recursos, relacionando todos os usuários,
recursos e formas de acesso, aplicando essas regras por procedimentos de autorização;
Registrar o uso dos recursos pelos usuários, para fins de auditoria e contabilização.
Assim, um sistema operacional visa abstrair o acesso e gerenciar os recursos de hardware,
provendo aos aplicativos um ambiente de execução abstrato, no qual o acesso aos recursos se faz
por interfaces simples, independentes das características e detalhes de baixo nível, minimizando os
conflitos no uso do hardware (Maziero, 2019).
As principais funções dos sistemas operacionais estão diretamente ligadas aos objetivos, pois,
para cumprir os objetivos de abstração e gerência, eles devem atuar em várias frentes. Cada um [1]

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 23/29
dos recursos do sistema tem suas particularidades, que impõem exigências específicas para
gerenciá-los e abstraí-los. Essas são as principais funcionalidades implementadas por um sistema
operacional típico.
Além dessas funcionalidades básicas oferecidas pela maioria dos sistemas operacionais, várias
outras se agregam aos sistemas modernos, para cobrir aspectos complementares, como a interface
gráfica, suporte de rede, fluxos multimídia, fontes de energia etc.
As funcionalidades do sistema operacional geralmente são interdependentes: por exemplo, a
gerência do processador depende de aspectos da gerência de memória, assim como a gerência de
memória depende da gerência de dispositivos e da gerência de proteção.

TEMA 4 – ARQUITETURA: CLASSIFICAÇÃO
É essencial conhecer as diferenças entre as arquiteturas dos sistemas operacionais para
escolher o mais adequado a cada situação. Algumas características básicas diferenciam os vários
tipos de sistemas operacionais, que
são classificados, segundo a arquitetura, quanto ao tempo de resposta e à entrada de dados
em sistema operacional, em lote (batch), interativos, tempo real e híbridos.
Essas características envolvem dois aspectos independentes. O primeiro especifica se o
sistema de computação é interativo ou é se um sistema de processamento em lotes (batch). Num
sistema interativo, o programador/usuário interage diretamente com o computador, normalmente
com um teclado e um monitor de vídeo, para requisitar a execução de tarefas (jobs) ou efetuar
transações. Além disso, ele pode, dependendo da natureza da aplicação, comunicar-se com o
computador durante a execução de uma tarefa.
Num sistema de processamento em lotes (batch), ocorre o oposto. O programa de um usuário é
agrupado com programas de outros usuários, e esse lote de programas é submetido à execução por
um operador de computador. Quando a execução do programa termina, os resultados são
impressos para ser entregues ao usuário. Hoje em dia são raros os sistemas que fazem
processamento exclusivamente em lotes, no entanto, é útil examiná-los brevemente para
entendermos melhor os sistemas operacionais atuais.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 24/29

O batch não exige interação com o usuário. A entrada de dados é feita por um dispositivo,
geralmente arquivos em disco, processamento de cálculos, compilações, ordenações e backups. Os
sistemas interativos – também conhecidos como sistemas de tempo compartilhado – geralmente
permitem a interação com usuário por meio de terminais, vídeo, teclado e mouse.

Com os sistemas de processamento em tempo real, o tempo de resposta é o fator principal do
sistema, utilizado em monitoramentos, controle de tráfego aéreo, de usinas nucleares etc. Os
sistemas híbridos são uma combinação de sistema batch com sistemas interativos.

Quanto à execução de tarefas, os sistemas operacionais são classificados como sistemas
monotarefa, multitarefa e multiprocessamento. Trata-se de outro aspecto independente, que
especifica se o sistema de computação emprega multiprogramação ou não.
A multiprogramação é uma tentativa de deixar o processador ocupado o maior tempo possível,
mantendo-o trabalhando em mais de um programa de cada vez. 

Diversos programas são simultaneamente carregados na memória, e o tempo do processador é 
dividido entre eles. 

A alternativa para esse tipo é um sistema de monoprogramação (uniprogramação), que executa
apenas um programa de cada vez. Os sistemas monotarefa executam uma única aplicação de cada vez;
já nos sistemas multitarefa várias tarefas concorrem pelos recursos de processamento. 

Os sistemas multiprocessados têm duas ou mais CPUs interligadas, trabalhando em conjunto e fortemente ou
fracamente acopladas.

Os sistemas com multiprocessadores fortemente acoplados têm duas ou mais CPUs, que
compartilham uma única memória e são controladas por um único sistema operacional.

Os fracamente acoplados têm duas ou mais CPUs, cada uma com sua memória, sendo controladas
por sistemas operacionais independentes.

Quanto à estrutura, os sistemas operacionais são classificados basicamente como monolíticos,
em camadas, máquinas virtuais e cliente servidor.

Os sistemas operacionais ainda são classificados como sistemas operacionais de
computadores de grande porte, servidores, computadores pessoais e sistemas operacionais
embarcados. Os embarcados são sistemas que controlam dispositivos móveis ou que não são
computadores, como micro-ondas, geladeiras, PDAs etc.

Os sistemas operacionais modernos se dividem em várias camadas, e cada uma prova
serviços à camada superior mais próxima, protegendo a camada mais inferior, o núcleo do sistema
(ou kernel) do sistema operacional.

Os recursos do kernel são acessados por chamadas de sistema (system calls) de forma
protegida para não danificar o sistema. As instruções que têm o poder de comprometer o sistema
são conhecidas como instruções privilegiadas (modo kernel), enquanto as instruções não
privilegiadas não oferecem perigo.

Chamadas de sistema são os comandos de acesso às funções do sistema operacional e podem
ser divididos em chamadas: para gerenciar processos, para sinalização, para gerenciar arquivos,
manipular diretórios, proteger e gerenciar o tempo.

TEMA 5 – TIPOS E EXEMPLOS

Já classificados e denominados, os sistemas operacionais passam então a dividir-se em grupos
especializados, sendo mais indicados a certas demandas e menos a outras. A seguir, apresentamos
alguns tipos de sistemas operacionais. Muitos se encaixam em mais de um deles. Vejamos:
Batch (de lote): os sistemas operacionais mais antigos trabalhavam “por lote”, ou seja, todos
os programas a executar eram colocados numa fila, com seus dados e demais informações
para a execução. O processador recebia os programas e os processava sem interagir com os
usuários, o que permitia um alto grau de utilização do sistema. Atualmente, esse conceito se
aplica a sistemas que processam tarefas sem interação direta com os usuários, como os
sistemas de processamento de transações bancárias. Além disso, o termo “em lote” também é
usado para designar um conjunto de comandos que deve ser executado em sequência, sem
interferência do usuário. Exemplos: os clássicos IBM OS/360 e o VAX/VMS, entre outros;
De rede: um sistema operacional de rede deve ter suporte à operação em rede, ou seja, a
capacidade de oferecer às aplicações locais recursos localizados em outros computadores
conectados à rede, como arquivos e impressoras. Ele também deve disponibilizar seus
recursos locais aos demais computadores de forma controlada. A maioria dos sistemas
operacionais atuais oferece esse tipo de funcionalidade, dispensando exemplos;
Distribuído: num sistema operacional distribuído, os recursos de cada computador estão
disponíveis a todos que estejam conectados à rede, de forma transparente aos usuários. Ao

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 26/29
lançar uma aplicação, o usuário interage com sua interface, mas não sabe onde está
executando ou armazenando seus arquivos: o sistema é quem decide, de forma transparente
ao usuário. Sistemas operacionais distribuídos já existem há muito tempo (como o Amoeba)
(Tanenbaum et al., 1991); recentemente, os ambientes de computação em nuvem têm
implementado esse conceito. Numa aplicação cloud (nuvem), o usuário interage com a
interface da aplicação num computador ou telefone, mas não tem uma visão clara das
máquinas em que seus dados estão sendo processados e armazenados. Exemplo: AWS
(Amazon Web Services) e Docker;

Multiusuário: um sistema operacional multiusuário deve suportar a identificação do “dono” de
cada recurso dentro do sistema (arquivos, processos, áreas de memória, conexões de rede) e
impor regras de controle de acesso para impedir o uso desses recursos por usuários não
autorizados. Essa funcionalidade é fundamental para a segurança dos sistemas operacionais
de rede e distribuídos. Grande parte dos sistemas atuais são multiusuários;

Servidor: um sistema operacional servidor deve permitir a gestão eficiente de muitos recursos
(disco, memória, processadores), impondo prioridades e limites sobre o uso dos recursos pelos
usuários e seus aplicativos. Normalmente um sistema operacional servidor também tem
suporte à rede e aos multiusuários. Exemplos: Windows Server 2019 e Oracle Linux Server;
Desktop: um sistema operacional “de mesa” é voltado ao atendimento do usuário doméstico
ou corporativo para atividades corriqueiras, como editar textos e gráficos, e reproduzir mídia.
Suas principais características são a interface gráfica, o suporte à interatividade e a operação
em rede. Exemplos de desktops: Windows 10, Linux e macOS X;
Móvel: um sistema operacional móvel é usado em equipamentos de uso pessoal compactos,
como smartphones e tablets. Nesse contexto, as principais prioridades são a gestão eficiente
da energia (bateria), a conectividade nos diversos tipos de rede (wi-fi, GSM, bluetooth, NFC
etc.) e a interação com uma grande variedade de sensores (GPS, giroscópio, luminosidade,
tela de toque, leitor de digitais etc.). Android e iOS são exemplos dessa categoria;
Embarcado: um sistema operacional é dito embarcado (embutido ou embedded) quando é
construído para operar sobre um hardware com poucos recursos de processamento,
armazenamento e energia. Aplicações típicas desse tipo de sistema aparecem em sistemas de
automação e controladores automotivos, equipamentos eletrônicos de uso doméstico (leitores
de DVD, TVs, micro-ondas, centrais de alarme etc.). Muitas vezes um sistema operacional
embarcado se apresenta na forma de uma biblioteca a ser ligada ao programa da aplicação

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 27/29
durante sua compilação. LynxOS, TinyOS, Contiki e VxWorks são exemplos de sistemas
operacionais embarcados;
Tempo real: são sistemas em que o tempo é essencial. Ao contrário da ideia usual, um
sistema operacional de tempo real não precisa ser necessariamente ultrarrápido; sua
característica essencial é ter um comportamento temporal previsível, ou seja, seu tempo de
resposta deve ser previsível no melhor e no pior caso de operação. A estrutura interna de um
sistema operacional de tempo real deve ser construída de forma a minimizar esperas e
latências imprevisíveis, como tempos de acesso a disco e sincronizações excessivas.
Exemplos de sistemas operacionais de tempo real incluem o QNX, RT-Linux e VxWorks.
Muitos sistemas embarcados têm características de tempo real, e vice-versa. Existem sistemas
de tempo real críticos (hard real-time systems), nos quais a perda de um prazo pelo sistema pode
perturbar seriamente o sistema físico sob seu controle, com graves consequências humanas,
econômicas ou ambientais. Exemplos desse tipo de sistema são o controle de funcionamento de
uma turbina de avião ou um freio ABS.
Por outro lado, nos sistemas de tempo real não críticos (soft real-time systems), a perda de um
prazo é perceptível e degrada o serviço prestado, sem maiores consequências. Exemplos desse tipo
de sistema são os softwares de reprodução de mídia: em caso de atrasos, podem ocorrer falhas na
música que está sendo tocada.

FINALIZANDO
Nesta aula apresentamos os conteúdos iniciais de sistemas operacionais. No Tema 1,
enfatizamos os conceitos e as definições por uma visão geral; no Tema 2, o histórico e a evolução
dos sistemas operacionais, utilizando uma linha do tempo em paralelo à história e à evolução dos
computadores, descritas em suas gerações, visualizando as gerações das máquinas e seus
sistemas operacionais em cada período da história.
No Tema 3, vimos os objetivos, funções e princípios fundamentais que estabelecem as
atividades desenvolvidas pelos sistemas operacionais. O destaque desse tema é o item 3.1, que
descreve o sistema operacional como gerente de recursos, seu principal objetivo e função, pois ele é
responsável por gerenciar o uso dos recursos computacionais. As principais atividades de gestão

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 28/29
foram descritas nesse tema e servirão como base para entendermos os temas das aulas seguintes,
quando estudarmos os processos (tarefas) de gestão.
Na sequência, definimos e apresentamos a classificação e a arquitetura dos sistemas
operacionais para, em seguida, finalizar o conteúdo introdutório com a apresentação de tipos e
exemplos atuais, permitindo o conhecimento suficiente para a escolha correta de sistemas
operacionais adequados às necessidades de cada situação do cotidiano, nos mais diversos
ambientes.
Enfim, compreender esses conceitos é o princípio para entender as atividades desenvolvidas
pelos sistemas computacionais. Assim, futuramente ampliaremos nosso conhecimento com os
conceitos das principais atividades de gerência feitas pelos sistemas operacionais, individualmente
apresentadas e descritas.

REFERÊNCIAS
ARPACI-DUSSEAU, R.; ARPACI-DUSSEAU, A. Operating systems: three easy pieces.
Madison: Arpaci-Dusseau Books, 2014.
CORBATÓ, F.; DAGGETT, M.; DALEY, R. An experimental time-sharing system. In:
PROCEEDINGS OF THE SPRING JOINT COMPUTER CONFERENCE, 1., New York. Anais... New
York: ACM, 1962.
MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas operacionais. 4. ed. Rio de Janeiro:
LTC, 2007.
MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: UFPR, 2019.
SILBERSCHATZ, A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.
SILBERSCHATZ, A.; GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro: Campus, 2016.
STALLINGS, W. Operating systems: internals and design principles. 9. ed. London: Pearson,
2017.

05/05/2022 22:49 UNINTER

https://univirtus.uninter.com/ava/web/roa/ 29/29
TANENBAUM, A. S.; BOS, H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.
TANENBAUM, A. S. et al. The Amoeba distributed operating system – a status report.
Computer Communications, v. 14, p. 324-335, jul. 1991.
TANENBAUM, A. S.; WOODHULL, A. S. Sistemas operacionais: projeto e implementação. 3.
ed. Porto Alegre: Bookman, 2008.
WEIZER, N. A history of operating systems. Datamation, [S.l.], p. 119-126, jan. 1981.

Formas de ataque virtual que utilizam diversas técnicas para forçar um servidor de rede a
dedicar seus recursos para atender um determinado usuário em detrimento dos demais. Por
exemplo, ao abrir milhares de conexões simultâneas num servidor de e-mail, um atacante pode
reservar para si todos os recursos do servidor (processos, conexões de rede, memória e
processador), fazendo com que os demais usuários não sejam mais atendidos.
-----------------------------------------------------------------------------------------------------------------------
uninter sistemas operacionais aula 2

05/05/2022 22:50  UNINTER

  SISTEMAS OPERACIONAIS

      AULA 2

            Prof. André Roberto Guerra

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 1 End-----------------------

05/05/2022 22:50                            UNINTER

CONVERSA INICIAL

      Seguindo os
 conteúdos previstos e a
 definição de gestão apresentada, nesta aula são
apresentados os
 conceitos e as técnicas das gerências de processos e do processador
subdivididos e descritos em cinco temas:

       Princípios de gestão de processos (concorrência).
       Tarefas (conceitos, gerência e ciclo).
       Processos (contextos e definições).
       Threads (definição e modelos/tipos).
       Gerência do processador (escalonamento).

      Aproveite e bons
estudos!

TEMA 1 – PRINCÍPIOS DE GESTÃO DE PROCESSOS

      Stallings (2017, p. 241, grifo
 nosso) define o sistema operacional como “um programa que
gerencia os recursos
 do computador, fornece serviços para os programadores e estabelece uma
ordem
 de execução de outros programas”. Ele (SO) é o software que controla
 a execução de
programas em um processador e gerencia os recursos do computador.

      Uma das funções desempenhadas
 pelo SO, considerada a mais relevante nesta aula, é o
escalonamento de
processos. Quase todos os processadores dispõem do suporte a esse recurso,
em maior ou menor extensão, incluindo hardware de gerenciamento de
 processos. Isso inclui
registradores de propósito especial e áreas de
armazenamento temporário, além de um conjunto de
circuitos para realizar
tarefas básicas de gerenciamento de recursos. (Tanenbaum; Woodhull, 2008)

https://univirtus.uninter.com/ava/web/roa/           2/24
-----------------------Page 2 End-----------------------

05/05/2022 22:50                                 UNINTER

Sistemas operacionais podem ser vistos como um conjunto de rotinas executadas de forma
concorrente e ordenada. A possibilidade de o processador executar instruções ao mesmo tempo
que outras operações, por exemplo operações de E/S, permite que diversas
tarefas sejam executadas concorrentemente pelo sistema (Siqueira,2020).

O conceito de concorrência é o princípio básico para o projeto e a implementação dos sistemas
multiprogramáveis.

Nos sistemas multiprogramáveis, vários programas podem estar residentes em
memória, concorrendo pela utilização do processador. Dessa forma, quando um programa
solicita uma operação de E/S, outros programas podem utilizar o processador (Siqueira,
2020).

O sistema operacional implementa diversos mecanismos de software e/ou de hardware para
possibilitar a concorrência entre programas. Um sistema de computação quase sempre tem mais
atividades a executar que o número de processadores disponíveis. Assim, é
necessário criar métodos para multiplexar o(s) processador(es) da máquina entre
as atividades presentes. Além disso, como as diferentes tarefas têm
necessidades distintas de processamento e nem sempre a capacidade de processamento existente
é suficiente para atender a todas, estratégias precisam
ser definidas para que cada tarefa receba uma quantidade de processamento que atenda
suas necessidades (Maziero, 2019).
 
Por outro lado, um processador convencional somente trata um fluxo de instruções de cada vez.

Até mesmo computadores com vários processadores, várias cores ou com tecnologia hyper-
threading, por exemplo, têm mais atividades a executar que o número de processadores
disponíveis (Maziero, 2019).

Como fazer para atender simultaneamente as múltiplas necessidades de processamento dos
usuários?

Uma solução ingênua para esse problema seria equipar o sistema com um processador para cada
tarefa, mas essa solução ainda é inviável econômica e tecnicamente. Outra solução seria
multiplexar o processador entre as várias tarefas que requerem processamento, ou seja,
compartilhar o uso do processador entre as várias tarefas, de forma a atendê-las da melhor
maneira possível.

Para uma gestão eficaz do processamento, é fundamental
compreender o conceito de tarefa. O próximo tema aborda o conceito de tarefa,
como estas são definidas, quais os seus estados possíveis e como/quando elas mudam
de estado. (Maziero, 2019, p. 40-41)

https://univirtus.uninter.com/ava/web/roa/                3/24
-----------------------Page 3 End-----------------------

05/05/2022 22:50                            UNINTER

TEMA 2 – TAREFAS (CONCEITOS, GERÊNCIA E CICLO)

Uma tarefa é definida por
(Maziero, 2019, p. 41) como sendo a

                            [...] execução de um fluxo sequencial de instruções,
 construído para atender uma finalidade
                            específica: realizar um cálculo
complexo, a edição de um gráfico, a formatação de um disco etc.
                            Assim, a
 execução de uma sequência de instruções em linguagem de máquina, normalmente
                            gerada pela compilação de um programa escrito em uma linguagem qualquer, é
 denominada
                            “tarefa” ou “atividade” (do inglês task).

Maziero (2019, p. 41, grifo do
original) ressalta as diferenças entre tarefa e programa:

                                    Programa é um conjunto de uma ou mais sequências de
 instruções escritas para resolver um
                                    problema específico, constituindo assim
 uma aplicação ou utilitário. O programa representa um
                                    conceito estático, sem um
 estado interno definido (que represente uma situação específica da
                                    execução) e
sem interações com outras entidades (o usuário ou outros programas).

                                    Tarefa é a execução sequencial, por um processador, da
sequência de instruções definidas em um
                                    programa para realizar seu objetivo.
 Trata-se de um conceito dinâmico, que possui um estado
                                    interno bem definido a
 cada instante (os valores das variáveis internas e a posição atual da
                                    execução
 evoluem com o tempo) e interage com outras entidades: o usuário, os
 dispositivos
                                    periféricos e/ou outras tarefas.

      Tarefas podem ser
 implementadas de várias formas, como processos ou threads, que serão
apresentados nos temas seguintes, confira!

Maziero (2019, p. 41)
apresenta que

                  Fazendo uma analogia simples, pode-se dizer que um programa é
o equivalente de uma “receita
                  de torta” dentro de um livro de receitas (um
 diretório) guardado em uma estante (um disco) na
                  cozinha (o computador). Essa
 receita de torta define os ingredientes necessários (entradas) e o
                  modo de
 preparo (programa) da torta (saída). Por sua vez, a ação de “executar” a
 receita,
                  providenciando os ingredientes e seguindo os passos definidos na
mesma, é a tarefa propriamente
                  dita.

                  [...]

                  A cada momento, a cozinheira (o processador) está seguindo um
 passo da receita (posição da
                  execução) e tem uma certa disposição dos
 ingredientes e utensílios em uso (as entradas e
                  variáveis internas da tarefa).

                  Assim como uma receita de torta pode definir várias
atividades interdependentes para elaborar a

                  torta (preparar a massa, fazer o
recheio, assar, decorar, etc.), um programa também pode definir

                  várias
sequências de execução interdependentes para atingir seus objetivos.

https://univirtus.uninter.com/ava/web/roa/                                                     4/24
-----------------------Page 4 End-----------------------

05/05/2022 22:50                            UNINTER

      Maziero (2019, p. 42) prossegue:

                                    Dessa forma, as tarefas definem as atividades a serem
 realizadas dentro do sistema de
                                    computação. Como geralmente há muito mais
tarefas a realizar que processadores disponíveis, e
                                    as tarefas não têm todas a
mesma importância, a gerência de tarefas tem uma grande importância
                                    dentro de
um sistema operacional.

Leitura complementar

Leia o capítulo 4.3, A gerência de tarefas, do livro indicado:

MAZIERO, C. Sistemas operacionais: conceitos e mecanismos. Curitiba: Ed. UFPR, 2019.

Os sistemas monotarefa foram:

Os primeiros sistemas de computação, nos anos 40, executavam
apenas uma tarefa de cada vez.
                            Nestes sistemas, cada programa binário era
carregado do disco para a memória e executado até
                            sua conclusão. Os dados de
entrada da tarefa eram carregados na memória junto à mesma e os
                            resultados
obtidos no processamento eram descarregados de volta no disco após a conclusão
da
                            tarefa. Todas as operações de transferência de código e dados entre o disco
 e a memória eram
                            coordenadas por um operador humano. Esses sistemas primitivos
 eram usados sobretudo para
                            aplicações de cálculo numérico, muitas vezes com
 fins militares (problemas de trigonometria,
                            balística, mecânica dos fluidos
etc.). (Maziero, 2019, p. 42-43)

Os sistemas multitarefas
surgiram logo em seguida, pois

Como a velocidade de processamento era muito maior que a
velocidade de comunicação com os
dispositivos de entrada e saída, o processador
ficava ocioso durante os períodos de transferência
de informação entre disco e
 memória.  Se a operação de entrada/saída envolvesse fitas
magnéticas, o
 processador podia ficar parado vários minutos, aguardando a transferência de
dados. O custo dos computadores e seu consumo de energia eram elevados demais
para deixá-
los ociosos por tanto tempo.

A solução encontrada para resolver esse problema foi permitir
ao monitor suspender a execução
da tarefa que espera dados externos e passar a
 executar outra tarefa. Mais tarde, quando os
dados de que a tarefa suspensa
necessita estiverem disponíveis, ela pode ser retomada no ponto
onde parou.
Para tal, é necessário ter mais memória (para poder carregar mais de um
programa
ao mesmo tempo) e criar mecanismos no monitor para suspender uma
 tarefa e retomá-la mais
tarde.

Uma forma simples de implementar a suspensão e retomada de
 tarefas de forma transparente
consiste no monitor fornecer um conjunto de
 rotinas padronizadas de entrada/saída à tarefas;
essas rotinas implementadas
pelo monitor recebem as solicitações de entrada/saída de dados das

https://univirtus.uninter.com/ava/web/roa/                                            5/24
-----------------------Page 5 End-----------------------

05/05/2022 22:50                                                                            UNINTER

                      tarefas e
 podem suspender uma execução quando for necessário, devolvendo o controle ao
                      monitor.

                      [...]

                      Essa evolução levou a sistemas mais produtivos (e complexos),
nos quais várias tarefas podiam
                      estar em andamento simultaneamente: uma ativa
 (executando) e as demais prontas (esperando
                      pelo processador) ou suspensas
(esperando dados ou eventos externos). (Maziero, 2019, p. 44)

O diagrama de estados básicos
das tarefas da Figura 1 ilustra o comportamento de uma tarefa:

                      Figura 1 – Diagrama de estados das tarefas

                                            Fonte: com base em Maziero, 2019.

2.1 CICLO DE VIDA DAS TAREFAS

      A estrutura do diagrama de ciclo
de vida das tarefas pode variar de acordo com a interpretação
dos autores. Por
exemplo, a forma trazida neste texto condiz com a apresentada em Silberschatz,
Gagne e Galvin (2018) e outros
autores.

      Por outro lado, o diagrama
 apresentado em Tanenbaum e Bos (2016) divide o
 estado
“suspenso” em dois subestados separados: bloqueado, quando a tarefa
 aguarda a ocorrência de
algum evento (tempo, entrada/saída etc.), e suspenso,
para tarefas bloqueadas que foram movidas
da memória RAM para a área de troca
 pelo mecanismo de paginação em disco. Todavia, tal
distinção de estados não faz
mais sentido nos sistemas operacionais atuais baseados em memória
paginada,
 pois neles os processos podem se executar mesmo estando somente parcialmente
carregados na memória.

O diagrama apresentado na Figura
2 é conhecido na literatura da área como diagrama de ciclo

de vida das tarefas.

https://univirtus.uninter.com/ava/web/roa/                                     6/24
-----------------------Page 6 End-----------------------

05/05/2022 22:50                                                               UNINTER

                  Figura 2 – Diagrama de ciclo de vida das tarefas

                                                     Fonte: com base em Maziero, 2019.

Os estados e as transições do
ciclo de vida têm o seguinte significado (Maziero, 2019):

                            Nova: A tarefa está sendo criada, seu código está sendo
 carregado em memória, junto com as
                            bibliotecas necessárias, e as estruturas de
dados do núcleo estão sendo atualizadas para permitir
                            sua execução.

                            Pronta: A tarefa está em memória, pronta para iniciar ou
 retomar sua execução, apenas
                            aguardando a disponibilidade do processador. Todas
as tarefas prontas são organizadas em uma
                            fila (fila de prontas, ready queue ou
 run queue), cuja ordem é determinada por algoritmos de
                            escalonamento, que são
apresentados e definidos no Tema 5 desta aula.

                            Executando: O processador está dedicado à tarefa, executando
suas instruções e fazendo avançar
                            seu estado.

                            Suspensa: A tarefa não pode executar porque depende de dados
externos ainda não disponíveis
                            (do disco ou da rede, por exemplo), aguarda
algum tipo de sincronização (o fim de outra tarefa ou
                            a liberação de algum
 recurso compartilhado) ou simplesmente espera o tempo passar (em uma
                            operação
sleeping, por exemplo).

                            Terminada: O processamento da tarefa foi encerrado e ela pode
 ser removida da memória do
                            sistema.

                            Tão importantes quanto os estados das tarefas apresentados na
Figura 2.2 são as transições entre
                            esses estados, que são explicadas a seguir:

                            → Nova: Esta transição ocorre quando uma nova tarefa é
 admitida no sistema e começa a ser
                            preparada para executar.

https://univirtus.uninter.com/ava/web/roa/                                              7/24
-----------------------Page 7 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  Nova → Pronta: ocorre quando a nova tarefa termina de ser
carregada em memória, juntamente
                  com suas bibliotecas e dados, estando pronta
para executar.

                  Pronta → Executando: esta transição ocorre quando a tarefa é
 escolhida pelo escalonador para
                  ser executada (ou para continuar sua execução),
dentre as demais tarefas prontas.

                  Executando → Pronta: esta transição ocorre quando se esgota a
fatia de tempo destinada à tarefa
                  (ou seja, o fim do quantum); como nesse
momento a tarefa não precisa de outros recursos além
                  do processador, ela volta
à fila de tarefas prontas até recebê-lo novamente.

                  Executando → Suspensa: caso a tarefa em execução solicite
acesso a um recurso não disponível,
                  como dados externos ou alguma
sincronização, ela abandona o processador e fica suspensa até o
                  recurso ficar
disponível.

                  Suspensa → Pronta: quando o recurso solicitado pela tarefa se
torna disponível, ela pode voltar a
                  executar, portanto volta ao estado de
 pronta para aguardar o processador (que pode estar
                  ocupado com outra tarefa).

                  Executando → Terminada: ocorre quando a tarefa encerra sua
 execução ou é abortada em
                  consequência de algum erro (acesso inválido à
 memória, instrução ilegal, divisão por zero, etc.).
                  Na maioria dos sistemas a
tarefa que deseja encerrar avisa o sistema operacional através de uma
                  chamada
de sistema (no Linux é usada a chamada exit).

                  Terminada → ·: Uma tarefa terminada é removida da memória e
 seus registros e estruturas de
                  controle no núcleo são liberados.

                  [...]

                  Nos sistemas operacionais de mercado é possível consultar o
estado das tarefas em execução no
                  sistema. Isso pode ser feito no Windows, por
 exemplo, através do utilitário “Gerenciador de
                  Tarefas” (Maziero, 2019, p. 47-48).

      Para Maziero (2019), tarefa é
a unidade básica de atividade dentro de um sistema operacional.
Tarefas podem
ser implementadas de várias formas, como processos, threads, transações
e jobs.

2.2 CONTEXTOS

De acordo com Maziero (2019,
p. 51),

                  [...] uma tarefa possui um estado interno bem definido, que
 representa sua situação atual: a
                  posição de código que ela está executando, os
 valores de suas variáveis e os recursos que ela
                  utiliza, por exemplo. Esse
estado se modifica conforme a execução da tarefa evolui. O estado de
                  uma tarefa
 em um determinado instante é denominado contexto. /Uma parte importante do
                  contexto de uma tarefa diz respeito ao estado interno do processador durante
sua execução, como

https://univirtus.uninter.com/ava/web/roa/  8/24
-----------------------Page 8 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  o valor do contador de programa (PC - Program Counter), do
 apontador de pilha (SP - Stack
                  Pointer) e demais registradores. Além do estado
interno do processador, o contexto de uma tarefa
                  também inclui informações
sobre os recursos usados por ela, como arquivos abertos, conexões de
                  rede e
semáforos.

A Figura 3 ilustra os
contextos do processo ou tarefa.

                  Figura 3 – Contextos de processo ou tarefa

                  Fonte: com base em Machado, 1997, citado por Maia, 2001.

Na mesma obra, Maziero (2019,
p. 51-52, grifo nosso) descreve que

                  A cada
tarefa presente no sistema é associado um descritor, ou seja, uma estrutura de
dados no
                  núcleo que representa essa tarefa. Nessa estrutura de dados são
 armazenadas as informações
                  relativas ao seu contexto e os demais dados
necessários à sua gerência, como prioridades, estado
                  etc. Essa estrutura de
 dados é geralmente chamada de TCB (Task Control Block) ou PCB
                  (Process Control Block).

                  Um TCB tipicamente
contém as seguintes informações:

                  identificador do processo (PID – Process Identifier);
                  estado do processo (novo, pronto, executando, suspenso, terminado);
                  informações de contexto do processador (valores dos registradores);
                  lista de áreas de memória usadas pelo processo;
                  listas de arquivos abertos, conexões de rede e outros recursos usados pelo processo
                  (exclusivos ou compartilhados com outras tarefas);

https://univirtus.uninter.com/ava/web/roa/                                  9/24
-----------------------Page 9 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                           informações de gerência e contabilização (prioridade, usuário proprietário, data de início,
                           tempo de processamento já decorrido, volume de dados lidos/escritos etc.).

                  Dentro do núcleo, os
descritores das tarefas são geralmente organizados em listas ou vetores de
                  TCBs. Por exemplo, normalmente há uma lista de tarefas prontas para executar,
 uma lista de
                  tarefas aguardando acesso ao disco rígido etc.

TEMA 3 – PROCESSOS (CONTEXTOS E DEFINIÇÕES)

Um processo pode ser entendido inicialmente como um programa
em execução, só que seu conceito é mais abrangente. Este conceito torna-se mais
claro quando pensamos de que forma os sistemas multiprogramáveis (multitarefa)
atendem os diversos usuários (tarefas) e mantêm informações a respeito dos
vários programas que estão sendo executados concorrentemente. (Machado, 1997,citado por Maia, 2001, p. 21)

Processo é definido pelos autores clássicos Silberschatz, Gagne e Galvin (2018) e Tanenbaum
e Bos (2016) como equivalente a tarefas, com seus respectivos recursos, como
arquivos abertos e canais de comunicação, em uma área de memória delimitada e
isolada das demais. Ou seja, um processo é definido como uma espécie de
"cápsula” isolada de execução, contendo uma tarefa e seus recursos. Essa visão é mantida.

      De fato, segundo Maziero (2019, p. 54),

                                    [...] os sistemas operacionais mais antigos, até meados dos
 anos 80, suportavam somente um
                                    fluxo de execução em cada processo. Assim, as
 unidades de execução (tarefa) e de recursos
                                    (processo) se confundiam. No
 entanto, quase todos os sistemas operacionais atuais suportam a
                                    existência de
mais de uma tarefa em cada processo. Hoje em dia, o processo deve ser visto
como
                                    uma unidade de contexto, ou seja, um contêiner de recursos utilizados por
 uma ou mais tarefas
                                    para sua execução, com áreas de memória (código, dados,
 pilha), informações de contexto e
                                    descritores de recursos do núcleo (arquivos
abertos, conexões de rede, etc.). Um processo pode
                                    então conter várias tarefas,
que compartilham esses recursos. Os processos são isolados entre si
                                    pelos
mecanismos de proteção providos pelo hardware (isolamento de áreas de memória,
níveis
                                    de operação e chamadas de sistema), impedindo que uma tarefa acesse um
recurso atribuído ao
                                    processo.

                                    Os sistemas operacionais atuais geralmente associam por
 default uma única tarefa a cada
                                    processo, o que corresponde à execução de um
programa sequencial (iniciado pela função main()
                                    de um programa em C, por
exemplo). Caso se deseje associar mais tarefas ao mesmo processo,
                                    cabe ao
 desenvolvedor escrever o código necessário para solicitar ao núcleo a criação
 dessas
                                    tarefas adicionais, usualmente sob a forma de threads, que são
apresentadas no próximo tema. O

https://univirtus.uninter.com/ava/web/roa/  10/24
-----------------------Page 10 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  núcleo do sistema operacional mantém descritores
 de processos, denominados PCBs (Process
                  Control Blocks), descritos no tema
anterior.

      Segundo Maziero (2019), um processo possui informações dos contextos
 de hardware, de
software e de endereçamento de
memória, como já ilustrado na Figura 3.

Definido por Maia (2001,
p. 22):

                            O contexto de hardware é fundamental para a implementação dos
 sistemas de tempo
                            compartilhado (time-sharing), onde os processos se revezam na
 utilização do processador,
                            podendo ser interrompidos e, posteriormente,
 restaurados como se nada tivesse acontecido. A
                            troca de um processo por outro
 na CPU, realizada pelo sistema operacional, é denominada
                            mudança de contexto
(context switching). A mudança de contexto consiste em salvar o conteúdo
                            dos
 registradores da CPU e carregá-los com os valores referentes ao do processo que
 esteja
                            ganhando a utilização do processador. Essa operação resume-se, então, em
substituir o contexto
                            de hardware de um processo pelo de outro.

Nos sistemas atuais, segundo Maziero
(2019, p. 53-54),

                            [...] a realização de uma troca de contexto, envolvendo a
interrupção da tarefa atual, o salvamento
                            de seu contexto e a reativação da
 próxima tarefa, é uma operação relativamente rápida (alguns
                            microssegundos,
 dependendo do hardware e do sistema operacional). A execução do
                            escalonador,
 entretanto, pode ser bem mais demorada, sobretudo se houverem muitas tarefas
                            prontas para executar. Por esta razão, muitos sistemas operacionais não
executam o escalonador
                            a cada troca de contexto, mas apenas periodicamente,
quando há necessidade de reordenar a fila
                            de tarefas prontas.

O contexto de software
é descrito por Maia (2001, p. 22) em sua dissertação e

                  [...] especifica características do processo que vão influir
 na execução de um programa, como o
                  número máximo de arquivos abertos
simultaneamente ou o tamanho do buffer para operações de
                  E/S. Essas
características são determinadas no momento da criação do processo, mas algumas
                  podem ser alteradas durante sua existência. O contexto de software define
 basicamente três
                  grupos de informações de um processo: sua identificação, suas
quotas e seus privilégios.

                  O espaço de endereçamento é a área de memória do processo
 onde um programa poderá ser
                  executado, além do espaço para os dados utilizados
 por ele. Cada processo possui seu próprio
                  espaço de endereçamento, que deve ser
protegido do acesso dos demais processos.

Os processos são
executados de forma cíclica alternando seu estado, como ilustra
a Figura 4:

https://univirtus.uninter.com/ava/web/roa/  11/24
-----------------------Page 11 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                                            Figura 4 – Estados do processo

                                            Fonte: com base em Maziero, 2019.

      Definido por Maia (2001),
 um processo está no estado de execução (running) quando
 está
sendo processado pela CPU. Estado de pronto (ready) ocorre
 quando apenas aguarda uma
oportunidade para executar, ou seja, espera que o
 sistema operacional aloque a CPU para sua
execução. Estado de espera (wait)
é quando aguarda algum evento externo ou algum recurso para
poder prosseguir
seu processamento.

3.1 PROBLEMAS DE COMUNICAÇÃO ENTRE PROCESSOS OU THREADS

A comunicação entre processos
é outro importante aspecto a ser considerado:

                                    Tarefas associadas ao mesmo processo podem trocar informações
facilmente, pois compartilham
                                    as mesmas áreas de memória. Todavia, isso não é
possível entre tarefas associadas a processos
                                    distintos. Para resolver esse
problema, o núcleo deve prover às aplicações chamadas de sistema
                                    que permitam a
 comunicação interprocessos (IPC – Inter-Process Communication). (Maziero,
                                    2019,
p. 57)

      Contudo, processos podem
 solicitar recursos, mesmo que estejam em posse de recursos
obtidos
 anteriormente. Caso estes recursos já estejam alocados em outros processos, o processo
solicitante deve aguardar pela liberação daquele. Essa é a condição natural do
sistema de alocação
de recursos, porém alguns problemas naturalmente podem
ocorrer. Neste caso, temos os problemas
de comunicação entre processos ou threads
(Oliveira, 2015).

      Condição de corrida: também
chamada de corriza de hazards, é uma das consequências da
sincronização
 incorreta. Essa condição gera a disputa de recursos do sistema por múltiplos
processos, ou threads, causando o corrompimento dos dados. Isso faz com
que parte desses dados
sejam modificadas por um processo/thread, e parte,
 por outro, ou seja, acontece quando dois ou
mais processos entram simultaneamente
na região crítica (Oliveira, 2015).

https://univirtus.uninter.com/ava/web/roa/                                                       12/24
-----------------------Page 12 End-----------------------

05/05/2022 22:50                                  UNINTER

Starvation: conhecido
também como livelock, acontece quando processos e/ou threads
 estão

em execução, mas nada acontece. Isso ocorre geralmente quando dois ou
mais processos/threads

então trabalhando com intenções contrarias, situação
em que o que é feito por um processo/thread é

desfeito pelo outro.
Também ocorre quando um processo/thread tenta o acesso a um recurso que

está sendo utilizado por outro processo/thread – o SO pede para que este
 aguarde sua liberação,

porém o processo/thread não está preparado para a
espera, ou seja, ele vai continuar solicitando o

recurso indefinidamente, mesmo
 que o recurso seja liberado, pois o processo/thread não foi

programado
para uma “rejeição” (Oliveira, 2015).

      Deadlock: é o
problema mais terrível e mais estudado em sistemas operacionais. Trata-se de
uma
situação em que dois ou mais processos/threads estão em estado
simultâneo de espera, cada
um aguardando que um dos demais libere um bloqueio
 para ele poder prosseguir, ou seja, um
conjunto de N processos está em deadlock
 quando cada um dos N processos está bloqueado à
espera de um recurso que
 somente pode ser liberado por um processo desse conjunto (Oliveira,
2015).

                  Figura 5 – Situação de impasse – deadlock

                                                             Créditos: Ilya kovshik/Shutterstock.

TEMA 4 – THREADS (DEFINIÇÃO E MODELOS/TIPOS)

      “Os primeiros sistemas
 operacionais suportavam uma única tarefa por processo” (Maziero,
2019, p. 58).
 Cada processo tem seu espaço de endereçamento individual e apenas um fluxo de
controle (thread). “À medida em que as aplicações se tornavam mais complexas,
essa limitação se
tornou bem inconveniente” (Maziero, 2019, p. 58), pois,
algumas vezes, desejamos ter vários fluxos
de controle (threads) no
mesmo espaço de endereçamento simulando uma execução em paralelo,

https://univirtus.uninter.com/ava/web/roa/                   13/24
-----------------------Page 13 End-----------------------

05/05/2022 22:50                            UNINTER

como se cada
 fluxo fosse visto realmente como um processo distinto (exceto pelo fato de

compartilharem um único espaço de endereçamento) (Oliveira,
2015).

                                    Por exemplo, um editor de textos geralmente executa tarefas
simultâneas de edição, formatação,
                                    paginação e verificação ortográfica sobre os
mesmos dados (o texto em edição). Da mesma forma,
                                    processos que implementam
 servidores de rede (de arquivos, bancos de dados etc.) devem
                                    gerenciar as
 conexões de vários usuários simultaneamente, que muitas vezes requisitam as
                                    mesmas informações. Essas demandas evidenciaram a necessidade de suportar mais
 de uma
                                    tarefa operando sobre os mesmos recursos, ou seja, dentro do mesmo
processo. (Maziero, 2019,
                                    p. 58)

      Thread é
 definida por Maziero (2019, p. 58) como “um fluxo de execução independente. Um
processo
 pode conter uma ou mais threads, cada uma executando seu próprio código
 e
compartilhando recursos com as demais threads localizadas no mesmo
 processo”. Alguns autores
usam também o termo processo leve (lightweigth
process) como sinônimo de thread.

                                    Cada thread é caracterizada por um código em execução e um
pequeno contexto local, o Thread
                                    Local Storage (TLS), composto pelos
 registradores do processador e uma área de pilha em
                                    memória, para que a thread
possa armazenar variáveis locais e efetuar chamadas de funções.

                                    Threads são também utilizadas para implementar fluxos de
 execução dentro do núcleo do SO,
                                    neste caso recebendo o nome de threads de
 núcleo (em oposição às threads dos processos,
                                    denominadas user threads).

                                    Além de representar as threads de usuário dentro do núcleo,
 as threads de núcleo também
                                    incluem atividades internas do núcleo, como rotinas
 de drivers de dispositivos ou tarefas de
                                    gerência. (MAZIERO, 2019, p. 58-59).

      Muitas threads podem
existir dentro de um único contexto de processo, cooperando entre si a
fim de
 realizar um dado cálculo e compartilhando o espaço de endereçamento e o
 restante do
contexto desse processo. (multithread).

      Um ambiente multithread
se utiliza dos mesmos mecanismos de concorrência entre processos,
interrupções,
 exceções e a comunicação entre processos (inter process comunication –
 IPC),
essenciais para permitir acesso concorrente a um recurso compartilhado (Oliveira, 2015).

4.1 MODELOS DE THREADS

As threads
 contidas nos processos, segundo Maziero (2019, p. 59), “definidas no espaço de

usuário, devem ser gerenciadas pelo núcleo do sistema operacional. Essa
gerência pode ser feita de

https://univirtus.uninter.com/ava/web/roa/                          14/24
-----------------------Page 14 End-----------------------

05/05/2022 22:50                            UNINTER

diversas formas, conforme os seguintes modelos de
implementação de threads”:

4.1.1 O modelo N:1

                  Os sistemas operacionais mais antigos suportavam apenas
processos sequenciais, com um único
                  fluxo de execução em cada um. Os
 desenvolvedores de aplicações contornaram esse problema
                  construindo bibliotecas
 para salvar, modificar e restaurar os registradores da CPU dentro do
                  processo,
 permitindo assim criar e gerenciar vários fluxos de execução (threads) dentro
 de cada
                  processo, sem a participação do núcleo.

                  Com essas bibliotecas, uma aplicação pode lançar várias threads
conforme sua necessidade, mas
                  o núcleo do sistema irá sempre perceber (e
 gerenciar) apenas um fluxo de execução dentro de
                  cada processo (ou seja, o
 núcleo irá manter apenas uma thread de núcleo por processo). Esta
                  forma de
implementação de threads é denominada Modelo de Threads N:1, pois N threads
dentro
                  de um processo são mapeadas em uma única thread no núcleo. Esse modelo
 também é
                  denominado fibers ou ainda green threads.

                  [...]

                  O modelo de threads N:1 é muito utilizado, por ser leve e de
fácil implementação. Como o núcleo
                  somente vê uma thread, a carga de gerência
 imposta ao núcleo é pequena e não depende do
                  número de threads dentro da
aplicação. Essa característica torna este modelo útil na construção
                  de
 aplicações que exijam muitos threads, como jogos ou simulações de grandes
 sistemas.
                  (Maziero, 2019, p. 59-60, grifo do original)

Por
outro lado, de acordo com Maziero, o modelo de threads N:1 apresenta
alguns problemas:

                    as operações de
 entrada/saída são realizadas pelo núcleo; se uma thread de usuário
                    solicitar a
 leitura do teclado, por exemplo, a thread de núcleo correspondente será
                    suspensa até a conclusão da operação, bloqueando todas as threads daquele
processo;
                    o núcleo do sistema
divide o tempo de processamento entre as threads de núcleo. Assim,
                    um processo
com 100 threads irá receber o mesmo tempo de processador que outro com
                    apenas
uma thread, ou seja, cada thread do primeiro processo irá receber 1/100 do
tempo
                    que recebe a thread única do outro processo;
                    threads do mesmo
 processo não podem executar em paralelo, mesmo se o computador
                    dispuser de
vários processadores ou cores, porque o núcleo somente escalona as threads
                    de
núcleo nos processadores. (2019, p. 60)

4.1.2 O modelo 1:1

Maziero
(2019, p. 60-61, grifo do original) descreve que:

                  A necessidade de suportar aplicações multithread levou os
 desenvolvedores de sistemas
                  operacionais a incorporar a gerência dos threads do
 processo no núcleo do sistema. Para cada

https://univirtus.uninter.com/ava/web/roa/                                    15/24
-----------------------Page 15 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  thread de usuário foi então associado
um thread correspondente dentro do núcleo, suprimindo com
                  isso a necessidade de
 bibliotecas de threads. Essa forma de implementação é denominada
                  Modelo de
Threads 1:1.  Este é o modelo mais frequente nos sistemas operacionais atuais,
como
                  o Windows NT e seus descendentes, além da maioria dos UNIXes.

                  [...]

                  O modelo 1:1 resolve vários problemas: caso uma thread de
 usuário solicite uma operação
                  bloqueante, somente sua thread de núcleo
correspondente será suspensa, sem afetar as demais
                  threads do processo. Além
disso, a distribuição de processamento entre as threads é mais justa e,
                  caso o
 hardware tenha mais de um processador, mais threads do mesmo processo podem
                  executar ao mesmo tempo, o que não era possível no N:1.

                  O modelo de threads 1:1 é adequado para a maioria das
 situações usuais e atende bem às
                  necessidades das aplicações interativas e
 servidores de rede. No entanto, é pouco escalável: a
                  criação de um número muito
grande de threads impõe uma carga elevada ao núcleo do sistema,
                  inviabilizando
 aplicações com muitas tarefas (como grandes servidores Web e simulações de
                  grande porte).

4.1.3 O modelo N:M

                  Para resolver o problema de escalabilidade da abordagem 1:1,
 alguns sistemas operacionais
                  implementam um modelo híbrido, que agrega
características dos modelos anteriores. Nesse novo
                  modelo, uma biblioteca
gerencia um conjunto de N threads de usuário (dentro do processo), que é
                  mapeado em M < N threads no núcleo.

                  O conjunto de threads de núcleo associadas a um processo,
denominado thread pool, geralmente
                  contém uma thread para cada thread de
 usuário bloqueada, mais uma thread para cada
                  processador disponível; esse
conjunto pode ser ajustado dinamicamente, conforme a necessidade
                  da aplicação. (Maziero,
2019, p. 61, grifo do original)

4.2 FERRAMENTAS PARA PROCESSOS E THREADS

      Algumas
tarefas específicas auxiliam o sistema operacional no controle e gestão dos
processos
e threads. Essas rotinas estão descritas a seguir:

       Região crítica: também chamada de seção
crítica. É a parte do sistema que permite acesso
       concorrente entre os
processos, por exemplo: spool de impressão, buffer de memória
etc.
       Exclusão mútua: é uma técnica usada em programação concorrente para evitar
que dois ou
       mais processos ou threads tenham acesso simultaneamente a um
 recurso compartilhado do
       sistema, ou seja, a uma região crítica.

https://univirtus.uninter.com/ava/web/roa/  16/24
-----------------------Page 16 End-----------------------

05/05/2022 22:50                            UNINTER

Sinais: são interrupções
 de software que notificam ao processo que um evento ocorreu. Os

sinais
 não permitem que processos especifiquem dados para trocar com outros processos.

São utilizados para sincronização entre processos e SO, ou seja, os sinais só
ocorrem entre

processos ou entre processos e o SO.

Trap: é o
 sinal que o processo envia para o SO solicitando um serviço protegido deste
 (por

exemplo, sua entrada em uma região crítica). Um trap bloqueia o
processo até que o serviço

requerido por este ao sistema operacional seja
realizado (Oliveira, 2015).

TEMA 5 – GERÊNCIA DO PROCESSADOR (ESCALONAMENTO)

      As tarefas de gestão do
 processor são descritas individualmente, e suas rotinas são
apresentadas neste último
 tema, complementando os temas anteriores, que descreveram a
concorrência, os
processos e as threads.

      A política de escalonamento de
um sistema operacional tem diversas funções básicas, como a
de manter o
 processador ocupado a maior parte do tempo, auxiliando o hardware no
 objetivo de
minimizar a ociosidade, balancear o uso da CPU entre processos,
 privilegiar a execução de
aplicações críticas, maximizar o throughput do
 sistema e oferecer tempos de resposta razoáveis
para usuários interativos (Oliveira, 2015).

      Essas funções são apresentadas
nesse tema e complementam uma das funções básicas dos
sistemas operacionais,
apresentada em aula anterior: o escalonamento de processos.

      Em ambientes que implementam
 apenas processos, o escalonamento é realizado com base
nos processos prontos
para execução. Em sistemas que implementam threads, o escalonamento é
realizado considerando os threads no estado de pronto (Machado; Maia, 2007), independentemente
do
processo.

      Justificando a utilização do
 nome escalonador, o termo é originário da tradução do termo
escalonador de
tarefas (task scheduler) e é um dos componentes mais importantes da
gerência de
tarefas, pois decide a ordem de execução das tarefas prontas. “O algoritmo
utilizado no escalonador
define o comportamento do sistema operacional, permitindo
 obter sistemas que tratem de forma
mais eficiente e rápida as tarefas a executar,
 que podem ter características diversas” (Maziero,
2019, p. 70).

https://univirtus.uninter.com/ava/web/roa/                                  17/24
-----------------------Page 17 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  Antes de se definir o algoritmo usado por um escalonador de tarefas,
é necessário ter em mente a
                  natureza das tarefas que o sistema irá executar.
 Existem vários critérios que definem o
                  comportamento de uma tarefa; uma primeira
 classificação possível diz respeito ao seu
                  comportamento temporal:

                  Tarefas de tempo real: exigem previsibilidade em seus
tempos de resposta aos eventos externos,
                  pois geralmente estão associadas ao
 controle de sistemas críticos, como processos industriais,
                  equipamentos médicos
etc.

                  Tarefas interativas: são tarefas que recebem eventos
externos (do usuário ou através da rede) e
                  devem respondê-los rapidamente,
 embora sem os requisitos de previsibilidade das tarefas de
                  tempo real. Esta
classe de tarefas inclui a maior parte das aplicações dos sistemas desktop e
dos
                  servidores.

                  Tarefas em lote (batch): são tarefas sem requisitos
 temporais explícitos, que normalmente
                  executam sem intervenção do usuário, como
 procedimentos de backup, varreduras de antivírus,
                  cálculos numéricos longos,
 tratamentos de grandes massas de dados em lote, renderização de
                  animações etc.

                  Além dessa classificação, as tarefas também podem ser
 classificadas de acordo com seu
                  comportamento no uso do processador:

                  Tarefas orientadas a processamento (CPU-bound tasks):
são tarefas que usam intensivamente
                  o processador na maior parte de sua
existência. Essas tarefas passam a maior parte do tempo nos
                  estados pronta ou
executando.

                  Tarefas orientadas a entrada/saída (I/O-bound tasks):
são tarefas que dependem muito mais dos
                  dispositivos de entrada/saída que do
 processador. Essas tarefas ficam boa parte de suas
                  existências no estado
suspenso, aguardando respostas às suas solicitações de leitura e/ou escrita
                  de
dados nos dispositivos de entrada/saída. (Maziero, 2019, p. 70-71, grifo do
original)

5.1 CRITÉRIOS DE ESCALONAMENTO

      Os objetivos e as metas de
 cada sistema operacional determinam quais são os principais
aspectos para a
implementação de uma política de escalonamento adequada. Os principais
critérios,
segundo Machado e Maia (2007), são:

       Utilização do processador: na maioria
 dos sistemas, é desejável que o processador
       permaneça a maior parte do tempo
ocupado (Oliveira, 2015).
       Throughput: representa o número de processos executados em um determinado intervalo de
       tempo (Oliveira, 2015).

https://univirtus.uninter.com/ava/web/roa/  18/24
-----------------------Page 18 End-----------------------

05/05/2022 22:50                            UNINTER

Tempo de processador /tempo de UCP: é o
 tempo que um processo leva no estado de

execução durante seu processamento (Machado;
Maia, 2007).

Tempo de espera: tempo total que um processo
 permanece na fila de pronto durante seu

processamento, aguardando para ser
executado (Oliveira, 2015).

Tempo de turnaround: é o
 tempo que um processo demora desde a sua criação até seu

término, levando em
consideração todo o tempo gasto em espera para alocação de memória,

espera na
fila de pronto, processamento na UCP e fila de espera, como nas operações de
E/S

(Machado; Maia, 2007). É uma medida típica de sistemas em lote, nos quais
não há interação

direta com os usuários do sistema. Não deve ser confundido com
o tempo de processamento

(Maziero, 2019).

Tempo de resposta: tempo decorrido entre uma
requisição ao sistema ou uma aplicação e o

instante em que a resposta é
 exibida. Essa medida de desempenho é típica de sistemas

interativos, como
 sistemas desktop e de tempo real, e depende sobretudo da rapidez no

tratamento das interrupções de hardware pelo núcleo e do valor do quantum
de tempo, para

permitir que as tarefas interativas cheguem mais rápido ao
 processador quando saem do

estado suspenso (Maziero, 2019).

5.2 TIPOS DE ESCALONAMENTOS

      As políticas de escalonamento
 de um sistema operacional podem ser classificadas em
preemptivo ou não
preemptivo (cooperativo):

      Preemptivos: são a
 possibilidade de o sistema operacional interromper um processo em
execução e
substituí-lo por um outro (Siqueira, 2020).
Nesses
 sistemas, uma tarefa pode perder o
processador caso termine seu quantum
de tempo, execute uma chamada de sistema ou ocorra uma
interrupção que acorde
 uma tarefa mais prioritária (que estava suspensa aguardando um evento)
(Machado;
 Maia, 2007). “A cada interrupção, exceção ou chamada de sistema, o escalonador
reavalia todas as tarefas da fila de prontas e decide se mantém ou substitui a
tarefa atualmente em
execução” (Maziero, 2019, p. 72).

      No escalonamento preemptivo, o
 sistema operacional pode interromper um processo em
execução e passá-lo para o estado
de pronto, com o objetivo de alocar outro processo na UCP.

                  Em um sistema preemptivo simples, normalmente as tarefas só
 são interrompidas quando o

                  processador está no modo usuário; a thread de núcleo
 correspondente a cada tarefa não sofre

https://univirtus.uninter.com/ava/web/roa/                      19/24
-----------------------Page 19 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  interrupções. Entretanto, os sistemas mais
 sofisticados implementam a preempção de tarefas
                  também no modo núcleo. Essa
 funcionalidade é importante para sistemas de tempo real, pois
                  permite que uma
 tarefa de alta prioridade chegue mais rapidamente ao processador quando for
                  reativada. (Maziero, 2019, p. 72)

      Não preemptivo (sem
interrupção ou cooperativos): este foi o primeiro tipo de escalonamento
implementado nos sistemas multiprogramáveis, em que predominava tipicamente o
processamento
bath (Oliveira, 2015).

      A tarefa em execução permanece
 no processador tanto quanto possível, só liberando-o caso
termine de executar,
solicite uma operação de entrada/saída ou libere explicitamente o processador,
voltando à fila de tarefas prontas. Esses sistemas são chamados de cooperativos
 por exigir a
cooperação das tarefas entre si na gestão do processador (Oliveira,
2015), para que todos possam
executar.

      First-in-first-out (FIFO): o processo
que chegar primeiro ao estado de pronto é o selecionado
para execução (Maziero,
2019).

      First-come, first served (FCFS): “A
 forma de escalonamento mais elementar consiste em
simplesmente atender as
tarefas em sequência, à medida em que elas se tornam prontas (ou seja,
conforme
 sua ordem de ingresso na fila de tarefas prontas) e tem como principal vantagem
 sua
simplicidade” (Maziero, 2019, p. 73).

      Round-robin (RR):
“A
adição da preempção por tempo ao escalonamento FCFS dá origem ao
algoritmo de
 escalonamento por revezamento, ou Round-Robin” (Maziero, 2019, p. 74). É
 menos
eficiente para a execução de tarefas em lote, entretanto, por distribuir
melhor o uso do processador
entre as tarefas ao longo do tempo, é melhor para
aplicações interativas. Deve-se observar que os
algoritmos de escalonamento
 FCFS e RR não consideram a importância das tarefas nem seu
comportamento em
relação ao uso dos recursos (Maziero, 2019).

      Shortest-job-first (SJF): seleciona
primeiro o processo de menor tempo de processador ainda
por executar. Menor
tarefa primeiro consiste em atribuir o processador à menor (mais curta) tarefa
da fila de tarefas prontas (Maziero, 2019).

Shortest remaining time first (SRTF):

https://univirtus.uninter.com/ava/web/roa/  20/24
-----------------------Page 20 End-----------------------

05/05/2022 22:50                                                                        UNINTER

                  O algoritmo SJF é cooperativo, ou seja, uma vez que uma
 tarefa recebe o processador, ela
                  executa até encerrar. Em uma variante
 preemptiva, o escalonador deve comparar a duração
                  prevista de cada nova tarefa
 que ingressa no sistema com o tempo de processamento restante
                  das demais
 tarefas presentes, inclusive aquela que está executando no momento. Caso a nova
                  tarefa tenha um tempo restante menor, ela recebe o processador. (Maziero, 2019,
p. 76)

      Escalonamento cooperativo: é uma
 implementação que busca aumentar o grau de
multiprogramação em políticas de
 escalonamentos que não possuam mecanismos de preempção.
Neste caso, um processo
 em execução pode voluntariamente liberar o processador para outro
processo
(Oliveira,
2015).

Escalonamento circular: é um escalonamento do tipo preemptivo, projetado especialmente
para sistemas de tempo compartilhado. Quando um processo passa para o estado de execução,
existe um tempo-limite para uso contínuo do processador denominado fatia de tempo (time
slice) ou quantum (Oliveira, 2015).

Escalonamento por prioridades: é um
escalonamento do tipo preemptivo realizado com base
em um valor associado a
 cada processo denominado prioridade de execução. O processo com
maior
prioridade no estado de pronto é sempre o escolhido para execução, e processos
com valores
iguais são escalonados seguindo critérios de FIFO (Machado;
Maia, 2007).

      Circular com prioridades: implementa
 o conceito de fatia de tempo e de prioridade de
execução associada a cada
processo (Oliveira, 2015).

      Escalonamento por múltiplas
filas: existem diversas filas de processos no estado de pronto,
cada qual com uma prioridade específica. Os processos são associados às filas
 em função de
características próprias, como importância para a aplicação, tipo
 de processamento ou área de
memória necessária (Oliveira, 2015).

      Escalonamento por múltiplas
filas com realimentação: é semelhante ao escalonamento por
múltiplas
filas, porém os processos podem trocar de filas durante seu processamento.
Possibilidade
de reorganizar os processos nas filas de acordo com o seu
comportamento (Machado; Maia, 2007).

FINALIZANDO

https://univirtus.uninter.com/ava/web/roa/  21/24
-----------------------Page 21 End-----------------------

05/05/2022 22:50                            UNINTER

Após a
apresentação das principais atividades de gestão em aula anterior, iniciamos o
estudo

da gestão avançada do sistema, na qual as rotinas (tarefas) de gestão de processos
e/ou tarefas e

do processador (escalonamento) foram individualmente
apresentadas e descritas.

      Foram apresentados e definidos
 os conceitos e as técnicas subdivididos em cinco temas. No
primeiro tema, uma
 introdução, com os princípios de gestão de processos, em uma explicação
sobre o conceito de concorrência, afinal o sistema operacional é o software
que controla a execução
de programas em um processador, gerencia os recursos do
computador e pode ser visto como um
conjunto de rotinas executadas de forma
concorrente e ordenada (Oliveira, 2015).

      No segundo tema, foi ampliado
o conceito, pois, para uma gestão eficaz do processamento, é
fundamental compreender o conceito de tarefa, definida por Maziero (2019)
como a execução de
um fluxo sequencial de instruções construído para atender
 uma finalidade específica denominada
“tarefa” ou “atividade” (do inglês task).

      Foi também apresentado o
conceito de tarefa, como são definidas, quais são os seus estados
possíveis e
 como/quando elas mudam de estado (Maziero, 2019), além do ciclo de vida e dos
contextos de hardware e software. Foram ressaltadas as diferenças
entre tarefa e programa.

      No
 tema seguinte, vimos os processos em seus contextos e
 definições. Processo pode ser
entendido inicialmente como um programa em
execução, só que seu conceito é mais abrangente e
define a forma como os sistemas
 multiprogramáveis (multitarefa) atendem os diversos usuários e
tarefas e mantêm
informações sobre vários programas em execução concorrente (Machado, 1997,
citado por Maia, 2001). É definido por autores clássicos, por exemplo Silberschatz
 (2018) e
Tanenbaum e Bos (2016), como equivalentes a tarefas, com seus recursos
 (arquivos abertos,
conexões de rede), em uma área de memória delimitada e
 isolada das demais, uma espécie de
“cápsula” isolada de execução, que contém uma
tarefa e seus recursos. Essa visão ainda é mantida.
Finalizamos o tema com a
apresentação dos problemas de comunicação entre os processos.

      Na
sequência, foram definidas e apresentadas as threads e seus modelos e/ou tipos. Devido à
necessidade
de suportar mais de uma tarefa em operação sobre os mesmos recursos, no mesmo
processo, a thread é definida como um fluxo de execução independente. Um
processo pode conter
uma ou mais threads, cada uma executando seu
próprio código e compartilhando recursos com as
demais threads
 localizadas no mesmo processo, também denominado processo leve (lightweigth
process). Ainda foram definidos os modelos das threads contidas nos
processos.

https://univirtus.uninter.com/ava/web/roa/                                      22/24
-----------------------Page 22 End-----------------------

05/05/2022 22:50                                           UNINTER

Em
seguida, finalizando o conteúdo da aula no último tema, a gerência do processador, com a

definição de escalonamento, termo
 originário da tradução de escalonador de tarefas (task

scheduler), é um
dos componentes mais importantes da gerência de tarefas, que decide a ordem de

execução das tarefas prontas (Maziero, 2019). Completando
as definições, foram apresentados os

critérios e os tipos de escalonamento.

      Nas
 aulas seguintes, os demais conceitos de gerência serão apresentados e
 definidos, não
perca!

REFERÊNCIAS

      MACHADO, F. B.; MAIA, P.
L. Arquitetura de sistemas operacionais. 4. ed. São Paulo: LTC,
2007.

      MAIA, L. P. SOsim:
simulador para o ensino de sistemas operacionais. 97. Dissertação (Mestre
em
 Ciências em Informática) – Universidade Federal do Rio de Janeiro, Rio de
 Janeiro, 2001.
Disponível em: <http://www.lapolli.pro.br/escolas/unicid/SistOpera/laboratorio/Tese.pdf>.
Acesso em:
9 set. 2020.

MAZIERO, C. Sistemas
operacionais: conceitos e mecanismos. Curitiba: Ed. UFPR, 2019.

      OLIVEIRA, C. A. Material
 de apoio Sistemas Operacionais. Disponível em: <http://univirtus.
uninter.com/ava/web/#/ava/roa/3083381/>
Acesso em: 5 jul. 2020.

      SILBERSCHATZ,
 A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New Jersey:
Wiley, 2018.

SIQUEIRA,
        F.                        de.  Sistemas  operacionais.  Disponível   em:

<https://sites.google.com/site/proffernandosiqueiraso/aulas>.
Acesso em: 9 set. 2020.

      STALLINGS,
 W. Operating systems: internals and design principles. 9. ed.
 [S.l.]: Pearson,
2017.

      TANENBAUM, A. S.; BOS,
H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.

https://univirtus.uninter.com/ava/web/roa/                                             23/24
-----------------------Page 23 End-----------------------

05/05/2022 22:50                            UNINTER

TANENBAUM, A. S.;
 WOODHULL; A. S. Sistemas operacionais, projeto e implementação.

3. ed.
Porto Alegre: Bookman, 2008.

      TEDESCO, K.
 Concorrência, paralelismo, processos, threads. Treinaweb. Disponível
 em:
<https://www.treinaweb.com.br/blog/concorrencia-paralelismo-processos-threads-programacao-
sincrona-e-assincrona>.
Acesso em: 9 set. 2020.

https://univirtus.uninter.com/ava/web/roa/           24/24
-----------------------Page 24 End-----------------------
----------------------------------------------------------------------------------------------------------
uninter sistemas operacionais aula 3

05/05/2022 22:52  UNINTER

                                                                          1/23
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        

   
   
  SISTEMAS OPERACIONAIS

      AULA 3
             
             
             
             
             
             
             
             
             
             
             
             
            Prof. André Roberto Guerra

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 1 End-----------------------

05/05/2022 22:52                            UNINTER

CONVERSA INICIAL

      Descritos anteriormente
 como “dispositivos eletrônicos criados para auxiliar nas tarefas do
cotidiano
 das pessoas”, os computadores são máquinas incríveis, com grande poder de
processamento e capacidade de armazenamento. São compostos basicamente pelo hardware
(dispositivos físicos) e software (tarefas e rotinas previamente
programadas) de forma dependente.
Sem memória de leitura/escrita de informações
pela CPU, não há computador digital com programa
armazenado.

      O hardware tem
como principais componentes a CPU, as memórias e os dispositivos de E/S, e
cada
um deles é individualmente gerenciado e controlado pelo sistema operacional. Apresentada
a
gerência de processos e do processador (CPU), agora apresentaremos a gerência
 de memória,
uma tarefa elementar que pode fazer toda a diferença na escolha
 do sistema operacional mais
adequado aos objetivos iniciais de conveniência e
eficiência.

      Enquanto a principal atividade
de gestão de processador e de processos é o escalonamento, na
gestão de memória
 é a alocação de memória, seguida pelas estratégias de paginação e
segmentação.
Contudo, de nada são válidas as explicações sobre as tarefas avançadas de
gestão
sem abordar os conceitos básicos. Então, vamos lá?

      O conteúdo desta aula contempla a definição de gestão (gerência) de memória e o
 seguinte
roteiro:

       Conceitos e definições – visão geral;
       Tipos e padrões de memória – classificação básica
       Alocação;
       Estratégias de paginação;
       Memória virtual.

https://univirtus.uninter.com/ava/web/roa/           2/23
-----------------------Page 2 End-----------------------

05/05/2022 22:52                            UNINTER

      Bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES – VISÃO GERAL

      Anteriormente definimos sistema
operacional como um programa que gerencia os recursos do
computador, em
particular, o gerenciamento da hierarquia de memória (Stallings, 2018). Trata-se
do
software que executa diversas funções, em especial: escalonamento de
 processos (já
apresentado) e gerenciamento de memória, que veremos a
partir de agora. Acompanhe!

      Para que as funções sejam executadas
de modo rápido e eficiente, é necessário que o sistema
operacional disponibilize
 o suporte adequado do hardware do processador. Quase todos os
processadores
 dispõem desse suporte, em maior ou menor extensão, incluindo hardware de
gerenciamento
 de memória virtual e de gerenciamento de processos, incluindo registradores de
propósito especial e áreas de armazenamento temporário, além de um conjunto de
 circuitos para
realizar tarefas básicas de gerenciamento de recursos.

      Fundamentais
 para qualquer sistema de computação, temos as memórias, em especial a
memória
 de usuário (random access memory – RAM), memória de acesso aleatório
 (aleatório no
sentido de que os processos podem acessar localizações de dados
 em qualquer ordem – Deitel;
Deitel; Choffnes, 2017)
ou memória principal.

      Memórias
 são recursos escassos e caros. Um desafio aos projetistas de sistemas é
desenvolver sistemas operacionais leves, que ocupem a menor quantidade de bytes
de memória e
simultaneamente otimizem os recursos computacionais. Num sistema
 multiprogramável, a
quantidade de memória disponível contribui diretamente para
 definir o número de processos que
podem ser alocados e consequentes à
capacidade de processamento do sistema computacional.

      Essa
etapa é responsabilidade da gerência de memória, que tem como meta manter
o maior
número de processos residentes na memória principal, permitindo
maximizar o compartilhamento do
processador e demais recursos computacionais,
auxiliando no combate à ociosidade da CPU.

      Tão
 relevante quanto quaisquer definições técnicas sobre as memórias, a gestão
 eficiente
desse precioso recurso é fundamental para o bom desempenho de
 qualquer sistema operacional.
Exemplo marcante no mercado é o popular Windows,
 que desde a sua primeira versão enfrenta
esse dilema. Por definição, todas as “janelas”
 fechadas permanecem como “em espera”, visando

https://univirtus.uninter.com/ava/web/roa/           3/23
-----------------------Page 3 End-----------------------

05/05/2022 22:52                            UNINTER

uma melhor performance, mas
 acabam obtendo o inverso, sendo necessária uma quantidade de

memória cada vez
maior. Uma solução bastante comum são softwares de terceiros que “limpam” os

arquivos dos processos já encerrados.

      Em
 outros sistemas operacionais, essa solução está incorporada (built-in),
 dispensando o
entendimento de temas mais complexos, atendendo objetivos básicos
da conveniência e eficiência,
comprovadas com a utilização de outro sistema
operacional no mesmo equipamento.

      No
 primeiro sistema operacional (Kali Linux 2020) são necessários menos de 512 MB
 de
memória RAM para o funcionamento inicial, enquanto no segundo sistema
operacional (Windows 10
1909) são necessários mais de 3 GB de memória RAM para
 as mesmas tarefas básicas. Esse
exemplo real (estudo de caso) aqui descrito
será apresentado futuramente.

      O gerenciamento
de memória é normalmente feito por software e por hardware de propósito
especial. O gerenciador de memória é definido por Deitel, Deitel e Choffnes (2017)
 como um
componente do sistema operacional responsável pelo esquema de
 organização da memória do
sistema, com as estratégias de gerenciamento de
 memória, determinando como o espaço de
memória disponível é alocado a processos
e como responder a mudanças na utilização da memória
de um processo.

      Ele também
interage com hardware de gerenciamento de memória de propósito específico (se
houver algum disponível) para melhorar o desempenho. Nesta aula e em aulas
 futuras,
descreveremos diversas estratégias de gerenciamento e organização de
memória.

      Deitel,
 Deitel e Choffnes (2017) complementam que cada estratégia de gerenciamento de
memória difere quanto ao modo como responde a certas perguntas:

Quando a estratégia recupera um novo programa e seus dados para colocá-los na memória?
A estratégia recupera o programa e seus dados quando o sistema os requisita
especificamente, ou ela tenta se antecipar às requisições do sistema?
Em que lugar da memória principal a estratégia posiciona o próximo programa a ser executado
e seus dados?
Ela minimiza o espaço desperdiçado (compactando programas e dados a mais que puder em
áreas disponíveis da memória) ou minimiza o tempo de execução (posicionando programas e
dados o mais rapidamente possível)?

https://univirtus.uninter.com/ava/web/roa/           4/23
-----------------------Page 4 End-----------------------

05/05/2022 22:52                            UNINTER

Se um novo programa ou novos dados devem ser colocados na memória principal (e se esta

estiver frequentemente cheia), a estratégia substitui quais programas ou dados que já estão na

memória?

Ela deve substituir os mais velhos, os usados com menos frequência ou os menos usados

recentemente?

      Há
 sistemas implementados que usam essas e outras estratégias de gerenciamento de
memória. Portanto, trata-se de uma importante função do sistema operacional,
 composta por
diversas rotinas e estratégias, e cada uma será descrita e
 analisada nos temas seguintes.
Acompanhe!

TEMA 2 – TIPOS E PADRÕES DE MEMÓRIA – CLASSIFICAÇÃO
BÁSICA

      Elementar para uma boa gestão é conhecer seus componentes.
 Neste tema, apresentaremos
os tipos e padrões das memórias, permitindo uma
classificação quanto às seguintes características:

       Capacidade de armazenamento (tamanho em bytes);
       Velocidade (taxa de transferência e tempo de acesso);
       Custo de armazenamento (e seu respectivo custo material/monetário);
       Consumo de energia e volatilidade (dependência da energia).

      Essa classificação é simples e
funcional, pois, quanto maior a capacidade de armazenamento,
menores seus
custos e velocidades (desempenho), e vice-versa. Veja a Figura 1:

Figura 1 – Hierarquia de memórias – uma classificação (o símbolo ≈ significa aproximadamente)

https://univirtus.uninter.com/ava/web/roa/           5/23
-----------------------Page 5 End-----------------------

05/05/2022 22:52                            UNINTER

       Memória volátil: é aquela em que se perde o conteúdo com a ausência de
 energia elétrica;
       são memórias rápidas e pequenas;
       Registradores: são usados geralmente para
endereçar a memória – são voláteis;
       Memória cache: o tamanho do barramento de
 endereços é igual ao tamanho da palavra.
       Oriunda do francês cacher, que
 significa esconder. Contém os dados e/ou instruções mais
       recentemente
referenciadas pelo processador.

Quando a CPU precisa de uma palavra de memória,
primeiro busca essa palavra no cache.
Somente no caso de ela não estar
armazenada lá é que a busca será na memória principal. 

Se uma parte substancial dos acessos for satisfeita pelo cache, o tempo médio de acesso a uma
palavra em memória será pequeno, próximo ao tempo de acesso à CPU. Na execução
de um programa de computador, muitas referências são feitas num pequeno
conjunto de posições de memória.

      Cache é um
 dispositivo interno a um sistema que serve de intermediário entre a CPU e o
dispositivo principal de armazenamento (memória principal). O acesso à memória
 principal pode
ser demorado, por isso vale a pena armazenar as informações mais
 procuradas num meio mais
rápido.

https://univirtus.uninter.com/ava/web/roa/           6/23
-----------------------Page 6 End-----------------------

05/05/2022 22:52                            UNINTER

Deitel, Deitel e Choffnes (2017) apresentam nas “Reflexões
 sobre sistemas operacionais,

caching” que os projetistas de sistemas
 devem equilibrar o custo e o desempenho de vários

dispositivos de armazenamento
para atender às necessidades dos usuários. Todos usamos caching

na vida
real.

      De modo geral, cache é um lugar para armazenar
 provisões que podem ser acessadas
rapidamente; esquilos armazenando bolotas
 (frutos do carvalho) enquanto se preparam para o
inverno é uma forma de caching.
Guardamos lápis, canetas, grampos, fitas e clipes nas gavetas da
mesa de
trabalho para poder ter acesso rápido a eles quando precisarmos (em vez de
buscá-los no
armário de suprimentos). Sistemas operacionais empregam muitas
 técnicas de caching, como
caching de dados e instruções para
acesso rápido em memórias cache de alta velocidade, e caching
de
 dados de discos na memória principal para acesso rápido enquanto um programa
 está em
execução.

      Projetistas de sistemas operacionais devem ser cuidadosos
 ao usar caching, porque num
sistema de computador os dados em cache
são uma cópia dos dados cujo original é mantido num
nível mais baixo da
 hierarquia da memória. A cópia em cache geralmente é aquela na qual as
mudanças são feitas em primeiro lugar; desse modo, rapidamente pode ficar fora
de sincronia com
os dados originais, causando inconsistência.

      Se um sistema falhar quando o cache contiver dados
atualizados, mas o original não, os dados
modificados poderão se perder.
 Portanto, sistemas operacionais frequentemente copiam os dados
em cache
 para o original – esse processo é denominado esvaziamento de cache.
 Sistemas de
arquivos distribuídos muitas vezes colocam o cache tanto no
servidor quanto no cliente, o que torna
ainda mais complexa a consistência do cache.

2.1 MEMÓRIA PRINCIPAL

      A memória principal armazena
 programas em execução e os dados utilizados por eles. É a
memória primária, que
também é volátil.

      A CPU processa instruções
obtidas da memória principal, e os resultados são retransmitidos a
ela. A
unidade básica de memória é o bit (binary digit – dígito
binário), uma abstração de valores 0
ou 1, pois fisicamente é mais fácil
 distinguir entre dois valores distintos do que de mais valores –
“tensão”, “corrente”.

https://univirtus.uninter.com/ava/web/roa/           7/23
-----------------------Page 7 End-----------------------

05/05/2022 22:52                            UNINTER

A
memória é formada por um conjunto de células (ou posições), cada uma das
quais podendo

guardar uma informação. Todas as células de uma dada memória têm
o mesmo número de bits, e os

números que identificam (referenciam) a
 posição da célula na memória são chamados de

endereços. A célula é a menor
 unidade endereçável da memória. Seus endereços são

indexadores, pelos quais
os programas podem referenciar dados na memória.

      Os
computadores modernos agrupam as células (ou bytes) em palavras (words).
Por exemplo:
uma palavra de 32 bits tem 4 bytes (ou 4 células). Nesses
computadores, a palavra é a parte mínima
de dados que podem ser transferidos
de/para a memória principal. A informação na palavra pode ser
um dado ou uma
instrução, portanto, “processadores de 32 bits” têm palavras e
registradores de 32
bits. O número de bits do barramento de
endereços em geral (mas não obrigatoriamente) é igual ao
número de bits
 dos registradores, e as instruções são (em geral) de 32 bits. Cada
 instrução deve
tratar palavras de 32 bits (movimentar, somar, subtrair
 etc.) como dados armazenados em
registradores de 32 bits.

      Outra
denominação da memória principal é a memória de acesso randômico (RAM).
A célula
pode ser acessada sem ter que percorrer os endereços anteriores. O
 tempo de acesso é
praticamente o mesmo para todas as células, e é memória volátil.
Recebe o nome randômico, pois
os processos podem acessar localizações de
dados em qualquer ordem; mas, em caso contrário, as
localizações de dados num
meio de armazenamento sequencial (por exemplo, fita) devem ser lidas
em
 sequência. Diferentemente de fitas e discos rígidos, as latências da memória
 para cada
endereço da memória principal são essencialmente iguais (Deitel; Deitel;
Choffnes, 2017).

2.2 MEMÓRIA SECUNDÁRIA

      Sua primeira
 característica é denominada memória não volátil, que retém o
 padrão de bits
original, mesmo que a energia seja desligada. É também chamada
 de memória endereçada
sequencialmente, na qual, para obter a informação
 de um endereço, é necessário percorrer os
endereços anteriores (por exemplo, fita
magnética).

      São
memórias não endereçadas diretamente, isto é, os dados são transmitidos
(enviados) para
a memória primária antes de a CPU executá-los. Esse é um procedimento
 necessário, devido à
volatilidade. Como dito, são não voláteis, o que permite
 guardar os dados permanentemente e,

https://univirtus.uninter.com/ava/web/roa/                                 8/23
-----------------------Page 8 End-----------------------

05/05/2022 22:52                            UNINTER

dessa forma, é possível executar programas
e ler arquivos contendo os dados quando o computador

for ligado novamente,
garantindo o armazenamento de dados a longo prazo.

      São
 diversos tipos e modelos de memórias secundárias, entre eles os discos rígidos
 (HDs)
convencionais e removíveis, memórias flash, discos de estado
 sólido (SSD), discos óticos, entre
outros. Sistemas operacionais modernos
utilizam a memória flash para expandir a memória principal
como memória
virtual, como veremos no Tema 5.

      As
memórias secundárias são responsáveis por armazenar dados e informações (data
storage),
e esse amplo conceito será definido e apresentado nas próximas
aulas.

TEMA 3 – ALOCAÇÃO

      Todos os softwares
do sistema de computação, desde o sistema operacional até os aplicativos,
dependem de memória disponível para serem executados. Neste tópico,
 apresentaremos a
sequência das tarefas de gestão das memórias, em especial a
 estratégia utilizada para evitar
conflitos entre aplicações e garantir espaço
para a execução, a alocação e os principais conceitos
relacionados.

      Utilizando os
 mecanismos de hardware de memória, o sistema operacional prevê espaços e
disponibiliza
 áreas de memória para os processos (ou para o próprio núcleo), conforme a
necessidade.
Segundo Maziero (2019), alocar memória
 significa reservar áreas de memória RAM
para serem usadas por um processo, por
um descritor de socket ou de arquivo no núcleo, por um
cache de blocos
 de disco, entre outros. Ao final de seu uso, cada área de memória alocada é
liberada (ou deveria ser) pela entidade que a solicitou e colocada à disposição
 do sistema para
novas alocações.

      O alocador de
 memória é o mecanismo responsável pela alocação e liberação de áreas de
memória. Em linhas gerais, o alocador reserva ou libera partes da memória RAM
de acordo com o
fluxo de solicitações que recebe (de processos ou do núcleo do
sistema operacional). Para isso, o
alocador deve manter um registro contínuo de
quais áreas estão sendo usadas e quais estão livres.
Para ser eficiente, deve fazer
alocações rapidamente e minimizar o desperdício de memória (Wilson
et al., 1995).

https://univirtus.uninter.com/ava/web/roa/                                9/23
-----------------------Page 9 End-----------------------

05/05/2022 22:52                            UNINTER

Considerando a
 atualização constante e a diversidade nos padrões de funcionamento, a

complexidade da tarefa de alocação torna necessária a separação dos alocadores
em:

Alocador de memória física: organiza a memória física do computador, alocando e liberando
grandes áreas de memória para carregar processos ou atender requisições do
núcleo;
Alocador de espaço de núcleo: o núcleo do sistema operacional continuamente cria e destrói
muitas estruturas de dados relativamente pequenas, como descritores de arquivos
abertos, de
processos, sockets de rede, pipes etc. O alocador de
 núcleo obtém áreas de memória do
alocador físico e as utiliza para alocar essas
estruturas no núcleo;
Alocador de espaço de usuário: um processo pode solicitar blocos de memória
 para
armazenar estruturas de dados dinâmicas, por meio de operações como malloc
 e free. O
alocador de memória do processo geralmente é implementado por bibliotecas
 providas pelo
sistema operacional, como a LibC. Essas bibliotecas interagem com
o núcleo para solicitar o
redimensionamento da seção Heap do processo quando
necessário (Maziero, 2019).

      Descrita por Maziero
 (2019), a estratégia de alocação básica traz que o problema básico de
alocação consiste
em manter uma grande área de memória primária (RAM) e atender a um fluxo de
requisições de alocação e liberação de partes dessa área para o sistema
 operacional e/ou as
aplicações. Essas requisições ocorrem o tempo todo, em
 função das atividades em execução no
sistema, e devem ser atendidas
rapidamente. Como resultado (efeito) das alocações e liberações, a
área de
memória inicialmente vazia se transforma numa sequência de áreas ocupadas (alocadas)
e
áreas livres, que evolui a cada nova requisição. Essas informações são geralmente
 mantidas em
uma ou mais listas duplamente encadeadas (ou árvores) de áreas de
memória.

3.1 ESTRATÉGIAS DE GERENCIAMENTO E ALOCAÇÃO DE MEMÓRIA

      Deitel, Deitel e Choffnes (2017) apresentam em paralelo as estratégias de alocação e
 de
gerenciamento de memória, projetadas para conseguir o melhor uso possível da
memória principal,
sendo divididas em: 1) de busca; 2) de posicionamento; e 3)
de substituição. Estratégias de busca
determinam quando transferir a
próxima porção de um programa ou dados para a memória principal
por meio do
armazenamento secundário. São divididas em dois tipos: 1) estratégias de busca
sob
demanda; e 2) estratégias de busca antecipada.

https://univirtus.uninter.com/ava/web/roa/                                          10/23
-----------------------Page 10 End-----------------------

05/05/2022 22:52                            UNINTER

Durante muitos
anos era comum empregar uma estratégia de busca sob demanda, com a qual

o
sistema posicionava a próxima porção do programa ou de dados na memória
principal quando um

programa em execução os referenciava. Projetistas
acreditavam que, como em geral não podemos

prever os trajetos de execução que
os programas tomarão, a sobrecarga envolvida em adivinhações

excederia em muito
 os benefícios. Atualmente, entretanto, muitos sistemas aumentaram seu

desempenho
 empregando estratégias de busca antecipada, que tentam carregar parte de um de

programa ou de dados na memória antes que sejam referenciados.

      Estratégias de posicionamento
determinam em que lugar da memória principal o sistema deve
colocar programas
ou dados que chegam. São consideradas as estratégias de posicionamento first-
fit
(o primeiro que couber), best-fit (o que melhor couber), worst-fit
(o que pior couber) e next-fit (o
próximo que couber).

      Quando a memória
 estiver muito cheia para acomodar um novo programa, o sistema deverá
remover
parte de um programa (ou ele todo) e dos dados que residem correntemente na
memória. A
estratégia de substituição do sistema determina que parte
 remover (Deitel; Deitel; Choffnes,
2017).
Vejamos alguns exemplos:

Alocação contígua simples: a memória principal é subdivida em duas áreas: uma para o
sistema operacional e outra para o programa do usuário;
Alocação particionada estática ou fixa: a memória era dividida em pedaços de
tamanho fixo,
chamados partições. O tamanho das partições estabelecido
 na inicialização do sistema era
definido em função do tamanho dos programas que
executariam no ambiente;

       Alocação fixa com código absoluto: os programas só podem ser executados em
       posições físicas dememória;
       Alocação fixa com código relocável: todas as referências a endereços no programa se
       relacionam ao início
 do código, e não a endereços físicos de memória. Nesse tipo de
       alocação, o
 principal problema é a fragmentação interna, os espaços que sobram nas
       partições ao alocar aplicações e o tamanho menor que a partição;
Alocação particionada dinâmica: as partições são criadas de acordo com o tamanho dos
programas
que serão executados, eliminando o problema da fragmentação interna. Cada vez
que surge um novo programa a ser executado, criam-se novas partições, e com
isso surge um
novo problema: a fragmentação externa (partições tão pequenas que
não são suficientes para
alocar os programas necessários).

https://univirtus.uninter.com/ava/web/roa/                      11/23
-----------------------Page 11 End-----------------------

05/05/2022 22:52                            UNINTER

As estratégias de alocação de memória surgiram para
 minimizar a fragmentação externa. Ao

longo da vida de um sistema, áreas de
memória são alocadas e liberadas continuamente. Com isso,

podem surgir áreas
 livres (“buracos” na memória) entre as áreas alocadas. Esse fenômeno se

chama fragmentação
externa, pois fragmenta a memória livre, fora das áreas alocadas.

      A fragmentação externa é muito
prejudicial, porque limita a capacidade de alocar a memória do
sistema. Além disso, quanto
 mais fragmentada a memória livre, maior o esforço necessário para
gerenciá-la,
 pois mais longas serão as listas encadeadas de área de memória livre. Pode-se
enfrentar o problema da fragmentação externa de duas formas: minimizando sua ocorrência,
 com
estratégias de alocação (desfragmentando periodicamente a memória do
sistema), ou permitindo a
fragmentação interna (Maziero, 2019).

      As estratégias de alocação
 são, em síntese, estratégias de posicionamento anteriormente
apresentadas. Vejamos:

First-fit (“o primeiro que se encaixa” ou “o primeiro que couber”): consiste em escolher a
primeira área livre que satisfaça o pedido de alocação. Sua vantagem é a
rapidez, sobretudo
se a lista de áreas livres for muito longa;
Best-fit (“o que melhor se encaixa” ou “o que melhor couber”): consiste em escolher a menor
área
possível que possa receber a alocação, minimizando o desperdício de memória.
Contudo,
algumas áreas livres podem ficar pequenas demais e, portanto, inúteis;
Worst-fit (“o que pior se encaixar” ou “o que pior couber”): consiste em escolher sempre a
maior
área livre possível, de forma que a “sobra” seja grande o suficiente para ser
usada em
outras alocações;
Next-fit (“o próximo que se encaixar” ou “o próximo que couber”): variante da estratégia first-fit
que percorre a lista de áreas com base na última área alocada ou liberada, para
que o uso das
áreas livres seja distribuído de forma mais homogênea no espaço
de memória.

      Diversas pesquisas
 demonstram que as abordagens mais eficientes são a best-fit e a first-fit,
sendo esta última bem mais rápida (Johnstone; Wilson,
 1999). Além dos alocadores de uso geral,
pode-se desenvolver alocadores
 customizados para aplicações específicas. Uma técnica muito
usada em sistemas
 de tempo real, por exemplo, é o memory pool (reserva de memória). Nessa
técnica, um conjunto de blocos de mesmo tamanho é pré-alocado, constituindo um pool.
A aplicação

https://univirtus.uninter.com/ava/web/roa/                                            12/23
-----------------------Page 12 End-----------------------

05/05/2022 22:52                            UNINTER

pode então obter e liberar blocos de memória desse pool com
rapidez, pois o alocador só precisa

registrar quais blocos estão livres ou
ocupados (Maziero, 2019).

TEMA 4 – ESTRATÉGIAS DE PAGINAÇÃO

      Apresentaremos
agora quais programas e dados podem ser divididos em pedaços de tamanho
fixo
 denominados páginas, que podem ser posicionadas em qualquer “moldura de página”
disponível. Nesses tipos de sistema, as estratégias de posicionamento são
 triviais e gerenciadas
com o auxílio de políticas de alocação e substituição de
páginas.

      A política de
 alocação de páginas determina quantos frames cada processo pode manter
 na
memória principal. São duas as estratégias utilizadas:

1. Alocação fixa: cada
 processo tem um número máximo de páginas que pode ser utilizado
   durante sua
execução;

2. Alocação variável: o número máximo
de páginas alocadas ao processo pode variar durante
   sua execução.

      Já a política de substituição
 de páginas consiste na atuação do sistema operacional na
substituição de páginas
 (page out e page in) quando o processo atinge o número máximo de
páginas alocadas. A estratégia working set tem o objetivo de reduzir o
 problema de thrashing
(sucessivos page faults e I/O de páginas) e
 erros de page faults (páginas não encontradas na
memória).

      A paginação de
memória, especialmente a paginação em disco, consiste em técnicas para que
um
 dispositivo de armazenamento secundário seja uma extensão da memória RAM, de
 forma
transparente para as aplicações. Partes ociosas da memória podem ser
 transferidas para alguma
memória secundária, liberando a memória RAM para
 outros usos. Caso algum processo tente
acessar esse conteúdo posteriormente,
 ele deverá ser trazido de volta à memória, e essa
transferência de dados entre memória
 principal e secundária é feita pelo sistema operacional, de
forma transparente
para os processos (Maziero, 2019).

      Existem diversas
técnicas para usar um espaço de armazenamento secundário como extensão
da
 memória RAM, com ou sem o auxílio do hardware. Entre elas, destacam-se a overlay,
 a
swapping e a paging.

https://univirtus.uninter.com/ava/web/roa/                        13/23
-----------------------Page 13 End-----------------------

05/05/2022 22:52                            UNINTER

4.1 OVERLAY

      A técnica de overlay
 divide a memória em área do sistema operacional, área do
 módulo
principal do programa do usuário e uma área de troca entre os módulos
secundários do programa do
usuário, denominada área de overlay.
 Essa organização em módulos é feita pelo desenvolvedor e
permite que eles sejam
carregados numa mesma região de memória em momentos distintos. Esses
módulos (overlays)
são gerenciados por uma biblioteca específica.

      Essa técnica
permite executar programas maiores que a quantidade de memória disponível, e
está
representada pela Figura 2:

                                            Figura 2 – Overlay

                  Fonte: elaborado com base em Machado; Maia, 2007.

4.2 SWAPPING

      Swapping é uma técnica aplicada à gerência de
 memória para programas que esperam por
memória livre para serem executadas. Nessa
 situação, o sistema escolhe um processo residente,
que é transferido da memória
 principal (RAM) para a memória secundária (swap out), geralmente

https://univirtus.uninter.com/ava/web/roa/                           14/23
-----------------------Page 14 End-----------------------

05/05/2022 22:52                            UNINTER

em
 disco, liberando a memória para executar outros processos. Caso esse processo seja

novamente executado (entrar na fila de prontos do escalonador), ele é novamente
 carregado na

memória principal (swap in).

      Essa é outra alternativa para
expandir a capacidade de processamento da máquina, pois alocar
um espaço em
disco para transferir arquivos da memória principal para a área de swapping
(e vice-
versa) também permite executar processos maiores que a quantidade de
memória principal (RAM)
disponível.

4.3 PAGING

      Já a técnica de paging consiste em mover
páginas individuais, conjuntos de páginas ou mesmo
segmentos da memória
principal para a secundária (page out). Se o processo tentar acessar alguma
dessas páginas mais tarde, é gerada uma interrupção de page fault (falta
de página), e o núcleo do
sistema operacional recarrega a página faltante na
 memória principal (page in). Essa é a técnica
mais utilizada nos
sistemas operacionais atuais, por sua flexibilidade, rapidez e eficiência.

4.4 ALGORITMOS DE SUBSTITUIÇÃO DE PÁGINAS

      Como a transferência de
páginas entre a memória principal e a secundária é feita pelo núcleo
do sistema
 operacional, é responsabilidade dele escolher quais páginas retirar da memória,
auxiliado por algoritmos de substituição de páginas. Assim, quando um processo
tentar acessar uma
página que está na memória secundária, o núcleo recebe um alerta
 e traz a página de volta à
memória para poder ser acessada. Para cada página
 transferida ao disco, a tabela de páginas do
processo é atualizada.

      Os algoritmos de substituição
 de páginas têm o objetivo de selecionar os frames com as
menores chances
de serem referenciados num futuro próximo. Com base no princípio da localidade,
a maioria dos algoritmos tenta prever o comportamento futuro das aplicações em
 função do
comportamento passado, avaliando o número de vezes que uma página foi
referenciada, quando foi
carregada para a memória principal e o intervalo de
tempo da última referência.

      Segundo Maziero (2019), vários
 critérios podem ser usados para escolher quais páginas
transferir da memória
RAM para o armazenamento secundário. Alguns deles são os seguintes:

https://univirtus.uninter.com/ava/web/roa/           15/23
-----------------------Page 15 End-----------------------

05/05/2022 22:52                                 UNINTER

Idade da página: tempo em que a página está na memória (páginas muito antigas talvez

sejam pouco usadas);

Frequência de acessos à página: páginas muito acessadas num passado recente

possivelmente ainda o serão num futuro próximo;

Data do último acesso: páginas há mais tempo
 sem acesso possivelmente serão pouco

acessadas num futuro próximo (sobretudo se
 os processos respeitarem o princípio da

localidade de referências);

Prioridade do processo proprietário: processos de alta prioridade, ou de tempo real, podem

precisar de suas páginas
 de memória rapidamente; se elas estiverem no disco, seu

desempenho ou tempo de
resposta poderão se prejudicar;

Conteúdo da página: páginas cujo conteúdo seja
código executável exigem menos esforço do

mecanismo de paginação, porque seu
conteúdo já está mapeado no disco (dentro do arquivo

executável correspondente
ao processo). Por outro lado, páginas de dados alteradas precisam

ser salvas na
área de troca;

Páginas especiais: páginas com buffers de operações de entrada/saída
 podem trazer

dificuldades ao núcleo caso não estejam na memória quando ocorrer
a transferência de dados

entre o processo e o dispositivo físico.

      O processo também pode
solicitar que certas páginas com informações sensíveis (como senhas
ou chaves
criptográficas) não sejam copiadas na área de troca, por motivos de segurança.

      A escolha correta das páginas a retirar da memória física é
um fator essencial para a eficiência
do mecanismo de paginação. Más escolhas
 poderão remover da memória páginas muito usadas,
aumentando a taxa de faltas de
página e diminuindo o desempenho do sistema. Veremos agora os
principais
algoritmos de substituição de páginas.

      O algoritmo Ótimo
seleciona para substituição uma página que não será mais referenciada no
futuro,
ou aquela que levará o maior intervalo de tempo para ser novamente utilizada.
Simplificando:
a melhor página a remover da memória num dado instante é a que
ficará mais tempo sem ser usada
pelos processos, mas, como o comportamento
 futuro dos processos não pode ser previsto com
precisão, esse algoritmo não é
implementável.

      No algoritmo Aleatório (Random)
 todas as páginas alocadas na memória principal têm a
mesma chance de serem
 selecionadas, inclusive os frames frequentemente referenciados, pois

https://univirtus.uninter.com/ava/web/roa/                16/23
-----------------------Page 16 End-----------------------

05/05/2022 22:52                            UNINTER

consiste
 em escolher aleatoriamente as páginas. Consome pouco recurso de memória, mas tem

baixa eficiência.

      O algoritmo de ordem First
 In, First Out (Fifo) seleciona para substituição a primeira página
utilizada (e que está há mais tempo na memória), e páginas mais antigas podem
ser removidas para
dar lugar a novas páginas. Esse algoritmo é muito simples de
 implementar, pois os números das
páginas recém-carregadas na memória são
registrados no final da lista, enquanto os números das
próximas páginas a substituir
 na memória estão no início da lista. No entanto, não oferece bons
resultados.
Seu principal defeito é considerar somente a idade da página, sem levar em
conta sua
importância. Páginas carregadas na memória há muito tempo podem ser frequentemente
acessadas.

      Para o algoritmo Least
 Frequently Used (LFU), a página que tiver o contador com o menor
número
 de referências será escolhida, ou seja, o algoritmo evita selecionar páginas
 bastante
utilizadas. O problema é que somente as páginas que estão há pouco
tempo na memória podem ser
selecionadas.

      O algoritmo Least
Recently Used (LRU) (menos usado recentemente) seleciona a página na
memória principal que está há mais tempo sem ser referenciada. É necessário que
 cada página
tenha associado a ela o momento do último acesso, que deve ser atualizado
a cada referência a um
frame. Quando for necessário substituir uma
página, o sistema fará a busca por um frame que esteja
há mais tempo sem
ser referenciado.

      Outra maneira de implementar o
 LRU é com uma lista encadeada, em que todas as páginas
estariam ordenadas pelo momento
 da última referência, partindo do pressuposto de que páginas
recentemente acessadas
no passado provavelmente serão acessadas num futuro próximo, evitando
removê-las
da memória, mas isso gera um elevado custo de implementação.

      O algoritmo Not Recently
 Used (NRU) (ou não usado recentemente) leva em conta o bit de
referência de cada página e o bit de modificação (dirty bit),
que indica se o conteúdo de uma página
foi modificado depois de ter sido
 carregada na memória. É bastante semelhante ao LRU, mas
menos sofisticado.

      Para implementar esse algoritmo,
 é necessário um bit adicional, conhecido como bit de
referência (BR), que indica se a página foi utilizada recentemente e
está presente em cada entrada

https://univirtus.uninter.com/ava/web/roa/           17/23
-----------------------Page 17 End-----------------------

05/05/2022 22:52                            UNINTER

da tabela de páginas. Quando uma página é
carregada para a memória principal, o bit de referência

é alterado pelo hardware,
indicando que a página foi referenciada (BR=1). Quando uma página for

substituída, o sistema seleciona um dos frames que não tenha sido utilizado
recentemente, ou seja,

com o bit de referência igual a zero.

      Há também o algoritmo Fifo com
 buffer de páginas, que combina uma lista de páginas
alocadas (LPA)
com uma lista de páginas livres (LPL). A LPA organiza todas as páginas que
estão
sendo utilizadas na memória principal, podendo ser implementada como uma
lista única para todos
os processos, ou uma lista individual para cada
processo. Independente da política utilizada, a LPA
organiza as páginas
alocadas há mais tempo na memória no início da lista, e as mais recentes no
final. Da mesma forma, a LPL organiza todos os frames livres da memória
 principal; as páginas
livres há mais tempo estão no início, as mais recentes,
no final.

      Sempre que um processo
necessita alocar uma nova página, o sistema utiliza a primeira página
da LPL,
colocando-a no final da LPA. Caso o processo tenha que liberar uma página, o
mecanismo
de substituição seleciona o frame em uso há mais tempo na
 memória, isto é, o primeiro da LPA,
colocando-o no final da LPL.

      É importante notar que a
 página selecionada e que entrou na LPL continua disponível na
memória principal
 por um determinado intervalo de tempo. Caso essa página seja novamente
referenciada e ainda não tenha sido alocada, basta retirá-la da LPL e devolvê-la
ao processo. Nesse
caso, a LPL funciona como um buffer de páginas,
 evitando o acesso à memória secundária. Por
outro lado, se a página não for mais
referenciada, com o passar do tempo chegará ao início da LPL,
quando será utilizada
 para outro processo. Caso a página seja posteriormente referenciada, o
sistema
terá que carregá-la novamente da memória secundária.

      O algoritmo Fifo circular
 utiliza como base o Fifo, porém as páginas alocadas na memória
estão numa
estrutura de lista circular, semelhante a um relógio. Esse algoritmo é
implementado com
pequenas variações na maioria dos sistemas Unix. Para
implementar o algoritmo, existe um ponteiro
que guarda a posição da página mais
 antiga na lista, e cada página tem associado um bit de
referência,
 indicando se ela foi recentemente referenciada. Quando é necessário substituir
 uma
página, o sistema verifica se o frame apontado tem o bit de
 referência desligado (BR=0). Nesse
caso, a página é selecionada para descarte
 pois, além de ser a mais antiga, não foi utilizada
recentemente. Por outro
 lado, se a página apontada tem o bit de referência ligado (BR=1), o bit
 é

https://univirtus.uninter.com/ava/web/roa/           18/23
-----------------------Page 18 End-----------------------

05/05/2022 22:52                            UNINTER

desligado e o ponteiro é incrementado, pois, apesar de ser a página mais
 antiga, foi utilizada

recentemente. O processo se repete até encontrar uma
página com bit de referência igual a zero.

      Nesse algoritmo, é possível que
todos os frames tenham o bit de referência ligado. Nesse caso,
o
ponteiro percorrerá toda a lista, desligando o bit de referência de cada
página. Ao final, a página
mais antiga é selecionada. O bit de
referência permite conceder a cada página uma segunda chance
antes de ser substituída.
É possível melhorar a eficiência do algoritmo utilizando o bit de
modificação
juntamente com o bit de referência, como apresentado no esquema
NRU.

TEMA 5 – MEMÓRIA VIRTUAL

A memória virtual é uma técnica sofisticada e poderosa de
gerência de memória, em que a memória principal e a secundária são combinadas,
dando ao usuário a ilusão de existir uma memória muito maior que a capacidade
real da memória principal.

O conceito de memória virtual fundamenta-se em não vincular o endereçamento feito pelo
programa dos endereços físicos da memória principal.

      Para ocultar a organização
 complexa da memória física e simplificar os procedimentos de
alocação da
memória aos processos, os sistemas de computação modernos implementam a noção
de memória virtual, na qual existem dois tipos de endereço de memória
distintos:

    1. Endereços físicos (ou reais): são os endereços
dos bytes de memória física do computador.
       Esses endereços são definidos
pela quantidade de memória disponível na máquina.

    2. Endereços lógicos (ou virtuais): são os endereços de memória usados pelos
 processos e
       pelo sistema operacional e, portanto, usados pelo processador
 durante a execução. Esses
       endereços são definidos de acordo com o espaço de
endereçamento do processador.

      Ao executar, os processos
“enxergam” somente a memória virtual. Assim, durante a execução
de um programa,
o processador gera endereços lógicos para acessar a memória, que devem então
ser traduzidos para os endereços físicos correspondentes na memória RAM em que
as informações
desejadas se encontram.

      Por questões de desempenho, a
 tradução de endereços lógicos em físicos é feita por um
componente específico do
hardware do computador, denominado unidade de gerência de memória

https://univirtus.uninter.com/ava/web/roa/           19/23
-----------------------Page 19 End-----------------------

05/05/2022 22:52                            UNINTER

(memory
 management unit – MMU). Na maioria dos processadores atuais, a MMU se
 encontra

integrada ao chip da própria CPU.

      A MMU intercepta os endereços
 lógicos emitidos pelo processador e os traduz para os
endereços físicos
 correspondentes na memória da máquina, permitindo seu acesso pelo
processador.
 Caso o acesso a determinado endereço lógico não seja possível (por não estar
associado a um endereço físico, por exemplo), a MMU gera uma interrupção de hardware
 para
notificar o processador sobre a tentativa de acesso indevido. O
comportamento da MMU e as regras
de tradução de endereços são configuradas pelo
núcleo do sistema operacional (Maziero, 2019).

      O mecanismo de tradução é essencial pois, sempre que o
 processo referenciar um endereço
virtual, a unidade de gerência de memória
 verifica pelo bit de validade se a página que contém o
endereço
 referenciado está ou não na memória principal. Caso a página não esteja na
 memória,
ocorre um page fault. Para corrigir o erro, o sistema deverá
 transferir a página da memória
secundária para a principal.

      Além de desacoplar os
 endereços lógicos dos endereços físicos e fazer a tradução entre
ambos, a noção
de memória virtual também permite implementar a proteção de memória do
núcleo
e dos processos entre si, fundamentais para a segurança e estabilidade
do sistema.

      Para implementar a proteção de
memória entre processos, o núcleo mantém regras distintas de
tradução de
endereços lógicos para cada processo e reconfigura a MMU a cada troca de
contexto.
Assim, o processo em execução, a cada instante, tem sua própria área
 de memória e é impedido
pela MMU de acessar áreas de memória dos demais
 processos. Além disso, a configuração das
MMUs mais sofisticadas inclui a
 definição de permissões de acesso às áreas de memória. Essa
funcionalidade
permite implementar as permissões de acesso às diversas áreas de cada processo
e
impedir os processos de acessar áreas exclusivas do núcleo do sistema operacional.

      As principais estratégias de
 tradução de endereços usadas pelas MMUs são por partições,
usadas nos
 primeiros sistemas de memória virtual, e por segmentos e por páginas,
 usadas nos
sistemas atuais.

      A memória virtual por paginação
é a técnica de gerência de memória com a qual o espaço de
endereçamento real é dividido
 em blocos de mesmo tamanho chamados páginas. Já a memória
virtual por segmentação
 é a técnica de gerência de memória com a qual o espaço de

https://univirtus.uninter.com/ava/web/roa/           20/23
-----------------------Page 20 End-----------------------

05/05/2022 22:52                            UNINTER

endereçamento virtual
 é dividido em blocos de tamanhos diferentes chamados segmentos.

Enquanto
 na paginação existe o problema da fragmentação interna, na segmentação surge o

problema da fragmentação externa.

      A técnica de swapping apresentada
é o exemplo mais popular de memória virtual, pois diversos
sistemas
operacionais (como o Linux) exigem (como requisito básico) a definição em disco
de uma
partição de swap, normalmente com o dobro do tamanho da memória
principal (RAM) disponível.

FINALIZANDO

      Os conteúdos da gerência de
memória foram apresentados e definidos nesta aula. Trata-se de
uma tarefa elementar que pode fazer toda a diferença na escolha do
 sistema operacional mais
adequado aos objetivos iniciais de conveniência e
eficiência. Mostramos que a gestão de memória
tem como meta manter o
 maior número de processos residentes na memória principal, permitindo
maximizar
 o compartilhamento do processador e demais recursos computacionais, auxiliando
 no
combate à ociosidade da CPU.

      No Tema 2, apresentamos tipos e padrões de memória numa
 classificação básica, pois
conhecer os componentes é elementar para uma boa
 gestão. Também mostramos os tipos e
padrões das memórias, permitindo uma
 classificação simples e funcional, pois, quanto maior a
capacidade de
armazenamento, menores seus custos e velocidades (desempenho) – e vice-versa,
como
vimos na Figura 1.

      No Tema 3, descrevemos a alocação
 de memória, em que todos os softwares do sistema de
computação, desde o sistema
operacional até os aplicativos, dependem de memória disponível para
serem
executados. Apresentamos a sequência das tarefas de gestão das memórias, em
especial a
estratégia utilizada para evitar conflitos entre aplicações e
 garantir espaço para a execução, a
alocação e os principais conceitos
relacionados, ressaltando que alocar memória significa reservar
áreas de
memória RAM para serem usadas por um processo.

      Demos destaque ao item 3.1,
 que trata das estratégias de gerenciamento e alocação de
memória: first-fit
(“o primeiro que se encaixa”, ou “primeiro que couber”), best-fit (“o
que melhor se
encaixa”, ou “o que melhor couber”), worst-fit (“o que pior
se encaixa”, ou “o que pior couber”) e o
next-fit (“o próximo que se
encaixa”, ou “o próximo que couber”).

https://univirtus.uninter.com/ava/web/roa/           21/23
-----------------------Page 21 End-----------------------

05/05/2022 22:52                            UNINTER

No Tema
4, vimos as estratégias de paginação, apresentando quais programas e dados
podem

ser divididos em pedaços de tamanho fixo denominados páginas, que
podem ser posicionados em

qualquer “moldura de página” disponível e gerenciadas
 com o auxílio de políticas de alocação e

substituição de páginas, com as
técnicas overlay, swapping e paging.

      No item
4.4, apresentamos os algoritmos de substituição de páginas, considerando a idade
da
página, frequência de acessos a ela, data do último acesso, prioridade do
 processo proprietário,
conteúdo da página e páginas especiais. Os principais
 algoritmos de substituição são: Ótimo;
Aleatório; de ordem Fifo; LFU; LRU; NRU;
Fifo com buffer de páginas; e Fifo circular.

      No Tema
5, falamos sobre a memória virtual, uma técnica sofisticada e poderosa de
gerência de
memória, em que a memória principal e a secundária são combinadas,
dando ao usuário a ilusão de
existir uma memória muito maior que a capacidade
 real da memória principal. Fundamenta-se em
não vincular o endereçamento feito
pelo programa dos endereços físicos da memória principal,

      com destaque à MMU, que
 permite implementar a proteção de memória do núcleo e dos
processos entre si. Finalizamos
 o tópico apresentando as principais estratégias de tradução de
endereços usadas
pelas MMUs, por partições, segmentos e páginas, paginação e segmentação.

      Compreender esses conceitos
 possibilita uma melhor e mais eficiente escolha do sistema
operacional,
 obedecendo aos critérios e às necessidades de cada software aplicativo e de
 cada
usuário.

REFERÊNCIAS

      DEITEL, P. J.; DEITEL, H. M.; CHOFFNES, D. R. Sistemas
 operacionais. 3. ed. São Paulo:
Pearson Brasil, 2017.

      JOHNSTONE, M. S.; WILSON, P. R. The memory fragmentation
 problem: solved? ACM
SIGPLAN Notices, New York, v. 34, n. 3, p.
26-36, 1999.

      MACHADO, F. B.; MAIA, P. L. Arquitetura de sistemas
operacionais. 4. ed. São Paulo: LTC,
2007.

      MAZIERO, C. Sistemas operacionais: conceitos e
mecanismos. Curitiba: UFPR, 2019.

https://univirtus.uninter.com/ava/web/roa/                            22/23
-----------------------Page 22 End-----------------------

05/05/2022 22:52                            UNINTER

STALLINGS, W. Operating systems: internals
 and design principles. 9. ed. London: Pearson,

2018.

      WILSON, P. R. et al. Dynamic storage allocation: a survey
 and critical review. New York:
Springer, 1995. Disponível em: <https://users.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf>.
Acesso em: 20 jun. 2020.

https://univirtus.uninter.com/ava/web/roa/           23/23
-----------------------Page 23 End-----------------------
----------------------------------------------------------------------------------------------------------------------

uninter sistemas operacionais aula 4

05/05/2022 22:54  UNINTER

                                                                          1/22
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        

   
   
  SISTEMAS OPERACIONAIS

      AULA 4
             
             
             
             
             
             
             
             
             
             
             
             
            Prof. André Roberto Guerra

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 1 End-----------------------

05/05/2022 22:54                            UNINTER

CONVERSA
INICIAL

      Os computadores
 são compostos basicamente pelo hardware e pelo software, de forma
dependente,
como definimos em aulas anteriores. O hardware tem como principais componentes
a
CPU, as memórias e os dispositivos de E/S, cada um dos quais é
 individualmente gerenciado e
controlado pelo sistema operacional. Após a
 apresentação da gerência de processos e do
processador (CPU) e da gerência de
 memória em aulas anteriores, agora apresentaremos a
gerência de dispositivos
 de E/S. Já estudamos as definições das atividades de gestão de
processador e de processos e da gestão de memória, com uma análise de processos
de gestão de
entrada e saída. Nesta aula, completaremos os conceitos de gestão
 dos elementos do hardware
pelo sistema operacional. Vamos lá?

      O Sistema Operacional deve
 controlar todos os dispositivos de E/S de um computador. Deve
emitir comandos
para os dispositivos, interceptar interrupções e tratar erros. Deve também
fornecer
uma interface simples e fácil de usar; na medida do possível, a interface
deveria ser a mesma para
todos os dispositivos. Ou seja, para o usuário, dados
de um arquivo ou de um dispositivo de rede, as
chamadas ao sistema são iguais,
 mudando apenas os parâmetros de entrada (Sousa Filho;
Alexandre, 2013)

      Os
conteúdos previstos para nossas discussões contemplam
nesta aula a gestão (gerência) de
dispositivos de
entrada e saída, apresentados e definidos em cinco temas: conceitos
e definições de
gestão de E/S; gerenciador de dispositivos;
device drivers; controladores de dispositivos; e técnicas
avançadas de E/S. 

TEMA 1 – CONCEITOS E DEFINIÇÕES DE GESTÃO DE E/S

https://univirtus.uninter.com/ava/web/roa/           2/22
-----------------------Page 2 End-----------------------

05/05/2022 22:54                             UNINTER

Segundo Guardia e Senger (2015).
o controle da entrada e saída (E/S – ou I/O input/output) de

dados dos dispositivos
é uma das funções principais de um sistema operacional. Para promover o

compartilhamento
 seguro do uso dos recursos, contudo, não é permitido aos processos o acesso

direto
 a dispositivos de entrada e saída. Assim, cabe ao SO oferecer serviços (chamadas
 de

sistema) que permitam ler e escrever dados.

      A interação dos programas com
o SO para o acesso aos dispositivos pode ocorrer enviando e
recebendo bytes
 de/para dispositivos de caractere, ou realizando operações de arquivos em
dispositivos de bloco (Guardia; Senger, 2015).

      Um dispositivo de bloco é
aquele que armazena informação em blocos de tamanho fixo, cada
um com seu
 próprio endereço. Os tamanhos de blocos variam de 512 bytes a 32.768 bytes. A
propriedade essencial de um dispositivo de blocos é que cada bloco pode ser
 lido ou escrito
independentemente dos outros. Discos são dispositivos de blocos
 mais comuns (Sousa Filho;
Alexandre, 2013).

      Há outro tipo de dispositivos
de E/S, que é o dispositivo de caractere, que envia ou recebe um
fluxo de
 caracteres, sem considerar qualquer estrutura de blocos. Ele não é endereçável
 e não
dispõe de qualquer operação de posicionamento. Impressoras, interface de
rede, mouses e a maior
parte de outros dispositivos diferentes do disco são
considerados dispositivos de caractere (Sousa
Filho; Alexandre, 2013).

      Os Sistema Operacionais devem
 atuar nas seguintes operações de E/S (Guardia; Senger,
2015):

emitir comandos para os dispositivos;
atender interrupções geradas pelos dispositivos;
tratar erros nas operações dos dispositivos;
prover uma interface para a utilização dos dispositivos; se possível, a mesma para todos
eles,
de forma que a sintaxe das operações seja independente dos dispositivos.

      Para entender como o SO trata
os dispositivos, é importante conhecer alguns aspectos de suas
operações (Guardia;
Senger, 2015).

      Gerenciar entrada/saída (E/S)
 envolve muitos componentes de sistema operacional, como
ilustra a figura a
seguir.

https://univirtus.uninter.com/ava/web/roa/            3/22
-----------------------Page 3 End-----------------------

05/05/2022 22:54                                                                          UNINTER

                  Figura 1 – Componentes de suporte de E/S do Windows XP

                                                  Fonte: Elaborado com base em Deitel; Deitel, 2017.

      Deitel e Deitel (2017) descrevem
 os componentes da figura individualmente. Processos de
modo usuário interagem
 com um subsistema de ambiente (como o subsistema Win32), e não
diretamente com
componentes de modo núcleo. Os subsistemas de ambiente passam requisições
de
 E/S para o gerenciador de E/S, que interage com drivers de dispositivo para
 tratar essas
requisições. Frequentemente, vários drivers de dispositivo
 organizados em uma pilha de drivers
cooperam para atender a uma requisição de
E/S.

      Um componente em destaque é o gerenciador
 de dispositivos plug-and-play (PnP), que
reconhece novos dispositivos quando são
conectados ao sistema. No entanto, é necessário que tais
dispositivos apresentem
suporte ao recurso. Ele disponibiliza recursos como portas de E/S ou canais
de
DMA. Dispositivos desenvolvidos mais recentemente suportam PnP.

      O gerenciador de energia
 administra a política de gerenciamento de energia do sistema
operacional. A
política de energia determina se é preciso reduzir a energia para certos
dispositivos,
para conservá-la, ou se é possível mantê-los completamente
energizados, de modo a garantir alta
responsividade (Deitel; Deitel, 2017).

https://univirtus.uninter.com/ava/web/roa/                                                         4/22
-----------------------Page 4 End-----------------------

05/05/2022 22:54                            UNINTER

Para a gerência de Entrada/Saída,
 considera-se um componente de gerenciamento de

memória, que inclui o controle
 de usos diversos da áreas de armazenamento temporário, ou uma

interface geral
para os diversos controladores de dispositivos, utilizando rotinas de controle
(device

drivers) dos diversos dispositivos (Silberschatz; Galvin; Gagne,
2016).

      Segundo Machado e Maia (2007),
 a gerência de entrada/saída no Unix foi desenvolvida de
forma integrada ao sistema
de arquivos. O acesso aos dispositivos de E/S, como terminais, discos e
a
própria rede, é feito por meio de arquivos especiais. Cada dispositivo está
associado a um ou mais
arquivos especiais, localizados no diretório /dev. Por
exemplo, uma impressora pode ser o arquivo
/dev/lp; um terminal, /dev/ttyl; e
uma interface de rede, /dev/net.

      Os arquivos especiais podem
 ser acessados da mesma forma que qualquer outro arquivo,
utilizando
 simplesmente as chamadas de sistema (system calls) de leitura e gravação. No
 Unix,
todas as operações de E/S são realizadas como uma sequência de bytes, inexistindo
os conceitos
de registro ou método de acesso. Isso permite enviar o mesmo dado para
diferentes dispositivos de
saída, como um arquivo em disco, terminal, impressora
ou linha de comunicação. Dessa forma, as
system calls de E/S podem manipular
qualquer tipo de dispositivo de maneira uniforme (Machado;
Maia, 2007).

      O subsistema de E/S é a parte
 do kernel responsável por lidar com as funções de entrada e
saída independentes
 do dispositivo, como buffering e controle de acesso. Para permitir a
comunicação entre o subsistema de E/S e os diferentes drivers de maneira
 uniforme, o sistema
implementa uma interface com os device drivers, padronizada
com base nas especificações Device
Driver Interface (DOI) e Driver Kernel lnterface
(DKl) (Machado; Maia, 2007).

      Os device drivers têm a função
de isolar os dispositivos de E/S do restante do kernel, tomando-
o independente
 da arquitetura de hardware. Para cada dispositivo, existe um device driver
associado. Os device drivers são acoplados ao sistema operacional quando o
 kemel é gerado.
Sempre que um novo dispositivo é acrescentado ao sistema, o
 driver correspondente deve ser
acoplado ao núcleo. A tarefa de geração do
 kernel não é simples, exigindo que o sistema seja
reinicializado (Machado; Maia,
2007).

      A figura a seguir apresenta as
 camadas que compõem a gerência de E/S no Unix. Os
processos se comunicam com o
subsistema de E/S por meio das system calls de E/S.

https://univirtus.uninter.com/ava/web/roa/                               5/22
-----------------------Page 5 End-----------------------

05/05/2022 22:54                                                                   UNINTER

                                            Figura 2 – Gerência de E/S

              Fonte: Elaborado com base em Deitel; Deitel, 2017; crédito: NATASHA ZALEVSKAYA/SHUTTERSTOCK

      As versões mais recentes do
Unix, como o Linux, permitem que os device drivers possam ser
acoplados ao
núcleo com o sistema em funcionamento, sem a necessidade de uma nova geração
do
kernel e reinicialização de sistema (Machado; Maia, 2007).

      Os device drivers podem ser
 divididos em dois tipos: orientados a bloco e orientados a
caractere. Os device
 drivers orientados a bloco estão ligados a dispositivos como discos rígidos
(HDs) e discos ópticos (BlueRay), que permitem a transferência de blocos de
 informações do
mesmo tamanho (Machado; Maia, 2007).

      Os drivers orientados a
 caractere são voltados para conectar dispositivos como terminais e
impressoras,
que transferem informação de tamanho variável, geralmente caractere a caractere,
ou
uma sequência de caracteres.

      Na última camada do sistema
operacional, os aplicativos (System Apps) oferecem ao utilizador
o acesso aos
 recursos físicos (hardware), como ilustra a Figura 3, já apresentada em aulas
anteriores.

https://univirtus.uninter.com/ava/web/roa/                                                  6/22
-----------------------Page 6 End-----------------------

05/05/2022 22:54                                                        UNINTER

                  Figura 3 – System apps e recursos físicos

      Por exemplo, ao executar o app câmera, o usuário acessa o
recurso de hardware (câmera) de
forma rápida e transparente, ficando com a sensação
 de que o acesso é direto da tela para as
lentes. Mas, como ilustram os blocos (verde
– Java API Framework; roxo – Native C/C++ libraries;
amarelo – ART; e azul
 claro – HAL), do app até as lentes da câmera são executadas inúmeras
outras
tarefas e funções (softwares).

      Cada uma das etapas é
responsável pela integração de todas as características disponíveis e
pela
 correta execução. Filtros, efeitos especiais 3D e animações são exemplos de
 recursos de
software.

https://univirtus.uninter.com/ava/web/roa/                                       7/22
-----------------------Page 7 End-----------------------

05/05/2022 22:54                            UNINTER

No caso das operações
orientadas a bloco, deve existir a preocupação de minimizar o número

de
transferências entre o dispositivo e a memória. utilizando o buffer cache.

      O buffer cache é uma área na
memória principal onde ficam armazenados temporariamente os
blocos recentemente
 referenciados. Por exemplo, quando uma operação de leitura a disco é
realizada,
o subsistema de E/S verifica se o bloco está no buffer cache. Se o bloco se
encontra no
cache, é possível passá-lo diretamente para o sistema de arquivos,
 sem acesso ao disco,
melhorando assim o desempenho do sistema.

      O núcleo do Sistema
Operacional (kernel) acessa dispositivos de sistema por meio da interface
de
E/S. O núcleo abstrai os detalhes do hardware de um sistema, fornecendo uma
interface comum
para chamadas ao sistema de E/S. O núcleo agrupa dispositivos
 em classes; membros de cada
classe de dispositivos executam funções similares,
 o que permite ao núcleo abordar as
necessidades de desempenho de certos
 dispositivos (ou classes de dispositivos) individualmente
(Deitel; Deitel,
2017).

TEMA 2 – GERENCIADOR DE DISPOSITIVOS

      Como abordamos em aulas
anteriores, aqui entra em cena o Sistema Operacional (SO), que é
uma
camada de software que opera entre o hardware e os aplicativos. É um software
de estrutura
ampla e complexa, que incorpora aspectos de baixo nível (como
drivers de dispositivos e gerência
de memória física) e de alto nível (como
softwares utilitários e a interface gráﬁca).

      A Figura 4 ilustra o
gerenciamento de dispositivos pelo SO.

                  Figura 4 – Gerenciamento de dispositivos

https://univirtus.uninter.com/ava/web/roa/                                     8/22
-----------------------Page 8 End-----------------------

05/05/2022 22:54  UNINTER

                                                    Fonte: Elaborado com base em Coutinho, 2010.

      O sistema operacional deve
 fornecer ao utilizador acesso aos dispositivos de forma
transparente, mas nem
sempre isso ocorre com perfeição. Podem ocorrer falhas, em cujos casos o
acesso
 aos dispositivos pode ser realizado utilizando uma GUI (Graphic User
Interface), aplicativo
interativo com interface gráfica, que fornece ao utilizador
dados técnicos e informações detalhadas
sobre cada dispositivo de hardware
conectado ao sistema de computação, auxiliando a resolução de
eventuais
conflitos ou falhas.

      É também desejável (e muito
 importante) que o sistema operacional disponibilize ao usuário
acesso fácil e
simples (transparente) a quaisquer novos dispositivos incluídos, em especial os
plug-
and-play (PnP), aqueles que apresentam como principal característica o
 recurso conectar e usar,
conforme descrevemos no Tema 1, ao abordar o gerenciador
de plug-and-play (PnP).

      Os sistemas computacionais
atuais apresentam centenas de dispositivos interconectados, dos
mais diversos
 tipos e padrões; cada um deles é individualmente gerenciado, apresentando
informações
particulares (endereços, tamanho, função etc.), descritas e gerenciadas pelos
softwares
de gerência. As figuras a seguir ilustram exemplos de gerenciadores
de dispositivos.

                                   Figura 5 – Gerenciador de Dispositivos Kali-Linux  9/22

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 9 End-----------------------

05/05/2022 22:54  UNINTER

                                         Fonte: Andre Roberto Guerra.

                  Figura 6 – Gerenciador de Dispositivos Windows 10

                                                                 Fonte: Andre Roberto Guerra.  10/22

                               Figura 7 – Gerenciador de Dispositivos Apple MacOS X

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 10 End-----------------------

05/05/2022 22:54                            UNINTER

                                            Fonte: Andre Roberto Guerra.

      A gerência
 de dispositivos recebe destaque, pois cada periférico do computador tem suas
particularidades; assim, o procedimento de interação com uma placa de rede é
 completamente
diferente da interação com um disco rígido SATA (Maziero,
 2019).
 Todavia, existem muitos
problemas e abordagens em comum para o acesso aos
periféricos.

      Por
 exemplo, é possível criar uma abstração única para a maioria dos dispositivos
 de
armazenamento, como cartão de memória, SSD, CD-ROMs etc., na forma de um
vetor de blocos de
dados.

      A
função da gerência de dispositivos (também conhecida como gerência de entrada/saída)
 é
implementar a interação com cada dispositivo, por meio de drivers, e criar
 modelos abstratos que
permitam agrupar vários dispositivos similares sob a
mesma interface de acesso.

      A
 impressão é outro recurso em que o acesso deve ser efetuado de forma mutuamente
exclusiva (apenas um aplicativo por vez). O sistema operacional resolve essa
questão utilizando o
recurso de Spooling, além de definir uma fila de trabalhos
 a imprimir (print jobs), normalmente
executados sequencialmente (First
In First Out). (Maziero, 2019)

      Melo Neto (2014) descreve que
 a gerência de dispositivos de entrada/saída é uma das
principais e mais
complexas funções do sistema operacional. Sua implementação é estruturada por

https://univirtus.uninter.com/ava/web/roa/                                11/22
-----------------------Page 11 End-----------------------

05/05/2022 22:54                            UNINTER

meio de camadas de um modelo semelhante ao apresentado para o sistema
operacional, utilizando

o conceito de máquina de níveis. As camadas de mais
 baixo nível escondem características das

camadas superiores, oferecendo uma
interface simples e confiável ao usuário em suas aplicações.

TEMA 3 – DEVICE DRIVERS

      Neste tema, vamos
 estudar o elemento de software responsável pelo funcionamento dos
dispositivos,
os device drivers.

      A camada inferior
 de software – drivers de dispositivos (device drivers) – é composta por um
conjunto
de módulos de software, cada um implementado para fornecer os mecanismos de
acesso a
um dispositivo de entrada e saída específico. O principal objetivo dos
 drivers de dispositivos é
“esconder” as diferenças entre os vários dispositivos
 de entrada e saída, fornecendo à camada
superior uma “visão uniforme” dos dispositivos,
com uma interface de programação única (Oliveira;
Carissimi; Toscani, 2010).

      Segundo Nigri (2018),
uma vez que o Sistema Operacional tem que suportar todos os tipos de
hardware,
não faria muito sentido que o programa que controla cada modelo disponível de
cada tipo
de dispositivo ficasse no kernel. Se assim fosse, haveria um grande
desperdício de memória. Para
resolver isso, existem os device drivers.

      Os módulos
 controlam funções específicas, sendo carregados pelo kernel à medida que os
dispositivos são detectados pelo sistema. No entanto, ao contrário dos
programas de usuário, uma
vez que o device driver é carregado, ele passa a
funcionar junto com o kernel e em “kernel mode”
(quase como uma parte dele); da
mesma forma que o kernel, os device drivers têm acesso irrestrito
ao hardware
do computador (Nigri, 2018).

      Nem todo device
 driver serve para controlar um dispositivo. Alguns servem para implantar
funções intermediárias (como se comunicar com o barramento USB em que os
 dispositivos são
conectados), enquanto outros servem para implementar funções
não obrigatórias do kernel (como o
protocolo IPV6, que nem sempre é suportado
pela rede local).

      Outra
 característica importante dos device drivers, segundo Nigri (2018), é o fato de
 que eles
normalmente não são programados pelas mesmas pessoas que implementam o
kernel. Na maioria
das vezes, os times nem são da mesma empresa. Isso
possibilita que um fabricante de dispositivo

https://univirtus.uninter.com/ava/web/roa/           12/22
-----------------------Page 12 End-----------------------

05/05/2022 22:54  UNINTER

seja capaz de programar sozinho o
 device driver, de modo a fornecer, aos compradores do seu

dispositivo, suporte
em vários sistemas operacionais diferentes.

      Em termos gerais,
quando compramos uma placa de rede, e na caixa está escrito “funciona em
Windows e em MAC OSX”, o fabricante está dizendo que estão disponíveis device
drivers para tais
sistemas. Afinal, com o driver correto, qualquer sistema
 operacional pode utilizar os dispositivos
(Nigri, 2018).

      Em sistemas
operacionais atuais, há também o gerenciamento de credenciais de usuário, tema
que
 será apresentado, definido e explicado em aula específica. No entanto, as
 imagens a seguir
ilustram as atribuições de políticas locais do Windows 10,
 indicando que apenas usuários
administradores (o usuário padrão do Windows 10 é
administrador) tem a permissão de carregar ou
descarregar os drivers de
 dispositivo. A Figura 8 apresenta uma explicação detalhada da função
carregar e
descarregar drivers de dispositivo.

      Assim, conhecendo
os recursos do sistema operacional, o usuário avançado pode estabelecer
políticas e normas para melhor desempenho, permitindo ou negando a determinados
 usuários ou
grupos de usuários acesso às funções das ferramentas.

                  Figura 8 – Editor de política de Grupo Local do Windows 10

                                                                 Fonte: Andre Roberto Guerra.  13/22

                           Figura 9 – Explicação sobre carga de drivers do Windows 10

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 13 End-----------------------

05/05/2022 22:54                            UNINTER

                                            Fonte: Andre Roberto Guerra.

      Segundo Melo
Neto (2014), o device driver, ou apenas driver, tem como função implementar a
comunicação
 do subsistema de E/S com os dispositivos, através de controladores. Enquanto o
subsistema de E/S trata de funções ligadas a todos os dispositivos, os drivers
 tratam apenas dos
seus aspectos particulares.

      Os drivers têm como função
receber comandos gerais sobre acessos aos dispositivos e traduzi-
los em
 comandos específicos para aquele dispositivo em questão. Cada driver manipula
 somente
um tipo de dispositivo ou grupos de dispositivos semelhantes.

      O driver está integrado
 diretamente às funções do controlador. Trata-se do componente do
sistema que
reconhece as características particulares do funcionamento de cada dispositivo
de E/S,
como número de registradores do controlador, funcionamento e comandos
 específicos. Os
controladores serão explicados e definidos no próximo tema. Sua
 função principal é receber os
comandos abstratos do subsistema de E/S e
 traduzi-los para comandos que o controlador possa
entender e executar (Melo
Neto, 2014).

      Além disso, o driver pode
 realizar outras funções, como a inicialização do dispositivo e seu
gerenciamento.
Os drivers fazem parte do núcleo do sistema operacional, sendo escritos geralmente
em assembly. Como os drivers são códigos reentrantes que executam em
 modo kernel, qualquer
erro de programação pode comprometer o funcionamento do
sistema. Por isso, um driver deve ser
cuidadosamente desenvolvido e testado (Melo
Neto, 2014)

https://univirtus.uninter.com/ava/web/roa/                                14/22
-----------------------Page 14 End-----------------------

05/05/2022 22:54                            UNINTER

Devido ao alto grau de
 dependência entre os drivers e o restante do kernel do sistema, os

fabricantes
desenvolvem, para um mesmo dispositivo, diferentes drivers, um para cada
arquitetura

de processador (32 ou 64bits), um para cada sistema operacional,
inclusive para versões diferentes.

Sempre que um novo dispositivo é instalado,
o driver do dispositivo deve ser adicionado ao kernel

do sistema (Melo Neto,
2014).

      Nos sistemas mais antigos, a
inclusão de um novo driver significava a recompilação do kernel,
uma operação
 complexa que exigia a reinicialização do sistema. Atualmente, os sistemas
operacionais permitem a fácil instalação de novos drivers; os drivers são carregados
dinamicamente,
sem a necessidade de reinicialização. Alguns sistemas permitem
até mesmo a instalação física de
dispositivos com o computador ligado (hot
swap ou hot plug) (Melo Neto, 2014).

      Além dessas definições, Maziero (2019)
 complementa que um driver de dispositivo, ou
simplesmente driver, é o componente
 do sistema operacional responsável por interagir com um
controlador de
 dispositivo. Cada tipo de dispositivo tem seu próprio driver, muitas vezes
 fornecido
pelo fabricante.

      Cada driver é geralmente capaz
 de tratar um único tipo de dispositivo, ou uma família de
dispositivos
 correlatos do mesmo fabricante. Internamente, um driver consiste em um conjunto
 de
funções, que são ativadas pelo núcleo do sistema operacional, conforme necessário
 (Maziero,
2019).

Existem três grupos de funções
implementadas por um driver, ilustradas na figura a seguir.

                                            Figura 10 – Funções do driver

                                            Fonte: Maziero, 2019.

https://univirtus.uninter.com/ava/web/roa/                                                  15/22
-----------------------Page 15 End-----------------------

05/05/2022 22:54                            UNINTER

Segundo Maziero (2019), as funções
 de entrada/saída de dados (data I/O functions) são

responsáveis pela
transferência de dados entre o dispositivo e o sistema operacional; essas
funções

recebem e enviam dados de acordo com a classe dos dispositivos:
 caracteres (bytes), blocos de

tamanho fixo (discos), blocos de tamanho variável
 (pacotes de rede) ou áreas de memória

compartilhadas entre o dispositivo e a
CPU (imagens/vídeo e outros).

      As funções de gerência (mgmt [management]
 functions) são responsáveis pela gestão do
dispositivo e do próprio
driver. Além de funções para coordenar a inicialização e finalização do driver
e do dispositivo, geralmente são fornecidas funções para configurar o
dispositivo, para desligar ou
colocar em espera o dispositivo quando não está
em uso, e para tratar erros no dispositivo. Algumas
dessas funções podem ser
 disponibilizadas aos processos no espaço de usuário, através de
chamadas de
sistema específicas.

      As funções de tratamento de
eventos (event handling) são ativadas quando uma requisição de
interrupção é gerada pelo dispositivo.

      Toda requisição de interrupção
 gerada pelo dispositivo é encaminhada ao controlador de
interrupções do
hardware, que a entrega ao núcleo do sistema operacional. No núcleo, um
tratador
de interrupções (IRq handler) reconhece e identifica a
interrupção junto ao controlador, e em seguida
envia uma notificação de evento
a uma função do driver, para o devido tratamento (Maziero, 2019).

      Além das funções descritas, um
 driver mantém estruturas de dados locais, para armazenar
informações sobre o
 dispositivo e sobre as operações em andamento. Os drivers normalmente
executam
dentro do núcleo do sistema operacional, em modo privilegiado.

      Por se configurarem como código
 de terceiros executando com acesso total ao hardware,
constituem um dos maiores
riscos à estabilidade e à segurança do sistema operacional. Drivers mal
construídos ou mal configurados são fontes frequentes de problemas como
 travamentos ou
reinicializações inesperadas (Maziero, 2019).

TEMA 4 – CONTROLADORES DE DISPOSITIVOS

      Controladores de dispositivos também são
 conhecidos como interfaces, por servirem como
meio de comunicação entre o
 Sistema Operacional e os devices (dispositivos). São componentes
eletrônicos
 (hardware) responsáveis por manipular diretamente os dispositivos de
 Entrada/Saída.

https://univirtus.uninter.com/ava/web/roa/                            16/22
-----------------------Page 16 End-----------------------

05/05/2022 22:54                            UNINTER

Em geral, apresentam memória e registradores próprios para
 executar instruções enviadas pelo

device driver (Zambiasi, 2011).

      O device driver comunica-se
 com os dispositivos indiretamente, através do controlador, de
modo que há um
 controlador para cada tipo de dispositivo físico de entrada/saída (disco,
impressora, fita etc.). Em geral, o controlador pode ser uma placa independente
acoplada a CPU por
um slot, ou pode ser implementado diretamente na placa do
processador (Siqueira, 2020).

      Os controladores são descritos por Melo
 Neto (2014) como componentes de hardware
responsáveis por
 manipular diretamente os dispositivos de E/S. O sistema operacional, mais
exatamente o driver, comunica-se com os dispositivos através dos controladores,
 por uma placa
independente ou implementada diretamente na placa-mãe. A figura a
seguir ilustra a interconexão.

                  Figura 11 – Interconexão entre controladores

                                                 Fonte: Baggio, 2018. Crédito: Bioraven/Shutterstock.

      O controlador tem memória e
 registradores próprios, utilizados na execução de instruções
enviadas pelo
driver. Essas instruções, de baixo nível, são responsáveis pela comunicação
entre o
controlador e o dispositivo de E/S. (Melo Neto, 2014)

      Inicialmente, o device driver
 executa as operações de Entrada/Saída gravando os comandos
nos registradores do
 controlador. O controlador executa a operação com o dispositivo enquanto a
UCP
 pode realizar outras tarefas. Em seguida, o device driver testa os resultados através
 dos
registradores do controlador. (Zambiasi, 2011)

https://univirtus.uninter.com/ava/web/roa/                      17/22
-----------------------Page 17 End-----------------------

05/05/2022 22:54                                           UNINTER

Em operações de leitura, o
controlador deve armazenar em seu buffer interno uma sequência

de bits
provenientes do dispositivo, até formar um bloco.

      Após verificar a ocorrência de erros, o bloco
 pode ser transferido para um buffer de E/S na
memória principal. A
transferência do bloco do buffer interno do controlador para o buffer de E/S na
memória principal pode ser realizada pelo processador ou por um controlador de
DMA (Melo
Neto,
2014). A técnica de DMA será apresentada no próximo tema.

      Alguns controladores,
 particularmente os de discos, implementam técnicas de cache
semelhante às
implementadas pelos sistemas de arquivos, na tentativa de melhorar o desempenho
das operações de E/S.

      Normalmente, o controlador
 avisa ao sistema operacional do término de uma operação de
gravação, quando os
dados no buffer do controlador são gravados no disco (write-through caching).

      O controlador também pode ser
 configurado para avisar do término da gravação, mesmo
quando os dados ainda se
encontram no buffer do controlador e a operação de gravação no disco
não foi
 realizada (write-back caching). Dessa forma é possível obter ganhos
 consideráveis de
desempenho (Melo Neto, 2014).

TEMA 5 – TÉCNICAS AVANÇADAS DE E/S

      DMA (Direct Memory Access),
ou acesso direto à memória, é uma funcionalidade implementada
nos processadores
e sistemas computacionais em geral, com o objetivo de melhorar o desempenho
e
aumentar a velocidade do processamento de dados (Robolivre, 2020).

      Em uma definição simples, o
 processo consiste em ler ou gravar dados diretamente em um
periférico, sem a
necessidade de ocupar o processador com essa tarefa. É muito útil,
principalmente
em sistemas com pouco poder de processamento, e por isso se
 popularizou rapidamente com a
chegada dos computadores pessoais.

      Um exemplo prático e muito
 claro da utilidade do DMA é o monitor. A quantidade de dados
processados para
 mostrar uma imagem na tela em tempo real é muito grande. Se apenas o
processador do PC trabalhasse para realizar essa tarefa, provavelmente, ao
colocarmos um vídeo
para rodar, não conseguiríamos fazer mais nada. Porém, como
podemos perceber, não é bem isso o

https://univirtus.uninter.com/ava/web/roa/                          18/22
-----------------------Page 18 End-----------------------

05/05/2022 22:54                            UNINTER

que acontece. Por quê? O uso da técnica de
 DMA evita que o processador fique ocupado com a

transferência do bloco para a
 memória. O controlador de DMA é um dispositivo de hardware que

pode fazer parte
do computador ou pode ser um dispositivo independente (Robolivre, 2020).

      Em operações de leitura, o
controlador armazena uma sequência de bits do dispositivo no seu
buffer interno
 e verifica a ocorrência de erros. Caso inexistam erros, o bloco é transmitido
 para a
memória principal (RAM).

      Na maioria dos dispositivos
 orientados a bloco, como os dispositivos de armazenamento de
longo prazo
 (discos), é implementada a técnica de DMA para transferência de dados entre o
controlador e a memória principal (Zambiasi, 2011), como ilustra a figura a
seguir.

                                            Figura 12 – Técnica de DMA

                  Fonte: Elaborado com base em Robolivre, 2020.

      Há ainda um componente adicional,
o Controlador de DMA (DMAC – DMA Controller). O DMAC
trabalha paralelo à
CPU. Ele é o responsável por controlar todo o processo de gravação ou leitura
de dados com uma interferência mínima da CPU. Resumidamente, o DMAC deve ser
previamente
definido com alguns dados para o correto funcionamento: endereço da
 fonte; posição inicial da
memória; quantidade de bytes.

Com esses dados, o DMAC envia
 um pedido de interrupção à CPU, que cede ao DMAC o

controle do fluxo de dados
do periférico a ser utilizado, por exemplo um leitor de DVD. Assim, esse

tráfego passa a ser controlado diretamente pelo DMAC; quando termina a tarefa (de
 gravação ou

https://univirtus.uninter.com/ava/web/roa/                                                 19/22
-----------------------Page 19 End-----------------------

05/05/2022 22:54                            UNINTER

leitura), este envia um novo pedido de interrupção à CPU, para
informar que ela já pode retomar o

controle do fluxo de dados que havia cedido
anteriormente.

      Dessa forma, a CPU economiza
em tempo de processamento, acelerando as tarefas realizadas
por esses processos
(Robolivre, 2020).

      Em microcontroladores, esse é
 um recurso muito importante. Tendo em vista que a sua
capacidade de
 processamento normalmente é bastante limitada, se comparada a um PC, o DMA
torna os microcontroladores muito mais robustos e funcionais. No entanto, não
 são todos os
microcontroladores que apresentam essa capacidade; normalmente,
 apenas os mais novos ou os
criados com alguns fins específicos (como os
 tocadores de MP3). Para ter certeza, é necessário
verificar o datasheet (Robolivre,
2020).

      Outra técnica avançada é o SCSI
(Small Computer Systems Interface), Interface de Pequenos
Sistemas de Computação.
 Este pe um padrão popular para a conexão de dispositivos ao
computador, inicialmente
utilizado em RISC. Define padrões de hardware e software que permitem
conectar
 ao computador qualquer tipo de dispositivo, mesmo de fabricantes diferentes. O
 Sistema
Operacional deve estar configurado com um driver SCSI e o hardware com
um controlador SCSI, no
qual os periféricos são conectados (Zambiasi, 2011).

FINALIZANDO

      Nesta
 aula, apresentamos conteúdos sobre a gestão de dispositivos de entrada e saída,
completando as definições das tarefas de gerenciamento dos principais
componentes do hardware
(CPU, memórias e dispositivos de E/S) pelos sistemas
operacionais,com destaque para conceitos e
definições.

      Já no
 segundo tema, apresentamos o gerenciador de dispositivos, utilizando figuras de
exemplos em sistemas operacionais populares
 e atuais, que proporcionam a visualização das
funcionalidades dessa
importante ferramenta.

      No terceiro tema, estudamos os
device drivers, essenciais para a comunicação entre o SO e os
dispositivos, contribuindo para que qualquer novo device ou periférico
conectado funcione, de forma
transparente para o usuário. O
conhecimento das rotinas descritas é muito importante, pois drivers
mal
escritos podem gerar sérios prejuízos, culminando na insatisfação dos
utilizadores.

https://univirtus.uninter.com/ava/web/roa/                  20/22
-----------------------Page 20 End-----------------------

05/05/2022 22:54                            UNINTER

No quarto tema, definimos os controladores de dispositivos, mais uma vez com figuras

ilustrando seu funcionamento, facilitando assim a compreensão desse conjunto de
 componentes,

que aumenta a eficiência e a gestão das E/S. Finalizando a aula, no último tema trabalhamos com

técnicas avançadas de E/S (DMA). O acesso direto à
memória é uma funcionalidade implementada

em CPUs e sistemas computacionais em
 geral, com o objetivo de melhorar o desempenho e

aumentar a velocidade do
 processamento de dados. Em uma definição simples, consiste em

ler/gravar dados
 diretamente em um periférico, sem ocupar a CPU, sendo muito útil em sistemas

com pouco poder de processamento, popular entre os PCs. Evita que a CPU se
 ocupe com a

transferência do bloco para a memória. O controlador de DMA é um
 dispositivo de hardware que

pode fazer parte do computador ou pode ser um
dispositivo independente (Robolivre, 2020).

      A compreensão desses conceitos
 completa o entendimento das atividades de gestão dos
principais componentes do
 hardware do computador (CPU, memórias e dispositivos de E/S)
desenvolvidos
 pelos sistemas computacionais. Nas aulas seguintes, vamos ampliar esse
conhecimento,
com os conceitos de atividades de gerência e proteção de arquivos e usuários.
Não
perca!

REFERÊNCIAS

      BAGGIO, M. Sistemas
 Operacionais. IFSul, 2018. Disponível em:
 <https://sites.google.com/
site/ifsulmiguel/>. Acesso em: 20 out. 2020.

      COUTINHO, B. C. Sistemas
Operacionais. Colatina: CEAD / IFES, 2010.

      DEITEL;
P. J.; DEITEL, H. Java How to Program, Early Objects. London:
Pearson, 2017.

      GUARDIA, H. C.; SENGER,
 H. Gerenciamento de Entrada e Saída. São Carlos: UFSCar,
2015.

      MACHADO, F. B.; MAIA,
 P. L. Arquitetura de Sistemas Operacionais. 4. ed. Curitiba: LTC,
2007.

      MAZIERO, C. Sistemas
 Operacionais: Conceitos e Mecanismos. Curitiba: Editora UFPR,
2019.

https://univirtus.uninter.com/ava/web/roa/                                                 21/22
-----------------------Page 21 End-----------------------

05/05/2022 22:54                            UNINTER

MELO NETO, A. Gerência
 de Dispositivos. USP, São Paulo, 2014. Disponível em:

<https://www.ime.usp.br/~adao/AGD.pdf>.
Acesso em: 20 out. 2020.

      NIGRI, A. Sistemas
 Operacionais – Parte 1. Winco, 2018. Disponível em:
<https://blog.winco.com.br/sistemas-operacionais-parte-1/>. Acesso em: 20
out. 2020.

      OLIVEIRA, R. S.;
 CARISSIMI, A. S.; TOSCANI, S. S. Sistemas Operacionais. 7. ed. Porto
Alegre: Bookman, 2010.

      ROBOLIVRE – Plataforma
 Robótica Livre. DMA: Acesso Direto à Memória. Disponível em:
<http://www.roboliv.re/conteudo/dma-acesso-direto-a-memoria>. Acesso em:
20 out. 2020.

      SILBERSCHATZ, A.; GALVIN,
P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de Janeiro:
Campus, 2016.  

      SIQUEIRA, F. Sistemas
 Operacionais. Disponível em:
 <https://sites.google.com/site/
proffernandosiqueiraso/>. Acesso em: 20
out. 2020.

      SOUSA FILHO G. F.;
ALEXANDRE, E. S. M. Introdução à computação. João Pessoa: Editora
da
 UFPB, 2013. Disponível em:
 <http://producao.virtual.ufpb.br/books/camyle/introducao-a-
computacao-livro/livro/livro.pdf>.
Acesso em: 20 out. 2020.

      ZAMBIASI, S. P. Sistemas
Operacionais: Gerência de Dispositivos. Florianópolis: UFSC, 2011.
Disponível em: <https://www.gsigma.ufsc.br/~popov/aulas/so1/>. Acesso em:
20 out. 2020.

https://univirtus.uninter.com/ava/web/roa/                        22/22
-----------------------Page 22 End-----------------------
----------------------------------------------------------------------------------------------------------------------
uninter sistemas operacionais aula 5

05/05/2022 22:55  UNINTER

                                                                          1/29
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
             
             
             
             
             

  SISTEMAS OPERACIONAIS

      AULA 5
             
             
             
             
             
             
             
             
             
             
            Prof. André Roberto Guerra

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 1 End-----------------------

05/05/2022 22:55                            UNINTER

CONVERSA INICIAL

      Os sistemas computacionais (os
 computadores) possuem como principais componentes do
hardware a CPU, as
 memórias os dispositivos de E/S, que são gerenciados pelo software de
sistema, o sistema operacional, todos descritos e apresentados anteriormente e
agora, nesta aula,
serão complementados pela gestão de arquivos, considerada
 como a principal ferramenta de
interação entre o usuário e o sistema de
computação.

      A parte mais visível de um sistema
 operacional é o seu sistema de arquivos. Programas
aplicativos utilizam o
sistema de arquivos (via chamadas de sistema) para criar, ler, gravar e remover
arquivos. Usuários utilizam interativamente o sistema de arquivos (via shell)
 para listar, alterar
propriedades e remover arquivos. A conveniência e a
facilidade de uso de um sistema operacional
são fortemente determinadas pela
 interface, estrutura e contabilidade de seu sistema de arquivos
(Unicamp, S.d.)

      Desde os primórdios da computação,
 percebeu-se a necessidade de armazenar informações
para uso posterior, como
programas e dados.

                                           Figura 1 – Arquivos e pastas digitais

https://univirtus.uninter.com/ava/web/roa/           2/29
-----------------------Page 2 End-----------------------

05/05/2022 22:55  UNINTER

                                                            Créditos: Andrea Danti/Shutterstock.

      Hoje, parte importante do uso de um
 computador consiste em recuperar e apresentar
informações previamente armazenadas,
como documentos, fotografias, músicas e vídeos. O próprio
SO também precisa
 manter informações armazenadas para uso posterior, como programas,
bibliotecas
e configurações.

                                      Figura 2 –
Visualização de arquivos digitais

                                                                Créditos: Nata-Lia/Shutterstock.  3/29

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 3 End-----------------------

05/05/2022 22:55                              UNINTER

Para simplificar o armazenamento e a
busca dessas informações, surgiu o conceito de arquivo.

Portanto, os
 sistemas operacionais são responsáveis (também) pelo controle e gestão segura e

controle do armazenamento e uso de arquivos.

      Nesta aula, apresentaremos nos
 próximos capítulos os principais conceitos relacionados a
arquivos, seu uso e a
forma como são implementados e gerenciados pelo sistema operacional, nos
cinco seguintes temas:

Conceitos
e definições de arquivos;
Acesso (utilização);
Estrutura de diretórios, subdiretórios e atalhos;
Armazenamento de dados (arquivos) a longo prazo;
O sistema de arquivos e seus tipos.

TEMA 1 – CONCEITOS E DEFINIÇÕES DE ARQUIVOS

      Os arquivos de um sistema de computação (ou
 simplesmente computador) são formados por
informações logicamente relacionadas,
 podendo representar programas (instruções) ou dados.
Também definidos como um
 conjunto de registros definidos pelo sistema de arquivos que será
apresentado
no tema 5 desta aula.

      Para Tannenbaum (2016), os arquivos podem ser
 entendidos como uma sequência de bytes
não interpretadas pelo sistema,
 dependendo-se de aplicações apropriadas para sua correta
utilização, sendo um
poderoso mecanismo de abstração que permite ao usuário e seus programas
utilizarem dados armazenados dentro do sistema computacional.

      É por meio da manipulação dos arquivos que são
realizadas as operações de escrita e a leitura
de dados de forma transparente,
 evitando que sejam conhecidos detalhes do funcionamento, com
que essas
operações tratam e armazenam a informação.

      Em sua forma mais simples, segundo Maziero (2019),
 um arquivo contém basicamente uma
sequência de bytes, que pode ser
estruturada de forma a representar diferentes tipos de informação,
como
 imagens, música, textos ou código executável. Essa estrutura interna do arquivo
 pode ser
entendida pelo kernel (núcleo do sistema operacional) ou
 somente pelas aplicações que acessam
esse conteúdo.

https://univirtus.uninter.com/ava/web/roa/             4/29
-----------------------Page 4 End-----------------------

05/05/2022 22:55                            UNINTER

O kernel geralmente reconhece apenas
 alguns poucos formatos de arquivos, como binários

executáveis e bibliotecas. Os
 demais formatos de arquivos são vistos pelo núcleo apenas como

sequências de bytes
 opacas, sem um significado específico, cabendo às aplicações interessadas

interpretá-las.

      Uma aplicação pode definir um formato próprio
 para armazenar seus dados, ou pode seguir
formatos padronizados. Por exemplo,
 há um grande número de formatos padronizados para o
armazenamento de imagens,
 como JPEG, GIF, PNG e TIFF, mas também existem formatos de
arquivos
proprietários, definidos por algumas aplicações específicas, como os formatos
PSD e XCF
(dos editores gráficos Adobe Photoshop e GIMP, respectivamente).

      Mas a adoção de um formato proprietário ou
 exclusivo limita o uso das informações
armazenadas, pois somente aplicações que
reconheçam aquele formato específico conseguem ler
corretamente as informações do
arquivo.

                  Figura 3 –
Identificação de arquivos digitais

                                                                Créditos: Tele52/Shutterstock.

      A organização dos arquivos, segundo (Cunha,
2017), consiste no modo como os dados estão
internamente armazenados, podendo
 ter uma estrutura de acordo com a função do tipo de
informação contida no
arquivo.

https://univirtus.uninter.com/ava/web/roa/                       5/29
-----------------------Page 5 End-----------------------

05/05/2022 22:55                            UNINTER

Maziero (2019) apresenta o arquivo como uma
unidade de armazenamento de informações, e

que além de seu conteúdo, um arquivo
 é caracterizado por atributos ou metadados, que são

informações
 adicionais relativas ao conteúdo, e operações ou ações que podem ser realizadas

sobre o conteúdo e/ou sobre os atributos dos arquivos, que variam de acordo com
 o sistema de

arquivos utilizado.

      Os atributos mais usuais presentes na maioria
 dos sistemas, segundo Deitel (2017) e
Tannenbaum (2016), são os seguintes:

Nome: uma string
que identifica o arquivo para o usuário;
Tipo: indicação do formato dos dados contidos
no arquivo, como áudio, vídeo, imagem, texto
etc. Muitos sistemas operacionais
usam parte do nome do arquivo para identificar o tipo de seu
conteúdo, na forma
de uma extensão;
Tamanho: indicação do tamanho (em bytes) do
conteúdo do arquivo;
Datas: para fins de gerência, é importante
manter as datas mais importantes relacionadas ao
arquivo, como suas datas de
criação, de último acesso e de última modificação do conteúdo;
Proprietário: em sistemas multiusuários,
 cada arquivo tem um proprietário, que deve estar
corretamente identificado;
Permissões de acesso: indicam que usuários têm
 acesso àquele arquivo e que formas de
acesso são permitidas (leitura, escrita,
remoção etc.);
Localização: indicação do dispositivo
 físico onde o arquivo se encontra e da posição do
arquivo dentro deste.

      Além desses, vários outros atributos podem ser
 associados a um arquivo, por exemplo para
indicar se ele é um arquivo de
 sistema, se está visível aos usuários, se tem conteúdo binário ou
textual etc.

      Cada sistema de arquivos normalmente define
 seus próprios atributos específicos, além dos
atributos usuais acima. Mas nem
 sempre os atributos oferecidos por um sistema de arquivos são
suficientes para
 exprimir todas as informações a respeito de um arquivo. Nesse caso, a solução
encontrada
pelos usuários é usar o nome do arquivo para registrar a informação desejada.

      Portanto, muitos sistemas operacionais utilizam
a extensão (atributo de tipo) da segunda parte
do nome do arquivo, como uma
 referência para o tipo de seu conteúdo. Particularmente, no SO

https://univirtus.uninter.com/ava/web/roa/           6/29
-----------------------Page 6 End-----------------------

05/05/2022 22:55                            UNINTER

Windows, podem
 ser associadas aplicações a determinadas extensões, auxiliando o usuário, por

exemplo:

Programa.exe
(arquivo executável – instrução);
Texto.txt
(arquivo texto – dados);
Classe.Java
(arquivo texto, código fonte de um aplicativo escrito em Java);
Audiofile.mp3
(arquivo de áudio – formato MP3).

      Para (Maziero, 2019),
a forma mais básica de organização é por meio de uma sequência não
estruturada
 de bytes, cuja organização e interpretação é de inteira responsabilidade
 da aplicação
que irá utilizá-los.

      Um arquivo é essencialmente uma sequência de bytes
 armazenada em um dispositivo físico
não volátil, como um disco rígido ou de
estado sólido, que preserva seu conteúdo mesmo quando
desligado. Cada arquivo
possui um nome ou outra referência, que permita sua localização e acesso.

      Do ponto de vista do usuário e das aplicações,
o arquivo é a unidade básica de armazenamento
de informação em um dispositivo
 não volátil, pois para eles não há forma mais simples de
armazenamento persistente
de dados.

      Arquivos são extremamente versáteis em conteúdo
 e capacidade, podendo conter desde um
texto com alguns poucos caracteres até
vídeos com dezenas de gigabytes, ou ainda mais (Maziero,
2019).

      Cunha, Preuss e Macedo (2017)
 citam que, genericamente, arquivos comuns utilizados pelos
usuários para o
 armazenamento de informações podem ser considerados como do tipo texto,
quando seu conteúdo pode ser visualizado diretamente, ou do tipo binário,
 quando seu conteúdo
precisa ser interpretado por uma aplicação para poder ser
visualizado.

      Os arquivos executáveis também são arquivos
binários, cuja execução é realizada diretamente
pelo SO.

      Alguns sistemas operacionais estabelecem
diferentes organizações de arquivos e cada arquivo
deve seguir a um modelo
 suportado. As organizações mais conhecidas e implementadas são a
sequencial,
relativa e indexada.

https://univirtus.uninter.com/ava/web/roa/                                   7/29
-----------------------Page 7 End-----------------------

05/05/2022 22:55                            UNINTER

Como um dispositivo de armazenamento pode
conter milhões de arquivos, esses arquivos são

então organizados em estruturas
hierárquicas denominadas diretórios para facilitar sua localização e

acesso
pelos usuários.  

      Portanto, se o sistema
 de arquivos é a parte mais visível de um sistema operacional, é muito
importante como os engenheiros e desenvolvedores de sistemas operacionais
 tratam de sua
imagem, afinal cada utilizador tem sua preferência e os SO
 diferem entre si, como ilustram as
imagens. Confiram:

                  Figura 4 – Prompt
de comando de listagem de arquivos Linux

                  Figura 5 – Prompt de comando de listagem de arquivos
Windows

https://univirtus.uninter.com/ava/web/roa/                                      8/29
-----------------------Page 8 End-----------------------

05/05/2022 22:55  UNINTER

                  Figura 6 –
Gerenciador de arquivos Linux

                                      Figura 7 –
Gerenciador de arquivos Windows  9/29

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 9 End-----------------------

05/05/2022 22:55                            UNINTER

TEMA 2 – ACESSO (UTILIZAÇÃO)

      Deitel (2017) define que um sistema de arquivos
 deve permitir que os usuários possam criar,
modificar e eliminar arquivos, bem
como realizar sua duplicação ou a transferência de dados entre
arquivos. Além
 disso, deve possibilitar o compartilhamento de arquivos por meio de mecanismos
controlados e bem definidos. Também é desejável que as operações de cópia de
 segurança dos
arquivos (backup) e sua restauração sejam suportadas e que
 seja possível a adoção ou
implementação de procedimentos de proteção e
 segurança, com uma interface amigável e
consistente, admitindo a
 realização de operações apenas por meio dos nomes simbólicos dos
arquivos,
garantindo independência do dispositivo utilizado.

      O sistema operacional, por meio de seu sistema
 de arquivos, deve prover um conjunto de
operações para manipulação dos arquivos
e de seu conteúdo e também dos diretórios.

      Para Maziero (2019),
 uma vez o arquivo aberto, a aplicação pode ler os dados contidos nele,
modificá-los
ou escrever novos dados. Há várias formas de se lerem ou se escreverem dados em
um arquivo, que dependem da estrutura interna deste. Considerando apenas
 arquivos simples,
vistos como uma sequência de bytes, duas formas de
acesso são usuais: o acesso sequencial e o
acesso aleatório.

https://univirtus.uninter.com/ava/web/roa/           10/29
-----------------------Page 10 End-----------------------

05/05/2022 22:55                            UNINTER

2.1 ACESSO SEQUENCIAL

      No acesso sequencial, os dados são sempre lidos
e/ou escritos em sequência, do início ao final
do arquivo. Para cada arquivo
 aberto por uma aplicação é definido um ponteiro de acesso, que
inicialmente
 aponta para a primeira posição do arquivo. A cada leitura ou escrita, esse
 ponteiro é
incrementado e passa a indicar a posição da próxima leitura ou
escrita. Quando esse ponteiro atinge
o final do arquivo, as leituras não são mais
 permitidas, mas as escritas podem sê-lo, permitindo
acrescentar dados ao final dele.
A chegada do ponteiro ao final do arquivo é normalmente sinalizada
ao processo por
meio de um flag de fim de arquivo (EoF – End-of-File).

2.2 ACESSO ALEATÓRIO

      No método de acesso aleatório (ou direto),
 pode-se indicar a posição no arquivo onde cada
leitura ou escrita deve ocorrer,
sem a necessidade de um ponteiro de posição corrente. Assim, caso
se conheça
 previamente a posição de um determinado dado no arquivo, não há necessidade de
percorrê-lo sequencialmente até encontrar o dado desejado. Essa forma de acesso
 é muito
importante em gerenciadores de bancos de dados e aplicações congêneres,
que precisam acessar
rapidamente as posições do arquivo correspondentes.

      Na prática, a maioria dos sistemas operacionais
usa o acesso sequencial como modo básico de
operação, mas oferece operações
 para mudar a posição do ponteiro de acesso do arquivo caso
necessário, o que
permite então o acesso direto a qualquer registro do arquivo (Maziero,
2019).

      O acesso mapeado em memória é uma forma
particular de acesso aleatório ao conteúdo de um
arquivo. 

O mapeamento em memória faz uso dos mecanismos de paginação em disco. Nessa
modalidade de acesso, o arquivo é associado a um vetor de bytes (ou de registros) de
mesmo tamanho na memória principal, de forma que cada posição do vetor
corresponda à sua posição equivalente no arquivo.

      Quando uma posição específica do vetor na
 memória é lida pela primeira vez, é gerada uma
falta de página. Nesse momento, o
mecanismo de memória virtual intercepta o acesso à memória, lê
o conteúdo
correspondente no arquivo e o deposita no vetor, de forma transparente à
aplicação, que
em seguida pode acessá-lo. Escritas no vetor são transferidas
para o arquivo por um procedimento
similar. Caso o arquivo seja muito grande,
podem-se mapear em memória apenas partes dele.  

https://univirtus.uninter.com/ava/web/roa/           11/29
-----------------------Page 11 End-----------------------

05/05/2022 22:55                            UNINTER

O acesso mapeado em memória é extensivamente
 usado pelo núcleo para carregar código

executável (programas e bibliotecas) na
memória. Como somente as partes efetivamente acessadas

do código serão
carregadas em RAM, esse procedimento é usualmente conhecido como paginação

sob
demanda (demand paging), pois os dados são lidos do arquivo para a
memória em páginas.  

      Alguns sistemas operacionais oferecem também a
possibilidade de acesso indexado aos dados
de um arquivo, que implementa
arquivos cuja estrutura interna pode ser vista como uma tabela de
pares
 chave/valor. Os dados do arquivo são armazenados em registros com chaves (índices)
associados a eles e podem ser recuperados, usando essas chaves como em um banco
 de dados
relacional.

      Como o próprio núcleo desse sistema implementa
 os mecanismos de acesso e indexação do
arquivo, o armazenamento e a busca de
dados nesse tipo de arquivo costumam ser muito rápidos,
dispensando bancos de
 dados para a construção de aplicações mais simples. A maioria dos
sistemas
 operacionais de mercado não implementa essa funcionalidade diretamente no
 núcleo
(Maziero,
2019)

      As aplicações e o sistema operacional usam arquivos
 para armazenar e recuperar dados. O
acesso aos arquivos é feito por meio de um
conjunto de operações, geralmente implementadas sob
a forma de chamadas de
sistema e funções de bibliotecas.  

      Para os arquivos, vistos como unidades, devem
 ser oferecidas operações essenciais, citadas
por Deitel, Deitel
e Choffnes (2017) e por Tannenbaum (2016):

Criação
(create): cria um novo arquivo. a criação de um novo arquivo implica em
alocar espaço
para ele no dispositivo de armazenamento e definir valores para
seus atributos;
Exibição
(type ou list): exibe o conteúdo de um arquivo;
Catalogação
(cat ou dir): lista os arquivos existentes em um determinado
diretório ou unidade;
Abertura
 (open): prepara (abre) o arquivo para uso. Antes que uma aplicação possa
 ler ou
escrever dados em um arquivo, ela deve solicitar ao sistema operacional
 a abertura desse
arquivo. O sistema irá então verificar se o arquivo desejado
existe, verificar se as permissões
associadas ao arquivo permitem aquele
 acesso, localizar seu conteúdo no dispositivo de
armazenamento e criar uma
referência para ele na memória da aplicação;
Cópia
(copy): copia o conteúdo de um arquivo para outro;
Renomeação
(rename): troca o nome do arquivo;

https://univirtus.uninter.com/ava/web/roa/           12/29
-----------------------Page 12 End-----------------------

05/05/2022 22:55                            UNINTER

Modificação
de atributos (get ou set): obtém ou modifica os atributos de um
arquivo;

Fechamento
 (close): encerra o uso do arquivo evitando sua alteração. Ao concluir o
 uso do

arquivo, a aplicação deve informar ao sistema operacional que este não é
mais necessário, a

fim de liberar as estruturas de gerência do arquivo mantidas
na memória do núcleo;

Eliminação
(erase, delete ou destroy): remove (elimina) o arquivo do
dispositivo, descartando

seus dados e liberando o espaço ocupado por ele.    

      Em relação ao conteúdo e à manipulação
 dos dados armazenados nos arquivos, devem
também existir operações para:

Pesquisa
(seek ou find) para determinar uma posição para escrita ou
leitura em um arquivo;
Leitura
(read): possibilita a leitura de dados contidos nos arquivos;
Escrita
(write): efetua a gravação de dados em um arquivo;
Inserção
(insert): inclusão de um dado em um arquivo;
Anexação
(append): adição de novos dados em um arquivo existente;
Atualização
(update): modificação de um dado existente em um arquivo;
Eliminação
(delete): remoção de um dado existente em um arquivo.

      Como muitos sistemas de arquivos suportam diretórios,
 operações específicas devem ser
providas para sua utilização (Tannenbaum,
2016):

Criação
(create): efetua a criação e preparo de um novo diretório;
Navegação
(traverse): permite a navegação entre diretórios do sistema;
Pesquisa
(search): possibilita a localização de arquivos em um diretório;
Leitura
(read) que permite a leitura do conteúdo de um diretório, ou seja, sua
catalogação ou
listagem;
Abertura
(open): operação que permite a leitura de um diretório;
Renomeação
(rename): troca o nome de um diretório;
Fechamento
(close): operação que encerra o uso de um dado diretório;
Remoção
(delete ou remove): elimina um diretório e opcionalmente seu
conteúdo.

      Ainda podem ser possíveis outras operações
 sobre arquivos e diretórios, como inclusão ou
remoção de ligações (links
 e atalhos), obtenção de informações sobre arquivos ou diretórios,
associação
com aplicativos, dentre outras.

https://univirtus.uninter.com/ava/web/roa/                                            13/29
-----------------------Page 13 End-----------------------

05/05/2022 22:55                            UNINTER

Todas as operações suportadas pelo SO para
 manipulação de arquivos e diretórios estão

disponíveis para utilização em
programas por meio das chamadas do sistema (system calls).

TEMA 3 – ESTRUTURA DE DIRETÓRIOS, SUBDIRETÓRIOS E
ATALHOS

      A estrutura de diretórios é um padrão de
 estruturas hierárquicas adotado pela maioria dos
sistemas operacionais,
 utilizado essencialmente para organizar os conteúdos, separando os
arquivos de
 sistema e de usuários, bem como permitir nova organização nas pastas ou
 diretórios
adjacentes.

      As figuras do Tema 1 ilustram exemplos de
estruturas de diretórios dos sistemas operacionais
Linux e Windows,
reapresentados e complementados pelas figuras a seguir:

                                            Figura 8 – Estrutura de diretórios

                                                   Créditos: Mmaxer/Shutterstock.

                                            Figura 9 –
Organização de pastas

                                            Créditos: Kmis/Shutterstock.

https://univirtus.uninter.com/ava/web/roa/                                                 14/29
-----------------------Page 14 End-----------------------

05/05/2022 22:55                            UNINTER

A Unicamp (S.d.) apresenta
 que convém também observar que é possível colocar os

subdiretórios do diretório
 raiz em partições separadas. O objetivo é facilitar a manutenção do

sistema e
aumentar a segurança dos dados.

      Portanto, a distribuição do diretório raiz em
 várias partições é uma escolha pessoal do
administrador do sistema.

      Os sistemas operacionais atuais que aqui foram
apresentados possuem inúmeras ferramentas
(softwares) que auxiliam na
 gestão dos arquivos, acessadas por meio do próprio gerenciador de
arquivos ou
mesmo por meio de outras ferramentas avançadas.

      Ao abrir um arquivo, o sistema operacional
 utiliza o nome do arquivo e o seu diretório ou
caminho (path) que são fornecidos
pelo utilizador, para localizar os blocos do disco associados ao
arquivo. O
 mapeamento do nome nos inodes está associado com a forma como o sistema
 de
diretório encontra-se organizado.

      A estrutura de diretório usada no UNIX é bastante
 simples. Cada entrada contém o nome do
arquivo e o número do seu inode,
 representados por 16 bytes, sendo, 2 bytes para o número do
inode
e 14 bytes para o nome. Todos os diretórios do UNIX são arquivos e podem
conter um número
arbitrário destas entradas de 16 bytes.

      Quando um arquivo é aberto, o sistema deve, por
meio do nome do arquivo, localizar os seus
blocos no disco, caso o nome do
arquivo seja relativo, isto é, associado ao diretório corrente.

      No sistema operacional Linux, é frequentemente sugerido
que os seguintes diretórios possuam
uma partição própria: /root /tmp, /home,
 /opt, /usr e /usr/local, como ilustra a reapresentação da
Figura 6 do Tema 1,
confiram:

                  Figura 10 – Gerenciador de arquivos Linux.

https://univirtus.uninter.com/ava/web/roa/                    15/29
-----------------------Page 15 End-----------------------

05/05/2022 22:55                            UNINTER

                                            Créditos: Kmis/Shutterstock.

TEMA 4 – ARMAZENAMENTO DE DADOS (ARQUIVOS) A LONGO
PRAZO

      Os dispositivos de armazenamento secundário são
 memórias não voláteis, utilizados para
armazenar dados de forma permanente, ou
 seja, de forma confiável e íntegra, mesmo quando o
sistema computacional
 permanece desligado por longos períodos de tempo. Para que isso ocorra
(possa
ser realizado de modo permanente), é necessária uma adequada organização desses
dados
nos dispositivos destinados ao armazenamento secundário, por exemplo: unidades
de disco (HDD,
SSD), flash drives (pendrives), unidades de
fita magnética (DAT) (Cunha; Preuss; Macedo,
2017).

      O sistema operacional controla as operações
 sobre os arquivos, organizando seu
armazenamento no sistema de arquivos (file
 system), que possui um método de acesso, que é a
forma como os dados
são armazenados nos arquivos.

      O sistema de arquivos é o responsável pelo gerenciamento
 de arquivos, um conjunto de
mecanismos de armazenamento, referência,
 compartilhamento e segurança. Também possui
mecanismos de integridade
 que asseguram que os dados de um arquivo permanecem íntegros
(Deitel, 2017).

https://univirtus.uninter.com/ava/web/roa/                                16/29
-----------------------Page 16 End-----------------------

05/05/2022 22:55                            UNINTER

O gerenciamento de espaço em disco é uma
 importante tarefa para o armazenamento, pois

como apresentado, os arquivos são
 normalmente armazenados em dispositivos de memória

secundária (disco). Para o
armazenamento há duas possíveis estratégias para armazenamento em

um arquivo
com n bytes: n bytes consecutivos do disco são alocados;
ou o arquivo é dividido em um

número de blocos não necessariamente contíguos. A
 mesma política está presente no sistema de

gerenciamento de memória entre a
segmentação pura e a paginação.

      Armazenar um arquivo como uma sequência contígua
 de bytes apresenta um problema óbvio
que é o crescimento do arquivo, uma
 ocorrência muito comum. O arquivo provavelmente terá que
ser movido no disco. O
mesmo problema é apresentado para segmentação na memória, exceto que
mover um
segmento na memória é uma operação relativamente mais rápida.

      Por essa razão, normalmente todos os sistemas
de arquivos armazenam os arquivos em blocos
de tamanho fixo, que não precisam
 ser adjacentes, salvo alguns sistemas operacionais,
notadamente os voltados à computação
de tempo real, cujo armazenamento contínuo é adotado por
razões de desempenho.

      Uma vez decidido armazenar arquivos em blocos
de tamanho fixo, a questão é definir qual será
o tamanho do bloco a ser usado. Devido
à forma como os discos são organizados, os setores, as
trilhas e os cilindros são
candidatos óbvios para a unidade de alocação.

      Uma unidade de alocação grande, tal como um
 cilindro, implica que muitos arquivos, até
mesmo arquivos de 1 byte,
deverão ocupar o cilindro inteiro. Por outro lado, usar uma unidade de
alocação
 pequena, significa que cada arquivo terá muitos blocos. A leitura de cada bloco
normalmente requer uma busca e uma latência rotacional. Assim, a leitura de
arquivos consistindo
de muitos blocos pequenos será lenta.

      É compromisso usual escolher um bloco de
 tamanho 512, 1K ou 2K bytes. Se um bloco de
tamanho 1K for escolhido em um
disco com setor de 512 bytes, então o sistema de arquivo sempre
irá ler ou
escrever em dois setores consecutivos, e tratá-los como uma unidade indivisível.

      Uma vez escolhido o tamanho do bloco, a próxima
questão é como manter o rastreamento de
blocos livres no disco. Dois métodos são
largamente usados e apresentados a seguir.

      O primeiro, ilustrado na Figura 11, consiste no
 uso de uma lista ligada de blocos, com cada
elemento da lista armazenando
 tantos blocos livres quanto possível. Com elementos de 1K e o

https://univirtus.uninter.com/ava/web/roa/                        17/29
-----------------------Page 17 End-----------------------

05/05/2022 22:55                            UNINTER

número do bloco
de 16 bits, cada elemento na lista de blocos livre armazena 511 blocos livres.
Um

disco com 20 gigabytes necessita de uma lista ocupando aproximadamente 40K
blocos para apontar

para todos os 20G blocos do disco (ou seja, a lista ocupa
0,2% do disco).

                  Figura 11 – Blocos livres armazenados em lista ligada

      Uma outra técnica de gerenciamento de espaço
livre é o mapa de bits. Um disco com n blocos
necessita de um mapa de
bits com n bits. Blocos livres são representados por 1s no mapa de bits;
blocos alocados por 0s (ou vice-versa). Um disco com 20 Gigabytes necessita de 20M
bits para o
mapa, volume equivalente a 2500 blocos (ou seja, o mapa ocupa
apenas 0,013% do disco).

      Não é surpresa que um mapa de bit
 necessite de menos espaço, desde que usa um bit por
bloco, versus
 16 bits da lista ligada. Entretanto, para um disco cheio (com poucos blocos livres)
 a
lista ligada necessita de menos espaço que o mapa de bits.

      No armazenamento de arquivos, se um arquivo
 consistir de uma sequência de blocos, o
sistema de arquivos deve ter uma maneira
de acessar todos os blocos do arquivo.

      Como visto acima, um método possível consiste em
 armazenar os blocos de um arquivo em
uma lista ligada. Cada bloco de disco de
1024 ou 33 blocos para encontrar o dado. Ler 33 blocos
para buscar um dado, é inaceitável.

Entretanto, a ideia de representar um arquivo
 como uma lista encadeada, pode ser ainda

explorada se mantermos os ponteiros em
 memória. A Figura 12 mostra o esquema de alocação

https://univirtus.uninter.com/ava/web/roa/                                 18/29
-----------------------Page 18 End-----------------------

05/05/2022 22:55                            UNINTER

usado pelo MS-DOS.

      Nesse exemplo, temos três arquivos, A
com os blocos 6,8,4 e 2; B com os blocos 5, 9 e 12; e C
com os
 blocos 10, 3 e 13 bytes, contém 1022 bytes de dados e um ponteiro
 de 2 bytes para o
próximo elemento da lista.

      Esse método tem duas desvantagens, entretanto.
Primeiro, o número de bytes de dados em um
elemento da lista não é uma potência
 de 2, o que frequentemente é uma desvantagem para sua
manipulação.

      Segundo, e mais sério, o acesso aleatório é de difícil
implementação. Se um programa busca o
byte 32768 de um arquivo, o
sistema operacional tem que percorrer 32768/1022.

                                            Figura 12 – Mapa
de bits

      A
 forma de armazenamento consiste em dispor os dados em setores ou blocos
 consecutivos
nas unidades de disco, porém, como os arquivos são constantemente
modificados e eliminados, a
alocação não consegue manter um arquivo de forma
sequencial.

Esse fato provoca o que se chama de fragmentação,
quando começam a surgir setores livres

entre os setores ocupados. Se o arquivo
aumenta de tamanho, um novo setor, provavelmente bem

longe do último ocupado,
 será alocado para dar continuidade nos dados do arquivo, deixando o

arquivo
 fragmentado. Se o tamanho do arquivo for reduzido, um espaço no sistema de
 arquivos

ficará ocioso e gerará uma fragmentação do sistema de arquivos.

https://univirtus.uninter.com/ava/web/roa/                            19/29
-----------------------Page 19 End-----------------------

05/05/2022 22:55                                  UNINTER

Normalmente os SO oferecem algum tipo de
utilitário que realiza a desfragmentação do sistema

de arquivos, movendo os
arquivos de modos que todos os blocos de cada arquivo fiquem de modo

contíguo e
que não haja espaço vazio entre eles.

      Para definir um sistema de arquivos em um disco
ou unidade de armazenamento, é necessário
realizar o particionamento do disco,
criando as partições, em que cada partição é independente das
outras, ou seja,
cada partição pode ter o seu próprio sistema de arquivos.

      Dessa forma, podemos, por exemplo, instalar o
Linux em uma partição e o Windows em outra
partição, em um mesmo disco rígido. A
 tabela, onde são armazenadas as informações sobre as
partições, fica no
 primeiro setor do disco e chama-se MBR (Master Boot Record). O MBR é um
padrão antigo que define a estrutura das partições, mantendo a informação sobre
como as partições
lógicas estão organizadas no disco.

      Usando essa estrutura, há algumas limitações. Um
 disco pode dividir-se em um máximo de 4
partições primárias ou em até 3
partições primárias e 1 partição estendida. Uma partição estendida
pode
 dividir-se em múltiplas partições lógicas. Cada partição primária e lógica tem
 a sua própria
unidade.

      Como o MBR usa 32 bits para guardar informações
das partições, cada partição apenas pode
ter um tamanho máximo de 2 TB e toda a
informação das partições é guardada apenas em um único
local, o MBR.

      Os novos sistemas computacionais permitem o uso
 de GPT (Tabela de Partição Guid), que é
uma nova forma de realizar o
 particionamento de discos rígidos. O GPT traz muitos benefícios
comparativamente ao tradicional MBR (Master boot record), entre os quais
se destacam:

Suporte
para partições bem maiores do que 2 TB;
Suporte
para até 128 partições primárias;
Melhor
estrutura/ organização ao nível das partições;
Mecanismos
para detecção de dados e partições corrompidas;
Aumento
 da probabilidade de recuperação de dados, na existência de setores do disco
danificados, uma vez que tem um cabeçalho secundário (Secondary GPT Header)
 que
funciona como backup da tabela de partições;
Manutenção
da compatibilidade com o MBR, para sistemas legados.

https://univirtus.uninter.com/ava/web/roa/                 20/29
-----------------------Page 20 End-----------------------

05/05/2022 22:55                            UNINTER

Depois de realizado o particionamento do disco
é necessário realizar a formatação da partição,

escolhendo um sistema de
arquivos para esta, de acordo com o SO que vai ser usado.

TEMA 5 – SISTEMA DE ARQUIVOS E SEUS TIPOS

      Do ponto de vista do usuário, o aspecto mais
importante do sistema de arquivos é como este se
apresenta, isto é, o que
constitui um arquivo, como os arquivos são identificados e protegidos, que
operações são permitidas sobre os arquivos, e assim por diante.

5.1 FUNDAMENTOS BÁSICOS DOS SISTEMAS DE ARQUIVOS

      A maior parte dos sistemas operacionais trazem
a seguinte proposta para armazenamento de
informação: permitir aos usuários deﬁnir
 objetos chamados arquivos, que podem armazenar
programas, dados, ou qualquer
outra informação.

      Esses arquivos não são parte endereçável de nenhum
processo e o sistema operacional provê
chamadas de sistema para criar,
 destruir, ler, atualizar e proteger arquivos. Todos os sistemas
operacionais
visam uma independência dos dispositivos de armazenamento, permitindo acessar
um
arquivo sem especificar em qual dispositivo este se encontra fisicamente
armazenado.

      Um programa que lê um arquivo de entrada e
escreve um arquivo de saída deve ser capaz de
operar com arquivos armazenados
 em quaisquer dispositivos, sem necessidade de um código
especial para
explicitar o tipo de periférico.

      Alguns sistemas operacionais proveem maior independência
 dos dispositivos de
armazenamento que outros.

      No UNIX, por exemplo, um sistema de arquivos
pode ser montado em qualquer dispositivo de
armazenamento, permitindo que qualquer
arquivo seja acessado pelo seu nome (path name), sem
considerar o dispositivo
físico.

      No MS-DOS, por outro lado, o usuário deve especificar
 em qual dispositivo cada arquivo se
encontra (exceto quando um dispositivo é default
e for omitido). Assim, se o dispositivo default for o
drive C, para
executar um programa localizado no drive A com arquivos de entrada e de saída
no

https://univirtus.uninter.com/ava/web/roa/                                          21/29
-----------------------Page 21 End-----------------------

05/05/2022 22:55                                UNINTER

drive B, cada um deles dever ser especificado juntamente com o nome
 do arquivo, seguindo o

modelo: A:programa < B:entrada > B:saída

5.2 TIPOS DE SISTEMAS DE ARQUIVOS

      A Figura 13 apresenta alguns tipos de sistemas
 de arquivos, comuns à maioria dos sistemas
operacionais. Confiram:

                  Figura 13 – Tipos de sistemas de arquivos do GParted Linux

      Os
 principais tipos de Sistemas de arquivos, de acordo com os sistemas
 operacionais mais
usuais e formato nativo de arquivos, são:

Para os sistemas operacionais Apple Macintosh:

      HFS – Hierarchical File System:
é um sistema de arquivos desenvolvido pela Apple Computer
para uso em
computadores rodando o Mac OS, também pode ser referenciado como HFS Standard
e Mac OS Standard, sendo que o seu sucessor HFS Plus também é
 chamado HFS Extended ou
Mac OS Extended;

Para os sistemas operacionais Unix
(FreeBSD, OpenBSD, Linux, Solaris):

UFS: o Unix
File System (UFS), é um sistema de arquivos usado por simplesmente FFS. É o
sistema original do tipo i-nodes;
SWAP: sistema de arquivo para o arquivo de
paginação da memória virtual do Linux;

https://univirtus.uninter.com/ava/web/roa/                                    22/29
-----------------------Page 22 End-----------------------

05/05/2022 22:55                            UNINTER

Reiser: criado por Hans Reiser e inicialmente
mantido pela empresa Namesys, o ReiserFS foi

o primeiro sistema de arquivos com
suporte a journaling incluído no kernel do Linux;

Ext2 (second extended file system):
 sistema de arquivos para dispositivos de blocos (disco

rígido, disquete, pendrive).
O Ext2 foi projetado e implementado para corrigir as deficiências do

Ext e
prover um sistema que respeitasse a semântica do Unix;

Ext3: o Ext3 (third extended file system)
é um sistema de arquivos desenvolvido para o Linux,

que acrescenta o recurso de
journaling ao Ext2. O journaling é o controle de transações que

permite desfazer uma operação que falhou e voltar ao último estado seguro do
sistema;

Ext4: sistema de arquivos do Linux
desenvolvido para ser o sucessor do Ext3 a partir de 2006.

As novas
 funcionalidades propostas são: alocação tardia (delay ed allocation);
 marcas

temporais com maior resolução (nanossegundos) verificação de integridade
do journal (jornal

check sums) e suporte para tamanhos maiores de
volumes e arquivos;

XFS: sistema de arquivos inicialmente
 desenvolvido pela Silicon Graphics Inc. para o seu

sistema operacional
 IRIX. Posteriormente teve seu código fonte liberado e foi adaptado para

funcionar no Linux. Usa alocação dinâmica de i-nodes e journaling;

HPFS: sistema de arquivos utilizado pelo OS/2
da IBM, com recursos que se aproximam muito

dos permitidos pelo NTFS como nome
de arquivos com até 254 caracteres incluindo espaços,

partições de até 512 GB e
unidades de alocação de 512 bytes. Embora muito eficiente, esse

sistema
 de arquivos caiu em desuso juntamente com o OS/ 2, sendo suportado atualmente

somente pelo Linux;

JFS: o Journaling File System é um
sistema de arquivos desenvolvido pela IBM, disponível em

licença open-source,
 com o intuito de ser utilizado nos UNIXes que a IBM vendia. Além de

possuir journal,
ele permite que as partições do sistema sejam redimensionadas sem que seja

necessário desligar o computador.

      O sistema de arquivos JFS também usa a
 estrutura i-node para armazenar a localização dos
blocos de cada arquivo
nas estruturas físicas do disco, a versão JFS2 armazena esses i-nodes em
uma árvore binária para acelerar o acesso a essas informações;

Para os sistemas operacionais Microsoft MS-DOS/
Windows:

FAT16 ou
FAT: sistema básico usado no MS-DOS da década de 90 e nos sistemas Windows
atuais.
Suporta somente nomes com 8 caracteres e extensão de 3 caracteres;

https://univirtus.uninter.com/ava/web/roa/                                             23/29
-----------------------Page 23 End-----------------------

05/05/2022 22:55                            UNINTER

FAT32: usado nos sistemas últimos MS-DOS e Windows.
 Tem suporte a nomes longos e é

largamente usado em pendrives e cartões
de memória, devido à simplicidade da sua estrutura.

Apresenta uma limitação de
que o maior arquivo não pode exceder 4GB;

NTFS: usado nos Windows atuais, apresenta um
algo grau de confiabilidade com controle de

permissões de usuários, suporte à
criptografia e compactação;

Para
os discos ópticos (CDs/DVDs/BDs (BluRay Disc)

IS09660: padrão internacional que especifica como
os dados são fisicamente gravados no CD
(setor por setor) em uma árvore de
diretório (até oito níveis de diretórios). CD-ROMs criados
de acordo com as
 especificações ISO 9660 Nível 1 podem ser lidos em vários sistemas
operacionais
(Macintosh, DOS, Windows e Linux);
Joliet: padrão desenvolvido pela Microsoft para
 o Windows 95 que permite que CDs sejam
gravados usando nomes de arquivo longos.
O padrão Joliet permite usar nomes de arquivos
com até 64 caracteres de
comprimento, incluindo espaços, e também permite usar caracteres
Unicode para
 um melhor suporte internacional. O padrão Joliet grava o nome de arquivo
padrão
DOS associado (8 + 3 caracteres) para cada arquivo de modo que o CD possa ser
lido
em sistemas DOS ou em versões anteriores do Windows;
RockRidge: extensão que permite nomes
 longos para o IS09660 file system, usado com o
Linux;
El Torito: pode ser usado para produzir
CD-ROMs bootáveis (inicializáveis);
UDF: Universal Disk Format é um padrão
 desenvolvido pela Optical Storage Technology
Association (OSTA) e é um
 sistema de arquivos usado com tecnologias de disco óptico, tal
como DVD e
 BluRay Disc. Este padrão é particularmente útil na gravação de arquivos muito
grandes (maiores que 1 GB). O sistema de arquivos UDF permite uma maior
flexibilidade em
comparação com os sistemas Joliet ou ISO 9660.

      Diferentes sistemas operacionais podem usar
 diferentes sistemas de arquivos. Atualmente, o
NTFS (New Technology File
 System) é o sistema de arquivos padrão do Windows, já o Ext4 é o
mais usado
no Linux.

5.3 SISTEMAS DE ARQUIVOS WINDOWS

https://univirtus.uninter.com/ava/web/roa/                            24/29
-----------------------Page 24 End-----------------------

05/05/2022 22:55                            UNINTER

O NTFS (New Technology File System) é um
sistema de arquivos que surgiu juntamente com o

lançamento do Windows NT. Por
apresentar excelente desempenho e confiabilidade, foi adotado nas

várias
versões Windows.

      O NTFS possui várias características, em caso
de falhas, por exemplo, quando o computador
tem um desligamento repentino, ele
tem a capacidade de reverter os dados para a condição anterior
ao problema. O
NTFS também possui a característica de suportar uma replicação de dados,
controle
de permissões de acesso e possui muita eficiência no trabalho com
 grandes arquivos e também
unidades de discos bastante cheias. Suporta
criptografia, indexação e compactação.

      Cada unidade ou volume de disco é identificada
com uma letra, começando por padrão com C.
Armazena as estruturas de controle
do sistema de arquivos em duas áreas distintas do disco para
garantir a
integridade, no caso de falha em uma área do disco.

5.4 SISTEMAS DE ARQUIVOS LINUX

      O Linux é um SO que dá suporte a diversos sistemas
 de arquivos. Atualmente, o sistema de
arquivos mais utilizado é o ext4
desenvolvido para ser o sucessor do ext3 a partir de 2006. O Ext4
apresenta
inúmeros novos aprimoramentos quanto a desempenho, escalabilidade e
confiabilidade e
suporta sistemas de arquivos de até 1 exabyte (um bilhão
de Gigabytes).

      Apresenta uma performance considerada
 muito boa, principalmente para o seu uso em
máquinas de grande porte, superando
a capacidade de armazenamento do EXT3. O novo sistema
de journaling do
EXT4 melhora a quantidade de arquivos e processos suportados pelo Linux.

      Devido à alocação tardia, existe uma
considerável redução de fragmentação, por ele melhorar
nas decisões do sistema
 sobre o arquivo levando em consideração o tamanho deste, porém isso
apresenta
riscos de ocorrência de perda de dados em caso de desligamentos abruptos.

      No Linux, um diretório (corresponde ao conceito
 de pasta do Windows) pode ter outros
diretórios (subdiretórios) ou arquivos. O
diretório acima, onde um subdiretório foi criado, é chamado
de diretório pai.

      O Linux implementa um sistema de arquivos
 baseado nos i-nodes do Unix, em que há uma
tabela na unidade de armazenamento
 onde são controlados os nomes, permissões e atributos de
cada arquivo ou
diretório, bem como os endereços dos blocos iniciais de cada arquivo ou
diretório.

https://univirtus.uninter.com/ava/web/roa/           25/29
-----------------------Page 25 End-----------------------

05/05/2022 22:55  UNINTER

Os demais endereços das partes de cada arquivo ou diretório são
gravados espalhados pelo disco,

próximos aos blocos dos respectivos arquivos e
diretórios.

      O diretório raiz do Linux (ou diretório/) é o
 diretório com maior hierarquia entre todos os
diretórios do sistema. Isto
significa que todos os diretórios do Linux ficam abaixo deste diretório. A
Figura
14 apresenta alguns exemplos de diretórios que ficam abaixo do diretório raiz:

                  Figura 14 – Prompt
de comando de listagem de arquivos Linux

      bin – diretório com os comandos
disponíveis para os usuários (não privilegiados);  26/29
      boot – diretório com os arquivos
do boot de inicialização;
      dev – diretório com as definições
dos dispositivos de entrada/saída;
      etc – diretório com os arquivos
de configuração do sistema;
      home – diretório que armazena os
diretórios dos usuários do sistema;
      lib – diretório com as
bibliotecas e módulos (carregáveis) do sistema;
      mnt – diretório usado para
montagem de partições;
      proc – diretório com informações
sobre os processos do sistema;

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 26 End-----------------------

05/05/2022 22:55                            UNINTER

root – diretório home do root
(administrador do sistema);

sbin – diretório com os
aplicativos usados na administração do sistema;

tmp – diretório com arquivos
temporários;

usr – diretório com aplicativos e
arquivos utilizados pelos usuários;

var – diretório com arquivos de
dados variáveis (spool, logs etc.).

FINALIZANDO

      Nesta aula foi apresentado o
 principal componente responsável pela interface ou interação
humano computador,
pois os arquivos são frequentemente a justificativa de acesso ao
 dispositivo.
Apresentados e explicados os termos que definem os arquivos e a
 sua gerência, em especial no
primeiro tema, numa visão geral, com diversas
imagens que auxiliam.

      No segundo tema, foram apresentados os conteúdos que descrevem que, após efetuado o
acesso ao(s) arquivo(s) de forma sequencial
 e/ou aleatória, o sistema deve oferecer. Além das
operações
 essenciais, devem também existir operações para o conteúdo e a manipulação
 dos
dados armazenados nos arquivos, e para muitos sistemas de arquivos que
 suportam diretórios,
devem ser oferecidas operações específicas.

      No tema seguinte, foi a vez
das definições das estruturas de diretórios,
subdiretórios e atalhos,
com a tarefa de localizar os seus blocos no disco, por
meio do nome do arquivo, quando associado
ao diretório corrente, com o objetivo
de facilitar a manutenção do sistema e aumentar a segurança
dos dados.

      O armazenamento de dados (arquivos) a longo prazo é o quarto tema, e
nele foram definidos e
apresentados inicialmente as operações sobre
os arquivos, que organizam seu armazenamento no
sistema de arquivos (file
system) com um método de acesso (forma como dados são armazenados
nos
arquivos).

      Ao final, o sistema de arquivos e seus tipos fecham a conceituação e as
 definições, com a
proposta para armazenamento de informação de permitir aos
 usuários deﬁnir arquivos, armazenar

https://univirtus.uninter.com/ava/web/roa/                               27/29
-----------------------Page 27 End-----------------------

05/05/2022 22:55                            UNINTER

programas, dados, ou qualquer outra
informação, com o detalhamento dos tipos especiais para os

sistemas
operacionais Apple Macintosh, Microsoft e Unix.

REFERÊNCIAS

      CUNHA, G. B., PREUSS, E.,
MACEDO, R. T. Sistemas operacionais. Santa Maria, RS: UFSM,
2017.

      DEITEL, P. J., DEITEL,
 H. M., CHOFFNES, D. R. Sistemas operacionais. 3. ed. São Paulo:
Pearson,
2017.

      GUIA LINUX. Sistemas de
 arquivos. Guia Linux, S.d.                        Disponível  em:
<https://guialinux.uniriotec.br/sistemas-de-arquivos/>.
Acesso em: 2 nov. 2020.

      MACHADO, F. B.; MAIA, P.
 L. Arquitetura de sistemas operacionais. 4. ed. Rio de Janeiro:
LTC, 2014.

MAZIERO, C. Sistemas
operacionais: conceitos e mecanismos. Ed. da
UFPR, 2019.

      SILBERSCHATZ,
 A.; GAGNE, G.; GALVIN, P. B. Operating system concepts. New
 Jersey:
Wiley, 2018.

      SILBERSCHATZ, A.;
GALVIN, P. B.; GAGNE, G. Sistemas operacionais com Java. 8. ed. Rio
de
Janeiro: Campus, 2016.  

      STALLINGS,
 W. Operating systems: internals and design principles. 9. ed.
 São Paulo:
Pearson, 2017.

      TANENBAUM, A. S.; BOS,
H. Sistemas operacionais modernos. 4. ed. São Paulo: Pearson,
2016.

      TANENBAUM, A. S.;
WOODHULL, A. S. Sistemas operacionais: projeto e implementação 3.
ed. Porto
Alegre: Bookman, 2008.

      UNICAMP – Universidade
 Estadual de                   Campinas.            Disponível  em:
<https://www.unicamp.br/unicamp/>.
Acesso em: 2 nov. 2020.

https://univirtus.uninter.com/ava/web/roa/                                                   28/29
-----------------------Page 28 End-----------------------

05/05/2022 22:55                            UNINTER

https://univirtus.uninter.com/ava/web/roa/           29/29
-----------------------Page 29 End-----------------------

----------------------------------------------------------------------------------------------------------------------

uninter sistemas operacionais aula 6

05/05/2022 22:56  UNINTER

                                                                          1/24
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
             
             
             
             
             

  SISTEMAS OPERACIONAIS

      AULA 6
             
             
             
             
             
             
             
             
             
             
            Prof. André Roberto Guerra

https://univirtus.uninter.com/ava/web/roa/
-----------------------Page 1 End-----------------------

05/05/2022 22:56                            UNINTER

CONVERSA INICIAL

      Desde a nossa primeira aula, são
 apresentados conceitos e definidos termos relacionados à
gerência dos sistemas
de computação. Agora, finalizamos o conteúdo das aulas com a gerência de
proteção de arquivos e usuários, tema atual e essencial para a boa gestão do
 item mais precioso
dos sistemas, os dados e informações dos usuários,
armazenados nos arquivos.

De alguma forma, tudo o que desenvolvemos e produzimos está digitalizado, seja no
smartphone, seja no flash drive portátil, na central multimídia de um veículo, no relógio (smartwatch),
nos óculos (smartglasses) ou em qualquer outro dispositivo vestível (weareble);
 e, principalmente, nos computadores tradicionais, nos desktops, nas workstations,
 nos servidores; e, atualmente, na nuvem (cloud computing), em
 grandes data centers especializados das gigantes da tecnologia da
informação (TI) (exemplos: Google, Microsoft, Apple, Oracle, Amazon).

E essas preciosas informações são alvo dos cibercriminosos, que, das mais diversas formas
(exemplo: crypto-ransomware WannaCry[1]), buscam a propriedade da informação,
 ou seja, as credenciais que permitam total controle sobre os arquivos, desde o
simples acesso de leitura até a total e absoluta exclusão de dados, gerando
 grandes prejuízos, pois todos sabemos o valor de
nossos dados, desde as mais simples conversas com contados até as mais elaboradas fórmulas e
projetos. Com os mais diversos propósitos, desde conhecer e explorar nossos hábitos até obter
nossas informações mais confidenciais e sigilosas (dados econômicos/financeiros,
privados etc.), os cibercriminosos, conhecedores desse valor e preparados para
explorar as “brechas” de segurança, são contratados para executarem ataques a
 sistemas vulneráveis, em que se desconhece ou simplesmente se negligencia um
 melhor cuidado da informação, e que não utilizam os padrões e políticas de
 segurança adequados, visando à manutenção da confidencialidade, disponibilidade
 e integridade dos dados. Nesses casos, os cibercriminosos conquistam altas
 taxas de sucesso em suas investidas.

https://univirtus.uninter.com/ava/web/roa/           2/24
-----------------------Page 2 End-----------------------

05/05/2022 22:56                            UNINTER

Mas aqueles que conhecem as
 definições e práticas de gestão de proteção de arquivos,

fazendo o uso dos
 procedimentos recomendados, conseguem níveis satisfatórios de defesa e

proteção
 contra esses ataques e ameaças, preparando-se da melhor forma contra eles. Devido
 a

tamanha complexidade, há cursos superiores específicos sobre cibersegurança,
além da certificação

profissional de empresas especializadas. Contudo, todas as
técnicas de ataque e defesa envolvem

diretamente os arquivos de usuários e os sistemas
operacionais que os geram e mantêm. Portanto,

conhecer as definições e
propriedades alinhadas às tarefas de gestão apresentadas nas atividades

práticas fornece o conhecimento inicial para uma preparação que exige formação
 continuada em

cursos mais específicos e avançados.

      Para Maziero (2019), a segurança de um sistema de computação diz respeito à garantia de
algumas propriedades fundamentais associadas às informações e recursos
 presentes em um
sistema. Provavelmente, é em seu computador pessoal que a
maioria dos seus dados está gravada
e é por meio dele que você acessa redes e
 realiza transações bancárias e comerciais. Por isso,
mantê-lo seguro é
essencial para se proteger dos riscos (Maziero, 2019). Muitas vezes, os
atacantes
estão interessados no acesso a uma grande quantidade de devices,
 independentemente de quais
são e das configurações que possuem. Por isso,
acreditar que seu computador está protegido, por
ele supostamente não
apresentar atrativos para um atacante, pode ser um grande erro (Cert, 2016).

      Os conteúdos previstos
para esta aula teórica abrangem a gerência e a proteção de usuários,
que
serão individualmente descritas e apresentadas nos cinco
temas a seguir:

1.
Conceitos
e definições de segurança;

2. Riscos, ameaças e vulnerabilidades;

3. Criptografia;

4. Autenticação, gerenciamento e controle de acesso;

5. Gerenciamento e proteção de usuários.

Aproveite e bons estudos!

TEMA 1 – CONCEITOS E DEFINIÇÕES DE SEGURANÇA

https://univirtus.uninter.com/ava/web/roa/            3/24
-----------------------Page 3 End-----------------------

05/05/2022 22:56                            UNINTER

O professor Luis Gonzaga de Paulo
 apresenta, na reportagem intitulada Aumento de ataques

cibernéticos alertam
para a necessidade de se ter cuidados com a proteção, que:

                                    Um ataque
 cibernético é um evento que tem por objetivo atingir as bases da segurança da
                                    informação: a confidencialidade, a integridade e a disponibilidade da
informação. Para tanto usam
                                    técnicas, métodos e ferramentas com o propósito de
ter acesso indevido a informações restritas,
                                    falsificar, alterar ou destruir
informações de valor ou tornar inviável o uso dessas informações ou o
                                    acesso a
 elas. Geralmente são parte de planos bem orquestrados por quadrilhas do crime
                                    organizado, mas pode ser executado de forma amadora, por alguém com algum
 conhecimento
                                    técnico ou mesmo um aprendiz, ou por serviços de espionagem e
 grupos terroristas. É bom
                                    salientar que nem sempre o ataque é motivado por
 interesses financeiros, embora esse seja o
                                    principal fator em grande parte dos
ataques. (Paulo, 2020, citado por Zanluca, 2020)

      Em português, a palavra segurança
 abrange muitos significados distintos e por vezes
conflitantes, como define Maziero
 (2019). Em inglês, as palavras security, safety
 e reliability
permitem definir mais precisamente os diversos aspectos da
 segurança: a palavra security se
relaciona a ameaças intencionais, como
intrusões, ataques e roubo de informações; a palavra safety
se relaciona
a problemas que possam ser causados pelo sistema aos seus usuários ou ao
ambiente,
como acidentes provocados por erros de programação; por fim, o termo reliability
 é usado para
indicar sistemas confiáveis, construídos para tolerar erros de
software, de hardware ou dos usuários
(Avizienis et al., 2004; Maziero, 2019).

      Nesta aula, serão considerados
 somente os aspectos de segurança relacionados ao termo
security, ou
 seja, à proteção do sistema contra ameaças intencionais. Trataremos dos
 principais
conceitos de segurança, como propriedades e princípios de segurança,
ameaças, vulnerabilidades e
ataques típicos em sistemas operacionais,
 concluindo com uma descrição da infraestrutura de
segurança típica de um
sistema operacional. Grande parte dos tópicos de segurança apresentados
não são
 exclusivos de sistemas operacionais, se aplicam a sistemas de computação em
 geral
(Maziero,
2019).

      Outras boas definições dos
 termos segurança e seguro podem ser obtidas no Michaelis
dicionário
brasileiro da língua portuguesa (2015):

                  segurança
                  [...]
                  2 Estado do que se
acha seguro ou firme; estabilidade, solidez.

https://univirtus.uninter.com/ava/web/roa/                                         4/24
-----------------------Page 4 End-----------------------

05/05/2022 22:56                                                                        UNINTER

                  [...]
                  5 Condição ou
estado do que está livre de danos ou riscos.
                  6 Crença ou
opinião firme; certeza, confiança, firmeza [...].
                  [...]
                  seguro
                  [...]
                  3 Que envolve
pouco ou nenhum risco; eficaz, garantido [...].
                  4 Livre de perigo
ou não exposto a ele; protegido, testo.
                  [...]
                  6 Que oferece
 segurança contra ataques, acidentes, desastres ou danos de qualquer outra
                  natureza [...].
                  [...]
                  11 Que não oferece
dúvida; certo, incontestável, indubitável.
                  12 Em que se pode
crer ou ter confiança [...]. (Michaelis, 2015)

1.1 INFORMAÇÃO

      Em complemento à definição de
 segurança, torna-se necessária a definição de informação,
pois, como descrito
pelo professor Luis Gonzaga de Paulo (2020),

                                    vivemos na
 Era da Informação, e produzimos, armazenamos e movemos diariamente uma
                                    quantidade incalculável de informação. Apesar da quantidade de informação ter
passado por um
                                    grande impulso a partir da invenção da imprensa, por Gutemberg,
 foi a partir do final do século
                                    XVIII, com a invenção da fotografia, seguida do
 telégrafo – que inaugurou a era das
                                    telecomunicações – que a quantidade de
informação produzida, disponível e transportada ganhou
                                    tamanha proporção.

      Numa reflexão sobre o que é
 informação, temos, então, nomes, números, imagens e sons,
sensações, enfim,
tudo que podemos experimentar com nossos sentidos – e, além deles, com o uso
da
tecnologia – e que tenha algum uso, propósito, que possa ser utilizado por meio
da razão ou da
emoção, tudo isso é informação. E tudo isso tem valor, um valor
mensurável ou não (Paulo, 2020).

https://univirtus.uninter.com/ava/web/roa/  5/24
-----------------------Page 5 End-----------------------

05/05/2022 22:56                            UNINTER

Mas, na TI, o conceito de
 informação é diferenciado, a começar pela separação entre

informação e dados.
 Dados são elementos, valores, grandezas medidas e ainda por analisar ou

processar por meio de recursos computacionais. Informações são os resultados
 dessa análise ou

processamento, que, mediante processos e regras definidas,
 tornam-se inteligíveis e utilizáveis

pelos seres humanos. Entretanto, ambos –
 dados ou informações – têm um valor intrínseco,

requerendo um tratamento pelo
qual possam manter sua utilidade e seu valor (Paulo, 2020).

      A norma ABNT NBR ISO/IEC
 27002:2103 define informação como um ativo – isto é, bem,
patrimônio – de uma
 organização, de grande importância e valor e que, por isso, necessita de
proteção adequada (ABNT, 2013). Para isso, deve-se considerar a informação em
 suas diversas
formas e nos diversos meios utilizados para obtê-la, armazená-la,
transportá-la e modificá-la:

                  O valor da
 informação vai além das palavras escritas, números e imagens: conhecimentos,
                  conceito, ideias e marcas são exemplos de formas intangíveis da informação. Em
 um mundo
                  interconectado, a informação e os processos relacionados, sistemas,
redes e pessoas envolvidas
                  nas suas operações são informações que, como os
 outros ativos importantes, têm valor para o
                  negócio da organização e,
 consequentemente requerem proteção contra vários riscos. (ABNT,
                  2013)

      Devido à grande diversidade de
informações, no ambiente pessoal e no ambiente corporativo, é
necessário classificar
 as informações, isto é, diferenciá-las em função de níveis e critérios
específicos, como a sua natureza, o seu valor e o seu grau de importância. Esses
critérios e níveis
podem definir o grau de sigilo e confidencialidade a ser
aplicado à informação. É também em função
desses critérios que serão definidos
 os mecanismos de controle e proteção das informações.
Certamente, você já ouviu
 ou leu a respeito de informações confidenciais, secretas, de caráter
reservado ou público. São exemplos de classificações para
 informações que determinam quem,
quando e onde pode-se ter acesso, transportar
 ou modificar determinadas informações (Paulo,
2020).

      De maneira semelhante aos
 arquivos e tarefas, conforme definido nas aulas anteriores, a
informação também
percorre um ciclo de vida, isto é, um período compreendido entre a
criação ou
origem da informação e o momento em que ela pode ser descartada.
Durante esse ciclo de vida, a
informação é manuseada, manipulada ou tratada,
 podendo sofrer alterações, desde que
controladas, de modo a não perder seu
valor. Ela também pode ser armazenada ou transportada –
submetida a processos
que, entretanto, não mudam seu significado ou valor. Nesse ciclo de vida, a

https://univirtus.uninter.com/ava/web/roa/                                                 6/24
-----------------------Page 6 End-----------------------

05/05/2022 22:56                            UNINTER

informação também está exposta a riscos – isto é, está vulnerável –, por
exemplo, o roubo, a perda

ou a alteração indevida. Para evitar que isso ocorra,
é necessário proteger a informação e monitorar

seu ciclo de vida por completo.
 Esse é o principal objetivo da segurança da informação (Paulo,

2020).

                                            Figura
1 – Ciclo de vida da informação

                                            Fonte: Paulo, 2020.

1.2 SEGURANÇA DA INFORMAÇÃO

      Para se garantir a segurança
da informação, é necessário que os seguintes princípios básicos
sejam
respeitados:

       Confidencialidade: deve-se
assegurar que a informação será acessível somente a quem tem
       autorização de
acesso;
       Integridade: deve-se
assegurar que a informação não foi alterada durante o seu processo de
       transporte;
       Disponibilidade: deve-se
assegurar que usuários autorizados tenham acesso a informações e
       recursos a estas
associados, quando por eles requeridos (Projetos, 2019).

      Além desses princípios básicos,
outras propriedades importantes estão geralmente associadas
à segurança de um
sistema, segundo Maziero (2019):

       Autenticidade: todas as entidades de um
 sistema são autênticas ou genuínas; em outras
       palavras, os dados associados a
 essas entidades são verdadeiros e correspondem às
       informações do mundo real que
elas representam, como as identidades dos usuários, a origem
       dos dados de um
arquivo etc.
       Irretratabilidade: todas
 as ações realizadas no sistema são conhecidas e não podem ser
       escondidas ou
 negadas por seus autores; essa propriedade também é conhecida como
       irrefutabilidade
ou não repúdio.

https://univirtus.uninter.com/ava/web/roa/                                          7/24
-----------------------Page 7 End-----------------------

05/05/2022 22:56                            UNINTER

É função do sistema
 operacional garantir a manutenção das propriedades de segurança para

todos os
recursos sob sua responsabilidade. Essas propriedades podem estar sujeitas a
violações

decorrentes de erros humanos ou de software, praticadas por indivíduos
 mal-intencionados

(maliciosos), internos ou externos ao sistema (Maziero,
2019).

De acordo com a norma ABNT NBR
ISO/IEC 27002:2013:

                  A segurança
 da informação é alcançada pela implementação de um conjunto adequado de
                  controles, incluindo políticas, processos, procedimentos, estrutura
 organizacional e funções de
                  software e hardware. Estes controles precisam ser
 estabelecidos, implementados, monitorados,
                  analisados criticamente e
 melhorados, quando necessário, para assegurar que os objetivos do
                  negócio e a
segurança da informação sejam atendidos. (ABNT, 2013)

1.3 PRINCÍPIOS DE SEGURANÇA DA INFORMAÇÃO

      Além das técnicas usuais de engenharia
 de software usadas para a produção de sistemas
corretos, segundo Maziero
(2019), a construção de sistemas computacionais seguros é pautada por
uma
 série de princípios específicos, relativos tanto à construção do sistema quanto
 ao
comportamento dos usuários e dos atacantes. Alguns dos princípios mais
 relevantes, compilados
por Maziero (2019), são indicados a seguir:

       Privilégio mínimo: todos os usuários e programas devem operar com o mínimo possível
 de
       privilégios ou permissões de acesso necessários para poderem funcionar.
 Dessa forma, os
       danos provocados por erros ou ações maliciosas intencionais
serão, também, minimizados.
       Separação de privilégios: sistemas de proteção baseados em mais de um controle ou regra
       são mais robustos, pois, se o atacante conseguir burlar um dos controles, mesmo
assim não
       terá acesso ao recurso. Em um sistema bancário, por exemplo, uma
 operação de valor
       elevado pode requerer a autorização de dois gerentes.
       Mediação completa: todos os acessos a recursos, tanto diretos quanto indiretos,
devem ser
       verificados pelos mecanismos de segurança. Eles devem estar dispostos
 de forma a ser
       impossível contorná-los.
       Default seguro: o mecanismo de segurança deve
 identificar claramente os acessos
       permitidos; caso um certo acesso não seja
 explicitamente permitido, ele deve ser negado.
       Esse princípio impede que
 acessos inicialmente não previstos no projeto do sistema sejam
       inadvertidamente
autorizados.

https://univirtus.uninter.com/ava/web/roa/                      8/24
-----------------------Page 8 End-----------------------

05/05/2022 22:56                               UNINTER

Economia de mecanismo: o projeto de um sistema de proteção deve ser pequeno e simples,

para que possa ser facilmente e profundamente analisado, testado e validado.

Compartilhamento mínimo: mecanismos compartilhados entre usuários são fontes potenciais

de problemas de segurança, devido à possibilidade de haver fluxos de informação
imprevistos,

entre usuários. Por isso, o uso de mecanismos compartilhados deve
ser minimizado, sobretudo

se envolver áreas de memória compartilhadas. Por
exemplo, caso uma funcionalidade de um

sistema operacional possa ser
implementada como chamada a um núcleo ou como função de

biblioteca, deve-se
preferir essa última forma, pois envolve menos compartilhamento.

Projeto aberto: a robustez do mecanismo de proteção não deve depender da
ignorância dos

atacantes; ao invés disso, o projeto deve ser público e aberto,
 dependendo somente do

segredo de poucos itens, como listas de senhas ou chaves
 criptográficas. Um projeto aberto

também torna possível a sua avaliação por
 terceiros independentes, provendo confirmação

adicional da segurança do
mecanismo.

Proteção adequada: cada recurso computacional deve ter um nível de proteção
coerente com

seu valor intrínseco. Por exemplo, o nível de proteção requerido
 em um servidor web de

serviços bancários é bem distinto daquele de um terminal
público de acesso à internet.

Facilidade de uso: o uso dos mecanismos de segurança deve ser fácil e intuitivo,
 caso

contrário eles serão evitados pelos usuários.

Eficiência: os
 mecanismos de segurança devem ser eficientes no uso dos recursos

computacionais, de forma a não afetarem significativamente o desempenho do
sistema ou as

atividades de seus usuários.

Elo mais fraco: a segurança do sistema é limitada pela segurança de seu elemento
 mais

vulnerável, seja ele o sistema operacional, sejam as aplicações, a conexão
 de rede ou o

próprio usuário.

      Esses princípios devem pautar a
 construção, configuração e operação de qualquer sistema
computacional com
requisitos de segurança. A maioria dos problemas de segurança dos sistemas
atuais provém da não observação desses princípios (Maziero,
2019).

TEMA 2 – RISCOS, AMEAÇAS E VULNERABILIDADES

      Como mencionado por Paulo (2020), a
informação está sujeita a riscos, seja no seu processo
de produção e manuseio,
 seja no seu armazenamento ou em seu transporte por qualquer meio.

https://univirtus.uninter.com/ava/web/roa/                                              9/24
-----------------------Page 9 End-----------------------

05/05/2022 22:56                            UNINTER

Esses riscos
 são decorrência dos diversos fatores envolvidos nesses processos: pessoas,

tecnologias, ambientes, fenômenos naturais e o seu próprio desgaste ou fadiga
pelo uso.

      “Os incidentes, isto é, as
 ocorrências que transformam a possibilidade do risco em um
acontecimento, um
 fato, podem comprometer uma ou mais características da segurança da
informação”
(Paulo, 2020), com probabilidade de que uma ameaça venha a explorar ou agir em
face
de uma vulnerabilidade, gerando um incidente de segurança da informação
 que fira aspectos
básicos da segurança da informação, identificados com o
 acrônimo CID: confidencialidade,
integridade e disponibilidade (Paulo, 2020),
conforme apresentado no item 1.2.

      Por meio de registros históricos,
da análise matemática ou estatística, é possível determinar a
probabilidade da
ocorrência do risco e o impacto que essa ocorrência – ou incidente – pode
causar
nos negócios. Ao processo de avaliação de riscos executado dessa maneira
denomina-se análise de
riscos (Paulo, 2020).

      Para o professor Carlos Alberto
Maziero (2019), ameaça pode ser considerada qualquer ação
que coloque em risco
as propriedades de segurança do sistema descritas na seção anterior. Alguns
exemplos de ameaças às propriedades básicas de segurança seriam:

Ameaças à confidencialidade: um processo vasculhar as áreas de memória de outros
processos,
 arquivos de outros usuários, o tráfego de rede nas interfaces locais ou áreas
 do
núcleo do sistema, buscando acesso a dados sensíveis como números de cartão
 de crédito,
senhas, conteúdos de e-mails privados etc.
Ameaças à integridade: um processo alterar as senhas de outros usuários, instalar
programas, drivers ou módulos de núcleo maliciosos, visando obter o
 controle do sistema,
roubar informações ou impedir o acesso de outros usuários.
Ameaças à disponibilidade: um usuário alocar para si todos os recursos do sistema, como a
memória, o processador ou o espaço em disco, para impedir que outros usuários
 possam
utilizá-lo (Maziero, 2019).

      Para Paulo (2020),
as ameaças são agentes ou eventos que, podendo explorar ou agir perante
uma vulnerabilidade, representam um risco.

      Para evitar incidentes de segurança da
 informação, uma organização necessita conhecer e
gerenciar seus ativos –
 incluindo-se, entre esses, as informações de valor – e as suas

https://univirtus.uninter.com/ava/web/roa/                                               10/24
-----------------------Page 10 End-----------------------

05/05/2022 22:56                            UNINTER

vulnerabilidades.
 O processo de identificação e avaliação dos ativos, asset assessment ou

inventário, deve, então, identificar, descrever e localizar cada ativo, seu uso
 e controles de

segurança atuais e as ameaças às quais eles estão expostos ou
submetidos (Paulo, 2020).

      Maziero (2019) conclui
que, obviamente, para cada ameaça possível, devem existir estruturas,
no
 sistema operacional, que impeçam sua ocorrência, como controles de acesso às
 áreas de
memória e arquivos, quotas de uso de memória e processador,
 verificação de autenticidade de
drivers e outros softwares etc. As
ameaças podem ou não se concretizar, dependendo da existência
e da correção dos
 mecanismos construídos para evitá-las ou impedi-las. As ameaças podem se
tornar
realidade na medida em que existam vulnerabilidades que permitam sua ocorrência
(Maziero,
2019)

      Como já visto e apresentado
por Paulo (2020), a
informação é um valioso ativo – isto é, um bem
ou patrimônio da organização. No
entanto, para fazer uso desse valioso bem, de forma a empregá-lo
adequadamente
 ao processo produtivo da organização, é necessário prover meios para interagir
com a informação no seu ciclo de vida. Esses meios são os ativos da informação
ou da TI.

      Os ativos compreendem uma
vasta gama de dispositivos, equipamentos e componentes, desde
os circuitos de
 comunicação de dados até os softwares – os programas –, passando por redes,
meios
 de armazenamento, computadores e periféricos. Cada ativo está sujeito a
 incidentes que
podem influenciar na segurança da informação, seja pelo seu uso
intenso, por se tratar de uma nova
tecnologia cuja efetividade na segurança da
 informação ainda não foi comprovada; seja por haver
interesses escusos em
relação ao seu possível alto valor. Enfim,
tais ativos estão expostos a falhas
de segurança da informação, possuindo
 pontos fracos que podem vir a ser explorados ou
apresentarem comportamento
incompatível, fraquezas, às quais denominamos vulnerabilidades. Ou
seja,
 vulnerabilidades são pontos fracos, nos ativos da informação, que podem ser
 explorados ou
fazê-los apresentar falhas, gerando incidentes de segurança da
informação (Paulo, 2020).

      Além disso, para Paulo (2020), estendendo o conceito de ativos às pessoas e
 processos da
organização que atuam no ciclo de vida da informação, é possível
 afirmar que esses elementos
também apresentam vulnerabilidades. Isso porque um
 suborno, a corrupção, a omissão ou uma
ação proposital podem gerar incidentes
de segurança da informação, ou seja, pessoas e processos
também apresentam
vulnerabilidades.

https://univirtus.uninter.com/ava/web/roa/                                               11/24
-----------------------Page 11 End-----------------------

05/05/2022 22:56                            UNINTER

Tanto indivíduos quanto empresas são
vulneráveis a roubos de dados e a ataques que podem

comprometer dados, corromper
 arquivos e provocar a queda de sistemas. A indústria da

computação procura
 atender essas necessidades com suas organizações, trabalhando para

melhorar a
segurança computacional. Por exemplo, a iniciativa de computação confiável
proposta

pelo presidente da Microsoft, Bill Gates, é um esforço para concentrar
a prioridade das empresas no

fornecimento de aplicações confiáveis, disponíveis
e seguras (Deitel; Deitel; Choffnes, 2017).

      Para o professor Carlos
Alberto Maziero (2019), uma vulnerabilidade é um defeito ou problema
presente na especificação, implementação, configuração ou operação de um software
 ou sistema,
que possa ser explorado para violar as suas propriedades de
segurança. Dentre alguns exemplos de
vulnerabilidades, vale destacar:

um erro de programação no serviço de
compartilhamento de arquivos, que permita a usuários
externos o acesso a outros
arquivos do computador local, além daqueles compartilhados;
uma
conta de usuário sem senha, ou com uma senha predefinida pelo
fabricante, que permita
a usuários não autorizados acessarem o sistema;
a
ausência de quotas de disco, permitindo a um único usuário alocar
todo o espaço em disco
para si e assim impedir os demais usuários de usarem o
sistema (Maziero, 2019).

      Em sua versão 2.404, o sistema operacional
 Windows 10 lançou o kernel data protect –
proteção de dados do kernel
(KDP), uma nova tecnologia que evita ataques de corrupção de dados,
protegendo partes do kernel e drivers do Windows por meio da
segurança baseada em virtualização
(VBS). A KDP é um conjunto de interfaces de programação
 de aplicativos (APIs) que permitem
marcar algumas memórias do kernel
 como somente para leitura, impedindo que invasores
modifiquem a memória
 protegida. Por exemplo, invasores usam drivers de dispositivos assinados,
mas vulneráveis, para atacar estruturas de dados de políticas e instalar um driver
mal-intencionado
não assinado. A KDP atenua esses ataques, garantindo que as
estruturas de dados da política não
possam ser violadas (Microsoft, 2020).

TEMA 3 – CRIPTOGRAFIA

      O termo criptografia tem sua origem no
 grego kryptós (escondido, oculto, secreto) e gráphos
(grafia, escrita). É a arte ou a ciência de escrever em cifra ou
 em código. Assim, a criptografia foi
criada para codificar informações, por
meio da formulação de um conjunto de técnicas que permitem

https://univirtus.uninter.com/ava/web/roa/                                                      12/24
-----------------------Page 12 End-----------------------

05/05/2022 22:56                             UNINTER

tornar
incompreensível uma mensagem originalmente escrita com clareza, de forma a
permitir que

somente as pessoas autorizadas (seu remetente e seu destinatário)
 a decifrem e compreendam,

com acesso ao seu conteúdo (Maziero, 2019).

      Conceitualmente, segundo Maziero (2019), a
criptografia faz parte de um escopo mais amplo de
conhecimento, que envolve:

Criptografia: conjunto
 de técnicas para codificar/decodificar informações, ocultando seu
conteúdo de
pessoas não autorizadas a acessá-las.
Criptanálise: conjunto de técnicas usadas
 para “quebrar” uma criptografia, expondo a
informação ocultada por ela.
Criptologia: área geral, englobando
criptografia e criptanálise.
Criptossistema: conjunto de
 algoritmos/mecanismos para realizar um tipo específico de
criptografia.

      As técnicas criptográficas são extensivamente
usadas na segurança de sistemas, para garantir
a confidencialidade e
integridade dos dados. Além disso, elas desempenham um papel importante
na
autenticação de usuários e recursos (Maziero, 2019). Pistelli ([S.d.])
apresenta que a criptologia é
uma ciência muito antiga, já presente no sistema
de escrita hieroglífica dos egípcios, há quase 4 mil
anos. Ela “também foi usada na antiga Roma, onde os soldados
 simplesmente substituíam umas
letras por outras, tornando assim, impossível para
 os inimigos ler as mensagens, pois somente o
remetente e o destinatário
possuíam o código capaz de decifrar o conteúdo das mensagens” (Paiva;
López,
 2002). “Desde então vem sendo muito utilizada, principalmente para fins
 militares e
diplomáticos [...]. Sua utilização durante a Segunda Guerra, e a
 consequentemente quebra dos
códigos alemão e japonês, foi fundamental para o
sucesso dos Aliados” (Pistelli, [S.d.], p. 1).

3.1 OBJETIVOS DA CRIPTOGRAFIA

      “O uso da criptografia tem como objetivo garantir
 que uma mensagem ou informação só será
lida e compreendida pelo destinatário
autorizado para isso” (Mota, 2006, p. 44).

      Os objetivos do uso da criptografia são quatro,
conforme a seguir descritos:

             1. Confidencialidade: deve-se
assegurar, por meio de encriptação dos dados, que só os
       receptores autorizados
tenham acesso às informações.

https://univirtus.uninter.com/ava/web/roa/            13/24
-----------------------Page 13 End-----------------------

05/05/2022 22:56                            UNINTER

2.
Integridade: deve-se
assegurar, por meio de assinatura digital, que a informação não

seja alterada
durante o seu processo de transporte da informação.

      3.
Autenticação: o remetente
e o receptor devem poder confirmar as identidades uns dos
outros, assim como a
 origem e o destino da informação, por meio de assinatura digital e
certificados.

      4.
Não recusa: o
criador/remetente do documento deve poder assiná-lo de forma digital,
limitando
legalmente a sua responsabilidade, por meio de assinatura digital e certificados.

3.2 TIPOS DE CRIPTOGRAFIA

      Existem dois tipos básicos de criptografia: a criptografia
simétrica e a criptografia assimétrica.

      Para Cavalcante (2019), a criptografia simétrica
 ou de chave secreta foi o primeiro tipo de
criptografia criado. Funciona
transformando um texto em uma mensagem cifrada, mediante definição
de uma chave
 secreta, que será utilizada, posteriormente, para descriptografar a mensagem,
tornando-a novamente um texto simples (Cavalcante, 2019). Os algoritmos
simétricos usam chaves
simétricas e um algoritmo de bloco, como DES, Desx, Idea,
RC2, RC4, Blowfish, para criptografar e
descriptografar dados. Ela tem por:

                                    ÖVantagem – Rapidez na criptografia e
decriptografia das informações.

                                    ÖDesvantagem – A chave secreta deve
ser transmitida ou comunicada para o receptor, tornando-a
                                    mais vulnerável a
roubo.

                                    [...]

                                    A Criptografia
 Assimétrica, [...] também conhecida como de chave pública, utiliza duas chaves,
                                    uma para cifrar o texto ou mensagem, e outra para decifrar. Pode ser empregada
para assinatura
                                    digital e autenticação. É possível combinar a criptografia
simétrica com a assimétrica, somando a
                                    segurança com a rapidez.

                                    Vantagens - mais segura que a
 criptografia simétrica, por não precisar comunicar o receptor a
                                    chave
necessária para decriptografar a mensagem e, pode ser utilizada em assinatura
digital

                                    Desvantagem - costuma ser mais lenta
do que a criptografia simétrica (Celestino, 2005, p. 30-31).

      Já a assinatura digital é um código,
 incluído na mensagem ou no texto, que identifica o
remetente de uma mensagem. A
 mensagem ou texto é criptografado(a) com uma chave privada,

https://univirtus.uninter.com/ava/web/roa/                         14/24
-----------------------Page 14 End-----------------------

05/05/2022 22:56                            UNINTER

criando uma espécie
 de assinatura.  Para essa mensagem ser descriptografada, é utilizada uma

chave
pública.

3.3 PUBLIC KEY INFRASTRUCTURE (PKI)

      A UFRGS ([20--]) define que a public key
infrastructure (PKI) se refere a um processo que utiliza
chaves públicas e certificados
digitais para garantir a segurança do sistema e confirmar a identidade
de seus
usuários. Rodrigues (2009) apresenta o seguinte exemplo:

                  uma empresa pode usar a
PKI para controlar o acesso a sua rede de computadores. No futuro, as
                  empresas
poderiam usar a PKI para controlar o acesso a tudo, desde a entrada nos prédios
até a
                  obtenção de mercadorias.

                  A PKI permite que
pessoas e empresas realizem negócios em particular. Os funcionários podem
                  enviar e-mails pela Internet com segurança, sem se preocupar com a sua
 interceptação por um
                  concorrente. As empresas podem construir sites privativos,
 enviando informações somente para
                  clientes conhecidos.

                  A PKI baseia-se em um
 sistema de confiança, no qual duas partes (pessoas ou computadores)
                  confiam
mutuamente em uma CA (Autoridade Certificadora) para verificar e confirmar a
identidade
                  de ambas as partes.

                  Por exemplo, a maioria
das pessoas e empresas confia na validade de uma carteira de habilitação
                  de
motorista ou em um passaporte. Isto ocorre porque elas confiam na forma pela
qual o governo
                  emite estes documentos. Entretanto, uma caderneta de estudante é
 normalmente aceita como
                  prova de sua identificação apenas para a escola que a
emite. O mesmo vale para os Certificados
                  Digitais.

                  Com a PKI, ambas as
partes de uma transação (seja ela um banco on-line e seus clientes ou um
                  empregador e seus funcionários) concordam em confiar na CA que emite seus
 Certificados
                  Digitais.

                  Normalmente, o
 aplicativo de software que utiliza seu Certificado Digital tem algum mecanismo
                  para confiar nas CAs. Por exemplo, um navegador contém uma lista das CAs em que
 confia.
                  Quando é apresentado ao navegador um Certificado Digital (por exemplo,
de um shopping on-line
                  realizando comércio seguro), ele consulta a CA que
emitiu o Certificado Digital. Se a CA estiver na
                  lista de CAs confiáveis, o
navegador aceita a identidade do site da Web e exibe a página da Web.
                  Entretanto,
se a CA não estiver na lista de CAs confiáveis, o navegador exibe uma mensagem
de
                  aviso que lhe pergunta se você deseja confiar na nova CA. Geralmente seu
 navegador lhe dá
                  opções para confiar permanente ou temporariamente na CA ou não
 confiar em absoluto. Como
                  usuário, você tem controle sobre em qual(is) CA(s) deseja
 confiar, porém o gerenciamento da
                  confiança é feito pelo aplicativo de software
(neste exemplo, pelo navegador). (Rodrigues, 2009)

https://univirtus.uninter.com/ava/web/roa/           15/24
-----------------------Page 15 End-----------------------

05/05/2022 22:56                            UNINTER

TEMA 4 – AUTENTICAÇÃO, GERENCIAMENTO E CONTROLE DE

ACESSO

      “Você não pode confiar em um código que você
 mesmo não tenha criado inteiramente (em
especial, códigos de empresas que
empregam pessoas como eu)”, diz Thompson (1983, citado por
Deitel; Deitel;
Choffnes, 2017).

                  Segurança de
computadores aborda a questão da prevenção do acesso não autorizado a recursos
                  e informações mantidos em computadores. Sistemas de computador devem fornecer
mecanismos
                  para gerenciar ameaças à segurança originadas tanto externamente ao
computador (via conexão
                  de rede), quanto internamente (via usuários e softwares
 mal-intencionados). Segurança de
                  computador comumente abrange garantir a
 privacidade e a integridade de dados sensíveis,
                  restringir a utilização de
 recursos de computação e oferecer proteção contra tentativas de
                  incapacitar o
 sistema. Proteção abrange mecanismos que protegem recursos como hardware
 e
                  serviços de sistemas operacionais contra ataques. A segurança está se tomando
rapidamente um
                  dos tópicos mais ricos e desafiadores da computação; a segurança
do sistema operacional está no
                  âmago de um sistema de computação seguro. (Ribeiro,
2005, p. 153)

4.1 AUTENTICAÇÃO

      Para Ribeiro (2005, p. 157-159,
grifos nossos),

                                    Identificar
usuários e as ações que eles têm permissão de realizar é vital para manter a
segurança
                                    de um sistema de computador. Um usuário pode ser identificado por:

                                    • Uma característica
 exclusiva da pessoa (impressões digitais, impressões vocais, varredura de
                                    retina e assinaturas) [algo que o usuário é];

                                    • Propriedades de um
item (crachás, carteiras de identidade, chaves e cartões inteligentes) [algo
                                    que o usuário tem]; e

                                    • Conhecimento do
 usuário (senhas, números de identificação pessoal (PINs) e combinações de
                                    travas) [algo que o usuário sabe].

                                    [...]

                                    O esquema de
 autenticação mais comum é uma simples proteção por senha, onde o usuário
                                    escolhe e memoriza um código secreto e o registra no sistema para obter
admissão a um recurso
                                    ou sistema. A maioria dos sistemas suprime a exibição da
senha na tela, substituindo seu texto por
                                    caracteres mascaradores (que
 apresentam caracteres fictícios – quase sempre asteriscos — no
                                    lugar dos da
senha) ou ocultando a entrada da senha.

https://univirtus.uninter.com/ava/web/roa/           16/24
-----------------------Page 16 End-----------------------

05/05/2022 22:56                                                                        UNINTER

                  A proteção por senha
introduz diversos pontos fracos em um sistema seguro. Usuários tendem a
                  escolher senhas fáceis de lembrar, como o nome de um cônjuge ou de um animal de
estimação.
                  Alguém que tenha obtido informações pessoais do usuário poderia
 tentar o acesso ao sistema
                  (login) várias vezes, usando senhas
 correspondentes às características do usuário; várias
                  tentativas repetidas
 podem resultar em uma violação da segurança. Alguns sistemas antigos
                  limitavam
 o usuário a senhas curtas; esses eram facilmente comprometidos simplesmente
 pela
                  tentativa de todas as senhas possíveis – uma técnica conhecida por quebra
por força bruta.

                  A maioria dos sistemas
 de hoje exige senhas mais longas que incluem caracteres alfabéticos e
                  numéricos
para frustrar as tentativas de invasão. Alguns sistemas até mesmo proíbem a
utilização
                  de palavras do dicionário como valores de senhas. Contudo, senhas
 longas não melhoram
                  necessariamente a segurança de um sistema; se elas forem
difíceis de lembrar os usuários ficarão
                  mais inclinados a anotá-las,
facilitando a obtenção da senha por um intruso.

                  A invasão das defesas
 de um sistema operacional não precisa resultar necessariamente em um
                  comprometimento significativo da segurança. Por exemplo, suponha que um intruso
consiga obter
                  acesso à lista mestra de senhas de um sistema. Se o arquivo de
 senhas estivesse armazenado
                  em texto comum, essa invasão permitiria ao intruso
o acesso a qualquer informação do sistema,
                  assumindo a identidade de qualquer
usuário. Para reduzir a efetividade de um arquivo de senhas
                  roubado, muitos
sistemas operacionais criptografam o arquivo de senhas ou armazenam apenas
                  valores de hash para cada senha. Nesse caso, uma cópia do arquivo de senhas é
 de pouca
                  utilidade, a menos que o intruso possa decriptá-las. Para frustrar
ainda mais as tentativas de obter
                  senhas, vários sistemas empregam o salpicamento
de senha; uma técnica que insere caracteres
                  em várias posições da senha antes
 de criptografá-la [...]. Uma pequena quantidade de
                  salpicamento pode alterar
significativamente um texto cifrado, mesmo quando se estiver utilizando
                  uma
cifra fraca, como uma cifra de substituição (codificação base 64). O
salpicamento pode evitar
                  que intrusos obtenham uma chave criptográfica com base
 em padrões produzidos por senhas
                  comuns após a criptografia.

                  [...]

                  Usuários são
incentivados a trocar suas senhas frequentemente; mesmo que um intruso obtenha
                  uma senha, ela pode ser trocada antes que algum dano real seja causado. Alguns
 sistemas
                  exigem que os usuários escolham novas senhas periodicamente.
 Infelizmente, alguns usuários
                  reutilizarão duas ou três senhas ciclicamente, o
 que reduz a segurança geral. Como resposta,
                  vários sistemas de autenticação
proíbem a reutilização das senhas escolhidas mais recentemente
                  por um usuário.

                  Uma defesa simples
 contra a quebra por força bruta e tentativas repetidas de entrar a senha é
                  limitar o número de tentativas de acesso ao sistema que podem ser iniciadas em
um certo período
                  de tempo de um único terminal ou estação de trabalho (ou de
uma única conta). É claro que as
                  pessoas cometem erros ao tentarem obter acesso
 ao sistema, mas não é razoável que alguém
                  que saiba a senha correta tenha de
fazer dezenas, centenas ou milhares de tentativas. Portanto,

https://univirtus.uninter.com/ava/web/roa/  17/24
-----------------------Page 17 End-----------------------

05/05/2022 22:56                                                                        UNINTER

                  um sistema pode
permitir três ou quatro tentativas e, então, desconectar o terminal durante
vários
                  segundos ou minutos. Após um período de espera, o terminal pode ser
 reconectado. (Ribeiro,
                  2005, p. 156-158, grifos nossos)

4.2 CONTROLE DE ACESSO

                                    Na qualidade de
 gerenciador de recursos, o sistema operacional deve se defender
                                    cuidadosamente
 contra utilizações não intencionais e maliciosas de recursos de computação.
                                    Consequentemente, os sistemas operacionais são projetados para proteger
 serviços de sistema
                                    operacional e informações sensíveis contra usuários e/ou softwares
 que obtiveram acesso aos
                                    recursos do computador. Direitos de acesso protegem
 recursos e serviços do sistema contra
                                    usuários potencialmente perigosos,
restringindo ou limitando as ações que podem ser executadas
                                    no recurso. Esses
direitos normalmente são gerenciados por listas de controle de acesso ou listas
                                    de capacidades.

                                    [...]

                                    Uma lista de
 controle de acesso armazena os mesmos dados que uma matriz de controle de
                                    acesso, mas mantém um registro somente das entradas que especificam um direito
de acesso. A
                                    lista de controle de acesso de um sistema pode ser baseada nas
 linhas (os sujeitos) ou nas
                                    colunas (os objetos) de uma matriz. Para cada
 objeto de um sistema operacional, uma lista de
                                    controle de acesso contém
 entradas para cada sujeito e os privilégios associados àquele sujeito
                                    em
relação àquele objeto. Quando um sujeito tenta acessar um objeto, o sistema
procura pela lista
                                    de controle de acesso para aquele objeto para identificar os
privilégios daquele sujeito.

                                    O problema desse método
 está na ineficiência com a qual o sistema operacional determina os
                                    privilégios
 de usuário para determinado objeto. A lista de controle de acesso para cada
 objeto
                                    contém uma entrada para cada sujeito com privilégios para aquele objeto –
 uma lista
                                    potencialmente grande. Toda vez que um objeto for acessado, o sistema
deve pesquisar a lista de
                                    sujeitos para encontrar os privilégios adequados.
Quando se usam listas de controle de acesso, é
                                    difícil determinar quais
 direitos de acesso pertencem a um certo domínio de proteção; é preciso
                                    pesquisar a lista de acesso para cada objeto, procurando entradas relativas
 àquele objeto
                                    particular. (Ribeiro, 2005, p. 161-164, grifos do original)

TEMA 5 – GERENCIAMENTO E PROTEÇÃO DE USUÁRIOS

                  A chave para a
 segurança do sistema operacional é controlar o acesso a dados e recursos
                  internos. Direitos de acesso definem como vários sujeitos podem acessar
vários objetos. Sujeitos
                  podem ser usuários, processos, programas ou outras
 entidades. Objetos são recursos como
                  hardware, software e dados; podem ser
 objetos físicos como discos, processadores ou memória
                  principal. Também podem
ser objetos abstratos como estruturas de dados, processos ou serviços.

https://univirtus.uninter.com/ava/web/roa/     18/24
-----------------------Page 18 End-----------------------

05/05/2022 22:56                                                                        UNINTER

                  Sujeitos
também podem ser objetos do sistema; um sujeito pode ter direitos de acesso a
um outro.
                  Sujeitos são entidades ativas; objetos são entidades passivas. À
medida que um sistema executa,
                  sua população de sujeitos e objetos tende a
 mudar. A maneira pela qual um sujeito pode ter
                  acesso a um objeto é denominada privilégio
e pode incluir leitura, escrita e impressão.

                  Objetos devem ser
 protegidos contra sujeitos. Caso fosse permitido que um processo tivesse
                  acesso
 a todos os recursos de um sistema, um usuário poderia, inadvertida ou
 mal-
                  intencionadamente, comprometer a segurança do sistema ou causar a queda de
 outros
                  programas. Para impedir que tais eventos ocorram, cada sujeito deve
 obter autorização para
                  acessar objetos dentro de um sistema.

                  Um domínio de
 proteção é uma coleção de direitos de acesso. Cada direito de acesso de um
                  domínio de proteção é representado como um par ordenado com campos para o nome
do objeto e
                  seus privilégios correspondentes. Um domínio de proteção é
exclusivo de um sujeito. Por exemplo,
                  se um usuário puder ler e escrever para o
 arquivo example.txt, o par ordenado correspondente
                  para o direito de acesso
desse usuário poderá ser representado por <example.txt/ {read, write}>.

                  Os direitos de acesso
mais comuns são ler, escrever e executar. Alguns sujeitos também podem
                  conceder
 direitos de acesso a outros sujeitos. Na maioria dos sistemas de computação, o
                  administrador possui todos os direitos de acesso e é responsável pelo
gerenciamento dos direitos
                  de outros usuários.

                  Direitos de acesso
 podem ser copiados, transferidos ou propagados de um domínio para outro.
                  Copiar
 um direito de acesso implica simplesmente conceder um direito de um usuário a
 outro
                  usuário. Quando um direito de acesso é transferido do sujeito A para o
 sujeito B, o direito de
                  acesso do sujeito A é revogado quando a transferência
 for concluída. Propagar um direito de
                  acesso é similar a copiar um direito de
acesso; contudo, além de compartilhar o direito de acesso
                  original, ambos os
sujeitos também podem copiar o direito para outros sujeitos.

                  Quando um sujeito não
 precisa mais do acesso a um objeto, os direitos de acesso podem ser
                  revogados.
 Nesse caso surgem várias questões: a revogação deve ser imediata ou tardia? A
                  revogação deve ser aplicada a todos os objetos ou apenas a alguns? A revogação
 deve ser
                  aplicada a sujeitos específicos ou a todo domínio? A revogação deve
 ser permanente ou
                  temporária? Cada implementação de gerenciamento de direitos
de acesso aborda a revogação de
                  maneira diferente. (Ribeiro, 2005, p. 161-162,
grifos do original)

5.1 GERÊNCIA DE PROTEÇÃO

      A gerência de proteção de
dados e usuários é outra importante tarefa de gestão de recursos.
Para Maziero
(2019), “com computadores conectados em rede e compartilhados por
vários usuários,
é importante definir claramente os recursos que cada usuário
 pode acessar, as formas de acesso
permitidas (leitura, escrita etc.) e garantir
 que essas definições sejam cumpridas”. Por exemplo, a

https://univirtus.uninter.com/ava/web/roa/  19/24
-----------------------Page 19 End-----------------------

05/05/2022 22:56                             UNINTER

proteção contra
 os ataques de negação de serviço (DoS, de denial of service[2]), comuns na

internet.
 É responsabilidade do sistema operacional do servidor detectar e impedir
 ataques como
esses, em que todos os recursos do sistema são monopolizados por
um único usuário.

      Ainda para Maziero (2019), para
proteger os recursos do sistema contra acessos indevidos, é
necessário:

a.
“definir
usuários e grupos de usuários”;

      b. “identificar
 os usuários que se conectam ao sistema”, mediante procedimentos de
autenticação;

      c. “definir
 e aplicar regras de controle de acesso aos recursos”, relacionando todos os
usuários, recursos e formas de acesso e aplicando essas regras por meio de
 procedimentos
de autorização;

d. “registrar
o uso dos recursos pelos usuários, para fins de auditoria e contabilização”.

      Assim, um sistema operacional visa abstrair o
 acesso e gerenciar os recursos de hardware,
provendo aos aplicativos um
ambiente de execução abstrato, no qual o acesso aos recursos se faz
através de
interfaces simples, independentes das características e detalhes de baixo
nível, e no qual
os conﬂitos no uso do hardware são minimizados (Maziero, 2019).

      O controle de identidade é imprescindível para
 a segurança da informação e dos sistemas e
requer um tratamento especial.
Diferentemente do ambiente natural, no mundo digital a simulação
de perfis ou
identidades é algo relativamente simples, exigindo muito dos dispositivos e
técnicas de
controle, pois são esses controles que garantirão a autorização e a
 autenticidade das operações,
além do não repúdio. Além dessa garantia, tais
 controles também têm que resistir ao roubo de
identidades, evitando que agentes
ou usuários mal-intencionados possam simular ou passar-se por
alguém
devidamente autorizado e, assim, realizar operações fraudulentas.

                  Os controles de acesso
 geralmente operam em conjunto com os controles de verificação para
                  estabelecer
a devida autorização e garantir a autenticidade das operações. A maioria dos sistemas
                  baseia-se no conjunto identificação (ID) e senha (password). Porém, para
 muitas operações
                  críticas e o uso de informações sensíveis, esses controles não
são suficientes.

https://univirtus.uninter.com/ava/web/roa/                                                  20/24
-----------------------Page 20 End-----------------------

05/05/2022 22:56                                      UNINTER

“Controles biométricos, certificados digitais e
 assinaturas eletrônicas complementam esses

controles, e cada vez mais é
necessário o uso de técnicas e mecanismos que garantam a identidade

dos agentes”,
mas que, ao mesmo tempo, permitam a “independência do ambiente, a flexibilidade
e

a interatividade com diversas tecnologias e funcionalidades, além de um
desempenho elevado”, em

um mundo extremamente veloz e cada vez mais conectado. O processo de identidade e autorização

é parte importante
da proteção, especialmente no que diz respeito à autenticação do usuário remoto

– aquele que pleiteia o acesso à rede, aos recursos computacionais e à
informação estando fora do

perímetro de segurança da organização (Paulo, 2020).

      O processo de identificação, segundo Paulo (2020), precisa ser completado com
 verificação,
com base em processos de autenticação já apresentados:

algo
que o indivíduo sabe: sua identidade (por meio de personal identification
number – PIN) e
as suas senhas;
algo
que o indivíduo possui: um token, uma chave criptográfica ou
física ou um smart card;
algo
que o indivíduo é: biometria estática, como a digital ou a íris;
algo
 que o indivíduo faz: biometria dinâmica, como por padrão de voz,
 caligrafia e taxa de
digitação.

FINALIZANDO

      Nesta aula, foram apresentados
os conteúdos que complementam a fundamentação teórica de
sistemas operacionais, com
 ênfase em gerência e proteção de usuários, com os conceitos e
definições de segurança apresentados no primeiro tema. No
segundo tema, os riscos, as ameaças e
as vulnerabilidades
 dos sistemas operacionais foram analisados e definidos
 individualmente,
enfatizando a importância de manter os sistemas seguros. No
 tema seguinte, foi abrangida a
criptografia, assim
como
os seus objetivos e tipos, com destaque para o item 3.3, que descreve a
PKI. Na
sequência, foram definidas e apresentadas a autenticação, o gerenciamento e o controle de
acesso, para, por fim, serem
analisados o gerenciamento e a proteção de usuários.

      Ao confiarmos o armazenamento e o
desenvolvimento de informações nos arquivos ou mesmo
a segurança de acesso a um
ambiente restrito, utilizando uma fechadura eletrônica, é fundamental
que
 lembremos que há um sistema operacional responsável por garantir a segurança
 desses
arquivos, pois, se houver algum código malicioso não tratado, criminosos
 podem se valer dessa

https://univirtus.uninter.com/ava/web/roa/                     21/24
-----------------------Page 21 End-----------------------

05/05/2022 22:56                                      UNINTER

vulnerabilidade e conseguir o acesso total e irrestrito ao
 sistema, abrindo facilmente a fechadura.

Portanto, o conhecimento das
características dos sistemas operacionais é fundamental para o bom

funcionamento de todas as atividades desenvolvidas pelos computadores.

      Em paralelo à leitura do texto desta aula, é
 muito importante que sejam consultadas as
referências indicadas e as atividades
 práticas sejam realizadas, pois a gestão da TI, que envolve
pessoas, empresas e
indústrias, tem como principal aliado o sistema operacional e as ferramentas
aqui apresentadas.

      Indicada em todos os tópicos, a especialização
 em sistemas operacionais específicos de
diferentes fabricantes, cada um com
 suas características, vantagens e desvantagens, permite aos
gestores a melhor e
 mais adequada escolha a cada situação de uso, obedecendo aos padrões e
normas
 internacionais, proporcionando o uso mais eficiente dos recursos e obtendo
 melhores
resultados.

Aproveite e bons estudos!  

REFERÊNCIAS

      ABNT –
 Associação Brasileira de Normas Técnicas. ABNT NBR ISO/IEC 27002:2013:
Tecnologia da informação – Técnicas de segurança – Código de prática para
controles de segurança
da informação. Rio de Janeiro, 2013.

CELESTINO,
 P. Redes virtuais privadas. 90 f. Dissertação (Mestrado em Automação) –

Universidade
     de                        Taubaté,  Taubaté,  2005.         Disponível  em:

<http://livros01.livrosgratis.com.br/cp012541.pdf>. Acesso em: 31 out. 2020.

      DEITEL, P.
 J.; DEITEL, H. M.; CHOFFNES, D. R. Sistemas operacionais. 3. ed. São
 Paulo:
Pearson, 2017.

MAZIERO, C.
Sistemas operacionais: conceitos e mecanismos. Curitiba: Editora UFPR,
2019.

      MICHAELIS dicionário
 brasileiro da língua portuguesa. São Paulo: Editora Melhoramentos,
2015.
Disponível em: <https://michaelis.uol.com.br/>. Acesso em: 31 out. 2020.

https://univirtus.uninter.com/ava/web/roa/                                                22/24
-----------------------Page 22 End-----------------------

05/05/2022 22:56                                         UNINTER

MICROSOFT.
 Introducing Kernel Data Protection, a new platform security technology for

preventing data corruption. Security, 8 jul. 2020. Disponível em: 

<https://www.microsoft.com/security/blog/2020/07/08/introducing-kernel-data-protection-a-new-

platform-security-technology-for-preventing-data-corruption/>.
Acesso em: 31 out. 2020.

      MOTA, R. P.
 B. Extensões ao protocolo de comunicação EPCGlobal para tags classe 1
utilizando autenticação com criptografia de baixo custo para segurança em
identificação por
radiofrequência. 91 f. Dissertação (Mestrado em Ciência
 da Computação) – Centro de Ciências
Exatas e de Tecnologia, Universidade
 Federal de São Carlos, São Carlos, 2006. Disponível em:
<https://repositorio.ufscar.br/bitstream/handle/ufscar/312/DissRPBM.pdf>.
Acesso em: 31 out. 2020.

      PAIVA, M.
A. L.; LÓPEZ, V. C. O documento, a firma e o notário eletrônico. Jus.com.br,
 jan.
2002. Disponível em: <https://jus.com.br/artigos/2504>. Acesso em: 31
out. 2020.

PAULO, L.
G. Segurança em sistemas de informação. [S.l], 2020.

      PISTELLI, D. Criptografia. [S.l.]: Geek Brasil, [S.d.]. Disponível
 em:
<http://www.josevalter.com.br/download/seguranca/Criptografia.pdf>. Acesso em: 31 out. 2020.

      RIBEIRO, R.
 Sistemas operacionais: apostila. [S.l.]: [S.n.], ago. 2005. Disponível
 em:
<http://brunotoledoifmg.com/SO/Apostilas/Apostila%20Sistemas%20Operacionais.pdf>.
 Acesso em:
1 nov. 2020.

      RODRIGUES,
 T. P. Entendendo PKI. Thiago Pereira Rodrigues Technology Blog, 12 ago.
2009. Disponível em:
 <https://thiagoprodrigues.wordpress.com/2009/08/12/entendendo-pki/>.
Acesso em: 1 nov. 2020.

TREND             MICRO.
                   Ramsomware.  [S.l.],  [20--].  Disponível           em:

<https://www.trendmicro.com/vinfo/us/security/definition/ransomware>. Acesso em: 30 out. 2020.

UFRGS – Universidade Federal do Rio Grande do Sul. Certificado digital
 da UFRGS:

instalação.       Porto                     Alegre,      [20--].           Disponível
          em:

<http://www.ufrgs.br/tri/cpd/servicos/seguranca/certificado-digital-da-ufrgs-instalacao>. Acesso em: 1

nov. 2020.

      ZANLUCA, A.
Aumento de ataques cibernéticos alertam para a necessidade de se ter cuidados
com a proteção. Entreverbos, 24 jun. 2020. Disponível em: <https://www.entreverbos.com.br/single-

https://univirtus.uninter.com/ava/web/roa/                                                      23/24
-----------------------Page 23 End-----------------------

05/05/2022 22:56                            UNINTER

post/2020/06/24/Aumento-de-ataques-cibernéticos-alertam-para-a-necessidade-de-se-ter-cuidados-

com-a-proteção>.
Acesso em: 30 out. 2020.

      [1] “O
ransomware é um tipo de malware (software malicioso) que
 impede ou limita o acesso
dos usuários ao sistema, bloqueando a tela do sistema
ou bloqueando os arquivos dos usuários, a
menos que um resgate seja pago. As
 famílias mais modernas de ransomware, coletivamente
categorizadas como crypto-ransomware,
 criptografam certos tipos de arquivos em sistemas
infectados e obrigam os
 usuários a pagar pelo seu resgate por meio de certos métodos de
pagamento on-line,
 para obterem uma chave de descriptografia” (Trend Micro, [20--], tradução
nossa).

      [2] Formas
 de ataque virtual que consistem na utilização de diversas técnicas para forçar
 um
servidor de rede a dedicar seus recursos para atender um determinado
usuário, em detrimento dos
demais. Por exemplo, ao abrir milhares de conexões
 simultâneas em um servidor de e-mail, um
atacante pode reservar para si todos
 os recursos do servidor (processos, conexões de rede,
memória e processador),
fazendo com que os demais usuários não sejam mais atendidos.

https://univirtus.uninter.com/ava/web/roa/           24/24
-----------------------Page 24 End-----------------------



----------------------------------------------------------------------------------------------------------------------
uninter redes aula 1

Rota de Aprendizagem
Redes de Computadores
Aula 01

Aula 01 - Parte 1 – Redes de Computadores
Introdução
Nesta primeira aula vamos abordar os conceitos gerais de Redes de Computadores,
apresentando uma visão geral sobre o tema, abordando os principais tipos e as tecnologias
utilizadas na composição das redes de computadores. Nosso objetivo é identificar e classificar
as redes de computadores dos mais diversos tipos, constituições e abrangência, os serviços
prestados por estas redes e as suas principais características.
Leituras recomendadas:
 Tanenbaum, 2011 – Seções 1.1 e 1.2 (pag. 2 a 17) e 1.5 (pag. 33 a 45).
 Kurose, 2003 – Seções 1.8 e 1.9 (pag. 41 a 48).
Contextualizando
O que são as redes de computadores?
As redes de computadores são sistemas de computadores e dispositivos de
comunicação computadorizados que estão interconectados entre si, possibilitando a troca de
informações no formato digital, isto é, de bits e bytes. Em uma rede, os computadores são
interligados através de um meio de comunicação, formando uma estrutura composta de
computadores e outros dispositivos, dos meios de transmissão, do software de rede e dos
equipamentos de comunicação. Uma rede, network ou simplesmente net também é conhecida
pelo acrônimo (sigla) em Inglês DCN – Data Communication Network.
Simplificando ao máximo, podemos dizer que uma rede de computadores é a utilização
de computadores integrada aos sistemas de comunicação:
Computador + Comunicação = DCN
(Data Communications and Computer Network)
Para ajudar a entender mais um pouco, assista o vídeo disponível em
https://www.youtube.com/watch?v=_axG2fUpUCs.
Qual é a finalidade das redes de computadores?
As redes de computadores estão presentes em praticamente todas as atividades
exercidas pelos seres humanos na atualidade, provendo os serviços de comunicação de
dados, através do qual possibilitam:

1

Rota de Aprendizagem
Redes de Computadores
Aula 01

- A interoperabilidade, ou seja a capacidade de diferentes sistemas computacionais
trocaram informações entre si para a realização de tarefas ou atividades – como um ERP e um
sistema bancário possibilitando a troca de informações sobre cobrança e pagamento bancário,
por exemplo. Ou um portal de comércio eletrônico que realiza vendas e aceita o pagamento
através de cartões de crédito. Sobre este assunto, faça uma pesquisa sobre os temas
“Comércio Eletrônico, Banco Eletrônico e Governo Eletrônico” na internet e comente no
FORUM “Interoperabilidade”.

- A interconectividade, isto é, a capacidade de diferentes tipos de dispositivos
conectarem-se para a troca de informações ou a realização de operações e atividades. Como
por exemplo um smartphone conectado à internet, um leitor de cartão de crédito ou débito
conectado ao sistema bancário através da rede de telefonia celular, um dispositivo de
rastreamento que permite seguir o trajeto de um veículo ou de uma encomenda através da
internet, etc.

- Os serviços de mensagem, ou troca de texto, sejam instantâneas ou não, como o email em geral, o Whatsapp, o Skype, Twitter, Messenger e muitos outros.
- Os serviços de telefonia, como o VoIP, ou seja, o tráfego de voz e imagem integrado
ao uso dos computadores, como o Skype, por exemplo.

- O acesso remoto à informação, à dispositivos e a serviços os mais diversos, desde
uma compra de passagem aérea em outro continente até o controle das comportas de uma
usina hidroelétrica.
As redes de computadores também possibilitam o compartilhamento de recursos
como impressoras, dispositivos de armazenamento, de obtenção e tratamento de imagem e
som, e até mesmo de processamento. Com isso, as redes possibilitam a otimização do uso
destes dispositivos, permitindo que mais pessoas possam fazer uso dos mesmos em um maior
período de tempo e a partir de regiões geográficas distintas. Com isto é possível obter uma
redução de custos, seja na aquisição – dispensando a compra de vários desses dispositivos
para cada local onde são necessários – ou na manutenção de vários equipamentos espalhados
por diversas áreas. Além disso as redes também possibilitam a distribuição da carga de
trabalho entre diversos computadores, que podem repartir uma tarefa pesada e complexa,

2

Rota de Aprendizagem
Redes de Computadores
Aula 01

fazendo com que cada um execute uma parte e assim obtenham o resultado mais
rapidamente.
Pesquisa
Procure descobrir como funcionam os buscadores na Internet, - também chamados
de motores de pesquisa ou ferramentas de busca, em inglês search engine - como por exemplo
o Google, o Bing, o Yahoo, o Baidoo e muitos outros.
As redes de computadores também reforçam a confiabilidade e segurança dos
sistemas, uma vez que permitem a estruturação de sistemas com tolerância a falhas, nos
quais, havendo problemas em um computador ou em um local específico, outro computador
ou outro local pode assumir a atividade em execução e dar sequência às operações. Aliás, foi
este aspecto levou às pesquisas que resultaram no desenvolvimento da Internet, você sabia?
Para saber mais sobre isto, faça uma pesquisa sobre ARPA / DARPA na Internet.
Outra finalidade das redes é o gerenciamento ou gestão de recursos, sejam estes
recursos computacionais ou não. Através da sua capilaridade – isto é, da capacidade de
chegar a diversos pontos – e da sua abrangência, as redes de computadores possibilitam a
disseminação ordenada das informações, além de possibilitar a administração do conteúdo e
da circulação de informações entre os pontos interligados.

A classificação das redes de computadores
As redes de computadores podem ser diferenciadas em função da sua abrangência
geográfica, ou seja, o espaço territorial que ocupam e no qual atuam. Sob este aspecto as
redes podem ser denominadas como:

 PAN, do Inglês Personal Area Network ou rede de área pessoal;
 LAN, de Local Area Network ou rede de área local, ou simplesmente Rede Local;
 MAN, de Metropolitan Area Network ou rede de área metropolitana
 WAN, de Wide Area Network ou rede de grande área;

 E a Internet, isto é, a interconexão de redes, a rede das redes, ou rede de alcance
mundial.

3

Rota de Aprendizagem
Redes de Computadores
Aula 01

Quanto à conectividade as redes podem ser classificadas em redes lógicas, na qual a
configuração é definida por um arranjo de software, ou redes físicas, que resultam da
combinação de meios de comunicação e hardware específico em arranjos físicos e com
distribuição geográfica conhecida. Uma rede também pode ser composta pelos combinação
destes dois tipos. O melhor exemplo para isto é a famosa Computação na Nuvem, ou seja, o
Cloud Computing. Para saber mais sobre o assunto, faça uma pesquisa sobre a computação na
nuvem (ou cloud computing) e exponha suas descobertas no FORUM “Computação na Nuvem”.
Em função da forma de gerenciamento as redes podem ser públicas, com seus
endereços e computadores conhecidos e possíveis de serem acessados por todos –
respeitadas as regras de segurança, ou privadas, com o acesso restrito à um grupo ou
organização que seleciona e condiciona à determinadas regras aqueles que podem fazer uso
da rede.
Quanto à arquitetura uma rede pode ser identificada como Cliente/Servidor, com
um computador provendo informações e gerindo a comunicação de outros, pode ser uma rede
ponto a ponto na qual os computadores em comunicação trocam informações entre si e
gerenciam a comunicação em conjunto. E é possível a combinação de ambos os modelos,
formando assim uma rede híbrida.
As aplicações das redes de computadores
Como já mencionado, as redes são utilizadas para o compartilhamento de recursos,
como os de impressão e armazenamento, captura, armazenagem e tratamento de voz, sons e
imagens. Também são utilizadas para a troca de informações como no caso do e-mail, a troca
de arquivos (FTP), as mensagens instantâneas, a TV e os vídeos sob demanda. Através das
redes é possível fazer o compartilhamento de informações pessoais (blogs e redes sociais),
profissionais, educacionais e governamentais (você pesquisou sobre Governo Eletrônico?).
As redes também podem suportar serviços de telefonia, como o VoIP, por exemplo, e
as teleconferências de áudio e vídeo. Além disso podem ser estabelecidas redes de
computadores com o propósito de utilizar a computação paralela ou distribuída, como no
projeto SETI (Já ouviu falar ou leu a respeito? Que tal pesquisar?), na operação de redes de
radiotelescópios, sensores e radares com uso em astronomia, climatologia, energia, etc.

4

Rota de Aprendizagem
Redes de Computadores
Aula 01

Tipos de redes
Personal Área Network é uma pequena rede no ambiente pessoal que abrange alguns
poucos metros (<=10 m) em uma mesa, casa ou escritório, permitindo a interligação de
computadores, smart phones, mouse, teclado, fones de ouvido, câmeras, relógios, televisores,
eletrodomésticos e diversos outros tipos de dispositivos, normalmente através de tecnologia
Bluetooth ou raios infravermelhos. Um exemplo deste tipo de rede é a Piconet - uma rede
Bluetooth que conecta até oito dispositivos móveis no formato Master-Slave.
A Rede de Área Local ou simplesmente Rede Local é uma rede que interliga os
equipamentos de uma instalação ou edificação – casa, escritório, escola, prédio, planta de
fábrica, etc. – através de cabos ou ondas de rádio – as redes chamadas redes wireless ou sem
fio. Normalmente a área de abrangência fica em torno de poucas centenas de metros, e
conecta de dois até milhares de computadores. Em geral é a rede local que nos possibilita,
entre outras coisas, o compartilhamento de impressoras, scanners, o acesso aos servidores
(de dados, de aplicações, de comunicação) e à Internet, entre outros, e por isso é a rede típica
das organizações em geral.
Os equipamentos de rede utilizados em uma LAN são mais simples e de baixo custo, e é
comum encontrar nestas redes equipamentos com funções de Proxy, Firewall, Switch,
Roteador (Você sabe o que é isto? Que tal pesquisar?). Os endereços dos computadores desta
rede são privativos, isto é, de conhecimento apenas de quem faz parte da rede ou a
administra. As conexões são feitas por cabo (Ethernet ou Fibra Ótica) ou sem fio (WiFi ou
Wireless), e há um domínio próprio que não requer registro e tampouco é publicado na
Internet.
MAN ou rede metropolitana é um tipo de rede que abrange uma cidade ou uma área
metropolitana, interconectando diversas construções e diferentes organizações, cujos
endereços são públicos e a interconexão (enlaced ou links) é feita por cabo, fibra ótica, laser
ou rádio. Estas redes incorporam um serviço de domínio e de nomes, e formam um Backbone
que conecta outras redes – LANs – entre si. São típicas de serviços como os dos provedores de
Internet (ISP), Metro Ethernet, TV a Cabo, Telefonia fixa e interligação das estações rádio base
(ERBs) – as “torres” da telefonia celular.

5

Rota de Aprendizagem
Redes de Computadores
Aula 01

Uma WAN ou rede de grande abrangência é uma rede que atende a áreas enormes,
normalmente superando as fronteiras entre estados, países e até continentes, fazendo uso de
links compostos por cabo, fibra ótica ou satélite. É uma rede típica de provedores de serviços
de telecomunicações e grandes corporações, e que tem por finalidade conectar LANs e MANs
entre si através de um Backbone de grande extensão e altíssimo volume de tráfego de dados.
Normalmente é operada por corporações de alcance global e fornece serviços para
provedores de Internet (ISP), sistemas de telefonia fixa, transmissões de áudio e vídeo para
emissoras de televisão e corporações globais.
A Internetwork ou a rede das redes, ou simplesmente Internet é uma rede de alcance
global (World Wide Web) que contempla desde as conexões locais até as intercontinentais
por fibra óptica e satélite, tornando-se uma rede com uma enorme quantidade de
computadores conectados. Sua principal característica é o grande volume de informações
disponível, que contempla e-mails, texto e Imagens, áudio e vídeo, mídias sociais, comércio,
serviços e governo eletrônico. Uma pergunta que sempre é feita é: quem controla a Internet?
A resposta: a Internet não tem dono! Mas tem organismos de controle que zelam pela sua
operação e evolução.
Pesquisa
Para saber mais sobre os organismos que regulam a Internet, pesquise sobre ICANN,
IANA e IETF e compartilhe com os colegas de curso no FORUM “A Internet”. E assista o vídeo
“Guerreiros da Internet” disponível em https://www.youtube.com/watch?v=Iqcp3k8DgGw. E
então, você já sabe como surgiu a internet? E quem administra a Internet no mundo? E no
Brasil? Que tal pesquisar?
Tecnologias
Para que as redes funcionem e ofereçam os serviços com a qualidade esperada existem
diversos elementos e padrões que definem as características necessárias, possibilitando assim
a construção física e também a configuração lógica mais adequada. Neste aspecto as
tecnologias empregadas para a comunicação de dados nas redes de computador são cruciais,
tendo sido determinantes na evolução e na disseminação do uso das redes.
Uma dessas tecnologias é a Ethernet, um modelo e padrão desenvolvido em conjunto
pela DEC (Digital Equipment Corporation), Intel e Xerox no início da década de 70, e tornado

6

Rota de Aprendizagem
Redes de Computadores
Aula 01

padrão pelo IEEE (Institute of Electrical and Electronics Engineers) na década de 80. É típica de
topologia do tipo Estrela, e faz uso de prevenção e detecção de colisões com o CSMA/CD. As
interfaces (cartões ou placas) de rede física (MAC) possuem endereços de 48 bits, ou seja, é
possível designar até 248 endereços para os dispositivos ou hosts. 

A ethernet usa como padrões de mídia o 10 Base-T, com cabos CAT-5 e conector RJ-45. Com estes padrões
consegue atingir distâncias de até 100 metros mantendo uma velocidade de comunicação de
10 Mbps (dez megabits por segundo). Com o passar do tempo e a evolução tecnológica, a
ethernet também foi evoluindo, passando a apresentar novos padrões, tais como:

FAST ETHERNET, padrão IEEE 802.2, mídia 100 Base-T, cabo CAT-5 e conector RJ-45,
que atinge até 100 Mbps em distâncias de até 100m;
 FAST ETHERNET em fibra ótica, mídia 100 Base-Fx, que atinge até 100 Mbps em até
2.000 m (ou 2 Km, dois quilômetros);
 GIGABIT ETHERNET, padrão IEEE 802.3ab, cabos CAT-5, CAT-5e e CAT-6, com
velocidades até 1 Gbps (Gigabits por segundo);
 GIGABIT ETHERNET em fibra óptica, padrão IEEE 802.ah;

Uma outra tecnologia é a Token Ring, criado pela IBM nos anos 80. Esta tecnologia foi
padronizada pela norma IEEE 802.5, e é utilizada principalmente em redes de topologia ANEL
em ambientes de altíssimo volume de tráfego de dados, exigência de alta disponibilidade e
baixíssima taxa de erros. Geralmente é empregada para a comunicação de computadores de
grande porte, os Mainframes, dispositivos de armazenamento de grande capacidade, os
Storages ou dispositivos voltados para a cópia de segurança dos dados destes sistemas, o
Backup. Esta rede é eficiente para ambientes que trocam grandes volumes de dados pois evita
a colisão – a tentativa de comunicação simultânea entre mais de dois dispositivos. Isto porque
existe um TOKEN, isto é, um sinalizador que fica de posse de apenas um host a cada momento,
e somente o host que tiver a posse do token poderá transmitir seus dados através da rede.

Uma tecnologia que se tornou popular e é massivamente utilizada atualmente é o
WiFi® – Wireless Fidelity, marca registrada da WiFi Alliance. É definida pelos padrões IEEE
802.11a para a velocidade de até 2 Mbps, IEEE 802.11b para 11 Mbps, IEEE 802.11g para 54
Mbps e IEEE 802.11n de 150 até 600 Mbps. Esta tecnologia permite a conexão a redes sem o
uso de condutores (fios), e também por isso é conhecida como Wireless, ou seja, sem fio. É
importante não confundir comunicação sem fio com a comunicação móvel (mobile) dos
celulares e tablets, pois tratam-se de tecnologias bastante distintas entre si, embora ambas
utilizem a atmosfera (através dos sinais de rádio) como meio de transmissão. 

Duas questões críticas para esta tecnologia é a limitação de frequências disponíveis no espectro
eletromagnético e a segurança da informação. 

A limitação de frequências decorre da utilização da faixa de rádio frequências para o uso de outros serviços, como transmissões por micro-ondas, satélite, comunicação militar, radares, radiotelescópios e outros. A segurança
tem evoluído desde os primeiros mecanismos, como o WEP – Wired Equivalent Privacy – ou
privacidade equivalente à rede com fios, uma iniciativa que buscou a segurança durante os
processos de autenticação para a proteção e a confiabilidade no tráfego de dados entre os
dispositivos wireless e que se tornou parte do padrão IEEE 802.11. Por sua fragilidade e
constante quebra de segurança foi praticamente abandonado, sendo mantido apenas por
razões de compatibilidade com disposiivos mais antigos, tendo sido substituído pelo WPA –
Wi-fi Protected Access ou acesso Wi-Fi protegido, e posteriormente WPA2, que usa
criptografia AES, e pela sua versão simplificada para usuários domésticos, o WPS - Wi-Fi
Protected Setup, inicialmente chamado de Wi-Fi Simple Config.

O Bluetooth é outra tecnologia de rede sem fio, criada pela ERICSSON na década de 90,
e transformada no padrão IEEE 802.15.x, é uma tecnologia voltada para a comunicação à
curta distância, basicamente para as redes pessoais (PAN ou WPAN), e também associada à
mobilidade e à IOT – Internet of Things – internet das coisas, modelo que possibilita a conexão
à internet através de diversos dispositivos, incluindo os telefones celulares, impressoras,
scanners, videogames, GPS, mouse , teclado e também os eletrodomésticos, como televisores,
geladeiras e DVDs.

A comunicação móvel ou Mobile é composta de outras tecnologias que permitem o
tráfego de dados, denominadas 2G, 3G, 4G, etc. Estas tecnologias foram originalmente
desenvolvidas para o tráfego de voz e posteriormente aprimoradas para o tráfego de dados.

Por isto tratam-se de tecnologias mais vinculadas às redes de telefonia do que as redes de
computadores propriamente ditas, embora o seu uso crescente para acesso à internet venha
transformando rapidamente este cenário.

8

Rota de Aprendizagem
Redes de Computadores
Aula 01

Além destas tecnologias existem inúmeras outras, mais específicas e menos utilizadas,
mas não por isto menos importantes, tais como Frame Relay, xDSL, HDLC, FDDI, PPP, DLNA,
MHL e NFC.
Pesquisa
Você se interessa por infraestrutura de TI, Segurança da Informação ou
Telecomunicações? Que tal então pesquisar sobre as demais tecnologias citadas? O que as
diferencia entre si? Onde são usadas? Quais são as vantagens e desvantagens de cada uma?
Trocando Ideias
Acesse o FORUM “Tecnologias das Redes de Computadores” e exponha os resultados
de seu aprendizado e de suas pesquisas. Use os CHATS durante as aulas interativas.
Compartilhe suas descobertas, suas experiências, exponha suas dúvidas... Faça contato com
seus colegas de curso ou de turma, com os tutores, e discuta o que aprendeu, e assim reforce
seu conhecimento e esclareça suas dúvidas.
Síntese
Nessa aula conhecemos as redes de computadores, as suas classificações e os suas
finalidades e usos. Também aprendemos sobre os tipos de rede e as tecnologias empregadas
na construção destas redes de computadores, possibilitando a troca de informação desde os
mais pequenos espaços até as distâncias globais, com qualidade e velocidade.
Compartilhando
Que tal colocar à prova o que você aprendeu? Converse com seus colegas de curso, de
trabalho, seus amigos, seus familiares. Busque saber o que conhecem sobre o assunto e leve
até eles o que viu, ouviu e leu até aqui.
Autoavaliação
 O que são as redes de computadores?
 Para que servem as redes de computadores? Onde são usadas?

9

Rota de Aprendizagem
Redes de Computadores
Aula 01

 Quais os principais tipos de redes de computadores?
 Quais as tecnologias empregadas nas redes de computadores?
 O que diferencia estas tecnologias entre si?
 Onde são usadas as tecnologias apresentadas?
 Quais são as vantagens e desvantagens de cada uma destas tecnologias?
 As redes de computadores influenciam as atividades, os negócios e a história da humanidade?
Como? Isto é bom ou é ruim?

10

Rota de Aprendizagem
Redes de Computadores
Aula 01

Aula 01 - Parte 2 – Redes de Computadores
Introdução
Nesta aula vamos conhecer as topologias ou arquiteturas das Redes de Computadores,
os meios de transmissão de dados utilizados para estabelecer uma rede e as características
das principais conexões físicas utilizadas nas redes. Nosso objetivo é poder identificar e
diferenciar as redes de computadores de acordo com sua constituição física e lógica.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.6, pag. (46 a 52), 2.2 a 2.4 (pag. 58 a 76) e 2.6 a 2.9
(pag. 86 a 117).
Contextualizando
Topologia (ou arquitetura)
Topologia de uma rede de computadores é a forma através da qual os computadores e
demais componentes ou dispositivos da rede estão organizados, ligados ou conectados entre
si. Esta ligação pode ocorrer de forma física, através dos meios de comunicação e transmissão,
ou lógica, configurada por software.
A topologia física expressa a aparência ou layout da rede, e a lógica representa o fluxo
dos dados na rede. A topologia física representa como as redes estão conectadas (layout
físico) e o meio de conexão dos dispositivos de redes (nós ou nodos). A forma com que os
meios de transmissão, computadores e os dispositivos de rede estão conectados influencia os
aspectos críticos, como a flexibilidade, velocidade e segurança.
A topologia lógica trata da maneira como os dados trafegam através da rede a partir de
um computador ou dispositivo para o outro, desconsiderando as ligações físicas entre eles. A
topologias lógica é associadas ao controle do meio de acesso (mídia, ou meio de transmissão),
e podem ser reconfiguradas dinamicamente em tipos especiais de equipamentos, como
roteadores e switches.

11

Rota de Aprendizagem
Redes de Computadores
Aula 01

Ponto a ponto
Normalmente encontrada em uma rede simples onde dois computadores (dispositivos
ou hosts) são ligados diretamente entre si. Podem haver outros hosts no caminho entre estes
dois, porém devido às características da rede estes dois hosts ignoram a existência dos
demais, não precisando ter informações ou conhecer detalhes da rede ou dos hosts
intermediários. Um exemplo típico de uma rede ponto a ponto é a VPN – Virtual Privative
Network. Também pode ser a conexão física direta entre dois computadores ou dispositivos,
na qual o canal ou circuito de envio de um é conectado ao canal ou circuito de recebimento do
outro, também conhecida como conexão Cross Over.
Barramento (BUS)
Em uma rede do tipo barramento, todos os hosts compartilham um único meio para a
comunicação. Este tipo de rede é fácil de se construir, pois o meio é único – um único cabo
coaxial ou fibra ótica percorrendo toda a extensão da rede. Para evitar problemas de
transmissão este tipo de rede usa um controle de acesso ao meio e de detecção de colisão do
tipo CSMA/CD - Carrier Sense Multiple Access with Collision Detection ou Bus Master, ou seja,
quando um host vai iniciar uma transmissão, primeiro verifica se o meio está livre. Uma das
vantagens deste tipo de rede é que, em caso de falha de um host os outros não são afetados.
PPorém se o meio de transmissão – cabo ou fibra – sofrer uma falha, toda a rede deixa de
funcionar.
Estrela (Star)
Em uma rede do tipo estrela todos os hosts são conectados a um ponto ou nó central,
normalmente um dispositivo de rede do tipo Hub ou Switch , mas também podem ser do tipo
Repetidor, Bridge, Gateway, Router, etc. De fato existe uma conexão ponto a ponto entre os
hosts e este nó central, pelo qual passa todo o tráfego da rede. Por isso, em caso de falha de um
host os outros não são afetados, porém se o equipamento do nó central falhar, toda a rede fica
inoperante.

12

Rota de Aprendizagem
Redes de Computadores
Aula 01

Anel (Ring)
Na rede configurada em formato de anel cada host é conectado a dois outros, seu
antecessor e seu sucessor, ou o anterior e o seguinte. Desta forma há uma conexão ponto-aponto entre cada um destes dois hosts, e o tráfego da rede passa por cada um deles. Por isso
mesmo, em caso de falha de um host toda a rede falha. Para evitar este tipo de falha
normalmente há um anel backup no qual a informação circula em sentido contrário ao do
principal.
Mesh (Malha)
Nas redes do tipo malha, cada host é conectado a todos os outros hosts (Full Mesh) ou
pelo menos aos mais próximos a ele (Partially Mesh), através de uma conexão ponto a ponto
entre cada host. Esta configuração torna este tipo de rede bastante complexa e cara para a
conexão física, sendo mais usual em redes lógicas ou em conexões sem fio (wireless). Uma
vantagem deste tipo de rede é que, em caso de falha de um ou mais hosts a rede como um
todo não é afetada.

Árvore (Tree)
Também chamada de Hierárquica ou de Hierarquia, este tipo de rede é organizada em
camadas (layers), resultado de uma combinação das redes do tipo Barramento e Estrela. Hosts
vizinhos e dispositivos em nós de transição entre os níveis utilizam uma conexão ponto a
ponto, resultando que, em caso de falha dos nós centrais toda a rede falha. Esta é uma
configuração típica das Redes Locais.

Daisy Chain
Em uma rede do tipo Daisy Chain cada host é conectado a dois outros hosts, exceto os
dois da extremidade da rede. É o resultado de uma combinação de redes do tipo barramento
e anel, também fazendo uso de uma conexão ponto-a-ponto entre hosts vizinhos. Porém cada
nó e cada host representa um ponto de falha que pode segmentar a rede, isto é, impedir a

13

Rota de Aprendizagem
Redes de Computadores
Aula 01

comunicação daquele ponto em diante em caso de falha. De fato, cada host funciona como um
roteador para seus vizinhos, repassando a transmissão deles e para eles.
Híbrida
Uma rede do tipo híbrida é uma combinação das demais, da qual obtém-se as
vantagens e as desvantagens de cada modelo. Normalmente são redes de grande área, e o
melhor exemplo deste tipo de rede é a própria Internet.

Ativos de Rede

Ativos de rede são os equipamentos ou dispositivos que, em síntese, fazem a rede
funcionar. São eles que recebem e enviam as informações através da rede, estabelecidos nos
pontos de interconexão também chamados nós (ou nodos) da rede. Através deles faz-se a
configuração e o gerenciamento do tráfego da rede, e também respondem pelo desempenho,
flexibilidade e segurança da rede.

Concentrador ou Reforçador (Hub): É o dispositivo que centraliza a conexão de
diversos hosts em um mesmo segmento da rede, ligando-os e formando uma rede de topologia
estrela. Ao receber um pacote de dados, o Hub o envia a todos os demais hosts, dispositivos e
nós conectados a ele. Neste caso, quando um host transmite, todos os demais hosts e nós de
rede conectados ao Hub recebem, simultaneamente, a transmissão. Ou seja, escutam... E isso é
muito ruim do ponto de vista da segurança da rede.

Repetidor: É o equipamento que conecta dois segmentos de rede recuperando e
reforçando ou amplificando os sinais da transmissão. Com isso consegue-se aumentar a
distância alcançada - ou área de cobertura – daquele segmento de rede. São utilizados quando
a distância entre hosts ou nós da rede superam a extensão recomendada para o meio de
transmissão utilizado.

Bridge: É um ativo de rede que conecta dois segmentos de rede, tornando-os uma
única rede, ou duas redes distintas entre si. Possui a capacidade de promover a interconexão
de redes com tecnologias diferentes, fazendo a conversão e adequação de padrões e
protocolos.

14

Rota de Aprendizagem
Redes de Computadores
Aula 01

Comutador (Switch): É o equipamento mais comum em redes locais, pois conecta
hosts de diferentes segmentos de rede. Diferentemente do HUB, o Switch retransmite os
pacotes de dados apenas para o host ou nó de destino, fechando um circuito entre este e o host
ou nó de origem dos dados e emulando uma rede ponto a ponto entre ambos. Também
permite as transmissões simultâneas ("conversas em paralelo") e, devido à segregação dos
circuitos comutados, diminui o número de colisões no segmento de rede.

Roteador (Router): é o dispositivo que conecta - ou separa - redes distintas, evitando
que pacotes de uma trafeguem de forma indiscriminada para outra, e encaminhando os
pacotes destinados a hosts da outra rede. Um router é capaz de traçar a melhor rota – ou
caminho - para um determinado pacote de dados, identificar o estado dos segmentos de rede
quando à disponibilidade ou tráfego e ainda impor determinadas regras de segurança.
Normalmente é utilizado para conectar instalações entre si - redes entre si ou a empresa toda
à Internet.

Gateway: É o dispositivo que conecta redes com tecnologias distintas entre si, tal como
as Bridges, porém com capacidade de realizar a tradução de protocolos e a conversão de
dados. Um Gateway é utilizado para conectar sistemas que usam:
 Diferentes protocolos de comunicação;
 Estrutura de formatação dos dados diversa ou variada;
 Idiomas ou linguagem diferentes;
 Arquitetura de rede mista ou complexa, com dispositivos de várias funcionalidades e de
fabricantes distintos.
Um exemplo de uso de gateway é a conexão dos serviços de telefonia à rede de
comunicação de dados, o VoIP – Voice over IP, que possibilita o uso de uma mesma rede para
tráfego de voz e dados, além da interligação entre telefone e computador através da Interne,
como no software Skype, por exemplo. Outro exemplo é a conexão entre redes de PCs e de
computadores de grande porte – Mainframes.
Além desses ativos existem vários outros, dentre os quais podemos citar:
- Proxy
- Firewall

15

Rota de Aprendizagem
Redes de Computadores
Aula 01

- IDS ou Intrusion Detection System
Pesquisa
Você sabe o que é um Proxy? E um Firewall? E o IDS? Sabe onde são usados, e porquê?
Que tal pesquisar na bibliografia e na internet?
Meios de transmissão
Os meios de transmissão são os canais, as vias ou condutores pelos quais os
computadores e os dispositivos de rede enviam e recebem os dados. Eles são capazes de
transportar sinais elétricos e eletromagnéticos (ondas de rádio) e a luz, que por sua vez
carregam as informações em sua menor unidade, o BIT. Ou seja, os meios de transmissão
compõem as vias físicas percorridas pelos sinais que transportam os dados de um nó a outro
da rede.
Um dos mais utilizados são os Cabos Elétricos, condutores metálicos apresentados na
forma de cabos telefônicos, cabos coaxiais, pares de fios trançados e a própria rede elétrica
que leva energia às edificações em geral. Estes cabos apresentam a vantagem de ser de fácil
instalação em curtas distâncias e ambientes urbanos, e também de já existirem em alta
quantidade, em função das instalações de serviços de telefonia e de energia elétrica, por
exemplo. Entretanto, apesar disso apresentam inúmeras desvantagens, tais como o alto custo,
devido ao fato de serem compostos de metais como cobre, alumínio e até mesmo ouro e prata,
em casos especiais. Por serem condutores sofrem a interferência de sinais elétricos e
eletromagnéticos, descargas atmosféricas (raios), tensionamento, variação de temperatura,
radiação ultravioleta (do sol) e oxidação, necessitando de constante manutenção para evitar
problemas de segurança. Outro problema também é a ocupação de espaço e a falta de
flexibilidade. Por isso tem sido cada vez menos utilizado em longas distâncias.
Outro importante meio de transmissão de dados é a fibra ótica ou os Cabos Óticos,
utilizados cada vez mais para as conexões a longa distância e altas velocidades.
Diferentemente dos cabos elétricos, os cabos óticos são isolantes – feitos à base de sílica, o
mesmo produto com o qual se faz o vidro, daí a denominação popular de fibra de vidro.
Os cabos óticos também apresentam inúmeras vantagens, como possibilitar o tráfego
em altíssimas velocidades, a grande imunidade a ruído e interferências elétricas e

16

Rota de Aprendizagem
Redes de Computadores
Aula 01

eletromagnéticas, uma vez que transporta a luz, tem um custo menor e apresenta maior
durabilidade. Além disso oferece menores perdas de qualidade mesmo em longas distâncias.
Por outro lado, requer muitos cuidados durante a instalação e sua manutenção é muito
complexa, resultando em alto custo.
Para os casos de comunicação entre pontos muito distantes, como a interligação entre
continentes através de cabos submarinos, por exemplo, a necessidade de regeneração e
repetição do sinal de luz é algo que requer tecnologias de alto custo e complexidade.
O ar ou o espaço, ou também a atmosfera, é um importante meio de transmissão, no
qual podem transitar sinais luminosos (luz visível, infravermelho ou laser) ou as ondas
eletromagnéticas (sinais de rádio frequência). Este meio é o que suporta as comunicações sem
fio (Bluetooth, Wireless ou Wi-fi, Mobile, Satélite, Microondas, etc).
As vantagens deste meio de transmissão vão desde o fato de ser um isolante – em que
pese que as descargas atmosféricas percorram o ar, permitir a transmissão multidirecional
(omnidirecional ou em todas as direções), e a possibilidade de atingir longas distâncias sem a
necessidade de instalação de dispositivos intermediários.
Por outro lado, a instalação e a manutenção dos transmissores e receptores pode ser
difícil e cara, e o sinal transmitido sofre inúmeras interferências, desde as provocadas por
outros dispositivos, como motores, eletrodomésticos, equipamentos industriais, até a
radiação solar. Além disso o espectro de frequências disponíveis é limitado e disputado com
outros usuários, como as emissoras de rádio e televisão, os sistemas de telecomunicações e
radares, etc. Outro aspecto de grande preocupação para a comunicação por rádio ou através
da atmosfera é a segurança, uma vez que o sinal se espalha e pode ser captado por qualquer
um.
O uso da luz (visível ou invisível, infravermelho ou laser) para a comunicação
atmosférica resolve alguns dos problemas que afetam a radiocomunicação, e tem
características semelhantes, porém com custos menores tanto para instalação ou manutenção.
Ao mesmo tempo, apresenta dificuldades para distâncias maiores e também sofre com a
interferência ou bloqueio do sinal luminoso.
Um fator de grande importância para os meios de comunicação são as conexões
físicas, isto é, a forma de prover o contato elétrico ou mecânico entre condutores ou o meio

17

Rota de Aprendizagem
Redes de Computadores
Aula 01

de comunicação e os diversos dispositivos ou equipamentos. Por ser uma estrutura mecânica
ou necessitar fazer contato, são os principais causadores de perdas e ruídos, e estão entre os
principais itens que requerem manutenção contínua. Há uma vasta gama deste tipo de
componentes, condizente com os diversos tipos de equipamentos, meios e padrões existentes
para a conexão mecânica – elétrica, eletromagnética ou ótica. Saber diferenciá-los e escolher
os mais adequados pode ser a diferença entre ter uma rede confiável, segura e com alto
desempenho ou uma que causa mais problemas do que o tolerável.
Pesquisa
Você sabe por onde passam os dados que você envia ou recebe através de seu
computador? Conhece a estrutura de rede de seu local de trabalho ou estudo? Da sua
provedora de serviços de telefonia, TV ou internet? Já viu um quadro de distribuição em seu
prédio, seu bairro? Que tal se informar sobre isto? Já se perguntou a razão das torres de
celular serem sempre altas ou instaladas em pontos elevados? Pesquise, pergunte para as
pessoas que trabalham com isto... Descubra estas e outras respostas que certamente farão
você prestar mais atenção às redes daqui para a frete.
Trocando Ideias
Acesse os fóruns e use os CHATS durante as aulas interativas e compartilhe suas
descobertas, suas experiências, exponha suas dúvidas. Faça contatos com seus colegas de
curso e de turma e discuta o que aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula conhecemos as formas como são organizados os dispositivos que compõem
as redes de computadores, definindo assim a topologia ou arquitetura. Também aprendemos
sobre os vários meios de transmissão utilizados, suas características, vantagens e
desvantagens, assim como os dispositivos utilizados para prover a conexão física – mecânica,
elétrica e ótica – dos componentes e dos meios de transmissão.

18

Rota de Aprendizagem
Redes de Computadores
Aula 01

Compartilhando
Que tal repartir com os outros os conhecimentos que você adquiriu? Discuta com os
seus colegas de curso e de turma, o pessoal do trabalho, profissionais da área de
telecomunicações, os seus amigos e seus familiares. Pergunte o que eles sabem sobre o
assunto e apresente para eles o que viu e ouviu até aqui.
Autoavaliação
 O que é uma topologia de rede?
 Quais são as principais topologias utilizadas na constituição de uma rede de computadores?
Onde elas são mais utilizadas?
 Quais são as principais vantagens e desvantagens das topologias estudadas?
 O que são e para que servem os meios de transmissão?
 Quais são os principais meios de transmissão utilizados?


Quais são as principais vantagens e desvantagens dos meios de transmissão apresentados
nesta aula?

Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.
Na Internet:


https://pt.wikipedia.org/wiki/Topologia_de_rede



http://tecnologia.hsw.uol.com.br/lan-switch2.htm



http://www.infoescola.com/informatica/topologias-de-redes/



http://paginas.fe.up.pt/~goii2000/M3/redes2.htm



http://www.m8.com.br/antonio/redes/Topologia.htm



http://www.tutorialspoint.com/data_communication_computer_network/index.htm

19

__________________________________________________________________________________________
uninter - aula 2 - redes 

O modelo ISO/OSI é um padrão da ISO - International Standard Organization para a
interconexão de sistemas abertos (Open Systems Interconnection). É formado por sete
camadas ou níveis de tratamento da informação:
1 - Física
2 - Enlace
3 - Rede
4 - Transporte
5 - Sessão
6 - Apresentação
7 - Aplicação

Para que serve?
O modelo OSI/ISO tem por finalidade estabelecer um padrão para a comunicação entre
sistemas computacionais, que podem ser de tipos diferentes. Isto é feito pelo tratamento da
informação em cada camada, as quais contemplam protocolos e funções distintas,
apresentadas a seguir.

Camada 1 - Física

A camada física possibilita a ligação física de duas estações diferentes. É esta camada que trata
da interação entre o hardware e os mecanismos de sinalização. Define os padrões de
hardware, do cabeamento, das conexões, a fiação, potência do sinal, frequência de operação e
a forma de codificar os dígitos binários, os BITs. Esta camada fornece seus serviços para a
camada de enlace ou link de dados. Ela estabelece a ligação entre os nós da rede, com ou sem
fio, através de um meio de transmissão.

Camada 2 - Enlace ou link de dados

É a que faz a conversão do fluxo de dados recebido da camada de rede para os sinais a serem
transmitidos pela camada 1, interagindo com o hardware. Do lado do receptor da transmissão
a camada de enlace de dados recebe os dados de hardware, transformados de sinais elétricos
em BITs pela camada 1, e os agrupa em um formato de QUADRO reconhecível,
disponibilizando este quadro para a camada de rede.

É dividida em:

 Controle lógico do link: Cuida dos protocolos, controle de fluxo e do controle de erros.
 Controle de acesso ao meio (MAC - Media Access Control): Realiza o controle dos meios
de comunicação. Contém o endereço físico da mídia (“placa” ou “cartão” de rede)
denominado MAC Address.

Camada 3 - Rede

É a camada ou nível que:

Cuida da atribuição de endereços aos hosts. É nesta camada que o endereço lógico é
configurado, reconhecido e tratado;

Trata da definição do roteamento, isto é, o caminho pelo qual os pacotes de informação
serão enviados até o destino;

Faz o controle da transmissão, adequando o fluxo de dados às características do meio
de transmissão (como a velocidade, por exemplo);

Realiza o tratamento de erros de transmissão, fazendo a detecção e providenciando a
correção dos erros;

Mantém as tabelas de roteamento ou rotas estáticas;

Controla a formação dos pacotes de dados de entrada e saída e faz o encaminhamento
de acordo com a qualidade e as restrições do serviço;

Possibilita a conexão entre redes diferentes;

Busca a entrega de pacotes para o destino com o menor esforço;

Fornece os mecanismos para a comunicação através de conexões ou a comunicação
sem conexão.

Além disso, provê os seguintes serviços e recursos:

 Gerenciamento da qualidade dos serviços (QoS – Quality of Service);

 Balanceamento de carga e gerenciamento de link de dados;
 Segurança;

 Interação entre diferentes protocolos e a comunicação entre redes diferentes;

 Configuração de uma rede lógica sobre a rede física.

 Utilização de VPN - Virtual Privative Network ou Rede Privativa Virtual nível L3
 Túneis para a conexão dedicada ponto-a-ponto.

É na camada de rede que atuam os roteadores, tratando do encaminhamento (ou roteamento)
dos pacotes e da distribuição da transmissão, que pode ser:

 Unicast: destinado a um único host;
 Multicast: destinado a um grupo de hosts;

4
Rota de Aprendizagem
Redes de Computadores

Aula 02

Broadcast: destinado a todos os hosts da rede;
Anycast: destinado aos hosts mais próximos.

É importante destacar que um roteador não encaminha o Broadcast por padrão. Já o tráfego
Multicast recebe um tratamento especial, normalmente por ser um fluxo de vídeo ou de áudio
com maior prioridade. Anycast é semelhante ao Unicast, porém os pacotes são entregues no
destino mais próximo quando vários destinos estão disponíveis.

Camada 4 - Transporte

É a camada que responde pela entrega dos pacotes de dados aos hosts, cuidando da
comunicação de ponta a ponta, entre host que podem nem mesmo pertencer à mesma rede.

Suas principais atribuições são:
 Divide os dados fornecidos pela camada de aplicação em unidades menores, chamadas
segmentos, numerando-os e mantendo o registro de cada segmento.
 Assegura que os dados devem ser recebidos na mesma sequência em que foram
enviados.
 Além dos endereços de rede são associados aos segmentos um número de porta.
 Por sua vez estas portas estão associadas a determinados tipos de serviço e às
aplicações que os utilizam.
 As portas também são numeradas e tem usos definidos.
Camada 5 - Sessão
Nesta camada são estabelecidas as sessões de comunicação entre os hosts. Sessões são
definidas por intervalos de tempo nos quais um serviço é fornecido ou uma atividade é
realizada. Para iniciar uma sessão é necessário realizar uma autenticação, isto é, identificar
quem está solicitando o serviço ou a atividade.
Esta camada também cuida do reconhecimento de nomes e do registro das atividades (log) na
rede.
Camada 6 - Apresentação

Nesta camada é tratado o formato dos dados a serem apresentados pelos aplicativos. Pode-se
considerá-la com ar como o serviço tradutor da rede. Entre outros serviços, fornece a
conversão de códigos de caracteres, conversão, compactação / descompactação e criptografia
de dados;

Camada 7 - Aplicativo

Esta camada é a que interage com os programas de aplicação ou aplicativos do usuário para
que estes possam utilizar os serviços da rede. Entre suas funcionalidades encontram-se:

 O redirecionamento de dispositivo e o compartilhamento de recursos;
 O acesso a arquivos, dados e impressoras remotas;
 A comunicação entre processos, o gerenciamento de rede e os serviços de diretório;

 O suporte para as mensagens eletrônicas, como e-mail e instant messengers, por
exemplo;

 Os terminais virtuais de rede;
Para pesquisar:

Links: https://support.microsoft.com/pt-br/help/103884/the-osi-model-s-seven-layers-
defined-and-functions-explained

Vídeo: https://youtu.be/QaZwabhBbCw
-------------------------------------------------------------------------------------------

uninter aula 3 rede

Rota de Aprendizagem
Redes de Computadores
Aula 03

Aula 03 - Parte 1 – Redes de Computadores
Introdução
Esta aula aborda a conexão entre redes de diversos tipos, o internetworking ou
conexão inter-redes. Para isto vamos apresentar os protocolos da camada 2 do TCP/IP, o
protocolo IP e falar sobre o endereçamento IP.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 5.5 e 5.6.
 Kurose, 2003 – Seções 4.1, 4.4, 4.6 e 4.7.
Contextualizando
O que é o internetworking?
Na atualidade é comum que redes de uma mesma organização estejam dispersas
geograficamente. Também é comum a ligação de duas redes distintas, sejam do mesmo tipo,
ou de diferentes tipos. A conexão ou roteamento entre duas redes é chamada de
internetworking ou conexão inter-redes, e é tratada na camada 2 do protocolo TCP/IP,
principalmente pelo protocolo IP.
As redes podem ser caracterizadas com base em vários parâmetros, tais como os
protocolos empregados, a topologia e a sistemática ou esquema de endereçamento. No
ambiente de internetworking, os roteadores têm conhecimento dos endereços de outros
roteadores e dos endereços de outras redes além da qual eles pertencem. Esta informação
pode ser configurada estaticamente ou os roteadores podem “aprender” os endereços usando
um protocolo de roteamento de internetworking.
Protocolos de roteamento
Os protocolos de roteamento utilizados na rede interna de da organização são
chamados protocolos de gateway interior ou Interior Gateway Protocol (IGP), como por
exemplo os protocolos RIP e OSPF. Roteamento entre diferentes organizações requerem o
Exterior Gateway Protocol (EGP), e há apenas um EGP para cada rede, normalmente o Border
Gateway Protocol (BGP).

1

Rota de Aprendizagem
Redes de Computadores
Aula 03

Pesquisa:
 Existem outros protocolos de roteamento?
 Como funcionam?
 Que tal procurar na bibliografia da disciplina e na internet, entre outros?
Internetworking no TCP/IP e no ISO/OSI

No modelo TCP/IP a camada de Rede combina as camadas de enlace de dados (link) e a
física do modelo ISO/OSI (camadas 1 e 2) para que haja independência da infraestrutura de
rede, lembra-se? A camada superior – camada 2 ou inter-rede, equivalente à camada de rede
(camada 3) do modelo ISO/OSI, trata do roteamento ou encaminhamento de pacotes entre os
nós das redes.

No modelo TCP/IP as camadas de Aplicação, Apresentação e Sessão - camadas 7, 6 e 5
do modelo ISO/OSI - são combinadas e formam a camada de aplicação. Nesta camada estão
presentes os seguintes protocolos ou serviços, entre outros:

 DNS - Domain Name Service ou serviço de nomes do domínio;
 SMTP – Simple Mail Transfer Protocol ou protocolo simples de transferência de correio
 FTP – File Transfer Protocol ou protocolo de transferência de arquivo;
 Ping – serviço / programa de teste de tráfego entre hosts e redes que funciona por
meio de um “eco” de pacotes;
 HTTP – Hyper Text Transfer Protocol ou protocolo de transferência de hipertexto;
 NFS – Network File System ou sistema de arquivo em rede;
 POP – Post Office Protocol ou protocolo de correio;
 Telnet – Terminal Link over Network ou Terminal Virtual da Rede.
As camadas de Enlace e Física – camadas 2 e 1 do modelo ISO/OSI são unificadas na
camada de Rede – camada 1 do TCP/IP. Como já visto, isto se deve à necessidade de preservar,
no TCP/IP, a independência da rede.

2

Rota de Aprendizagem
Redes de Computadores
Aula 03

Pilha de protocolos
Na camada 2 do TCP/IP – camada inter-redes, são definidos os protocolos responsáveis
por tratar da comunicação entre as redes, a saber:
 IP – Internet Protocol ou protocolo internet, é o mais conhecido e mais importante
protocolo

desta

camada,

responsável,

entre

outras

funcionalidades,

pelo

endereçamento dos hosts na Internet, que também chamamos endereço IP. O IP faz o
encaminhamento dos pacotes entre as redes utilizando o endereço IP do host, a máscara de
rede e o gateway padrão. Por exemplo: endereço do host 192.168.1.25, máscara de rede
255.255.255.0 e gateway padrão 192.168.1.1;

 ARP – Address Resolution Protocol, ou protocolo de resolução de endereço, busca o
endereço físico da interface de rede que corresponde a um IP. Este endereço, também
chamado MAC Address, é um número de 48 bits, geralmente representado em
hexadecimal, como por exemplo:
94-eb-cd-26-5d-16
O ARP cria uma tabela em memória com a equivalência entre endereço físico e
endereço IP. É possível acessar esta tabela com o comando ARP –a na linha de
comando do Windows, por exemplo:
Microsoft Windows [versão 6.3.9600]
(c) 2013 Microsoft Corporation. Todos os direitos reservados.
C:\Users\LuisGonzaga>arp -a
Interface: 192.168.25.79 --- 0x3
Endereço IP
Endereço físico
192.168.25.1
06-e0-58-0f-c3-e8
192.168.25.8
2c-e4-12-03-46-4e
192.168.25.11
10-78-d2-49-a1-e1
192.168.25.25
78-e7-d1-55-d3-53
192.168.25.177
88-a7-3c-a6-3e-6f
192.168.25.202
2c-e4-12-00-56-77
192.168.25.255
ff-ff-ff-ff-ff-ff
224.0.0.2
01-00-5e-00-00-02
224.0.0.22
01-00-5e-00-00-16
224.0.0.252
01-00-5e-00-00-fc
224.0.0.253
01-00-5e-00-00-fd
239.255.255.250
01-00-5e-7f-ff-fa

Tipo
dinâmico
dinâmico
dinâmico
dinâmico
dinâmico
dinâmico
estático
estático
estático
estático
estático
estático

Neste exemplo são mostrados todos os endereços IP com os quais o host pode trocar
informações e seus endereços físicos, isto é, os Mac Address.

3

Rota de Aprendizagem
Redes de Computadores
Aula 03

 RARP - Reverse Address Resolution Protocol ou Protocolo de Resolução Reversa de
Endereços associa um endereço físico (MAC Address) conhecido à um endereço IP. É
necessário haver um servidor ou serviço RARP na rede para responder às solicitações
dos hosts, retornando o IP ligado ao MAC Address fornecido. Como o próprio nome diz,
faz o trabalho reverso do ARP.
 ICMP - O Internet Control Message Protocol ou Protocolo Internet de Controle de
Mensagem permite informar os erros ocorridos no processo de comunicação entre
hosts. O protocolo IP não trata os erros, mas os informa às camadas subjacentes que
podem tratar, registrar ou comunicar os erros. Os switches e os routers utilizam o ICMP
para assinalar erros (delivery problem). Um exemplo do uso do ICMP é o comando ping,
que faz uso de mensagens ICMP. O comando solicita um “eco” para um host destino. Se
o host destino devolver o pacote enviado à origem, então pode ser alcançado pela
comunicação.
 IGMP - Internet Group Management Protocol serve para controlar os membros de um
grupo de multicast controlando a entrada e a saída dos hosts deste grupo. Desta forma
o protocolo otimiza os recursos de uma rede, pois os roteadores só enviam multicast
para os hosts de um determinado grupo. Multicast é a transmissão de áudio e/ou vídeo
de um host para um grupo ou conjunto de outros hosts previamente conhecidos. Como
exemplos de uso de multicast estão os jogos em rede, as videoconferências e a
distribuição de vídeo pela rede no formado de Video on Demand - VOD e IP Television
– IPTV.
Exemplos de internetworking
São exemplos típicos de internetworking:
 A comunicação ponto-a-ponto entre dois hosts de redes fisicamente separadas;
 Conexões entre hosts de uma rede local espalhados por locais distintos;
 Uma rede local, podendo ser a de um provedor de conteúdo (ISP), conectada à
internet.

4

Rota de Aprendizagem
Redes de Computadores
Aula 03

Aula 03 - Parte 2 – Redes de Computadores
Introdução
O material na sequência dá continuidade ao estudo da interconexão entre redes, o
internetworking, abordando o endereçamento IP nas duas versões: IPv4 e IPv6.
Endereçamento IP
Todo host conectado à uma rede TCP/IP requer uma identificação exclusiva e universal
perante a rede, de forma que os pacotes endereçados a ele cheguem somente até ele. Para esta
identificação o host é designado por um endereço IP. O endereço é um número binário de 32
bits, que pode endereçar até 4.294.967.296 hosts. Este número, o endereço, pode ser
representado em binário:
01110101 10010101 00011101 00000010
Ou em decimal pontuado, que é a notação mais comum e mais fácil de entender e
memorizar:
117.149.29.2
A notação decimal é resultado da transformação de cada conjunto de oito bits (octetos
ou bytes) em um número decimal, que pode variar de 0 a 255, representando um intervalo de
256 valores (28). Os endereços IPv4 contém 32 bits e são divididos em endereço da rede e
endereço do host. As máscaras de subrede ou simplesmente Mask são conjuntos de bits
que mostram onde o endereço de rede termina e o onde o endereço de host começa. Para isto
são utilizados os bits 1 para as posições do endereço que representam a rede e os bits 0 para
as posições reservadas ao endereço dos hosts da rede.
Endereçamento IP - Classes
O endereço é composto de identificação da rede (endereço da rede ou NetID) e
identificação do host (endereço do host ou HostID). A organização de NetID e de HostID
define a classe de endereço, e a máscara de rede ajuda a identificar o NetID e o HostID, como
mostrado a seguir:

5

Rota de Aprendizagem
Redes de Computadores
Aula 03

As classes são designadas pelas letras A, B, C, D e E. Na Classe A o primeiro bit do
endereço é sempre 0 (zero), resultando em 224 ou 16.777.216 possíveis endereços de hosts (7
bits para NetID e 24 para HostID). Na Classe B os primeiros bits do endereço são sempre 10
(um, zero), resultando em 216 ou 65.536 possíveis endereços de hosts (14 bits para NetID e 16
para HostID). Na Classe C os primeiros bits do endereço são sempre 110 (um, um, zero),
resultando em 28 ou 256 possíveis endereços de hosts (21 bits para NetID e 8 para HostID). Na
Classe D os primeiros bits do endereço são sempre 1110 (um, um, um, zero). Esta classe é
conhecida por Multicast ID, dada a sua utilização padrão para grupos de multicast. Na Classe E
os primeiros bits do endereço são 1111 (um, um, um, um). Esta classe é de uso reservado
pelos gestores de endereços globais para uso em projetos de pesquisa e testes. A seguir uma
demonstração destas classes, na qual “n” refere-se ao NetID e “h” ao HostID.

6

Rota de Aprendizagem
Redes de Computadores
Aula 03

Endereçamento IP – Endereços reservados
Além dos endereços da Classe E existem determinados endereços que são reservados
para uso específico, isto é, nenhum host ou ativo de rede pode ser designado por estes
endereços. São os seguintes, os endereços reservados:
 127.x.x.x - Reservados para testes internos (também chamado de localhost ou
loopback);
 O primeiro e o último endereço da classe ou da sub-rede: O primeiro, por exemplo
192.168.10.0, é o endereço da rede. O último, por exemplo 192.168.255.255, é o
endereço de broadcast para a rede em questão.
Além disso existem os endereços específicos recomendados para as redes locais ou
redes internas conectadas à Internet. As faixas recomendadas para redes locais (internas) são:
 10.0.0.0 a 10.255.255.255
 172.16.0.0 a 172.31.255.255
 192.168.0.0 a 192.168.255.255
É por isto que sempre se verifica a ocorrência destes endereços nos hosts das redes
locais.
Notação Standard e CIDR
Notação Standard começa com o endereço e contém o prefixo que determina o
tamanho (máscara) da rede. Por exemplo, a representação 192.168.0.0 /24 corresponde a
uma sub-rede que contém 254 endereços possíveis, de 192.168.0.1 até 192.168.0.254, com

7

Rota de Aprendizagem
Redes de Computadores
Aula 03

192.168.0.0 sendo o endereço de rede e 192.168.0.255 sendo o endereço de broadcast para
esta rede.
Na representação 192.168.0.0 /22 tem-se uma sub-rede com 1022 possíveis endereços
de hosts, de 192.168.0.1 até 192.168.3.254, com 192.168.0.0 sendo o endereço de rede e
192.168.3.255 sendo o endereço de broadcast para esta rede.
Para o IPv4, uma representação alternativa usa o endereço de rede, escrito na forma
decimal com pontos, seguido da máscara de sub-rede após uma barra. Desta forma o endereço
192.168.0.0 /24 pode ser escrito como 192.168.0.0 255.255.255.0, pois contando os 24 bits da
esquerda para a direita temos:
11111111.11111111.11111111.00000000
Já o endereço 192.168.0.0 /22 pode ser escrito como 192.168.0.0 255.255.252.0, pois
contando os 22 bits da esquerda para a direita, temos:
11111111.11111111.11111100.00000000
A representação com a barra torna mais flexível o endereçamento, liberando-o do
emprego somente das classes-padrão de endereçamento. 

Por isto é chamada também de CIDR - Classless Inter-Domain Routing ou Roteamento inter-domínio sem uso de classes, e serve
para o endereçamento e agregação de sub-redes, flexibilizando as máscaras de rede e
permitindo um maior aproveitamento dos endereços.

Endereçamento IP – IPv6

O IPv6 é a versão mais atual do protocolo IP, desenvolvida em função do esgotamento
de faixas de endereço do IPv4. Os endereços são representados por números de 128 bits,
permitindo assim a representação de 2128 hosts. O de, normalmente escritos como oito grupos
de 4 dígitos hexadecimais, como por exemplo:
2001:0db8:85a3:08d3:1319:8a2e:0370:7344
Ao escrever o endereço os grupos de vários dígitos seguidos de zeros (0000) podem
ser omitidos, como por exemplo:
2001:0db8:85a3:0000:0000:0000:0000:7344 é o mesmo endereço IPv6 que
2001:0db8:85a3::7344.

8

Rota de Aprendizagem
Redes de Computadores
Aula 03

Endereçamento IP – DHCP
O DHCP - Dynamic Host Configuration Protocol ou Protocolo de configuração dinâmica
de host é um protocolo de serviço TCP/IP que oferece configuração dinâmica, concessão de
endereços IP de host, máscara de sub-rede e Default Gateway (Gateway Padrão). Isto evita o
cansativo e recorrente trabalho de atribuição de endereços aos hosts de uma rede. O DHCP
funciona do seguinte modo: um host envia um pacote UDP em broadcast com uma requisição
DHCP para a porta 67. Um servidor DHCP que capturar este pacote irá responder, caso o
cliente se enquadrar numa série de critérios, para a porta 68 do host solicitante, com um
pacote contendo um endereço IP, uma máscara de rede e outros dados, como o default
gateway, servidores de DNS, etc.

Endereçamento IP – NAT

O NAT - Network Address Translation ou Tradução de Endereços de Rede é uma técnica
que permite reescrever o endereço de um host de uma rede interna quando este é colocado na
Internet, e vice-versa. 

Desta forma os endereços da rede interna (rede local), geralmente
padronizados, não são publicados na internet. Desde modo o uso de NAT torna a rede interna
mais protegida e reduz o número de endereços IP necessários para a rede externa. Porém só é
possível utilizar NAT com os protocolos TCP e UDP. É bom ressaltar que o NAT permite um
máximo de 65535 conexões ativas concorrentes, devido ao uso de 16 bits para a identificação
das portas utilizadas para a conversão.

Trocando Ideias
Acesse o fórum sobre ENDEREÇAMENTO e compartilhe suas descobertas, suas
experiências, exponha suas dúvidas. Faça contato com seus colegas de curso e de turma e
discuta o que aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula foi apresentado o conceito de internetworking e o endereçamento IP nas
versões IPv4 e IPv6, tratando também das classes de endereçamento e das máscaras de rede.

9

Rota de Aprendizagem
Redes de Computadores
Aula 03

Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos com seus
colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo
apresentado.
Autoavaliação

1) Cite os intervalos das redes privadas classe A, B e C assim como suas máscaras padrões.
2) Indique os endereços IP válidos para a rede 192.168.15.0, com máscara 255.255.255.0, além
do endereço de broadcast desta rede.
3) Informe a qual classe de endereçamento IP pertence cada um dos endereços IP abaixo, se este
é válido, ou se é de rede, de host, broadcast ou loopback:
a) 145.32.59.24
b) 200. 42.129.16
c) 127.0.23.21
d) 192.128.23.0
e) 172.16.11.255
f) 10.23.20.2
g) 200.234.34.23
h) 136.23.0.2
4) Uma rede composta de 10 hosts necessita de um esquema que represente o layout ou mapa
desta rede, o endereço IP e a máscara de cada um dos hosts. Observação: o endereço da rede
é 192.168.0.0. Você consegue elaborar? Que tal tentar em equipe?
5) Considere a sub-rede da estação de endereço IP 192.168.100.20 e máscara 255.255.255.248.
Pergunta-se: Qual é o endereço de broadcast desta rede?
a)192.168.100.0
b)192.168.100.23
c)192.168.100.255

10

Rota de Aprendizagem
Redes de Computadores
Aula 03

d)192.168.100.248
e)192.168.255.255
6) Uma empresa tem um endereço de rede classe C 200.10.57.0. Para subdividir a rede física em
3 sub-redes de pelo menos 20 hosts por sub-rede, qual dos endereços a seguir é um IP válido
para uma nova rede?
a)200.10.57.5
b)200.10.57.65
c)200.10.57.161
d)200.10.57.194
e)200.10.57.227

7) A rede interna de uma empresa tem os seguintes hosts que não estão conseguindo comunicarse uns com os outros.
a) IP = 192.168.0.1, Mask = 255.255.255.0
b) IP = 192.168.0.2, Mask = 255.255.0.255
c) IP = 192.168.10.3, Mask = 255.255.255.0
d) IP = 193.168.0.4, Mask = 255.255.255
Resolva o problema refazendo o endereçamento.
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.
Na internet:
 http://www.vivaolinux.com.br/artigo/255.255.255.0-A-matematica-das-mascaras-derede/?pagina=6
 http://www.subnet-calculator.com/
 http://www.vivaolinux.com.br/script/Calculadora-de-host-de-uma-rede

11

Rota de Aprendizagem
Redes de Computadores
Aula 03

 http://www.vivaolinux.com.br/dica/GIP-Calculadora-de-Endereco-IP/
 http://meuip.net.br/calculadora-ip.asp
 http://www.calculadora-redes.com/

12



---------------------------------------------------------------------------------------------
uninter aula 4 rede

Rota de Aprendizagem
Redes de Computadores
Aula 04

Aula 04 - Parte 1 – Redes de Computadores
Introdução
Nesta aula serão tratadas as funcionalidades da camada de transporte. Para isto serão
abordados os protocolos da camada 3 do TCP/IP – TCP, UDP e SCTP e suas características
principais.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 6.1 a 6.5.
 Kurose, 2003 – Seções 3.3, 3.5 e 3.7
Contextualizando

O protocolo TCP

O Transmission Control Protocol, ou protocolo de controle de transmissão, é um dos
principais protocolos da Internet. É adequado às redes globais, pois verifica se os dados são
enviados pela rede da forma correta, na sequência apropriada e sem erros. É um protocolo da
camada de transporte do modelo TCP/IP (camada3), sobre o qual se assentam a maioria dos
demais protocolos e aplicações, como o SSH, FTP, HTTP — e praticamente toda a World Wide
Web.

O processo de transmissão nesta camada funciona da seguinte maneira: transmissor e
receptor criam pontos extremos – os sockets. 

Os Sockets são representados pelo endereço IPe mais um número de 16 bits, 
denominado porta. Por exemplo: 192.168.10.1:8080. 

As portas com valor abaixo de 1024 são chamadas de portas conhecidas e são reservadas
para serviços específicos do TCP. As portas conhecidas só podem ser inicializadas por
usuários com privilégio. 

Essas portas podem ser registradas para uso restrito em
www.iana.org (Internet Assigned Numbers Authority ou Autoridade de Designação de
Números da Internet).

Características do TCP

O protocolo TCP tem como principal característica a garantia da entrega da
informação, isto é, a confiabilidade da transmissão. As suas outras características são:

 Orientado à conexão: É necessário estabelecer uma conexão entre os hosts que
pretende comunicar entre si. Para isto é necessário encaminhar, por meio da rede,
informações de um para o outro de forma que se reconheçam e consigam iniciar a
comunicação.

 Ponto a ponto: A comunicação acontece entre um host e outro do início ao fim, isto é,
um host é a origem e outro é o destino (e vice-versa) como se estivessem fisicamente
ligados.

 Confiabilidade: As informações encaminhadas por meio da rede têm a garantia da
entrega durante todo o processo de comunicação, incluindo-se a identificação, o
tratamento e a correção de erros.

 Full duplex: Uma vez estabelecida a conexão entre os hosts a comunicação flui nos dois
sentidos, fazendo com que ambos sejam, simultaneamente, origem e destino da
comunicação.

 Handshake: O processo de comunicação precisa estabelecer o reconhecimento mútuo
entre os hosts antes de iniciar a transmissão/recepção das informações. O TCP usa para
isso o triplo handshake com o objetivo de sincronizar algumas informações, como o
número de sequência dos pacotes, por exemplo.

 Entrega ordenada: Os pacotes da informação são entregues em sequência ordenada ao
destinatário, de forma que a informação original possa ser remontada ou reconstruída
para ser entregue à camada de aplicação exatamente como estava na origem.
 
   Controle de fluxo: O processo de comunicação inclui a confirmação do recebimento de
cada pacote e a avaliação da quantidade de informações recebidas e aceitas, podendo
inclusive atuar sobre parâmetros da comunicação para adequar o fluxo às condições da
rede naquele momento.

Isto significa, em resumo, que:

 Todas as conexões TCP são full duplex e ponto-a-ponto;
 Full duplex implica em tráfego fluindo em ambas as direções ao mesmo tempo;
 Ponto-a-ponto significa que cada conexão tem obrigatoriamente dois pontos terminais;

2

Rota de Aprendizagem
Redes de Computadores
Aula 04

 O TCP não permite broadcast e tampouco multicasting.

Portas conhecidas do TCP

Existem portas do TCP associadas a serviços e protocolos específicos, que não podem
ser utilizadas com outro propósito. Como já mencionado, estas portas são denominadas
portas conhecidas e seu valor está no limite de 1024. As mais conhecidas são as seguintes:

O processo de transmissão

Transmissor e receptor trocam informações na forma de segmentos. Os Segmentos
são compostos de um cabeçalho de tamanho fixo de 20 bytes e os dados da transmissão
(informações que o usuário quer transmitir ou necessita receber). O software decide o
tamanho do segmento, porém este é limitado ao payload do IP, que é de 64 kBytes (65.535
Bytes). O segmento também é limitado pelo MTU (Maximum Transfer Unit) do enlace de
dados, isto é, a capacidade máxima de encaminhamento de segmentos e seu tamanho.

Um pacote TCP
Um pacote do TCP contém, além das informações de usuário que estão em tráfego,
sinalizações e informações do processo de comunicação em si que buscam prover, entre
outras características, a confiabilidade. Estas informações estão organizadas no pacote TCP da
seguinte maneira:

Os oito bits dos flags do TCP atuam no processo de comunicação com as seguintes
finalidades:

 CWR - Congestion Window Reduced ou janela de congestionamento reduzida, significa
que o fluxo de informação deve ser reuzido em função de perdas ou atraso na
informação;
 ECE - Confirma o “echo” da conexão TCP durante um handshake;
 URG – Indica que o pacote requer tratamento de urgência (pouco utilizado);
 ACK – Reconhecimento válido;
 PSH – Envio imediato dos dados, sem aguardar o preenchimento do buffer;
 RST, SYN e FIN – Processo de estabelecimento e liberação da conexão;
Conexão TCP

O TCP permite o estabelecimento de uma conexão normal, isto é, entre uma origem e
um destino, ou de uma conexão simultânea, na qual ambos os hosts são, ao mesmo tempo,
origem e destino, como mostrado abaixo:

Neste caso ambas as conexões são estabelecidas e operam no modo full duplex
distintamente.

Pesquisa:
O que é, como funciona e qual a finalidade do processo de sliding windows ou janelas
deslizantes do TCP?

-------------------------------------------------------------------------------
Aula 04 - Parte 2 – Redes de Computadores
Introdução
Nesta aula são abordados os protocolos UDP e SCTP da camada 3 do TCP/IP, o seu
funcionamento e as suas características principais.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.4, 3.1, 4.3, 5.1 e 6.2.
 Kurose, 2003 – Seções 1.5, 1.7, 2.1 e 3.1.
Contextualizando
Protocolo UDP
User Datagram Protocol é um protocolo simples da camada de transporte que permite
que a aplicação escreva um datagrama encapsulado num pacote (IPv4 ou IPv6), o qual é então
enviado ao endereço IP do destino. Porém não há qualquer tipo de garantia que o pacote será
entregue. O protocolo UDP não é confiável, e se for necessário garantir a entrega, é preciso
implementar controles tais como timeouts (limite de tempo), retransmissões, acknowlegments
(reconhecimento), controle de fluxo, etc.
Cada datagrama UDP tem um tamanho e pode ser considerado como um registro
indivisível. O UDP é um serviço sem conexão, isto é, não há necessidade de manter uma
ligação entre o cliente e o servidor (ou entre origem e destino). Isto significa que um cliente
UDP pode criar um socket, enviar um datagrama para um servidor e imediatamente enviar
outro datagrama com o mesmo socket para um servidor diferente. Da mesma forma, um
servidor poderia ler datagramas vindos de diversos clientes, usando um único socket. O UDP
também fornece os serviços de broadcast e multicast, permitindo que um único cliente envie
pacotes para vários outros na rede.
Características do UDP
O protocolo UDP é a escolha adequada para fluxos de dados em tempo real,
especialmente aqueles que admitem uma certa perda ou dano de parte de seu conteúdo, tais

6

Rota de Aprendizagem
Redes de Computadores
Aula 04

como vídeos ou voz (VoIP). As aplicações sensíveis a atrasos na rede, mas pouco sensíveis a
perdas de pacotes, como jogos de computadores, também são candidatas naturais ao seu uso.
O UDP suporta broadcasting e multicasting, portanto, caso estes recursos sejam utilizados, o
UDP deverá necessariamente ser utilizado. Parte do desempenho obtido por comunicação
com o UDP deve-se ao fato de que este não perde tempo com criação ou destruição de
conexões. Em função disso, durante uma conexão o UDP troca apenas 2 pacotes, enquanto no
TCP esse número é superior a 10.
O UDP também contempla portas específicas para determinados tipos de serviço ou
operações, dentre as quais cabe citar:

O pacote UDP
Um pacote do UDP é extremamente simples, e contém as informações minimamente
necessárias para o tráfego das informações entre origem e destino, como mostrado:

7

Rota de Aprendizagem
Redes de Computadores
Aula 04

A porta fonte corresponde à porta utilizada pela aplicação emissora do segmento UDP.
Este campo representa um endereço de resposta para o destinatário. A porta destino
corresponde à porta utilizada pela aplicação no host destinatário. O comprimento informa o
tamanho total do segmento, em bytes, incluindo o tamanho do próprio cabeçalho. O checksum
contém uma soma de controle realizada de maneira a poder controlar a integridade do
segmento, permitindo ao destinatário validar se houve alguma alteração no conteúdo da
mensagem que a possa invalidar.
O uso do UDP
Em função de suas características o UDP é frequentemente usado para fluxos de dados
em tempo real, aplicações que requerem Multicasting e Broadcasting e em serviços que
admitem certa perda de dados, tendo em contrapartida uma alta velocidade de comunicação,
como é o caso de streaming de vídeo e de voz. Entre os diversos exemplos de uso do UDP
estão o Youtube e outros serviços de streaming, tanto de áudio quanto de vídeo, as conexões
P2P, o Skype e inúmeros serviços de VOIP, além de serviços de impressão remota.
Protocolo SCTP
Stream Control Transmission Protocol é um protocolo de transporte confiável que
opera sobre um serviço de pacotes não confiável e sem conexão, como é o caso do IP. O SCTP é
orientado a mensagens e utiliza o conceito de associação para estabelecer vários fluxos de
comunicação. Além disso provê suporte para Multihoming.
As principais características do SCTP são:
 Entrega confirmada de dados de usuário, livre de erros e não duplicados;
 Fragmentação de dados em conformidade com o MTU descoberto do caminho;
 Entrega sequencial de dados de usuário em múltiplos fluxos;
 Empacotamento opcional de múltiplas mensagens de usuário num único pacote SCTP;
 Tolerância a falhas de rede através do suporte a caminhos múltiplos (multihoming);
 O SCTP é rate adaptative, adaptando-se às variações da rede;

8

Rota de Aprendizagem
Redes de Computadores
Aula 04

Benefícios do SCTP
O SCTP é um protocolo mais adaptado às necessidades de comunicação das redes
modernas, e, portanto, apresenta alguns benefícios quando comparado ao TCP e ao UDP, como
segue:
 O SCTP provê transmissão confiável, e detecta quando os dados são descartados,
reordenados, duplicados ou corrompidos, retransmitindo os dados quando necessário;
 O SCTP é orientado a conexão;
 O SCTP usa o conceito de associação, o que o torna mais abrangente que a conexão
TCP. Enquanto uma conexão TCP estabelece apenas um único fluxo full duplex, uma
associação SCTP estabelece um número arbitrário de fluxos simplex. Porém, para
simular uma conexão TCP, basta criar um fluxo SCTP em cada direção;
 O SCTP tem potencial de substituir o TCP em diversas aplicações, e além disso pois
todas as portas reservadas pelo IANA ao TCP são automaticamente reservadas ao SCTP.
Pesquisa
O que é a arquitetura de aplicações cliente/servidor? Onde é utilizada e quais são as os
benefícios e as desvantagens do uso desta arquitetura?
Trocando Ideias
Acesse o fórum sobre TRANSPORTE e compartilhe suas descobertas, suas experiências,
exponha suas dúvidas... Faça contato com seus colegas de curso e de turma e discuta o que
aprendeu, e assim busque esclarecer suas dúvidas e reforçar seus conhecimentos.
Síntese
Nessa aula foram apresentados os protocolos da camada 3 – Transporte do modelo
TCP/IP, o TCP, o UDP e o SCTP, incluindo a exploração de suas características e os usos destes
protocolos na comunicação de dados.

9

Rota de Aprendizagem
Redes de Computadores
Aula 04

Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre os protocolos estudados com
seus colegas de curso e de trabalho. Procure ampliar seu conhecimento sobre o conteúdo
apresentado.
Autoavaliação
- Qual a finalidade dos protocolos da camada de transporte do TCP/IP?
- Porque o TCP é considerado um protocolo confiável e o UDP não?
- O que dificulta o uso do TCP em aplicações sensíveis à atrasos na comunicação?
- O UDP faz algum tipo de controle de erro? Como?
- Porque os protocolos da camada 3 – Transporte do TCP/IP fazem referência às portas e não
aos endereços IP?
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo.
Pearson, 2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem.
São Paulo. Pearson, 2003.

10


------------------------------------------------------------------------------------------------
uninter aula 5 rede

Redes de Computadores
Rota de Aprendizagem – Aula 05

Parte 1
Introdução
O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e o endereçamento
por meio de nomes, bem como sua resolução. São tratadas também a estruturação dos nomes, os
domínios e o registro de domínios na internet.
Leitura recomendada:
 Tanenbaum, 2011 – Seções 1.6 e 7.1.
 Kurose, 2003 – Seção 2.5.
Contextualizando:
O que é o DNS?

O DNS – Domain Name System ou sistema de nomes de domínio é uma aplicação que realiza o
serviço de identificação de computadores na rede por meio de um nome. 

O DNS atende as outras aplicações, permitindo o uso de endereços da camada de aplicação – URLs ou um endereço de e-mail –
ao invés de endereços lógicos da camada de rede (endereço IP). 

Diferentemente das pessoas, a rede identifica os computadores por seu endereço IP, totalmente numérico e de difícil memorização. Por causa disto é necessário um serviço que possa relacionar um nome de domínio ou de um host à um
endereço IP: este serviço é o DNS.

As pessoas preferem guardar nomes ao invés de números. O que é mais fácil de memorizar:
ava.uninter.com ou 200.150.68.244?
Para as redes pequenas uma simples tabela contendo os nomes e os respectivos endereços IP
dos hosts é suficiente, como era no início da Internet. Assim cada host mantém sua própria tabela local
e consegue endereçar toda a rede. Porém com um número imenso de hosts, como é atualmente, é
impraticável esta solução, pois haveria necessidade de uma enorme tabela. Além disso seria inviável
atualizar as tabelas hosts de todos os hosts ao mesmo tempo, cada vez que uma mudança ocorresse.
Uma solução seria armazenar uma única tabela em um host específico: isto, porém, geraria um tráfego
enorme na rede, além de sobrecarregar este computador. Outra solução seria dividir o grande volume
de informações para diversos hosts, que passam a atender a consulta daqueles que necessitam
converter nomes em endereços. Estes hosts passam a atuar como servidores DNS e estão organizados
em uma hierarquia dentro do name space ou espaço de nomes. Um espaço de nomes é uma relação
única, em toda a rede, entre um nome e um endereço IP. Um espaço de nome pode ser PLANO ou
HIERÁRQUICO. Um espaço de nomes plano contém um nome qualquer – uma sequência de caracteres,
-1

Redes de Computadores
Rota de Aprendizagem – Aula 05

como servidor_da_rede, por exemplo – associado a um endereço IP. Isto inviabiliza o seu uso em redes
grandes e complexas, pois pode gerar ambiguidades ou nomes duplicados. Um espaço de nomes
hierárquico contém nomes compostos de várias partes, cada qual fazendo referência à uma
característica ou localização do host. Esta é a forma utilizada na internet, na qual as partes dos nomes
são organizadas no formato de uma árvore invertida, formando assim os espaços de nomes de domínio.
Esta “árvore” de domínios comporta até 128 níveis, partindo da raiz – nível 0 –até o nível mais
baixo – nível 127. Cada nó ou subdivisão da árvore é identificado por um rótulo (label) exclusivo que
não se repetirá naquele nível. 

Uma sequência de rótulos separadas por pontos “.” forma um nome de
domínio, como no exemplo dado: ava.uninter.com. A leitura e a formação do nome de domínio são
sempre feitas de baixo para cima na árvore.

Os domínios podem ser genéricos – por especialidade – como “.edu”, “.com”, “.net”, por área
geográfica ou país, como “.br”, “.ch”, “.ar” para Brasil, China e Argentina, por exemplo, sempre utilizando
duas letras. Há também os domínios reversos, cuja finalidade é associar um IP a um nome. Neste caso o
endereço IP faz parte do nome, porém é escrito ao contrário, e associado aos nomes “arpa” e “in-addr”,
como por exemplo em 10.20.30.130.arpa.in-addr, que se refere ao endereço 130.30.20.10.

Os domínios contêm diversos servidores de DNS, sendo o principal chamado de servidor DNS
RAIZ. Este servidor define uma ZONA, à qual estão vinculados todos os demais servidores DNS
primários e secundários. O servidor primário armazena e mantém atualizada a tabela de nomes do
domínio, enquanto o servidor secundário mantém uma cópia desta tabela para atuar em caso de falha
do servidor primário.

Para que um nome possa figurar em um servidor de domínio é necessário que seja cadastrado
em uma entidade registradora homologada pela ICANN - Internet Corporation for Assigned Names and
Numbers – Corporação da Internet para Designação de Nomes e Números. No Brasil o cadastro é
mantido pelo registro.br aos cuidados da FAPESP – Fundação de Amparo à Pesquisa do Estado de São
Paulo. Juntamente com o nic.br – Núcleo de Informações e Coordenação do Ponto BR este cadastro
define os nomes de domínio para o território brasileiro.
Como funciona o DNS
O DNS consiste em uma aplicação cliente/servidor. Um host executando o módulo cliente
encaminha uma mensagem de consulta à um host executando o servidor – ou um servidor DNS. A
mensagem compõe-se de um cabeçalho com as informações do cliente e uma seção de perguntas, que
contém os nomes de domínios a serem traduzidos para endereços IP.O servidor DNS devolve uma
mensagem de resposta formada pelo cabeçalho, com as informações do cliente e do servidor, a seção
-2

Redes de Computadores
Rota de Aprendizagem – Aula 05

de perguntas, uma seção de respostas, uma seção de autoridades e uma seção de informações
adicionais.
O que acontece se um servidor primário não conseguir resolver um determinado nome? Ele
repassará aos nós superiores da hierarquia do domínio para que estes resolvam o nome. Caso a
solicitação chegue até o servidor raiz sem a descoberta do IP, um erro será devolvido na mensagem de
resposta.
Pesquisa
Existem vários servidores de DNS públicos, como o do Google, cujo IP é 8.8.8.8. Descubra outros
e informe os seus nomes e os IPs a seus colegas de curso através do fórum ENDEREÇAMENTO.
DDNS – Dynamic Domain Name System
O sistema de nomes de domínio dinâmico – DDNS é uma evolução do DNS devido às constantes
mudanças nas redes, com a inclusão de novos hosts e domínios ou eliminação de hosts ou domínios.
Promover uma atualização de grande escala é inviável de forma manual. No DDNS, quando um nome é
resolvido as informações são enviadas por meio de DHCP para o servidor primário do domínio, que
cuida da replicação deste novo conjunto para os demais servidores, incluindo os servidores de DNS
secundários. 

Para evitar o uso inadequado o DDNS pode usar mecanismos de autenticação, garantindo
que somente servidores autorizados possam publicar as mudanças.

DNSSEC – Domain Name System Secure

O sistema de nomes de domínio seguro é uma versão de DNS que utiliza a criptografia e a
assinatura digital para a manutenção e o acesso à base de dados do sistema. O uso deste tipo específico
de serviço tem por objetivo evitar ataques de DNS forjado.

Pesquisa

Onde é usado o DNSSEC e com que finalidade? O que é um ataque de DNS forjado? Pesquise e discuta
com os colegas no fórum ENDEREÇAMENTO.

DNS – Características

O DNS pode usar tanto o TCP quanto o UDP, e faz as conexões através da porta 53. Para pacotes
de mensagem de resposta cujo tamanho não exceda os 512 bytes – tamanho típico de um pacote UDP –
este protocolo, o UDP, será usado. Caso o tamanho da mensagem de resposta ultrapasse os 512 bytes
ou não seja conhecido o tamanho, então será usada uma conexão TCP.

-3

Redes de Computadores
Rota de Aprendizagem – Aula 05

Introdução

Parte 2

O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e a utilização de
aplicações para login em outro host, transferência de mensagens entre host – o correio eletrônico ou email e a transferência de arquivos entre hosts.
Leitura recomendada:
 Tanenbaum, 2011 – Seção 7.2
 Kurose, 2003 – Seção 2.3 e 2.4
TELNET
O programa aplicativo cliente/servidor TELNET – de TErminaL NETwork é uma aplicação para
serviços de terminal virtual que provê uma conexão a um sistema remoto por meio da rede. É a
aplicação padrão do TCP/IP para os serviços de terminal virtual de acordo com a ISO – International
Standard Organization. 

O TELNET permite que um host crie, por meio de terminal local, uma conexão a
um host remoto, fazendo com que este terminal se comporte como se fosse um terminal do sistema
remoto. 

Um terminal, neste cenário, é um dispositivo composto de Teclado, Monitor e Mouse – ou um
computador emulando terminal – que possibilita a interação do usuário com os sistemas do
computador remoto. O uso de terminal é típico de sistemas operacionais de tempo compartilhado Time sharing – como o UNIX e o LINUX. O TELNET provê uma interface universal chamada NVT –
Network Virtual Terminal – que utiliza um conjunto de caracteres padrão, pois hosts diferentes podem
usar diferentes conjuntos de caracteres, em função do idioma ou do sistema operacional utilizado por
cada um.

Para tratar os diferentes recursos existentes em cada host o TELNET permite ao cliente e o
servidor negociarem as opções de configuração antes do uso do serviço. Estas opções são recursos
extras disponíveis para terminais mais sofisticados, como cores, gráficos e teclas de função ou
aceleradoras. 

O TELNET faz a conversão de caracteres de acordo com o tipo de computador acessado,
por meio de um driver específico. Para estabelecer a comunicação com o host remoto o TELNET usa
uma conexão TCP e a porta 23 do servidor. O funcionamento do TELNET ocorre de três modos de
operação:

 O modo Padrão, utilizado quando nenhum outro modo for negociado, e aquele no qual o eco
é local, isto é, uma vez digitado um caractere, o próprio cliente (terminal local) faz a
apresentação do mesmo na tela, porém só transmite para o servidor (host remoto) a linha
inteira (ou até que pressionada a tecla <ENTER>).

 No modo Caractere cada vez que um caracter é digitado o mesmo é enviado ao servidor, que
o retransmite de volta para que o cliente faça a apresentação na tela. Isto gera dois efeitos:
em conexões mais lentas ou congestionadas, pode haver um retardo entre a digitação e a
apresentação do caracter; além disso cada caracter digitado vai gerar três segmentos de TCP
na rede.

 No modo Linha a edição de linhas (eco, correção, etc.) é realizada pelo cliente. Quando
finalizada a edição pela tecla <ENTER> então toda a linha é enviada para o servidor.

CORREIO ELETRÔNICO
Uma das aplicações mais conhecidas da internet é o correio eletrônico, ou o E-mail (do Inglês
Electronic Mail). No início da era da internet era possível trocar mensagens curtas e somente de texto
entre dois hosts distantes. Atualmente as mensagens de e-mail são compostas de texto, áudio, imagem
e vídeo, e podem ser encaminhadas a vários destinos simultaneamente. O serviço de correio eletrônico
usa uma arquitetura com três componentes principais, a saber

 O User Agente (UA), agente de usuário, é o serviço ou aplicação responsável pelas operações
do e-mail no cliente, seja o remetente ou o destinatário;

 O Message Transfer Agent (MTA), agente de transferência de mensagens, é a aplicação
cliente/servidor que responde pelo envio de mensagens à um servidor de correio eletrônico;

 Message Access Agent (MAA), agente de acesso às mensagens, é a aplicação cliente/servidor
responsável por buscar as mensagens em um servidor de e-mail.

Um serviço de Correio Eletrônico pode operar de quatro modos distintos. No primeiro modo, o
remetente e destinatário est]ao conectados no no mesmo sistema. Neste caso é necessário apenas o uso
dos programas User Agent (UA). O remetente faz uso do UA para preparar e encaminhar seu e-mail para
o remetente que, quando usar seu UA, receberá a mensagem. É o caso típico do serviço “mail” do UNIX
/ LINUX.

Em um segundo modo, o remetente e destinatário estão conectados a sistemas distintos. Então
é necessário o uso de dois programas User Agent (UA) e um par de programas Message Transfer Agent
(MTA), que funcionam em um modelo cliente/servidor para encaminhar a mensagem de um sistema ao
outro. Este é o caso de uma mensagem de e-mail trocada entre dois sistemas UNIX / LINUX conectados
à rede.

Em um terceiro modo o Remetente faz parte de uma LAN / WAN e o destinatário está conectado
diretamente ao serviço de correio eletrônico. Neste modo é necessário o uso de dois programas User
Agent (UA) e dois pares de servidores Message Transfer Agent, cada par funcionando em modelo cliente
/ servidor para o encaminhamento da mensagem de um sistema até o outro.

Finalmente, no quarto modo, o remetente e destinatário estão conectados ao serviço de correio
eletrônico por meio de uma LAN / WAN. É necessário o uso de dois programas User Agent (UA), dois
pares de servidores Message Transfer Agent (MTA) e um par de servidores Message Access Agent

(MAA). Este é o cenário típico atualmente na internet

SMTP – Simple Mail Transfer Protocol

O SMTP - Simple Mail Transfer Protocol ou Protocolo Simples de Transferência de Mensagem é o
protocolo que define a comunicação entre cliente e servidor do Message Transfer Agent (MTA). O SMTP
utiliza a porta 25 (conexão em texto plano)1 ou a porta 465 (conexão criptografada via SSL). Em um
processo típico de envio de e-mail o SMTP é utilizado tanto entre o cliente (UA) e o servidor de correio
quanto entre os servidores de correio MTA).

POP3 – Post Office Protocol versão 3

O POP3 – Post Office Protocol versão 3 ou Protocolo de Posto de Correio é o protocolo que define
a comunicação entre cliente e servidor Message Access Agent (MAA) para acessar as mensagens
deixadas em um servidor de e-mail. 

O POP3 acessa as mensagens no servidor de e-mail e as disponibiliza para o UA apresentá-las ao seu destinatário. 
O POP3 permite o acesso em dois modos, o modo keep e o módulo delete. 

No modo keep as mensagens são acessadas, porém mantidas no servidor de e-mail, e, portanto, podem ser acessadas novamente a partir de outro cliente MAA. No modo delete as mensagens são acessadas e excluídas do servidor de e-mail, sendo mantidas no UA a partir deste ponto. 

O POP3 utiliza a porta 110 do TCP para acessar as mensagens de correio eletrônico em um
servidor.

No Brasil o CGI.BR orientou, em 2012, usuários, provedores e operadoras de internet a utilizar a porta 587. O intuito é
uma medida de segurança para diminuir o número de spans: http://www.cgi.br/noticia/cgi-br-anuncia-ultima-etapa-dacampanha-para-diminuir-numero-de-spams-enviados-por-redes-brasileiras/309.
-6
1

Redes de Computadores
Rota de Aprendizagem – Aula 05

IMAP4 – Internet Mail Access Protocol versão 4
O IMAP – Internet Mail Access Protocol ou Protocolo de Acesso a Correio pela Internet é o
protocolo que define a comunicação entre cliente e servidor Message Access Agent (MAA) de forma
similar ao POP3, porém com muitos recursos adicionais, como por exemplo:
 É possível acessar o assunto de um e-mail antes de transferi-lo para o UA;
 É possível pesquisar um conteúdo específico nos e-mails do servidor;
 É possível baixar parcialmente um e-mail (sem as imagens, vídeos ou anexos, por exemplo);
 Também é possível que o usuário gerencie pastas e defina o armazenamento de suas
mensagens nestas pastas no servidor de e-mail.
O IMPA4 utiliza a porta 143 do TCP para as conexões cliente / servidor com o servidor de e-mail.

TRANSFERÊNCIA DE ARQUIVOS - FTP – File Transfer Protocol

O FTP – File Transfer Protocol ou Protocolo de Transferência de Arquivos é o protocolo padrão
do TCP/IP para transferência de arquivos entre hosts. 

É uma aplicação cliente / servidor que estabelece duas conexões entre os hosts: uma para os dados e outra para o controle da transferência, e utiliza as portas 20 e 21 para estas duas conexões. Para acessar o servidor e fazer uma transferência é necessário
ter uma conta com um nome de usuário (login) e uma senha. A transmissão dos dados do FTP é feita
por uma conexão TCP. É possível utilizar também o FTP Anônimo para arquivos de acesso público.

Neste caso, geralmente não é necessário login e senha, porém o padrão é que sejam:
Login: anonymous
Senha: guest

Nestes casos o acesso ao sistema é restrito e poucas operações são permitidas.
Outra alternativa para o FTP é o TFPT - Trivial File Transfer Protocol , um protocolo de
transferência de arquivos muito simples e muito semelhante ao FTP. É muito utilizado para transferir
pequenos arquivos entre hosts de uma rede, como, por exemplo, quando um terminal remoto ou um
cliente inicia o seu funcionamento, a partir do servidor.
Pesquisa

O FTP é utilizado por diversos serviços para a transferência de arquivos. Você consegue
identificar quais são estes outros?
Trocando Ideias
-7

Redes de Computadores
Rota de Aprendizagem – Aula 05

Acesse o fórum sobre APLICAÇÔES e compartilhe suas descobertas, suas experiências, exponha
suas dúvidas.... Faça contato com seus colegas de curso e de turma por meio do fórum e discuta o que
aprendeu. Esclareça suas dúvidas.
Síntese
Nessa aula foram apresentados os protocolos e serviços da camada de aplicação voltados para o
acesso remoto via terminal, o correio eletrônico e a transferência de arquivos entre hosts.
Compartilhando
Que tal compartilhar o que você aprendeu? Acesso o fórum sobre as aplicações e discuta com
seus colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo apresentado.
Autoavaliação
- Para que poderia ser usado o TELNET?
- O que é possível “negociar” em uma conexão TELNET?
- Qual é a função de um UA – User Agent no correio eletrônico?
- Porque necessita-se de POP3 e IMAP4 nos serviços de correio eletrônico?
- Quantas conexões o FTP utiliza para a transferência de arquivos? Qual a finalidade destas conexões?
Referências
Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo. Pearson,
2011.
Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem. São
Paulo. Pearson, 2003.

-8



------------------------------------------------------------------------------------------------
uninter aula 6 rede

Redes de Computadores
Rota de Aprendizagem – Aula 06

Parte 1
Introdução
O assunto desta aula é a rede mundial de computadores – a World Wide Web ou teia de alcance
mundial, na tradução livre – e os protocolos do modelo TCP/IP que lhe dão sustentação, como o HTTP,
e a linguagem HTML.
Leitura recomendada: Tanenbaum, 2011 – Seções 1.5.1 e 7.3. Kurose, 2013 – Seções 1.1 e 2.2
Contextualizando
A rede mundial de computadores é um universo de informações distribuídas por toda a terra,
apresentando características de flexibilidade, facilidade de acesso e recursos os mais variados.
Desenvolvida originalmente pela Organização Europeia para a Pesquisa Nuclear (em francês:
Organisation Européenne pour la Recherche Nucléaire), conhecida como CERN (acrônimo para Conseil
Européen pour la Recherche Nucléaire), o maior laboratório de pesquisa de física de partículas do
mundo, a WWW espalhou-se rapidamente pelos ambientes científicos e acadêmicos, não demorando
metade de uma década para chegar aos computadores pessoais e tornar-se o maior fenômeno da
história das comunicações.
World Wide Web
A World Wide Web é um serviço cliente/servidor distribuído, no qual um cliente (browser)
pode acessar serviços em um ou mais servidores distribuídos por diversas localidades. Os serviços
constituem-se em sua maioria em provimento de conteúdo. O conteúdo é distribuído em sites, e cada
site administra seus documentos ou páginas web, com um servidor provendo o acesso aos documentos
mediante a requisição do browser do cliente.
O cliente
O cliente (browser) é aplicação que viabiliza o acesso, a apresentação dos documentos e a
interação com o usuário. É formado por três partes: o controlador, que provê a interface com o usuário
(teclado, mouse e tela), os programas clientes, que efetivamente acessam os documentos arquivados
nos servidores, e os interpretadores, que apresentam os documentos de acordo com o padrao por eles
definidos.

-1

Redes de Computadores
Rota de Aprendizagem – Aula 06

O servidor
O servidor armazena as páginas e os elementos que as compõem. Ao receber uma solicitação de
um cliente, busca a página e a transfere para o cliente para que possa interpretá-las e exibi-las. O
servidor também mantém as páginas solicitadas anteriormente em cache para melhorar a eficiência,
pois é provável que o acesso à uma página não seja único. Um servidor é um computador que utiliza
técnicas multitarefa / multithread / multiprocessamento para melhorar o desempenho, e assim
providenciar o atendimento a vários clientes simultâneos.

URL - Uniform Resource Locator

A URL - Uniform Resource Locator ou localizadora uniforme de recursos é utilizada pelo
protocolo HTTP para prover o acesso a documentos distribuídos mundo afora. Uma URL é um padrão
para a especificação de qualquer tipo de informação na Internet. O formato de uma URL é:

protocolo://host:porta/path, onde:
Protocolo: Identifica o tipo de aplicação utilizada para acessar o conteúdo;
Host: Nome do computador que armazena as informações. Geralmente começa com a
designação www, porém isto não é obrigatório;
Porta: Número da porta (0 – 65535) para acesso ao Host
Path: O caminho para chegar até a informação na estrutura de diretórios do Host. Utiliza o
mesmo modelo do sistema operacional UNIX.

Cookies

O projeto original da internet não previa a interatividade hoje existente, com sites que permitem
acesso apenas a clientes registrados previamente, lojas virtuais e comercio eletrônico com carrinhos de
compra, portais nos quais os usuários podem configurar as páginas que querem acessar e sites de
anúncios e publicidade. Para que isto se tornasse possível foi necessário criar um recurso destinado a
endereçar requisitos e funcionalidades das páginas destes sites, o cookie. A função do cookie é
armazenar informações da sessão e do cliente no host utilizado para o acesso ao site. O formato de um
cookie geralmente é um arquivo de texto ou sequência de caracteres contendo, na maioria dos casos:

 O nome de domínio do cliente;

 Informações coletadas pelo servidor relativas à sessão do cliente

 Data e hora

Estas informações permitirão o registro de preferências e da interatividade com o usuário de um site
de compras, por exemplo.

Pesquisa

Existem cookies no computador que você está usando? Como eles são? O que ele s contém? Isso
representa um risco para você? E para a rede ou os demais computadores da rede?

Documentos WEB

Os documentos da web podem ser de um dos seguintes tipos:

 Estáticos
 Dinâmicos
 Ativos

Os documentos estáticos apresentam uma estrutura fixa. O seu conteúdo é definido na criação
do documento. Armazenados nos servidores, estes documentos são apresentados pelo servidor ao
cliente quando solicitados, sem sofrer qualquer mudança: o cliente recebe apenas uma cópia do
documento. Este documento é construído com tags do HTML – Hipertext Markup Language ou
linguagem de marcação de hipertexto. O browser do cliente então “monta” a exibição do documento
obedecendo as marcações do texto feitas pelas tags HTML.

Os documentos dinâmicos, ao invés disso, são criados pelo servidor à cada solicitação de um
cliente. O seu conteúdo é definido por uma aplicação ou por um script. Quando o documento é solicitado,
o servidor executa a aplicação ou script para gerar seu conteúdo. 

Estes documentos são geralmente construídos com o uso conjunto de HTML e de código escrito
em CGI, PHP, JSP, ASP, ColdFusion, etc. São portanto caracterizados pelo processamento server 
side, ou seja, pelo processamento de informações no servidor para a formatação dos documentos.

Os documentos ativos são os que implicam na execução de um código pelo próprio cliente. Estes
documentos resultam de uma interação com o usuário ou com o host do cliente. Estes códigos são
geralmente formados por Applets Java ou JavaScript. O que diferencia estes códigos é que os Applets são
compostos de código executável, enquanto o JavaScript é composto por texto plano. Estes documentos
são caracterizados pelo processamento client side, ou seja, pelo processamento de informações no
próprio cliente, quer seja par ao envio ao servidor quer seja para a formatação dos documentos a serem
exibidos.
-3

Redes de Computadores
Rota de Aprendizagem – Aula 06

HTML – HyperText Markup Language

A HTML – Hipertext Markup Language ou linguagem de marcação de hipertexto. É a linguagem
padrão para a criação de páginas da World Wide Web. É composta por tags de início e fim para a
formatação da apresentação do conteúdo. Estas tags são incluídas no texto do documento para definir
a formação e a apresentação. As tags utilizam os sinais < > para delimitar seu conteúdo ou abrangência,
e é possível inserir atributos e valores nas tags. O HTML permite o uso de hyperlinks para referenciar
conteúdos em locais diferentes, por meio de URLs, seja este conteúdo uma imagem um áudio, um vídeo
ou mesmo outra página ou documento. Atualmente os sites já empregam o uso de HTML 5, com diversas
novas tags e funcionalidades, especialmente as voltadas para o tratamento e apresentação de
multimídia e gráficos.

HTTP – HyperText Transfer Protocol

O HTTP - HyperText Transfer Protocol ou protocolo para transferência de hipertexto é o
protocolo utilizado para acessar os dados na WEB. Pode-se dizer que é uma combinação de FTP e SMTP:
faz a transferência de arquivos do mesmo modo que o FTP usando conexão TCP, porém com apenas
uma conexão. 

E utiliza mensagens para a requisição de dados como o SMTP. O HTTP usa os serviços
TCP na porta 80 por padrão. 

Além disso o HTTP também inclui comandos ou métodos nas mensagens, tais como GET, POST e PUT, 
que são interpretados pelos clientes e servidores da Web e geram respostas em formato de códigos, 
dentre os quais o mais conhecido é o 404(Not Found). 

O HTTP requer uma conexão persistente, partindo do princípio que, uma vez transferida
e exibida uma página, haverá uma interação com o usuário que resultará em nova mensagem ou
consulta. 

Então o servidor mantém a conexão mesmo após enviar a resposta ao cliente.

O HTTP permite o uso de servidores PROXY, os quais mantém uma cópia dos documentos em
seu cache. Neste caso, o cliente consulta primeiro o PROXY: se a informação não for localizada, então o
próprio PROXY consulta o WEB Server para obter a informação atualizada. Isto reduz o tráfego na rede
de forma significativa, especialmente em redes locais de grande porte.
Pesquisa
Procure na literatura e na internet, ou junto a colegas de curso e de trabalho, modelos de páginas
da web que contenham documentos dos seguintes tipos:
 Estáticos
 Dinâmicos
-4

Redes de Computadores
Rota de Aprendizagem – Aula 06

 Ativos
Analise o código destas páginas (dica: use a tecla F12 no browser) e tente identificar as tags e os
elementos que as compõem.
Trocando Ideias
Acesse o fórum sobre WEB e compartilhe suas descobertas, suas experiências, exponha suas
dúvidas. Faça contato com seus colegas de curso e de turma e discuta o que aprendeu. Esclareça suas
dúvidas.

-5

Redes de Computadores
Rota de Aprendizagem – Aula 06

Parte 2
Introdução
O assunto desta aula é o gerenciamento de redes e o protocolo do modelo TCP/IP que possibilita
o gerenciamento, o SNMP.
Leitura recomendada: Tanenbaum, 2011 – Seções 6.6, 7.4 e 7.5. Kurose, 2013 – Capítulo 9.
Contextualizand
O gerenciamento de rede é uma atividade extensa e complexa que implica na configuração, no
monitoramento, na execução de teste e na elaboração de diagnósticos relativos à operação da rede. O
objetivo principal é manter a operação da rede de forma estável e eficiente, privilegiando a qualidade
dos serviços esperada pelos usuários. O gerenciamento também faz parte das atividades relativas à
segurança da informação.
As atividades de gerenciamento de redes são compostas de tarefas executadas pela combinação
de hardware e software e administradas por pessoas dedicadas às atividades principais do processo de
gerenciamento. O principal elemento deste processo é o protocolo de gerenciamento SNMP.
Sistema de Gerenciamento de Redes
Um sistema de gerenciamento de redes é composto de um conjunto de atividades e recursos
para atender às principais funções do gerenciamento de rede, que podem ser agrupadas em:
 Gerenciamento de configuração
 Gerenciamento de falhas
 Gerenciamento de desempenho
 Gerenciamento de segurança
 Gerenciamento de contabilização
Gerenciamento de configuração:
O gerenciamento de configuração tem por finalidade informar o estado de cada elemento e sua
relação com os demais a cada instante, incluindo as mudanças e problemas ocorridos. Geralmente estas
informações são fornecidas pelos processos de reconfiguração e de documentação da rede
A reconfiguração decorre da necessidade de ajustar os componentes e as características da
rede para adequá-las às mudanças ocorridas no ambiente no qual a rede opera, e pode refletir
alterações no Hardware, no Software e nas contas de usuário.
-6

Redes de Computadores
Rota de Aprendizagem – Aula 06

A documentação também deve contemplar a configuração atualizada de Hardware, de Software
e das contas de usuário. Esta documentação compõe-se de diagramas e documentos de especificações
com as configurações atualizadas. São informações importantes acerca dos equipamentos – que
compõem o inventário de hardware:
 O tipo
 A marca e o modelo
 O número de série
 O fornecedor, incluindo endereço, telefones de contato, e-mail e web site
 Data de aquisição
 Procedimento de garantia e assistência técnica/suporte
 Informações para a manutenção preventiva
 Localização e responsável pela guarda/posse.
Outro componente do gerenciamento de configuração de grande importância é a documentação
do software ou inventário de software, que deve ser integrada ao registro de hardware e contemplar
pelo menos as seguintes informações:
 O tipo
 Versão
 Histórico da instalação (data, hora, quem instalou, parâmetros utilizados)
 Acordo de licenciamento
 Arquivos criados e atualizados
 Patches e correções aplicadas
Gerenciamento de falhas
O gerenciamento de falhas trata do funcionamento adequado de cada elemento da rede,
buscando o bom funcionamento da rede como um todo. O processo de gerenciamento de falhas da rede
comporta duas abordagens: gerenciamento reativo e gerenciamento proativo. O gerenciamento reativo
abrange as tarefas de detecção, isolamento, correção e registro de falhas. O gerenciamento proativo tem
por objetivos impedir a ocorrência de falhas por meio de medidas de prevenção e identificação de sinais
divergentes, ou mesmo da utilização de critérios específicos como a vida útil e a capacidade de trabalho
de determinados elementos da rede. Estes critérios podem também servir de referência para a

-7

Redes de Computadores
Rota de Aprendizagem – Aula 06

manutenção preventiva / preditiva dos componentes e equipamentos e também para a evolução ou
atualização tecnológica que garanta a continuidade operacional.
Gerenciamento de desempenho
O gerenciamento de desempenho busca a melhor eficiência os equipamentos e da rede como um
todo, e trabalha e, conjunto com o gerenciamento de falhas. Trata-se do monitoramento e controle da
rede com base em critérios quantitativos e qualitativos que analisa constantemente a capacidade, o
tráfego na rede, o throughput e o tempo de resposta.
A capacidade de uma rede é determinada em seu projeto, e pelos equipamentos e meios de
transmissão que fazem parte da rede. A capacidade é limitada e, uma vez ultrapassada, resulta em
problemas das mais diversas naturezas, como queda da comunicação, atrasos, perda de informações,
entre outros. O tráfego representa a quantidade de bits ou bytes que são encaminhados e recebidos
pelos nós de rede em função do tempo, e o tráfego excessivo ou desbalanceado pode superar a
capacidade da rede. O throughput é a taxa de transferência medida em um nó da rede ou trecho da rede
para determinar se há um gargalo ou estrangulamento no tráfego. É comum avaliar o throughput em
equipamentos de borda (routers, bridges, modems) ou links que conectam redes, subredes ou pontos
distantes, pois estes elementos podem determinar o tráfego de toda a rede em função de
congestionamentos. Diferentemente do tráfego, que pode variar soente entre trechos da rede ou
subrede, o throughput pode variar de um nó para outro, definindo a existência de um estrangulamento
ou gargalo e significando que há um problema ou falta de capacidade naquele nó. O tempo de resposta
é o intervalo de tempo entre o encaminhamento de uma solicitação de usuário e o recebimento da
resposta. Pode diferenciar-se, e muito, em função do horário, sendo geralmente classificado em tempo
de resposta médio e o tempo de resposta em horários de pico. Uma dificuldade adicional na medida do
tempo de resposta é separar o tempo de resposta da rede e o tempo de resposta dos serviços fornecidos
por meio da rede, como o acesso à bases de dados e aplicações, pois a percepção do usuário decorre de
ambos.
Gerenciamento de segurança
O gerenciamento de segurança é o processo que concentra as atividades de controle de acesso à
rede e aos elementos da rede. É o responsável pela aplicação da política de segurança – especialmente
no que diz respeito a tráfego e acesso, e depende de todos os demais processos para fazer a aplicação,
o monitoramento e o controle de uso e acesso aos recursos da rede. A segurança da rede consiste em
-8

Redes de Computadores
Rota de Aprendizagem – Aula 06

garantir o acesso devido e vetar o indevido, bem como garantir a informação em tráfego pela rede. O
gerenciamento de segurança também é o responsável por registar o uso da rede para efeitos de Controle
e Auditoria.
Gerenciamento de contabilização
O processo de gerenciamento de contabilização providencia a quantificação de acessos e o uso
dos recursos da rede, conhecida como Tarifação. Esta medição é necessária para efeitos de desempenho
e segurança, e tem como principais objetivos evitar o monopólio de recursos escassos ou críticos da
rede – como o link de internet, por exemplo - e promover o uso da forma mais eficiente possível. Além
disso a contabilização provê informações para os administradores planejarem a expansão e a
atualização da rede em função da demanda e do desempenho. É comum também haver o fornecimento
de informações da tarifação para fins de Auditoria.

SNMP – Simple Network Management Protocol

O protocolo simples para gerenciamento de redes é um Framework para gerenciamento de
dispositivos em rede com base no TCP/IP e que usa o conceito de gerente e agente. 

É um protocolo do nível de aplicação, o que permite sua utilização independe das 
características físicas da rede e dos fabricantes do hardware.

Um elemento gerente – ou gerenciador – é um host ou estação que executa
uma aplicação SNMP Cliente. Um elemento agente é um equipamento de rede que executa uma
aplicação SNMP Servidor. O gerenciamento é o resultado da interação entre o cliente e o(s) servidor(es).

O agente é responsável por coletar as informações e mantê-las em uma base de dados, e encaminhá-las
ao gerente quando solicitado, para que o gerente avalie as informações e também possa endereçar ações
ao equipamento no qual o agente está em execução. Os agentes também podem transmitir mensagens
de alerta, os traps, no caso de identificação de situações anômalas, falhas ou problemas de capacidade.
Desta forma o gerenciamento de redes por meio do SNMP ocorre com base em três funções
primordiais:

1) O monitoramento dos agentes feito por um gerente que solicita as informações, aas quais
refletem o comportamento e a situação do equipamento no qual o agente está instalado;
2) A execução de tarefas pelo agente em cumprimento à uma determinação de um gerente;
3) A comunicação de exceções por meio de um agente a um gerente.

-9

Redes de Computadores
Rota de Aprendizagem – Aula 06

O SNMP geralmente é implementado em uma ferramenta mais abrangente que cuida da criação
e atualização de estatísticas e de sua apresentação, geralmente em formato gráfico. Além disso o SNMP
conta com dois protocolos auxiliares:
 SMI – Structure of Management Information, ou estrutura de informações de gerenciamento;
 MIB – Management Information Base, ou base de informações de gerenciamento.

SMI– Structure of Management Information
O SMI é o protocolo que define as regras de atribuição de nomes, estabelece tipos de objetos e
mostra como codificar os objetos e valores. Porém não define o número de objetos, não lhes dá nomes
e tampouco atua na associação entre s objetos e seus valores.

MIB – Management Information Base, ou base de informações de gerenciamento

O MIB é o protocolo que cuida da criação de um conjunto de objetos, nomes, tipos e relações
entre si para um equipamento gerenciável da rede, formando um banco de dados para o equipamento.
Estas informações serão solicitadas pelo SNMP e, em função delas, determinadas ações poderão ser
comandas ao agente.
Síntese
Foram apresentados nesta aula os protocolos de grande importância para o uso e para o
gerenciamento das redes. O mundo WWW e o protocolo HTTP, em conjunto com a linguagem HTML,
que tornaram a internet um padrão mundial e algo que não pode mais ser dissociado do cotidiano das
pessoas e das organizações. Pode-se dizer que estes protocolos definiram o que chamamos de internet
na atualidade, dando um formato característico e tornando-a uma ferramenta de fácil utilização.
Já o protocolo SNMP possibilita o gerenciamento de redes extensas e complexas de forma
simplificada e eficaz, possibilitando o uso de forma adequada e cada vez mais seguro, além de
possibilitar a evolução contínua dos serviços prestados por meio da rede.
Compartilhando
Que tal compartilhar o que você aprendeu? Discuta sobre a www, o HTTP e HTML e o
gerenciamento de redes com seus colegas de curso e de trabalho. Procure expandir e aprofundar o
conhecimento sobre o conteúdo apresentado lendo as páginas recomendadas da bibliografia e
acessando o conteúdo indicado.
- 10

Redes de Computadores
Rota de Aprendizagem – Aula 06

Autoavaliação
- Qual a relação entre WWW e HTTP?
- Quais as semelhanças entre HTTP e FTP? E entre HTTP e SMTP?
- Para que serve uma URL, e como é composta?
- Qual é estrutura de um browser, e qual é a finalidade de seus componentes?
- Quantos tipos de documentos WEB existem, e quais são suas características?
- Defina em poucas palavras o HTML.
- Quais são as funções básicas do gerenciamento?
- Compare o gerenciamento de falhas com o gerenciamento de desempenho, e defina qual é mais
importante para a segurança da rede.
- Como funciona o SNMP?
Referências
 Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo. Pearson,
2011.
 Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem. 6ª
Ed. São Paulo. Pearson, 2013.

- 11



------------------------------------------------------------------------------------------------



------------------------------------------------------------------------------------------------
google docs expoente potencia
altgr + 1,2,3

Usando a barra de ferramentas:

Escreva o elemento base e o elemento expoente juntos.
Selecione o elemento que será o expoente.
Vá para a barra de ferramentas e clique na guia de formato
Selecione a opção "Texto" e clique em "Sobrescrito X²".
ctrl+. sobrescrito
ctrl+, subscrito
-------------------------------------------------------------------------------------------
nping
nping -p 8000 192.168.10.101

-------------------------------------------------------------------------------------------
Redes Uninter

Aula 5 - Aplicação

Parte 1

Introdução

O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e o endereçamento
por meio de nomes, bem como sua resolução. São tratadas também a estruturação dos nomes, os
domínios e o registro de domínios na internet.

Leitura recomendada:

 Tanenbaum, 2011 – Seções 1.6 e 7.1.

 Kurose, 2003 – Seção 2.5.

Contextualizando:

O que é o DNS?

O DNS – Domain Name System ou sistema de nomes de domínio é uma aplicação que realiza o
serviço de identificação de computadores na rede por meio de um nome. 

O DNS atende as outras aplicações, permitindo o uso de endereços da camada de aplicação – URLs ou um endereço de e-mail –
ao invés de endereços lógicos da camada de rede (endereço IP). 

Diferentemente das pessoas, a rede identifica os computadores por seu endereço IP, totalmente numérico e de difícil memorização. Por causa disto é necessário um serviço que possa relacionar um nome de domínio ou de um host à um
endereço IP: este serviço é o DNS.

As pessoas preferem guardar nomes ao invés de números. O que é mais fácil de memorizar:
ava.uninter.com ou 200.150.68.244?

Para as redes pequenas uma simples tabela contendo os nomes e os respectivos endereços IP
dos hosts é suficiente, como era no início da Internet. 

Assim cada host mantém sua própria tabela local e consegue endereçar toda a rede. Porém com um número imenso de hosts, como é atualmente, é impraticável esta solução, pois haveria necessidade de uma enorme tabela. 

Além disso seria inviável atualizar as tabelas hosts de todos os hosts ao mesmo tempo, cada vez que uma 
mudança ocorresse.

Uma solução seria armazenar uma única tabela em um host específico: isto, porém, geraria um tráfego
enorme na rede, além de sobrecarregar este computador. 

Outra solução seria dividir o grande volume de informações para diversos hosts, que passam a atender a consulta daqueles que necessitam converter nomes em endereços. 

Estes hosts passam a atuar como servidores DNS e estão organizados em uma hierarquia dentro do name space ou espaço de nomes. Um espaço de nomes é uma relação única, em toda a rede, entre um nome e um endereço IP. Um espaço de nome pode ser PLANO ou HIERÁRQUICO. 

Um espaço de nomes plano contém um nome qualquer – uma sequência de caracteres,como servidor_da_rede, por exemplo – associado a um endereço IP. Isto inviabiliza o seu uso em redes grandes e complexas, pois pode gerar ambiguidades ou nomes duplicados. 

Um espaço de nomes hierárquico contém nomes compostos de várias partes, cada qual fazendo referência à uma característica ou localização do host. Esta é a forma utilizada na internet, na qual as partes dos nomes são organizadas no formato de uma árvore invertida, formando assim os espaços de nomes de domínio.

Esta “árvore” de domínios comporta até 128 níveis, partindo da raiz – nível 0 –até o nível mais
baixo – nível 127. 

Cada nó ou subdivisão da árvore é identificado por um rótulo (label) exclusivo que
não se repetirá naquele nível. Uma sequência de rótulos separadas por pontos “.” forma um nome de
domínio, como no exemplo dado: ava.uninter.com. A leitura e a formação do nome de domínio são
sempre feitas de baixo para cima na árvore.

Os domínios podem ser genéricos – por especialidade – como “.edu”, “.com”, “.net”, por área
geográfica ou país, como “.br”, “.ch”, “.ar” para Brasil, China e Argentina, por exemplo, sempre utilizando
duas letras. Há também os domínios reversos, cuja finalidade é associar um IP a um nome. 

Neste caso o endereço IP faz parte do nome, porém é escrito ao contrário, e associado aos nomes “arpa” e “in-addr”,
como por exemplo em 10.20.30.130.arpa.in-addr, que se refere ao endereço 130.30.20.10.

Os domínios contêm diversos servidores de DNS, sendo o principal chamado de servidor DNS
RAIZ. 

Este servidor define uma ZONA, à qual estão vinculados todos os demais servidores DNS
primários e secundários. O servidor primário armazena e mantém atualizada a tabela de nomes do
domínio, enquanto o servidor secundário mantém uma cópia desta tabela para atuar em caso de falha
do servidor primário.

Para que um nome possa figurar em um servidor de domínio é necessário que seja cadastrado
em uma entidade registradora homologada pela ICANN - Internet Corporation for Assigned Names and
Numbers – Corporação da Internet para Designação de Nomes e Números. 

No Brasil o cadastro é mantido pelo registro.br aos cuidados da FAPESP – Fundação de Amparo à Pesquisa do Estado de São
Paulo. Juntamente com o nic.br – Núcleo de Informações e Coordenação do Ponto BR este cadastro
define os nomes de domínio para o território brasileiro.

Como funciona o DNS

O DNS consiste em uma aplicação cliente/servidor. Um host executando o módulo cliente
encaminha uma mensagem de consulta à um host executando o servidor – ou um servidor DNS. A
mensagem compõe-se de um cabeçalho com as informações do cliente e uma seção de perguntas, que
contém os nomes de domínios a serem traduzidos para endereços IP.O servidor DNS devolve uma
mensagem de resposta formada pelo cabeçalho, com as informações do cliente e do servidor, a seção 
de perguntas, uma seção de respostas, uma seção de autoridades e uma seção de informações
adicionais.

O que acontece se um servidor primário não conseguir resolver um determinado nome? Ele
repassará aos nós superiores da hierarquia do domínio para que estes resolvam o nome. Caso a
solicitação chegue até o servidor raiz sem a descoberta do IP, um erro será devolvido na mensagem de
resposta.

Pesquisa

Existem vários servidores de DNS públicos, como o do Google, cujo IP é 8.8.8.8. Descubra outros
e informe os seus nomes e os IPs a seus colegas de curso através do fórum ENDEREÇAMENTO.

DDNS – Dynamic Domain Name System

O sistema de nomes de domínio dinâmico – DDNS é uma evolução do DNS devido às constantes
mudanças nas redes, com a inclusão de novos hosts e domínios ou eliminação de hosts ou domínios.
Promover uma atualização de grande escala é inviável de forma manual. No DDNS, quando um nome é
resolvido as informações são enviadas por meio de DHCP para o servidor primário do domínio, que
cuida da replicação deste novo conjunto para os demais servidores, incluindo os servidores de DNS
secundários. Para evitar o uso inadequado o DDNS pode usar mecanismos de autenticação, garantindo
que somente servidores autorizados possam publicar as mudanças.

DNSSEC – Domain Name System Secure

O sistema de nomes de domínio seguro é uma versão de DNS que utiliza a criptografia e a
assinatura digital para a manutenção e o acesso à base de dados do sistema. O uso deste tipo específico
de serviço tem por objetivo evitar ataques de DNS forjado.

Pesquisa

Onde é usado o DNSSEC e com que finalidade? O que é um ataque de DNS forjado? Pesquise e discuta
com os colegas no fórum ENDEREÇAMENTO.

DNS – Características

O DNS pode usar tanto o TCP quanto o UDP, e faz as conexões através da porta 53. Para pacotes
de mensagem de resposta cujo tamanho não exceda os 512 bytes – tamanho típico de um pacote UDP –
este protocolo, o UDP, será usado. Caso o tamanho da mensagem de resposta ultrapasse os 512 bytes
ou não seja conhecido o tamanho, então será usada uma conexão TCP. 

Introdução

O conteúdo desta aula versa sobre a camada 4 – aplicação do modelo TCP/IP e a utilização de
aplicações para login em outro host, transferência de mensagens entre host – o correio eletrônico ou email e a transferência de arquivos entre hosts.
Leitura recomendada:
 Tanenbaum, 2011 – Seção 7.2
 Kurose, 2003 – Seção 2.3 e 2.4

TELNET

O programa aplicativo cliente/servidor TELNET – de TErminaL NETwork é uma aplicação para
serviços de terminal virtual que provê uma conexão a um sistema remoto por meio da rede. É a
aplicação padrão do TCP/IP para os serviços de terminal virtual de acordo com a ISO – International
Standard Organization. O TELNET permite que um host crie, por meio de terminal local, uma conexão a
um host remoto, fazendo com que este terminal se comporte como se fosse um terminal do sistema
remoto. Um terminal, neste cenário, é um dispositivo composto de Teclado, Monitor e Mouse – ou um
computador emulando terminal – que possibilita a interação do usuário com os sistemas do
computador remoto. O uso de terminal é típico de sistemas operacionais de tempo compartilhado -
Time sharing – como o UNIX e o LINUX. O TELNET provê uma interface universal chamada NVT –
Network Virtual Terminal – que utiliza um conjunto de caracteres padrão, pois hosts diferentes podem
usar diferentes conjuntos de caracteres, em função do idioma ou do sistema operacional utilizado por
cada um.

Para tratar os diferentes recursos existentes em cada host o TELNET permite ao cliente e o
servidor negociarem as opções de configuração antes do uso do serviço. Estas opções são recursos
extras disponíveis para terminais mais sofisticados, como cores, gráficos e teclas de função ou
aceleradoras. O TELNET faz a conversão de caracteres de acordo com o tipo de computador acessado,
por meio de um driver específico. Para estabelecer a comunicação com o host remoto o TELNET usa
uma conexão TCP e a porta 23 do servidor. O funcionamento do TELNET ocorre de três modos de
operação:

 O modo Padrão, utilizado quando nenhum outro modo for negociado, e aquele no qual o eco
é local, isto é, uma vez digitado um caractere, o próprio cliente (terminal local) faz a 
apresentação do mesmo na tela, porém só transmite para o servidor (host remoto) a linha
inteira (ou até que pressionada a tecla <ENTER>).
 No modo Caractere cada vez que um caracter é digitado o mesmo é enviado ao servidor, que
o retransmite de volta para que o cliente faça a apresentação na tela. Isto gera dois efeitos:
em conexões mais lentas ou congestionadas, pode haver um retardo entre a digitação e a
apresentação do caracter; além disso cada caracter digitado vai gerar três segmentos de TCP
na rede.

 No modo Linha a edição de linhas (eco, correção, etc.) é realizada pelo cliente. Quando
finalizada a edição pela tecla <ENTER> então toda a linha é enviada para o servidor.
CORREIO ELETRÔNICO
Uma das aplicações mais conhecidas da internet é o correio eletrônico, ou o E-mail (do Inglês
Electronic Mail). No início da era da internet era possível trocar mensagens curtas e somente de texto
entre dois hosts distantes. Atualmente as mensagens de e-mail são compostas de texto, áudio, imagem
e vídeo, e podem ser encaminhadas a vários destinos simultaneamente. O serviço de correio eletrônico
usa uma arquitetura com três componentes principais, a saber:

 O User Agente (UA), agente de usuário, é o serviço ou aplicação responsável pelas operações
do e-mail no cliente, seja o remetente ou o destinatário;

 O Message Transfer Agent (MTA), agente de transferência de mensagens, é a aplicação
cliente/servidor que responde pelo envio de mensagens à um servidor de correio eletrônico;

 Message Access Agent (MAA), agente de acesso às mensagens, é a aplicação cliente/servidor
responsável por buscar as mensagens em um servidor de e-mail.

Um serviço de Correio Eletrônico pode operar de quatro modos distintos. No primeiro modo, o
remetente e destinatário estao conectados no mesmo sistema. Neste caso é necessário apenas o uso
dos programas User Agent (UA). O remetente faz uso do UA para preparar e encaminhar seu e-mail para
o remetente que, quando usar seu UA, receberá a mensagem. É o caso típico do serviço “mail” do UNIX
/ LINUX.

Em um segundo modo, o remetente e destinatário estão conectados a sistemas distintos. Então
é necessário o uso de dois programas User Agent (UA) e um par de programas Message Transfer Agent
(MTA), que funcionam em um modelo cliente/servidor para encaminhar a mensagem de um sistema ao
outro. Este é o caso de uma mensagem de e-mail trocada entre dois sistemas UNIX / LINUX conectados
à rede.

Em um terceiro modo o Remetente faz parte de uma LAN / WAN e o destinatário está conectado
diretamente ao serviço de correio eletrônico. Neste modo é necessário o uso de dois programas User
Agent (UA) e dois pares de servidores Message Transfer Agent, cada par funcionando em modelo cliente
/ servidor para o encaminhamento da mensagem de um sistema até o outro.

Finalmente, no quarto modo, o remetente e destinatário estão conectados ao serviço de correio
eletrônico por meio de uma LAN / WAN. É necessário o uso de dois programas User Agent (UA), dois
pares de servidores Message Transfer Agent (MTA) e um par de servidores Message Access Agent
(MAA). Este é o cenário típico atualmente na internet

SMTP – Simple Mail Transfer Protocol

O SMTP - Simple Mail Transfer Protocol ou Protocolo Simples de Transferência de Mensagem é o
protocolo que define a comunicação entre cliente e servidor do Message Transfer Agent (MTA). O SMTP
utiliza a porta 25 (conexão em texto plano)1 ou a porta 465 (conexão criptografada via SSL). Em um
processo típico de envio de e-mail o SMTP é utilizado tanto entre o cliente (UA) e o servidor de correio
quanto entre os servidores de correio MTA).

POP3 – Post Office Protocol versão 3

O POP3 – Post Office Protocol versão 3 ou Protocolo de Posto de Correio é o protocolo que define
a comunicação entre cliente e servidor Message Access Agent (MAA) para acessar as mensagens
deixadas em um servidor de e-mail. O POP3 acessa as mensagens no servidor de e-mail e as
disponibiliza para o UA apresentá-las ao seu destinatário. O POP3 permite o acesso em dois modos, o
modo keep e o módulo delete. No modo keep as mensagens são acessadas, porém mantidas no servidor
de e-mail, e, portanto, podem ser acessadas novamente a partir de outro cliente MAA. No modo delete
as mensagens são acessadas e excluídas do servidor de e-mail, sendo mantidas no UA a partir deste
ponto. O POP3 utiliza a porta 110 do TCP para acessar as mensagens de correio eletrônico em um
servidor.

1 No Brasil o CGI.BR orientou, em 2012, usuários, provedores e operadoras de internet a utilizar a porta 587. O intuito é
uma medida de segurança para diminuir o número de spans: http://www.cgi.br/noticia/cgi-br-anuncia-ultima-etapa-dacampanha-para-diminuir-numero-de-spams-enviados-por-redes-brasileiras/309.

IMAP4 – Internet Mail Access Protocol versão 4

O IMAP – Internet Mail Access Protocol ou Protocolo de Acesso a Correio pela Internet é o
protocolo que define a comunicação entre cliente e servidor Message Access Agent (MAA) de forma
similar ao POP3, porém com muitos recursos adicionais, como por exemplo:

 É possível acessar o assunto de um e-mail antes de transferi-lo para o UA;
 É possível pesquisar um conteúdo específico nos e-mails do servidor;
 É possível baixar parcialmente um e-mail (sem as imagens, vídeos ou anexos, por exemplo);

 Também é possível que o usuário gerencie pastas e defina o armazenamento de suas
mensagens nestas pastas no servidor de e-mail.

O IMPA4 utiliza a porta 143 do TCP para as conexões cliente / servidor com o servidor de e-mail.
TRANSFERÊNCIA DE ARQUIVOS - FTP – File Transfer Protocol

O FTP – File Transfer Protocol ou Protocolo de Transferência de Arquivos é o protocolo padrão
do TCP/IP para transferência de arquivos entre hosts. É uma aplicação cliente / servidor que estabelece
duas conexões entre os hosts: uma para os dados e outra para o controle da transferência, e utiliza as
portas 20 e 21 para estas duas conexões. Para acessar o servidor e fazer uma transferência é necessário
ter uma conta com um nome de usuário (login) e uma senha. A transmissão dos dados do FTP é feita
por uma conexão TCP. É possível utilizar também o FTP Anônimo para arquivos de acesso público.

Neste caso, geralmente não é necessário login e senha, porém o padrão é que sejam:

Login: anonymous
Senha: guest

Nestes casos o acesso ao sistema é restrito e poucas operações são permitidas.

Outra alternativa para o FTP é o TFPT - Trivial File Transfer Protocol , um protocolo de
transferência de arquivos muito simples e muito semelhante ao FTP. É muito utilizado para transferir
pequenos arquivos entre hosts de uma rede, como, por exemplo, quando um terminal remoto ou um
cliente inicia o seu funcionamento, a partir do servidor.
Pesquisa

O FTP é utilizado por diversos serviços para a transferência de arquivos. Você consegue
identificar quais são estes outros?

Trocando Ideias

Acesse o fórum sobre APLICAÇÔES e compartilhe suas descobertas, suas experiências, exponha
suas dúvidas.... Faça contato com seus colegas de curso e de turma por meio do fórum e discuta o que
aprendeu. Esclareça suas dúvidas.

Síntese

Nessa aula foram apresentados os protocolos e serviços da camada de aplicação voltados para o
acesso remoto via terminal, o correio eletrônico e a transferência de arquivos entre hosts.
Compartilhando
Que tal compartilhar o que você aprendeu? Acesso o fórum sobre as aplicações e discuta com
seus colegas de curso e de trabalho. Procure reforçar o entendimento sobre o conteúdo apresentado.
Autoavaliação

- Para que poderia ser usado o TELNET?

- O que é possível “negociar” em uma conexão TELNET?

- Qual é a função de um UA – User Agent no correio eletrônico?

- Porque necessita-se de POP3 e IMAP4 nos serviços de correio eletrônico?

- Quantas conexões o FTP utiliza para a transferência de arquivos? Qual a finalidade destas conexões?

Referências
Tanenbaum, Andrew S.; Wetheral, David. Redes de Computadores - 5ª edição. São Paulo. Pearson,
2011.
Kurose, James F.; Ross, Keith W. Redes de Computadores e a Internet: uma nova abordagem. São
Paulo. Pearson, 2003.



------------------------------------------------------------------------------------------------------------------------
Aula 4:

O protocolo TCP (Transmission Control Protocol)

O Transmission Control Protocol, ou Protocolo de Controle de Transmissão, é um dos principais protocolos da Internet. É adequado às redes globais, pois verifica se os dados são enviados pela rede da forma correta, na sequência apropriada e sem erros.

É um protocolo da camada de transporte do modelo TCP/IP (camada 3), sobre o qual se assentam a maioria dos demais protocolos e aplicações, como o SSH, FTP, HTTP — e praticamente toda a World Wide Web.

O processo de transmissão nesta camada funciona da seguinte maneira: transmissor e receptor criam pontos extremos – os sockets. Os sockets são representados pelo endereço IP e mais um número de 16 bits, denominado porta, por exemplo, 192.168.10.1:8080. As portas com valor abaixo de 1024 são chamadas de portas conhecidas e são reservadas para serviços específicos do TCP. As portas conhecidas só podem ser inicializadas por usuários com privilégio. Essas portas podem ser registradas para uso restrito no Internet Assigned Numbers Authority ou Autoridade de designação de números: https://www.iana.org/about

O protocolo TCP tem como principal característica a garantia da entrega da informação, isto é, a confiabilidade da transmissão. As suas outras características são:

1.Orientado à conexão: é necessário estabelecer uma conexão entre os hosts que pretendem se comunicar entre si. Para isso é necessário encaminhar, por meio da rede, informações de um para o outro de forma que se reconheçam e consigam iniciar a comunicação.

2.Ponto a ponto: a comunicação acontece entre um host e outro do início ao fim, isto é, um host é a origem e outro é o destino (e vice-versa) como se estivessem fisicamente ligados.

3.Confiabilidade: as informações encaminhadas por meio da rede têm a garantia da entrega durante todo o processo de comunicação, incluindo-se a identificação, o tratamento e a correção de erros.

4.Full duplex: uma vez estabelecida a conexão entre os hosts a comunicação flui nos dois sentidos, fazendo com que ambos sejam, simultaneamente, origem e destino da comunicação.

5.Handshake: o processo de comunicação precisa estabelecer o reconhecimento mútuo entre os hosts antes de iniciar a transmissão/recepção das informações. O TCP usa para isso o triplo handshake com o objetivo de sincronizar algumas informações, como o número de sequência dos pacotes, por exemplo.

Three-way Handshake:

Uma conexão TCP é geralmente estabelecida em 3 etapas:

a.O cliente envia um pacote com a flag SYN ativa.
b.O servidor responde com um pacote com as flags SYN + ACK.
c.O cliente reponde com um pacote com a flag ACK.

Flags to TCP

CWR
ECE ecn - echo
URG urgency
ACK acknowledgment - reconhecimento
PSH push encaminhe os dados agora
RST reset
SYN syncroneze
FIN finalization

6.Entrega ordenada: os pacotes da informação são entregues em sequência ordenada ao destinatário, de forma que a informação original possa ser remontada ou reconstruída para ser entregue à camada de aplicação exatamente como estava na origem.

7.Controle de fluxo: o processo de comunicação inclui a confirmação do recebimento de cada pacote e a avaliação da quantidade de informações recebidas e aceitas, podendo inclusive atuar sobre parâmetros da comunicação para adequar o fluxo às condições da rede naquele momento.

Isto significa, em resumo, que:

Todas as conexões TCP são full duplex e ponto-a-ponto;
Full duplex implica em tráfego fluindo em ambas as direções ao mesmo tempo;
Ponto-a-ponto significa que cada conexão tem obrigatoriamente dois pontos terminais;

O TCP não permite broadcast e tampouco multicasting, justamente pelo fato da comunicação ser ponto a ponto, o que dá confiabilidade. A informação que foi encaminhada até o destino tem que ser validada por esse destino e o destino tem que me responder que recebeu ok. Isso não é possível de ser feito com muitos pontos de recepção e muito menos com todos os elementos da rede simultâneamente, nós temos questões de propagação, atraso e até a capacidade de processamento do host que está enviando a informação que restringe esse tipo de validação. Então o protocola TCP é um protocolo seguro, mas tem essa restrição. Se eu tiver que fazer transmissões para vários pontos, ou para toda a rede, obviamente não vou utilizar o protocolo TCP.

O que é broadcast? É a transmissão generalizada, é quando o endereço de broadcast para a rede, o endereço de todos os computadores, um endereço que simula todos os computadores, quando eu transmito para este endereço que é finalizado lá em 255, então eu estou transmitindo para toda a rede. TCP não permite isso, por que? Porque seria difícil a rede toda responder e eu conseguir processar essa informação. Não é possível, e também não permite multicasting, professor, eu já ouvi isso e não me lembro o que é multicasting. Multicasting é aquela transmissão que é feita para vários destinos, como por exemplo uma vídeo conferência, uma apresentação de vídeo, o IPTV, enfim, eu estou lá assistindo um vídeo do youtube provavelmente tem várias pessoas assistindo e até eu mesmo, isto é um multicasting ok? O protocol TCP não permite esse tipo de transmissão.


Portas conhecidas do TCP
Existem portas do TCP associadas a serviços e protocolos específicos, que não podem ser utilizadas com outro propósito. Como já mencionado, essas portas são denominadas portas conhecidas e seu valor está no limite de 1024. As mais conhecidas são as seguintes:

Porta	Protocolo	Uso
20, 21	FTP	Transferência de arquivos
22	    SSH	Login remoto, substituto do Telnet
25	    SMTP	Correio eletrônico
80	    HTTP	World Wide Web
110	    POP-3	Acesso remoto a correio eletrônico
143	    IMAP	Acesso remoto a correio eletrônico
443	    HTTPS	Web segura (HTTP sobre SSL/TLS)
543	    RTSP	Controle de player de mídia
631	    IPP	Compartilhamento de impressora

O processo de transmissão
Transmissor e receptor trocam informações na forma de segmentos. Os Segmentos são compostos de um cabeçalho de tamanho fixo de 20 bytes e os dados da transmissão (informações que o usuário quer transmitir ou necessita receber).

O software decide o tamanho do segmento, porém este é limitado ao payload do IP, que é de 64 kBytes (65.535 Bytes). O segmento também é limitado pelo MTU (Maximum Transfer Unit) do enlace de dados, isto é, a capacidade máxima de encaminhamento de segmentos e seu tamanho.

Um pacote TCP
Um pacote do TCP contém, além das informações de usuário que estão em tráfego, sinalizações e informações do processo de comunicação em si, que buscam prover, entre outras características, a confiabilidade. Essas informações estão organizadas no pacote TCP da seguinte maneira:

Os oito bits dos flags do TCP atuam no processo de comunicação com as seguintes finalidades:

CWR: Congestion Window Reduced ou janela de congestionamento reduzida, significa que o fluxo de informação deve ser reduzido em função de perdas ou atraso na informação;
ECE: confirma o “echo” da conexão TCP durante um handshake
URG: indica que o pacote requer tratamento de urgência (pouco utilizado);
ACK: reconhecimento válido;
PSH: envio imediato dos dados, sem aguardar o preenchimento do buffer;
RST, SYN e FIN: processo de estabelecimento e liberação da conexão.

O TCP permite o estabelecimento de uma conexão normal, isto é, entre uma origem e um destino, ou de uma conexão simultânea, na qual ambos os hosts são, ao mesmo tempo, origem e destino, como mostrado abaixo. Neste caso, ambas as conexões são estabelecidas e operam no modo full duplex distintamente.


O que é, como funciona e qual a finalidade do processo de sliding windows ou janelas deslizantes do TCP?
--------------------------------------------------------------------------------------------------------------------------------------

Protocolo UDP

User Datagram Protocol é um protocolo simples da camada de transporte que permite que a aplicação escreva um datagrama encapsulado em um pacote (IPv4 ou IPv6), o qual é então enviado ao endereço IP do destino. Porém, não há qualquer tipo de garantia de que o pacote será entregue. O protocolo UDP não é confiável, e se for necessário garantir a entrega, é preciso implementar controles, tais como timeouts (limite de tempo), retransmissões, acknowlegments (reconhecimento), controle de fluxo etc.

Cada datagrama UDP tem um tamanho e pode ser considerado como um registro indivisível. O UDP é um serviço sem conexão, isto é, não há necessidade de manter uma ligação entre o cliente e o servidor (ou entre origem e destino).

ATENÇÃO
Isto significa que um cliente UDP pode criar um socket, enviar um datagrama para um servidor e imediatamente enviar outro datagrama com o mesmo socket para um servidor diferente. Da mesma forma, um servidor poderia ler datagramas vindos de diversos clientes, usando um único socket. O UDP também fornece os serviços de broadcast e multicast, permitindo que um único cliente envie pacotes para vários outros na rede.

Características do UDP

O protocolo UDP é a escolha adequada para fluxos de dados em tempo real, especialmente aqueles que admitem uma certa perda ou dano de parte de seu conteúdo, tais como vídeos ou voz (VoIP). As aplicações sensíveis a atrasos na rede, mas pouco sensíveis a perdas de pacotes, como jogos de computadores, também são candidatas naturais ao seu uso.

O UDP suporta broadcasting e multicasting, portanto, caso estes recursos sejam utilizados, o UDP deverá necessariamente ser utilizado. Parte do desempenho obtido por comunicação com o UDP deve-se ao fato de que este não perde tempo com criação ou destruição de conexões. Em função disso, durante uma conexão, o UDP troca apenas dois pacotes, enquanto no TCP esse número é superior a 10.

O UDP também contempla portas específicas para determinados tipos de serviço ou operações, dentre as quais cabe citar:

Porta	Protocolo	Descrição
7	     Echo	    Ecoa um datagram recebido de volta para o emissor
9	     Discard	Descarta qualquer datagrama recebido
11	     Users	    Usuários ativos
13	     Daytime	Retoma Data e Hora
17	     Quote  	Retoma um comentário do dia
19	     Chargen	Retoma uma string de caracteres
53	     Nameserver	Domain Name Services
67	     BOOTPs	    Servidos bootstrap
68	     BOOTPc	    Cliente boostrap
69	     TFTP	    Trivial File Transfer Protocol
111	     RPC    	Remote Procedure Call
123	     NTP	    Network Time Protocol
161	     SNMP	    Simple Network Management Protocol
162	     SNMP   	Simple Network Management Protocol (trap)

O pacote UDP
Um pacote do UDP é extremamente simples, e contém as informações minimamente necessárias para o tráfego das informações entre origem e destino, como mostrado (clique nos botões):

Porta fonte - Corresponde à porta utilizada pela aplicação emissora do segmento UDP. Este campo representa um endereço de resposta para o destinatário.

Porta destino - Corresponde à porta utilizada pela aplicação no host destinatário.

Comprimento - Informa o tamanho total do segmento, em bytes, incluindo o tamanho do próprio cabeçalho.

Checksum - Contém uma soma de controle realizada de maneira a poder controlar a integridade do segmento, permitindo ao destinatário validar se houve alguma alteração no conteúdo da mensagem que a possa invalidar.


0            15	    16            31
Porta de Origem  	Porta de Destino
    Tamanho	           Checksum
              Dados

O uso do UDP
Em função de suas características, o UDP é frequentemente usado para fluxos de dados em tempo real, aplicações que requerem Multicasting e Broadcasting e em serviços que admitem certa perda de dados, tendo, em contrapartida, uma alta velocidade de comunicação, como é o caso de streaming de vídeo e de voz.

Entre os diversos exemplos de uso do UDP estão o Youtube e outros serviços de streaming, tanto de áudio quanto de vídeo, as conexões P2P, o Skype e inúmeros serviços de VOIP, além de serviços de impressão remota.

--------------------------------------------------------------------------------------------------------
Protocolo SCTP

Stream Control Transmission Protocol é um protocolo de transporte confiável que opera sobre um serviço de pacotes não confiável e sem conexão, como é o caso do IP. O SCTP é orientado a mensagens e utiliza o conceito de associação para estabelecer vários fluxos de comunicação. Além disso provê suporte para Multihoming. As principais características do SCTP são:

Entrega confirmada de dados de usuário, livre de erros e não duplicados;
Fragmentação de dados em conformidade com o MTU descoberto do caminho;
Entrega sequencial de dados de usuário em múltiplos fluxos;
Empacotamento opcional de múltiplas mensagens de usuário em um único pacote SCTP;
Tolerância a falhas de rede através do suporte a caminhos múltiplos (multihoming);
O SCTP é rate adaptative, adaptando-se às variações da rede.

Benefícios do SCTP
O SCTP é um protocolo mais adaptado às necessidades de comunicação das redes modernas e, portanto, apresenta alguns benefícios quando comparado ao TCP e ao UDP, como segue:

O SCTP provê transmissão confiável, e detecta quando os dados são descartados, reordenados, duplicados ou corrompidos, retransmitindo os dados quando necessário;
O SCTP é orientado à conexão;
O SCTP usa o conceito de associação, o que o torna mais abrangente que a conexão TCP. Enquanto uma conexão TCP estabelece apenas um único fluxo full duplex, uma associação SCTP estabelece um número arbitrário de fluxos simplex. Porém, para simular uma conexão TCP, basta criar um fluxo SCTP em cada direção;
O SCTP tem potencial para substituir o TCP em diversas aplicações, pois todas as portas reservadas pelo IANA ao TCP são automaticamente reservadas ao SCTP.




------------------------------------------------------------------------------------
Curso de JavaScript

Aula 1


Aula 2

Aula 3

Aula 4

Aula 5

Aula 6
------------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu primeiro programa...</title>
    <style>
        body  {
            background-color: rgb(232, 241, 97);
            color: rgb(236, 86, 16);
            font: normal ;
        }
        h1 {
            color: rgb(69, 13, 223);
            font-family: Verdana, Geneva, Tahoma, sans-serif;            
            font-style: italic; 
            font-size: 53px;
            text-align: center;
        }


    </style>
</head>
<body>
   
    <h1>Olá, mundo!</h1>
<p>Já me livrei da maldição!!</p> 
<script>
var nome = window.prompt('Qual é seu nome?') // Vai perguntar o nome...
window.alert('É um grande prazer em te conhecer, ' + nome + '!') // Concatenação
</script>
</body>
</html>
------------------------------------------------------------------------------------
//Guardando

string para numero:

Number.parseInt(n)
Number.parseFloat(n)
Number(n)

<script>
var n1 = Number.parseInt(windows.prompt('Digite o número: '))
var n2 = Number.parseInt(windows.prompt('Digite outro número: '))
var s = n1 + n2
window.alert('A soma dos valores é ' + s) // Concatenação
// (number + number) para adição
// (string + string) para concatenação
 </script> 


String(n)

<script>
var n1 = Number.parseInt(windows.prompt('Digite o número: '))
var n2 = Number.parseInt(windows.prompt('Digite outro número: '))
var s = n1 + n2
window.alert('A soma dos valores é ' + String (s)) // Concatenação
// (number + number) para adição
// (string + string) para concatenação
 </script> 

template strings

var s = 'JavaScript'
'Eu estou aprendendo s' // não faz interpolação
'Eu estou aprendendo' + s // usa concatenação

`Eu estou aprendendo ${s}` // usa template string

s.length // quantos caractyeres a string tem
s.toUpperCase() // tudo para 'MAIÚSCULAS'
s.toLowerCase() // tudo para 'minúsculas'

Comando para formatar moeda localização:

> n1.toLocaleString('pt-BR', {style: 'currency', currency: 'BRL'})
'R$ 1.545,50'

> n1.toLocaleString('pt-BR', {style: 'currency', currency: 'USD'})
'US$ 1.545,50'

> n1.toLocaleString('pt-BR', {style: 'currency', currency: 'EUR'})
'€ 1.545,50'
------------------------------------------------------------------------------
Aula 7
 
 Operadores:
 
 aritméticos
 atribuição
 relacionais
 lógicos
 ternário
 
 
 aritméticos:
 
 +
 -
 *
 /
 %
 **
 
 5 + 2 -> 7
 5 - 2 -> 3
 5 * 2 -> 10
 5 / 2 -> 2,5
 5 % 2 -> 1 (resto)
 5 ** 2-> 25 (potencia)
 
 Precedência de operadores soma e divisão - primeiro a divisão.
 
 Ordem de precedência dos operadores aritméticos:
 () 
 ** 
 * / %
 + -
 
 var a = 5 + 3        8
 var b = a % 5        3 
 var c = 5 * b ** 2   45
 var d = 10 - a / 2   6
 var e = 6 * 2 / d    2
 var f = b % e + 4 / e  3 

Operadores de atribuição:
 
n = 3
3
> n = n + 4  n +=4
7
> n = n - 5  n -=5
2
> n = n * 4  n *=4
8
> n =n / 2   n /=2
4
> n = n ** 2 n **=2
16
> n = n % 5  n %=5
1


> num = 8
8
> num +=2
10
> num
10
> num %= 2
0

> num = 3
3
> num **= 2
9
> 

Operadores de incremento:


var x = 5
x = x + 1   x +=1  x++
6
x = x - 1   x -=1  x--
5

Pós incremento

> n = 10
10
> n++
10
> n
11
> n--
11
> n
10

Pré incremento

> ++n
11
> --n
10
> 


Aula 8 parte 2

Operadores Relacionais

operadores aritmeticos e relacionais na mesma linha, primeiro fazer aritméticos e depois os relacionais.
aritméticos e depois os relacionais e depois os lógicos

não e ou


Operador de identidade ou Operador de igualdade restrita:
===

> 5 == '5'
true
> var x = 5
undefined
> var y = '5'
undefined
> typeof x
'number'
> typeof y
'string'
> x == y
true
> x === y
false
> 

> x != y
false
> x !== y
true
> 

Operadores Lógicos:

!   negação
&&  conjunção
||  disjunção

 
aritméticos e depois os relacionais e depois os lógicos

Ordem:
1-não 
2-e
3-ou 
 
 
idade >= 15 && idade <=17 // a idade está entre 15 e 17?
estado == 'RJ' || estado == 'SP' // o estado é RJ ou SP?
salário > 1500 && sexo != 'M' // O slário é acima de 1500 e não é homem?

Ordem de precedência:

() ** /
> < >=
!
&&
||


Operador Ternário:

? :

> var x = 8
undefined
> var res = x % 2 == 0 ? 5: 9
undefined
> x
8
> var idade = 19
undefined
> var r = idade >= 18 ?
... 
> var r = idade >= 18 ? 'MAIOR' : 'MENOR'
undefined
> r
'MAIOR'
> 
-------------------------------------------------------------------------------------
Aula 9
Introdução ao DOM (Document Object Model)

`${Entendendo
     o DOM}`
     
     Árvore DOM
     
               window
                 |
     -------------------------
     location document history
     -------------------------
                 | 
               html
                 |
            ---------
            head body
            ---------
     meta title
     
     5 métodos de acesso: 
     
     1. Por marca getElementsByTagName()
     2. Por ID getElementsById()
     3. Por Nome getElementsByName()
     4. Por Classe getElementsByClassName()
     5. Por Seletor (por CSS)querySelector()
                             querySelectorAll()
     div # 
     class .
     
     -------------------------------------------------------------------------------
     Aula 10

     <!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eventos DOM</title>
     <style>
         div#area {
             font: normal 20pt Arial;
             background-color: rgb(1, 59, 1);
             color: white;
             width: 200px;
             height: 200px;
             line-height: 200px;
             text-align: center;
         }
     </style>
</head>
<body>
    <div id="area" onclick="clicar()" onmouseenter="entrar()" onmouseout="sair()">
        Interaja...
    </div>
    <script>
      var a = window.document.getElementById('area')

      function clicar() {
            a.innerText = 'Clicou!'
        }
      function entrar() {
            a.innerText = 'Entrou!'
        }
        function sair() {
            a.innerText = 'Saiu!'
        }
    </script>
</body>
</html>

     
     <DIV>
     mouseenter
     mousemove
     mousedown
     mouseup
     click
     mouseout

Pesquisar javascript DOM events lists

Funções
function ação(parametros){

}
     
     
     Achar erros devtools
     Botão direito - Inspecionar - erro no console
     
     
     
     
     
     
     
     
     
     
     
     


-------------------------------------------------------------------------------------
Aula 10 Eventos DOM
`Events DOM
--------------------------------------------------------------------------------
Curso de JavaScript ingles - Cisco

Modulo 2 


JSE1: Module 2: Variables, Data Types, Type Casting, and CommentsExternal tool

Variables

The ability to write various information on the screen, such as "Hello, World!" can be fun for a while, but it is not a universal way of writing programs. It's time to start learning more about the puzzle elements that will ultimately allow you to create programs that solve real problems.

There are quite a few of these elements, and we’ll introduce them gradually, although not necessarily in a simple chronology. We will often come back to what has already been discussed, extending the previous information with something new. Sometimes we will also go forward, using mechanisms that will only be explained in more detail over time. At first it may seem a bit overwhelming, but with time everything should start to merge into one coherent picture.

The first element of programming that we will talk about is the variable. You may know the name of a variable from mathematics, where it means a symbol used as a placeholder for different values that can change. They have a similar role in programming.

What do we actually need them for? As you can guess, most programs are quite complex, and we are rarely able to solve the problem with a single operation. Usually, the program will consist of many more operations, each of which can produce some intermediate results, which will be needed in the next steps. Variables allow us to store such results, to modify them, or to feed them into subsequent operations.


Naming the variables
Imagine variables as containers in which you can store certain information (such information will be called variable values). Each container must have its own name, by which we will be able to clearly indicate it.

Usually, we have quite a lot of freedom when it comes to inventing these names, but remember that they should refer to what we will store in the variable (e.g. height, color, stepCounter, and so on). Of course, JavaScript will not verify the correlation between the name and the contents of the variable – it is simply one of the many good practices that make it easier for us and others to understand the code later on.

In most programming languages, a variable must be declared before use, and JavaScript is no exception. Declaring a variable is simply "reserving" the name of the variable. This way, we inform the program that in the further part of the execution, we will use this name to refer to our container, in order to retrieve a value from it, or save a value to it.

In JavaScript, variable names may consist of any sequence of letters (lower-case and upper-case), digits, underscore characters, and dollar signs, but they must not start with a digit. There is a list of reserved words that cannot be used as variable names (look at the table below).

The important thing is also that the JavaScript interpreter distinguishes between lower-case and upper-case letters, also in variable names, so names such as test, Test, or TEST will be treated as different.

The names of variables in JavaScript can be virtually any character string. However, there is a set of reserved words that cannot be used to name variables, functions, or anything else. They are integral parts of the language and are assigned meaning that cannot be changed. Below you will find a list of them.

abstract	arguments	await	boolean

break	byte	case	catch

char	class	const	continue

debugger	default	delete	do

double	else	enum	eval

export	extends	false	final

finally	float	for	function

goto	implements	if	import

in	instanceof	int	interface

let	long	native	new

null	package	private	protected

public	return	short	static

super	switch	synchronized	this

throw	throws	transient	true

try	typeof	var	void

volatile	while	with	yield



Declaring variables
As we mentioned before, we declare the variable to reserve a name for it. This is a simplification, because in fact, memory space is also reserved for the variable, but when programming in JavaScript, we practically never have to think about what happens in the memory. Usually, the values stored in the variable will be able to be modified during the execution of the program (they are "variables", after all). Why usually? Because we can declare variables whose values cannot be changed. To be honest, we don't even call them variables anymore – we call them constants. For the declarations, we use the keywords var or let for variables and const for constants. For now, however, let's stay with the usual variables, and we will return to the constants in a moment.

Let’s analyze the following code sample (you will also find it in the editor window – run it there and watch the results in the console):


var height;
console.log(height); // -> undefined
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

The first line is the variable declaration (we can see the var keyword). This declaration means that the word height will be treated as the name of the container for certain values.



The declaration, like other JavaScript instructions, should end with a semicolon. In the second line, we try to write out the value of this variable (that is, what is in the container) on the console. Because we haven't put anything there yet, the result is undefined (the interpreter knows this variable, but it has no value yet – the value is undefined). In the next line, we try to print out the contents of the weight variable ... which we forgot to declare. This time, we will see ReferenceError. The JavaScript interpreter, which executes our program, has informed us that it doesn’t know a variable by this name (so the variable itself is undefined).

Variables - declaring variables cd.

In the example, we use the keyword var. The alternative to it is the keyword let. We use both keywords in the same way. Both are meant for declaring variables, and both can be found in different examples on the Internet or in books. However, they are not exactly the same, and we’ll discuss the differences in their operation later in this chapter (even in several places).

The keyword var comes from the original JavaScript syntax, and the keyword let was introduced much later. Therefore, you will find var more in older programs. Currently, it is highly recommended to use the word let for reasons that we’ll discuss in a moment.

So, let's take a look at our example rewritten this time using the keyword let.

let height;
console.log(height); // -> undefined

One of the basic differences in the use of var and let is that let prevents us from declaring another variable with the same name (an error is generated). Using var allows you to re-declare a variable, which can potentially lead to errors in the program execution.

var height;
var height;
console.log(height); // -> undefined

The example above demonstrates the possibility of re-declaring a variable using the keyword var. In this situation, it will not cause an error, but in more complex programs a redeclaration, especially by accident, may no longer be without consequences. When declaring with let, the interpreter checks whether such a variable has already been declared, no matter if let or var is used in the previous declaration.

let height;
let height; // -> Uncaught SyntaxError: Identifier 'height' has already been declared
console.log(height);

So use let to declare variables, if only because you don't want to accidentally declare a variable again.

var height;
console.log(height); // -> undefined
console.log(weight); // -> Uncaught ReferenceError: weight is not defined

Initializing variables
After a successful declaration, the variable should be initialized, in other words, it should be given its first value. Initialization is done by assigning a certain value to a variable (indicated by its name). To assign it, we use the operator =.



You can assign to a variable: a specific value; the contents of another variable; or, for example, the result returned by a function.

Initialization can be done either together with the declaration, or separately as an independent command. It is important to enter the first value into the variable before trying to read, modify, or display it.

let height = 180;
let anotherHeight = height;
let weight;
console.log(height); // -> 180
console.log(anotherHeight); // -> 180
weight = 70;  
console.log(weight); // -> 70

In the above example (check it in the editor), the declarations of the variables height and anotherHeight are combined with their initialization, while the variable weight is declared and initialized separately. The height and weight variables are initialized by providing specific values (more precisely, a number), while the anotherHeight variable receives a value read from the height variable. The values of all the variables are displayed on the console.

By the way, pay attention to one thing. If you specify a variable name in console.log, the interpreter recognizes it and displays its value. If you put the same name in quotation marks, it will be treated as plain text, and displayed as such.

let height = 180;
console.log(height); // -> 180
console.log("height"); // -> height

Declarations and strict mode
JavaScript had some major changes introduced in 2009 and 2015. Most of these changes extended the language syntax with new elements, but some of them concerned only the operation of the JavaScript interpreters. Often it was about clarifying the interpreters' behavior in potentially erroneous situations, such as in cases of variable initialization without any prior declaration.

Let's look at an example:

height = 180;
console.log(height); // -> 180

At first glance, you can see that we’ve forgotten to declare the variable height. The original JavaScript syntax allowed for such negligence, and at the moment of initialization it made this declaration for us. It seems like quite a good solution, but unfortunately it can sometimes lead to ambiguous and potentially erroneous situations (we’ll say a few more words about it while discussing the scope).

Let's modify our example:

"use strict";

height = 180; // -> Uncaught ReferenceError: height is not defined
console.log(height);

At the beginning of our code, we’ve added "use strict";. This statement has radically changed the behavior of the interpreter. Why? We use it when we want to force the interpreter to behave according to modern JavaScript standards. So, as long as you aren’t running some really old code, you should always use it. And this time, using a variable without its previous declaration is treated as an error.

The sentence "use strict"; must be placed at the very beginning of the code. It will cause the interpreter to deal with the rest of the code using strict mode, which is the modern JavaScript standard. All further examples in our course will be prepared to work in this mode by default, even if "use strict"; does not always appear at the beginning of the code.

Changing variable values
Variables, as their name suggests, can store data that will vary. Changes are made by assigning a new value to the variable, which overwrites the previous one.

let steps = 100;
console.log(steps); // -> 100
steps = 120; // -> 120
console.log(steps);
steps = steps + 200;
console.log(steps); // -> 320

In our example, we’ve declared a variable called steps. Initially, it contains the number 100, which is then changed to 120. Then we add 200 to the current contents of the variable, as a result of which the variable contains 320.

Variables in the JavaScript language are untyped (or, to be more precise, they are weakly and dynamically typed). This means that JavaScript will not control what type of value we store in the variable. What exactly is the data type? You can probably intuitively answer this question yourself. The type determines the belonging of a given data to a certain set that share the same properties and on which you can perform the same operations. Data types vary greatly depending on the programming language. In JavaScript, the main types are number and character string. We will talk much more about types in the next chapter. Let's declare a few variables and initialize them with values of different types:

let greeting = "Hello!";
let counter = 100;

As you can see, the greeting variable is initiated with a value of the string type, while the counter variable is initiated with a value of the number type. Continuing the example, we will make a small change in the contents of the greeting variable.

console.log(greeting); // -> Hello!
greeting = 1;
console.log(greeting); // -> 1

JavaScript allows us to easily replace the greeting variable with a value whose type is different from the one originally stored there. JavaScript goes one step further and not only allows us to change the types of values kept in a variable, but it also performs their implicit conversion if necessary (we will also return to this topic of conversion when discussing types). Let's restore the original value of the greeting variable and then add the value of the counter variable to it.

greeting = "Hello!";
greeting = greeting + counter;
console.log(greeting); // -> Hello!100

The interpreter will check the type of value stored in the greeting variable and convert the value from the counter variable to the same type before performing an addition operation. As a result, the string "100" will be added to the "Hello!" character string and stored to the greeting variable. By the way, note that JavaScript interprets 100 as a number, but "100" as a string.

Constants
The const keyword is used to declare containers similar to variables. Such containers are called constants. Constants are also used to store certain values, but once values have been entered into them during initialization, they can no longer be modified. This means that this type of container is simultaneously declared and initialized. For example, the following declaration of the greeting constant is correct:

const greeting = "Hello!";

But this next one definitely causes an error:

const greeting; // -> Uncaught SyntaxError: Missing initializer in const declaration
greeting = "Hello!";

As we said, a change in the constant is impossible. This time the declaration is correct, but we try to modify the value stored in the constant.

const greeting = "Hello!";
greeting = "Hi!"; // -> Uncaught TypeError: Assignment to constant variable.

The main purpose of a constant is to eradicate the possibility of accidentally changing a value stored in it. This is important when we have some values that really should never change. Typical examples of constants are paths to resources, tokens, and other data that never change throughout the lifetime of the script.

But constants can also be used as sub results in calculations or in other places where whatever information was gathered or calculated will not change any further. Using a const, besides preventing a value from being changed by mistake, allows the JavaScript engine to optimize the code, which may affect its performance.

Scope
Until now, we assumed that after declaring a variable, its name could be used in the whole code of the program (i.e. the scope of the variable is global). This is not entirely true – the scope of a variable depends on where it is declared. Unfortunately, for a good understanding of variable scope, we need to learn a few more programming elements, such as conditional instructions or functions, which will be discussed in more detail later in the course. So here we will limit ourselves to basic information, and will come back to this issue in different parts of the course. One of the basic elements that influence the scope of variables is a program block.

Program blocks
We can separate the code of a program into blocks. In the blocks that we create using curly brackets, there is a set of instructions, which for some reason should be treated independently. The blocks are usually associated with conditional instructions, loops, or functions, which we will talk about later. We can also separate a block of a program unrelated to anything special, simply by choosing a certain range of instructions (in practice, this is not particularly justified, and for now we will only do it for educational reasons).

Let's look at an example:

let counter;
console.log(counter); // -> undefined
{
    counter = 1;
    console.log(counter); // -> 1
}
counter = counter + 1;
console.log(counter); // -> 2

First, we declare the variable counter. Then we open a block inside which we initialize this variable and display its contents. Outside the block, we increase the value stored in the variable by 1 and display it again. In this case, the interpreter will execute the program as if it hadn't noticed the block, going through the instructions before the block, in the block, and after the block. Creating a block here, without, for example, conditional instructions, has no real justification – it is just an example of using brackets.

Program blocks can be nested, that is, we can create one block inside of another one.

let counter;
console.log(counter); // -> undefined
{
    counter = 1;
    {
        console.log(counter); // -> 1
    }
}
counter = counter + 1;
console.log(counter); // -> 2


By the way, please note that the code inside the block has been moved to the right. This is called an indentation. For a JavaScript interpreter, it doesn't matter at all, but it definitely increases the readability of the code, allowing the readers (including you) to quickly find out which parts of the code are inside, and which are outside, the block. Code editors usually add indentations in the right places by themselves, but it is a good habit to remember this yourself and, if they do not appear automatically, format the code by hand.

It's time to move on to determine what is actually going on with these scopes. Unfortunately, the scopes of variables (and constants) declared with let and const look slightly different than those declared with var. So we will discuss them independently.

let and const
The first rule is simple. If we declare any variable or constant using let or const, respectively, outside the code blocks, they will be global. By this we mean that their names will be visible throughout the program, outside blocks, inside blocks, in functions, and so on. We will be able to refer to them anywhere by their names, and of course have access to their values.

What happens if we declare something using let or const inside a block? This will create a local variable or constant. It will be visible only inside the block in which it was declared and in blocks that can optionally be nested in it.

Let's look at a simple example:

let height = 180;
{
    let weight = 70;
    console.log(height); // -> 180
    console.log(weight); // -> 70   
}
console.log(height); // -> 180
console.log(weight); // -> Uncaught ReferenceError: weight is not defined
The height variable, declared outside the block, is global. The weight variable is local – its scope is limited by the block in which it was declared. This is clearly visible when trying to display the values of both variables inside and outside the block. We can also test the case with nested blocks

let height = 200;
{
    let weight = 100;
    {
        let info = "tall";
        console.log(height); // -> 200
        console.log(weight); // -> 100
        console.log(info); // -> tall
    }
    console.log(height); // -> 200
    console.log(weight); // -> 100
    console.log(info); // -> Uncaught ReferenceError: info is not defined
 }

As you can see, the info variable declared in the most internal block is visible only inside it. The weight variable is visible both inside the block in which it was declared and inside the block nested in it. And the global variable height is visible everywhere.

Simple, isn't it?

var
In the case of variable declarations using the keyword var, the situation is slightly different. The variable declared using it outside the blocks will, as in the case of let, be global, in other words, it will be visible everywhere. If you declare it inside a block, then... well, it will usually turn out to be global again.

Let's start with a simple example:

var height = 180;
{
    var weight = 70;
    console.log(height); // -> 180
    console.log(weight); // -> 70   
}
console.log(height); // -> 180
console.log(weight); // -> 70

As expected, both variables, height and weight, turn out to be global. Will the variables declared using var always, regardless of the place of declaration, be global? Definitely not. The problem is that var ignores ordinary program blocks, treating them as if they do not exist. So in what situation can we declare a local variable using var? Only inside a function. We will devote a lot of space to discussing the function, and then we will come back to the problem of the variable scope as well. Now we will try to present and discuss only a simple example, which will show that var variables are sometimes local, too.

A brief word about functions
Let's start by explaining what functions are. It often happens that a certain piece of code, performing some specific task, will be used many times. Yes, you can copy this piece of code, all of its instructions, to any place where you want to use it. However, this would be very inefficient. First of all, the size of our program would grow unnecessarily. Secondly, if we would like to make some changes to this piece of code, for example, to correct some bug, we would have to do it in every place where we used it.

A simple solution to this problem is a function. A function is just a separated piece of code that you name, in the same way that you name a variable. If you want to use it somewhere, you simply refer to it using that name (we say that we call the function).

The declaration of a simple function, let's say testFunction, may look like this:

function testFunction() {
    console.log("Hello");
    console.log("World");
}

The way to define the function shown in the example is one of several available in JavaScript. The definition starts with the function keyword, followed by the function name we invented. After the name, you see parentheses, which optionally could contain parameters passed to the function (we will come back to this when we discuss the function more precisely). Then we open the program block, which contains the instructions belonging to the function. When defining a function, the instructions contained in the function are not executed. To execute the function, you must call it independently, using its name.

Take a look at the following program.

console.log("let's begin:"); // -> let's begin:
console.log("Hello"); // -> Hello
console.log("World"); // -> World
console.log("and again:"); // -> and again:
console.log("Hello"); // -> Hello
console.log("World"); // -> World
console.log("and once more:"); // -> and once more:
console.log("Hello"); // -> Hello
console.log("World"); // -> World

It will print out a sequence of text on the console:

let's begin:
Hello
World
and again:
Hello
World
and once more:
Hello
World

We can rewrite the same program using our testFunction function. Let's declare it again and call it in the right places:

function testFunction() {
    console.log("Hello");
    console.log("World");
}

console.log("let's begin:");
testFunction();
console.log("and again:");
testFunction();
console.log("and once more:");
testFunction();
output

The effect of the program will be the same as before (test both examples).

The var keyword - continued
After this short introduction to functions (this is obviously not our last meeting with them) let's return to the keyword var and variable scopes.

If we declare a variable using the keyword var inside a function, its scope will be limited only to the inside of that function (it's a local scope). This means that the variable name will be correctly recognized only inside this function.

Let's consider the following example:

var globalGreeting = "Good ";

function testFunction() {
    var localGreeting = "Morning ";  
    console.log("function:");
    console.log(globalGreeting);
    console.log(localGreeting);
}

testFunction();

console.log("main program:");
console.log(globalGreeting);
console.log(localGreeting); // -> Uncaught ReferenceError: localGreeting is not defined

First of all, run this program and observe the results on the console. What happened, and above all, why did it happen?

Let's take a closer look at the code. In the example, we declared the global variable globalGreeting. Then we defined the testFunction function, inside which we declared the local variable localGreeting. Then we called the testFunction function, which resulted in writing out the values of both variables (inside the function, we have access to both the global variable and the local ones). Attempting to access the local variable localGreeting outside the function will fail. So we’ve finally succeeded in demonstrating that variable declarations using the word var can also be local.

Variable shadowing
JavaScript allows for variable shadowing. What does that mean? It means that we can declare a global variable and a local variable of the same name.

In the local scope, in which we declare a local variable using its name, we will have access to the local value (the global variable is hidden behind the local one, so we do not have access to it in this local scope). Using this name outside the local scope means that we will be referring to the global variable. This is not best programming practice, however, and we should avoid such situations. It is not difficult to guess that with a bit of inattention, using this mechanism can lead to unintended situations and probably to errors in the operation of the program.

If we are to avoid such situations, it would be good to see exactly what they are about. Let's begin with an example without shadowing:

let counter = 100;
console.log(counter); // -> 100
{
   counter = 200;
   console.log(counter); // -> 200
}
console.log(counter); // -> 200

The counter variable, declared at the beginning of the program, is a global variable. Throughout the program, also inside the block, we operate on this very variable. A small change in the code is enough for the program to behave completely differently.

let counter = 100;
console.log(counter); // -> 100
{
  let counter = 200;
  console.log(counter); // -> 200
}
console.log(counter); // -> 100

You see the difference? This time in the block, instead of counter = 200; (i.e. changes in the contents of the global counter variable), the let counter = 200; statement appears (i.e. declarations of the local variable combined with its initialization). The interpreter would consider such a situation to be wrong if the re-declaration appeared in the same scope.

However, the declaration is local (it’s a different scope than global) and all references to the variable with this name inside the block will refer to this local variable. Outside the block, the global variable will still be seen under the same name. Pay attention to the values displayed by the console.

Variable shadowing - continued
Shadowing may not only be concerned with the situation in which a local variable covers a global variable. If nested scopes appear (e.g. nested blocks in the case of a let declaration), the local variable declared in a more nested block will overshadow the local variable of the same name declared in the external block.

Shadowing is also present in variable declarations using the word var, and this time the local scope is limited not by the program block, but by the function block.

var counter = 100;

function testFunction() {
    var counter = 200;  
    console.log(counter);
}

console.log(counter); // -> 100
testFunction(); // -> 200
console.log(counter); // -> 100

In most cases, this is not desirable, so try to avoid giving the same variable names to multiple variables, regardless of where you declare them.

Hoisting
Remember how we said that all variables must be declared before use? This is not entirely true, and really the word "should" is a better fit than "must". Of course, good practice is always to declare variables before they are used. And stick to this. But the original JavaScript syntax allows for some deviations from this rule.

The JavaScript interpreter scans the program before running it, looking for errors in its syntax, among other things. It does one more thing on this occasion. It searches for all variable declarations and moves them to the beginning of the range in which they were declared (to the beginning of the program if they are global, to the beginning of the block if it is a local let declaration, or to the beginning of the function if it is a local var declaration). All this happens, of course, in the interpreter memory, and the changes are not visible in the code.

Hoisting, because we are talking about it, is a rather complex and frankly speaking quite incoherent mechanism. Understanding it well requires the ability to freely use many JavaScript elements, which we have not even mentioned yet.

What's more, it's rather a curiosity than something practical that you will use when writing programs, so we will look at just one small example that will allow us to roughly understand the very principle of hoisting. This may make it easier for you to understand some surprising situations when writing your own code, or testing examples you find in various sources.

var height = 180;
console.log(height);  // -> 180
console.log(weight);  // -> Uncaught ReferenceError: weight is not defined

In the above example, we forgot to declare the variable weight. The result is obvious: we’re referring to a variable (that is, we’re trying to read its contents) which does not exist. Something like this must end in an error.

Let's make a small change:

var height = 180;
console.log(height);  // -> 180
console.log(weight);  // -> undefined
var weight = 70;
console.log(weight);  // -> 70

This time we declared our variable, but in a rather strange place. Together with the declaration, we also performed initialization. The result of the program may be a bit surprising. This time there are no errors. Hoisting has worked, and the declaration has been moved by the interpreter to the beginning of the range (in this case the program).

However, the attempt to display the contents of the weight variable give two different results. Why? Hoisting only concerns the declaration, not initialization. So the value 70, which we assign to the weight variable, remains on the line where the original declaration is. The above example is interpreted by the JavaScript engine more or less in the following way:

var weight;
var height = 180;
console.log(height);  // -> 180
console.log(weight);  // -> undefined
weight = 70;
console.log(weight);  // -> 70

Hoisting unfortunately works a little differently with the let and const declarations.

However, we will not go into it. It is enough that you are aware of the phenomenon. And most of all, you will remember ALWAYS to declare variables before using them.

Summary
Using variables, in other words, declaring, initializing, changing, or reading their values is an elementary part of practically every programming language. JavaScript is no exception, as you need to use variables to program in it. Remember to declare variables before using them. Pay attention to where you declare them – whether they are local or global. Try to use the keywords let and const, not the word var. Knowing the latter will be useful not for understanding the examples found in various sources, but rather so that you can avoid using it yourself. Remember not to use the same names for different variables, even if you declare them in different ranges. And, of course, give the variables names that will be related to what you want to store in them – the code should be readable not only to the interpreter, but also to people.


Tasks

Task 1

Let's play florist. Declare six variables, remembering to name them according to their purpose:

the price of a single rose (8) and the number of roses you have (70)
the price of a single lily (10) and the number of lilies you have (50)
the price of a single tulip (2) and the number of tulips you have (120)
Now declare three variables, one each for the roses, lilies, and tulips you have, in which you place their total price. Insert the corresponding values into the variables using the variables declared in the previous step. Finally, declare a variable in which you store the price of all your flowers (again, use the previous variables for initialization). Display all inventory information in the console in the following form:

Rose – unit price: 8 , quantity: 70 , value: 560
Lily – unit price: 10 , quantity: 50 , value: 500
Tulip – unit price: 2 , quantity: 120 , value: 240
Total:  1300

Solution
// there are many possible and correct variable names
let rosePrice = 8;
let lilyPrice = 10;
let tulipPrice = 2;

let numberOfRoses = 70;
let numberOfLilies = 50;
let numberOfTulips = 120;

let rosesValue = rosePrice * numberOfRoses;
let liliesValue = lilyPrice * numberOfLilies;
let tulipsValue = tulipPrice * numberOfTulips;

let total = rosesValue + liliesValue + tulipsValue;
console.log("Rose – unit price:", rosePrice, ", quantity:", numberOfRoses, ", value:", rosesValue);
console.log("Lily – unit price:", lilyPrice, ", quantity:", numberOfLilies, ", value:", liliesValue);
console.log("Tulip – unit price:", tulipPrice, ", quantity:", numberOfTulips, ", value:", tulipsValue);
console.log("Total: ", total);


Task 2

Modify the code from the previous example. Assume that the prices of flowers will be constant (they will not change). Declare and initialize the remaining variables in the same way as in the previous example. Display all the gathered information in the console. Now decrease the number of roses by 20 and lilies by 30. Display all the collected information in the console again.

Solution
const rosePrice = 8;
const lilyPrice = 10;
const tulipPrice = 2;

let numberOfRoses = 70;
let numberOfLilies = 50;
let numberOfTulips = 120;

let rosesValue = rosePrice * numberOfRoses;
let liliesValue = lilyPrice * numberOfLilies;
let tulipsValue = tulipPrice * numberOfTulips;

let total = rosesValue + liliesValue + tulipsValue;

console.log("Rose – unit price:", rosePrice, ", quantity:", numberOfRoses, ", value:", rosesValue);
console.log("Lily – unit price:", lilyPrice, ", quantity:", numberOfLilies, ", value:", liliesValue);
console.log("Tulip – unit price:", tulipPrice, ", quantity:", numberOfTulips, ", value:", tulipsValue);
console.log("Total: ", total);

numberOfRoses = numberOfRoses - 20;
numberOfLilies = numberOfLilies - 30;

rosesValue = rosePrice * numberOfRoses;
liliesValue = lilyPrice * numberOfLilies;
tulipsValue = tulipPrice * numberOfTulips;

total = rosesValue + liliesValue + tulipsValue;

console.log("Rose – unit price:", rosePrice, ", quantity:", numberOfRoses, ", value:", rosesValue);
console.log("Lily – unit price:", lilyPrice, ", quantity:", numberOfLilies, ", value:", liliesValue);
console.log("Tulip – unit price:", tulipPrice, ", quantity:", numberOfTulips, ", value:", tulipsValue);
console.log("Total: ", total);

LAB

Estimated time
15-30 minutes

Level of difficulty
Easy

Objectives
Familiarize the student with:

variables (i.e. naming, declaring, initializing and modifying their values)
Scenario
Our task will be to create a list of contacts. Initially, the list will be quite simple: we will only write three people to it using the data shown in the table below. In the rest of the course, you will return to this script and systematically extend it with new functionality, using the newly learned elements of JavaScript.

Name	Phone	Email
Maxwell Wright	(0191) 719 6495	Curabitur.egestas.nunc@nonummyac.co.uk
Raja Villarreal	0866 398 2895	posuere.vulputate@sed.com
Helen Richards	0800 1111	libero@convallis.edu
Declare and initialize the variables where you will store all the information (nine variables in total). Display in the console information about the first and last contact in the form: name/phone/email.












--------------------------------------------------------------------------------
Eliminar espaços em branco

find . -type f -name "* *.xml" -exec bash -c 'mv "$0" "${0// /_}"' {} \;

-------------------------------------------------------------------------
JavaScript

Front-end -> client-side
21/04/2022
Back-end -> server-side
css, java-script

html

Desenvolvedor front-end -> tecnologias que vão rodar no lado do cliente.

server-side -> back-end

server-side -> php, js, c#, python, java-script

https://www.youtube.com/watch?v=iSqf2iPqJNM

Linguagem php (server-side)

https://github.com/gustavoguanabara/javascript

https://github.com/gustavoguanabara/html-css


front-end + back-end = full-stack

Curso de JavaScript:
https://www.youtube.com/watch?v=Ptbk2af68e8

O que faz o JavaScript? Tudo!

Conceito de cliente x servidor

JavaScript é mais client-side do que server-side.

Website - 3 tecnologias:

1.Jornalista -> escrever, imagens, conteúdo - html
2.Designer -> Cores, formatos, tornar bonito - css
3.Programador -> Integrar, entrega, interações - JavaScript

html, css, js (JavaScript)
-------------------------------------------------------------------
log apt
vi /var/log/apt/history.log
-------------------------------------------------------------------
senha wifi windows
netsh wlan show profile YOUR_NETWORK_NAME key=clear
-------------------------------------------------------------------
apt dependencias quebradas
apt -f install
-------------------------------------------------------------------
speedtest
speedtest --accept-license --accept-gdpr
-------------------------------------------------------------------
Tutorial debian gpg

Exportar as chaves:
gpg -a --export fingerprint > aluno1.pub
"--export" exporta a chave pública.

gpg -a --export-secret-key fingerprint > aluno1.pvt
Pede senha
"--export-secret-key" exporta a chave privada.

Importar as chaves:
gpg --import aluno1.pub aluno1.pvt

Criptografia Simétrica
comando para criptografar:     gpg --symmetric -a teste.txt
criou o arquivo criptografado: teste.txt.asc
comando para descriptografar:  gpg -d teste.txt.asc > teste.txt

Criptografia Assimétrica (criptografa para a chave de alguém)
comando para criptografar:     gpg -e -a teste.txt
vai pedir senha e/ou id (fingerprint) copie e cole a mesma.
criou o arquivo criptografado: teste.txt.asc
comando para descriptografar:  gpg -d teste.txt.asc
pedirá senha

Listar chaves publicas que tenho:
gpg --list-keys

Listar chaves privadas que tenho:
gpg --list-secret-keys

Criptografar para a chave pública de alguém:
gpg -e -a arquivo.txt

Vai pedir "Insira o identificador do utilizador"

Copiar e colar a finger print da chave pública do destinatário.

Procurar chaves na internet:
Comando: gpg --search-keys emaildealguem@gmail.com

Assinar chave:


--------------------------------------------------------------------------
GPG #2 Mão na massa


Pacote gpg
apt install gpg


criar o par de chaves
gpg --gen-key
gpg --full-generate-key


listar chaves
gpg --list-keys
gpg --list-secret-keys


procurar / baixar
gpg --search-keys PESQUISA
gpg --keyserver keyserver.ubuntu.com --search-keys kretcheu
gpg --keyserver pgp.mit.edu --search-keys kretcheu


baixar chaves
gpg --recv-keys ID-CHAVE
gpg --recv-keys ID-CHAVE --keyserver keyserver.ubuntu.com


atualizar chaves
gpg --refresh-keys


remover chave
gpg --delete-keys
gpg --delete-secret-keys
gpg --delete-secret-and-public-keys


enviar servidor
gpg --send-keys --keyserver pgp.mit.edu


criptografar arquivo
gpg -c arquivo.tgz


descriptografar
gpg -d arquivo.tgz.gpg > arquivo.tgz


assinar arquivo
gpg --sign ARQUIVO
ARQUIVO.gpg
gpg --sign --armor ARQUIVO
gpg --sign -a ARQUIVO
ARQUIVO.asc


verificar assinatura
gpg --verify ARQUIVO.gpg
gpg --verify ARQUIVO.asc
gpg --output [original-filename] [signature-file]
gpg --verify [signature-file] [original-file]



GPG #3


criptografar
gpg --encrypt --sign --armor -r person@email.com name_of_file


assinar chave
gpg


exportar para backup
gpg -a --export FINGER-PRINT > chave-publica.key
gpg -a --export-secret-keys FINGER-PRINT > chave-privada.key
gpg --export-secret-keys 5E3A2D8ADA62D240622EC84239F17A5F5AEFBE73 > minha-chave.asc


importar (do backup)
gpg --list-keys
gpg --list-public-keys
echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf
gpg --import chave-publica.key
gpg --import chave-privada.key
gpg --import chave-publica.key chave-privada.key
gpg --list-keys
gpg --list-secret-keys


editar chave
gpg --edit-key


criar chave de revogação


enviar chave de revogação para um servidor de chaves
--------------------------------------------------------------------------
chaves chaveiro
finger print
94A74F78101AA86F8B1175609C66F3430CC5FDE8
FD6B29E9C08EEF7A526FB457FA5E79F69C6B66C8
--------------------------------------------------------------------------
smb.conf exemplo 30/03/2022
#
# Sample configuration file for the Samba suite for Debian GNU/Linux.
#
#
# This is the main Samba configuration file. You should read the
# smb.conf(5) manual page in order to understand the options listed
# here. Samba has a huge number of configurable options most of which 
# are not shown in this example
#
# Some options that are often worth tuning have been included as
# commented-out examples in this file.
#  - When such options are commented with ";", the proposed setting
#    differs from the default Samba behaviour
#  - When commented with "#", the proposed setting is the default
#    behaviour of Samba but the option is considered important
#    enough to be mentioned here
#
# NOTE: Whenever you modify this file you should run the command
# "testparm" to check that you have not made any basic syntactic 
# errors. 

#======================= Global Settings =======================

[global]

## Browsing/Identification ###

# Change this to the workgroup/NT-domain name your Samba server will part of
   workgroup = WORKGROUP

#### Networking ####

# The specific set of interfaces / networks to bind to
# This can be either the interface name or an IP address/netmask;
# interface names are normally preferred
;   interfaces = 127.0.0.0/8 eth0

# Only bind to the named interfaces and/or networks; you must use the
# 'interfaces' option above to use this.
# It is recommended that you enable this feature if your Samba machine is
# not protected by a firewall or is a firewall itself.  However, this
# option cannot handle dynamic or non-broadcast interfaces correctly.
;   bind interfaces only = yes



#### Debugging/Accounting ####

# This tells Samba to use a separate log file for each machine
# that connects
   log file = /var/log/samba/log.%m

# Cap the size of the individual log files (in KiB).
   max log size = 1000

# We want Samba to only log to /var/log/samba/log.{smbd,nmbd}.
# Append syslog@1 if you want important messages to be sent to syslog too.
   logging = file

# Do something sensible when Samba crashes: mail the admin a backtrace
   panic action = /usr/share/samba/panic-action %d


####### Authentication #######

# Server role. Defines in which mode Samba will operate. Possible
# values are "standalone server", "member server", "classic primary
# domain controller", "classic backup domain controller", "active
# directory domain controller". 
#
# Most people will want "standalone server" or "member server".
# Running as "active directory domain controller" will require first
# running "samba-tool domain provision" to wipe databases and create a
# new domain.
   server role = standalone server

   obey pam restrictions = yes

# This boolean parameter controls whether Samba attempts to sync the Unix
# password with the SMB password when the encrypted SMB password in the
# passdb is changed.
   unix password sync = yes

# For Unix password sync to work on a Debian GNU/Linux system, the following
# parameters must be set (thanks to Ian Kahan <<kahan@informatik.tu-muenchen.de> for
# sending the correct chat script for the passwd program in Debian Sarge).
   passwd program = /usr/bin/passwd %u
   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .

# This boolean controls whether PAM will be used for password changes
# when requested by an SMB client instead of the program listed in
# 'passwd program'. The default is 'no'.
   pam password change = yes

# This option controls how unsuccessful authentication attempts are mapped
# to anonymous connections
   map to guest = bad user

########## Domains ###########

#
# The following settings only takes effect if 'server role = classic
# primary domain controller', 'server role = classic backup domain controller'
# or 'domain logons' is set 
#

# It specifies the location of the user's
# profile directory from the client point of view) The following
# required a [profiles] share to be setup on the samba server (see
# below)
;   logon path = \\%N\profiles\%U
# Another common choice is storing the profile in the user's home directory
# (this is Samba's default)
#   logon path = \\%N\%U\profile

# The following setting only takes effect if 'domain logons' is set
# It specifies the location of a user's home directory (from the client
# point of view)
;   logon drive = H:
#   logon home = \\%N\%U

# The following setting only takes effect if 'domain logons' is set
# It specifies the script to run during logon. The script must be stored
# in the [netlogon] share
# NOTE: Must be store in 'DOS' file format convention
;   logon script = logon.cmd

# This allows Unix users to be created on the domain controller via the SAMR
# RPC pipe.  The example command creates a user account with a disabled Unix
# password; please adapt to your needs
; add user script = /usr/sbin/adduser --quiet --disabled-password --gecos "" %u

# This allows machine accounts to be created on the domain controller via the 
# SAMR RPC pipe.  
# The following assumes a "machines" group exists on the system
; add machine script  = /usr/sbin/useradd -g machines -c "%u machine account" -d /var/lib/samba -s /bin/false %u

# This allows Unix groups to be created on the domain controller via the SAMR
# RPC pipe.  
; add group script = /usr/sbin/addgroup --force-badname %g

############ Misc ############

# Using the following line enables you to customise your configuration
# on a per machine basis. The %m gets replaced with the netbios name
# of the machine that is connecting
;   include = /home/samba/etc/smb.conf.%m

# Some defaults for winbind (make sure you're not using the ranges
# for something else.)
;   idmap config * :              backend = tdb
;   idmap config * :              range   = 3000-7999
;   idmap config YOURDOMAINHERE : backend = tdb
;   idmap config YOURDOMAINHERE : range   = 100000-999999
;   template shell = /bin/bash

# Setup usershare options to enable non-root users to share folders
# with the net usershare command.

# Maximum number of usershare. 0 means that usershare is disabled.
#   usershare max shares = 100

# Allow users who've been granted usershare privileges to create
# public shares, not just authenticated ones
   usershare allow guests = yes

#======================= Share Definitions =======================
[servidor debbarra]

path = /mnt/arquivos
valid users = rangel
admin users = rangel
public = no
writable = yes

[homes]
   comment = Home Directories
   browseable = yes

# By default, the home directories are exported read-only. Change the
# next parameter to 'no' if you want to be able to write to them.
   read only = yes

# File creation mask is set to 0700 for security reasons. If you want to
# create files with group=rw permissions, set next parameter to 0775.
   create mask = 0700

# Directory creation mask is set to 0700 for security reasons. If you want to
# create dirs. with group=rw permissions, set next parameter to 0775.
   directory mask = 0700

# By default, \\server\username shares can be connected to by anyone
# with access to the samba server.
# The following parameter makes sure that only "username" can connect
# to \\server\username
# This might need tweaking when using external authentication schemes
   valid users = %S

# Un-comment the following and create the netlogon directory for Domain Logons
# (you need to configure Samba to act as a domain controller too.)
;[netlogon]
;   comment = Network Logon Service
;   path = /home/samba/netlogon
;   guest ok = yes
;   read only = yes

# Un-comment the following and create the profiles directory to store
# users profiles (see the "logon path" option above)
# (you need to configure Samba to act as a domain controller too.)
# The path below should be writable by all users so that their
# profile directory may be created the first time they log on
;[profiles]
;   comment = Users profiles
;   path = /home/samba/profiles
;   guest ok = no
;   browseable = no
;   create mask = 0600
;   directory mask = 0700

[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

# Windows clients look for this share name as a source of downloadable
# printer drivers
[print$]
   comment = Printer Drivers
   path = /var/lib/samba/printers
   browseable = yes
   read only = yes
   guest ok = no
# Uncomment to allow remote administration of Windows print drivers.
# You may need to replace 'lpadmin' with the name of the group your
# admin users are members of.
# Please note that you also need to set appropriate Unix permissions
# to the drivers directory for these users to have write rights in it
;   write list = root, @lpadmin




-------------------------------------------------------------------------------
Apaguei um arquivo de comando e quero reinstalar ele
dpkg -S /bin/ls

Após achar o pacote:
apt reinstall pacote
------------------------------------------------------------------------------
Apaga tudo sem perguntar
rm -rf
------------------------------------------------------------------------------
Instalar telegram-desktop linux 
tsetup.3.6.1.tar.xz

tar -Jxxvf tsetup.3.6.1.tar.xz
-------------------------------------------------------------------------------
Fubar:Fucked Up Beyond All Recognition
Fodido além de todo reconhecimento
-------------------------------------------------------------------------------
chromebook nao liga
esc + atualizar(reload) + power
ctrl D ou sair para nao apagar
desligar e ligar.
-------------------------------------------------------------------------------
03-02-2022
Otimizando Windows Para Melhor Desempenho!

   Por
   Leonardo Campos
   -
   27 de outubro de 2020

   Sempre vamos querer aproveitar o máximo do nosso computador, nesse
   artigo vamos abordar como configurar Windows para obter melhor
   desempenho. Nota; as dicas abaixo não são mágicas, no entanto você pode
   ter certeza que surtirá muito efeito, e você só saberá se testar os
   resultados.

Ajustes!

   Se você estiver usando a versão 20H2 do Windows 10 ou superior, acesse
   configurações do computador>sistema>sobre, depois clique em
   “configurações avançadas do sistema”. Se você estiver usando outras
   versões do Windows o caminho é um pouco diferente, clique com botão
   direito do mouse no ícone de meu computador>propriedades> configurações
   avançadas do sistema.
   Fonte: Internet

   Na janela exibida navegue em avançado>configurações>efeitos visuais.
   Marque a opção “ajustar para obter melhor desempenho”. A aparência do
   Windows talvez não fique muito legal, o melhor é você testar para
   sentir os resultados, outra dica é ler sobre o que foi desativado,
   exemplo mostrar miniaturas em vez de ícones, isso será notado quando
   você entrar em pasta de fotos, as miniaturas ali não serão exibidas.
   Fonte: BPV/Reprodução

   Você também poderá adicionar um novo plano de energia ao seu sistema,
   para conseguir ativar esse novo plano de energia você precisará ter a
   versão do Windows 1803 ou superior.
   Fonte: BPV/Reprodução

   Assim abra o CMD como administrador, cole o comando abaixo e pressione
   Enter. Depois navegue no painel de controle>hardware e sons>opções de
   energia. Chamado de Desempenho Máximo essa função fornece melhor
   desempenho aos computadores de última geração (em notebooks essa função
   irá consumir mais bateria).

   powercfg -duplicatescheme e9a42b02-d5df-448d-aa00-03f14749eb61

Desempenho gráfico

   Se você joga, edita vídeos e fotos ou trabalha com render em 3D essa
   função será muito útil. Abra configurações>sistema>vídeo>configurações
   de elementos gráficos.
   Fonte: BPV/Reprodução

   Ative o botão assim como exibido na imagem abaixo, depois você poderá
   adicionar o arquivo .Exe do jogo ou programa que você quer que Windows
   otimize ele usando o poder gráfico de sua placa de vídeo. Lembramos que
   essa função só está disponível na versão 2004 ou superior do Windows
   10, você também precisa estar com driver de vídeo nvidia/amd
   atualizado. Depois de configurar reinicie o PC para que as alterações
   surtam efeito.
   Fonte: BPV/Reprodução

   Essa funcionalidade permite que a própria placa de vídeo lide de
   maneira manual com a VRAM. Com isso, o sistema operacional deixa de ser
   responsável por essa tarefa, otimizando a performance e reduzindo a
   latência para o processamento e a renderização de imagens.

Apps

   Muitos apps ficam rodando em segundo plano, além dos aplicativos que
   iniciam junto com sistema. Nem todos consomem muito recursos do PC, no
   entanto, você poderá desativa-los. Abra
   configurações>aplicativos>inicialização.
   Fonte: BPV/Reprodução

   Nessa guia você verá todos os aplicativos e processos que iniciam junto
   com sistema, assim desmarque os que impactam mais no Windows (lembre-se
   que alguns são importantes, nesse caso deixe como está). Note que o
   próprio Windows notifica abaixo do botão ativado/desativado que o app
   gera pouco ou muito impacto na máquina.

   Ainda nessa guia digite no campo de pesquisa “aplicativos em segundo
   plano” ou se preferir navegue em configurações>privacidade>aplicativos
   em segundo plano. Na guia abaixo existe um botão que desativa todos os
   apps em segundo plano, no entanto, aconselhamos verificar um por um e
   desativar tal app cada um por vez.
   Fonte: BPV/Reprodução

   IFRAME:
   https://www.youtube.com/embed/WGq43H1WDog?start=1501&feature=oembed

   Para melhorar ainda mais a performance do sistema o usuário poderá
   desmarcar duas opções na guia de notificações. Acesse
   configurações>sistema>notificações e ações. Faça igual sugerido na
   imagem abaixo.
   Fonte: BPV/Reprodução

Otimização de entrega

   Por fim chegamos na otimização de entrega, essa opção é muito útil
   quando em sua residência ou local de trabalho existem várias máquinas
   rodando Windows 10, pois assim, se um sistema atualizar os outros
   computadores poderão atualizar também via rede local usando os arquivos
   de update do outro computador. Caso você não tenha outros computadores
   na rede com Windows 10, sugerimos desativar essa função.
   Fonte: BPV/Reprodução

   Ainda nessa mesma tela você poderá configurar o quanto de banda de rede
   o Windows poderá utilizar quando estiver baixando atualizações, para
   acessar essas configurações clique no link “opções avançadas”. Na tela
   seguinte mude os valores de download que Windows usa, observe que
   existem as opções em segundo plano e primeiro plano, configure de
   acordo com sua necessidade.

Desfragmentação!

   Por fim chegamos ao ponto da desfragmentação do disco. Uma das
   principais causas de lentidão nos computadores, aconselhamos fazer uma
   desfragmentação para discos comum HD de 15 em 15 dias. Já para discos
   SSDs basta fazer a otimização do TRIM.

   Recomendados o programa Defraggler, faça o download e instalação. No
   exemplo da imagem abaixo que fizemos uma análise em discos SSDs, na aba
   “Fragmentado” é exibido o quanto de fragmentos (arquivos fragmentados)
   existem nessa unidade (apenas 8%) o que nos leva a não desfragmentar
   essa unidade, apenas otimiza-la é o suficiente.

   [Fragmentos.jpg]

   Do contrário se a taxa de arquivos fragmentados for alta, e você
   estiver percebendo que o disco está lento, copiando os arquivos com
   lentidão ou iniciando o Windows com um pouco mais de demora, caso
   decida a desfragmentação é a melhor opção, mas só não faça disso algo
   diário. Alertamos que discos SSDs realmente não precisam ser
   desfragmentados, a otimização é o suficiente. Veja no exemplo abaixo
   que usando o programa Defraggler, vamos forçar a desfragmentação do
   disco SSD, mesmo o programa alertando que não é recomendado.

   [SSD.jpg]

   Share
   Facebook
   Twitter
   Google+
   Pinterest
   WhatsApp

   Artigo anteriorAprenda Remover Fundo De Fotos Sem Programas!
   Próximo artigoUsando 100% Da Sua Internet No Windows
   Leonardo Campos
----------------------------------------------------------------------
python2.7 converter binario octal hexadecimal
0b10 binario
010 octal
0x10 hexadecimal
----------------------------------------------------------------------
#para salvar tabela particoes particao
sfdik -d /dev/sdX > tabela_de_particoes
#para recuperar tabela de paticoes:
sfdik /dev/sdX < tabela_de_particoes
-----------------------------------------------------------------------------------
teclas volume teclado atalho xfce
Adicione os seguintes comandos para as teclas que desejar (como por exemplo Fn + F3... etc):
amixer set Master 5%+
amixer set Master 5%-
amixer set Master toggle
--------------------------------------------------------------------------
Re: xfce: Take screenshot without user interface immediately
Post by Flemur » Mon May 12, 2014 11:46 am

This almost does what you want:
$ xfce4-screenshooter -f -s /path/to/save

You still have to hit the 'Save' button after the screen capture because they weren't smart enough to allow for defining the file name, just its location.

programa scrot para captura automatica de tela. Bas ta teclas que salvará automaticamente.
Edit:
$ scrot /path/to/filename.jpg
works silently (also with .png extension). 'scrot' is in repositories.


scrennshot captura de tela printscreen debian xfce:
Go to: XFCE Menu --> Settings --> Keyboard --> Application Shortcuts, and add the xfce4-screenshooter -f command to use the "PrintScreen" key in order to take fullscreen

xfce4-screenshooter -f 
---------------------------------------------------------------------------
classes de dispositivos pci

PCI-IDs Classes


00 Unclassified device

00	Non-VGA unclassified device
01	VGA compatible unclassified device



01 Mass storage controller

00	SCSI storage controller
01	IDE interface
02	Floppy disk controller
03	IPI bus controller
04	RAID bus controller
05	ATA controller
06	SATA controller
07	Serial Attached SCSI controller
08	Non-Volatile memory controller
80	Mass storage controller



02 Network controller

00	Ethernet controller
01	Token ring network controller
02	FDDI network controller
03	ATM network controller
04	ISDN controller
05	WorldFip controller
06	PICMG controller
07	Infiniband controller
08	Fabric controller
80	Network controller



03 Display controller

00	VGA compatible controller
01	XGA compatible controller
02	3D controller
80	Display controller



04 Multimedia controller

00	Multimedia video controller
01	Multimedia audio controller
02	Computer telephony device
03	Audio device
80	Multimedia controller



05 Memory controller

00	RAM memory
01	FLASH memory
80	Memory controller



06 Bridge

00	Host bridge
01	ISA bridge
02	EISA bridge
03	MicroChannel bridge
04	PCI bridge
05	PCMCIA bridge
06	NuBus bridge
07	CardBus bridge
08	RACEway bridge
09	Semi-transparent PCI-to-PCI bridge
0a	InfiniBand to PCI host bridge
80	Bridge



07 Communication controller

00	Serial controller
01	Parallel controller
02	Multiport serial controller
03	Modem
04	GPIB controller
05	Smard Card controller
80	Communication controller



08 Generic system peripheral

00	PIC
01	DMA controller
02	Timer
03	RTC
04	PCI Hot-plug controller
05	SD Host controller
06	IOMMU
80	System peripheral



09 Input device controller

00	Keyboard controller
01	Digitizer Pen
02	Mouse controller
03	Scanner controller
04	Gameport controller
80	Input device controller



0A Docking station

00	Generic Docking Station
80	Docking Station



0B Processor

00	386
01	486
02	Pentium
03
04
10	Alpha
20	Power PC
30	MIPS
40	Co-processor



0C Serial bus controller

00	FireWire (IEEE 1394)
01	ACCESS Bus
02	SSA
03	USB controller
04	Fibre Channel
05	SMBus
06	InfiniBand
07	IPMI Interface
08	SERCOS interface
09	CANBUS



0D Wireless controller

00	IRDA controller
01	Consumer IR controller
10	RF controller
11	Bluetooth
12	Broadband
20	802.1a controller
21	802.1b controller
80	Wireless controller



0E Intelligent controller

00	I2O



0F Satellite communications controller

01	Satellite TV controller
02	Satellite audio communication controller
03	Satellite voice communication controller
04	Satellite data communication controller



10 Encryption controller

00	Network and computing encryption device
10	Entertainment encryption device
80	Encryption controller



11 Signal processing controller

00	DPIO module
01	Performance counters
10	Communication synchronizer
20	Signal processing management
80	Signal processing controller



12 Processing accelerators

00	Processing accelerators
01	AI Inference Accelerator



13 Non-Essential Instrumentation


15


40 Coprocessor


64


FF Unassigned class

---------------------------------------------------
clima tempo meteorologia terminal

curl wttr.in/rio_janeiro

----------------------------------------------------------------
kazam mp4 compativel compatibilidade problema solucao

1. ffmpeg -i 'Screencast 2021-11-25 14:37:40.mp4' -pix_fmt yuv420p -c:a copy -movflags +faststart out.mp4
2. ffmpeg -i out.mp4 -vcodec libx264 -acodec aac out2.mp4
O arquivo out2.mp4 é o resultado final que funciona.

Fontes:
https://www.vivaolinux.com.br/dica/Converter-videos-para-formato-suportado-no-WhatsApp
https://video.stackexchange.com/questions/20162/convert-kazam-video-file-to-a-file-playable-in-windows-media-player

Conteudo das fontes:

Converter vídeos para formato suportado no WhatsApp

   [302aa1aa42304.jpg]

     Publicado por Fábio Berbert de Paula em 21/04/2020

     [ Hits: 3.725 ]

     Blog: https://youtube.com/c/cotidianohackeado

   4 0


   Denuncie   Favoritos   Indicar   Impressora

Converter vídeos para formato suportado no WhatsApp

   Acredito que muitos, assim como eu, utilizam a versão Web do WhatsApp enquanto estão usando o desktop Linux. Acontece que
   muitas vezes, quando tentamos anexar um vídeo pela interface Web, ele acusa o arquivo como formato inválido e/ou não gera a
   pre-visualização.
   Isso ocorre porque o WhatsApp é compatível apenas com vídeo no codec H.264 e áudio AAC.
   Nesta dica, aprenderemos a converter teu arquivo de vídeo para um formato compatível com o WhatsApp. Utilizaremos a ferramente
   ffmpeg. Se ainda não a possui, instale-a com:
   sudo apt install ffmpeg
   E agora, a mágica! Supondo que temos um arquivo de vídeo incompatible.mp4 e queremos torná-lo compatível:
   ffmpeg -i incompatible.mp4 -vcodec libx264 -acodec aac compatible.mp4
   Onde:
     * -i incompatible.mp4 :: arquivo de input, o que queremos converter
     * -vcodec libx264 :: use o codec de vídeo H.264
     * -acodec aac :: use o codec de áudio AAC
     * compatible.mp4 :: arquivo a ser gerado como saída

   NOTA: o arquivo de input pode ser qualquer formato de vídeo (avi, ogg etc).
     *
     *

   Outras dicas deste autor

   Uma breve análise dos principais editores HTML

   Como ajustar o brilho da tela via linha de comando

   Carteira de Bitcoin Electrum no Linux

   Como descobrir se sua instalação GNU/Linux é 32 ou 64 bits

   Como copiar arquivos mantendo a estrutura de diretórios e sub-diretórios
   Leitura recomendada

   Como reproduzir vídeos no Chromecast usando o VLC

   K3B não está gravando CDs ou DVDs [Resolvido]

   Como instalar o Cheese no Slackware 14.2

   Instalando o Transmageddon no Deepin 20

   Instalação do mps-youtube no Fedora

   Comentários

   Nenhum comentário foi encontrado.

convert KAZAM video file to a file, playable in windows media player

   Ask Question
   Asked 4 years, 11 months ago
   Active 1 year ago
   Viewed 17k times
   (BUTTON)
   7
   (BUTTON) (BUTTON)
   1

   I have some mp4 video files that are created by KAZAM in Linux. But I need to play those files on Microsoft Windows only by
   Windows Media Player (for example I can not install VLC media player). Also I can not use any codec. So I think converting
   propoerties of file (for example format of files) is the only solution. But I do not know which output format is best for
   video file
     * without losing quality
     * ability of playing result in Windows Media Player

   Also I want to know how I can convert to that format?

   Note:
     * I prefer to use VLC media player for converting video files, but ffmpeg is also appreciable.
     * Also do you know a simple, light software for screen casting and recording sounds from speaker in Linux-Ubuntu 14.04 which
       it's output is playable directly in Windows Media Player? I can replace KAZAM by this.

   Edit:

   I tested output by WMP 12 (for windows 7) and also MediaInfo says:
General
Complete name                            : /path/to/file/Screencast 2016-12-17 07:19:13.mp4
Format                                   : MPEG-4
Format profile                           : Base Media / Version 2
Codec ID                                 : mp42
File size                                : 314 KiB
Duration                                 : 3s 280ms
Overall bit rate                         : 783 Kbps
Encoded date                             : UTC 2016-12-17 03:48:54
Tagged date                              : UTC 2016-12-17 03:48:54
Writing application                      : x264

Video
ID                                       : 1
Format                                   : AVC
Format/Info                              : Advanced Video Codec
Format profile                           : High 4:4:4 Predictive@L3.2
Format settings, CABAC                   : No
Format settings, ReFrames                : 1 frame
Codec ID                                 : avc1
Codec ID/Info                            : Advanced Video Coding
Duration                                 : 3s 280ms
Bit rate                                 : 744 Kbps
Width                                    : 1 366 pixels
Height                                   : 768 pixels
Display aspect ratio                     : 16:9
Frame rate mode                          : Constant
Frame rate                               : 25.000 fps
Color space                              : YUV
Chroma subsampling                       : 4:4:4
Bit depth                                : 8 bits
Scan type                                : Progressive
Bits/(Pixel*Frame)                       : 0.028
Stream size                              : 298 KiB (95%)
Writing library                          : x264 core 142 r2491 24e4fed
Encoding settings                        : cabac=0 / ref=1 / deblock=0:0:0 / analyse=0:0 / me=dia / subme=0 / psy=1 / psy_rd=1.00:0.00
/ mixed_ref=0 / me_range=16 / chroma_me=1 / trellis=0 / 8x8dct=0 / cqm=0 / deadzone=21,11 / fast_pskip=1 / chroma_qp_offset=6 / threads
=4 / lookahead_threads=1 / sliced_threads=0 / nr=0 / decimate=1 / interlaced=0 / bluray_compat=0 / constrained_intra=0 / bframes=0 / we
ightp=0 / keyint=250 / keyint_min=25 / scenecut=0 / intra_refresh=0 / rc=cqp / mbtree=0 / qp=15 / ip_ratio=1.40 / aq=0
Language                                 : English
Encoded date                             : UTC 2016-12-17 03:48:54
Tagged date                              : UTC 2016-12-17 03:48:54

Audio
ID                                       : 2
Format                                   : MPEG Audio
Format version                           : Version 1
Format profile                           : Layer 3
Codec ID                                 : 6B
Duration                                 : 3s 186ms
Bit rate mode                            : Constant
Bit rate                                 : 32.0 Kbps
Channel(s)                               : 1 channel
Sampling rate                            : 44.1 KHz
Compression mode                         : Lossy
Stream size                              : 12.4 KiB (4%)
Writing library                          : LAME3.99.5
Language                                 : English
Encoded date                             : UTC 2016-12-17 03:48:54
Tagged date                              : UTC 2016-12-17 03:48:54

   windows screen-casting linux vlc
   Share
   Improve this question
   (BUTTON) Follow
   edited Dec 29 '16 at 15:40
   hasanghaforian
   asked Dec 16 '16 at 14:57
   hasanghaforianhasanghaforian
   17711 gold badge11 silver badge66 bronze badges
   2
     * Need to know which version of WMP. And what does Mediainfo say about the file? Use View-Text mode
       – Gyan
       Dec 16 '16 at 15:16
     * @Mulvya I added more details in Edit part of question. Please see that.
       – hasanghaforian
       Dec 17 '16 at 4:13

   Add a comment  |

1 Answer 1

   Active Oldest Votes
   (BUTTON)
   14
   (BUTTON)

   Your KAZAM video features YUV444P pixel format which WMP may not support without extra filters. Using ffmpeg, run
ffmpeg -i in.mp4 -pix_fmt yuv420p -c:a copy -movflags +faststart out.mp4
     _________________________________________________________________________________________________________________________

   You can also use ffmpeg itself to capture screen and sound on linux. Basic syntax would be
ffmpeg -f v4l2 -i VIDEO -f alsa -i AUDIO -pix_fmt yuv420p -b:a 64k cap.mp4

   where VIDEO is the name of the video device. See http://ffmpeg.org/ffmpeg-devices.html#video4linux2_002c-v4l2 for details.

   AUDIO is the name of the audio device. See http://ffmpeg.org/ffmpeg-devices.html#alsa

   You can also use x11grab to capture from the X-Window system. See http://ffmpeg.org/ffmpeg-devices.html#x11grab
   Share
   Improve this answer
   (BUTTON) Follow
   answered Dec 17 '16 at 4:22
   GyanGyan
   28.7k22 gold badges4848 silver badges8383 bronze badges
   3
     * :) thanks a lot for sharing the command. worked like a charm.
       – Gaurav Sharma
       Nov 9 '17 at 14:50
     * this saved my life today!
       – j314erre
       Nov 17 '19 at 20:32
     * I left incognito mode and signed in, joined this community - just so I could upvote your answer @Gyan. Thanks for this
       amazing answer. God bless! :)
       – John Doe
       Aug 31 at 20:31

----------------------------------------------------------
ativar administrador windows 10
cmd como adm
comando:
net user administrador /active:yes
depois coloque uma senha
-----------------------------------------------------------
escapar alias
/ls
colocar uma barra antes do comando a ser digitado faz com que os alias sejam ignorados.
---------------------------------------------------------
Como rodar um teste de memória com MEMTESTER no Linux

Dica de Troubleshooting

   Trago para vocês hoje uma ferramenta que pode auxiliar no
   troubleshooting e identificação de erros de memória dentro do Linux.
   Vou ensinar como rodar um teste de memória com memtester no Linux.
   Veja, há distribuições que não possuem o memtest no menu de boot,
   nestes casos é interessante o uso desta ferramenta.

VÍDEO ATUALIZADO 2018

Como instalar o memtester

   Para instalar o memtester, você pode utilizar o tarball realizando o
   download aqui, ou instalar diretamente pelo terminal dependendo da sua
   distribuição:
$ apt-get install memtester -y

Como iniciar um teste de memória com memtester?

   Antes de iniciar os testes, gostaria de fazer duas observações:

   Obs. 1: O teste só poderá ser feito na quantidade de memória
   disponível, ou seja, que não esteja sendo usada por outros processos.

   Obs. 2: O teste poderá ser efetuado com o tanto de memória que o
   sistema operacional conseguir reconhecer. Por exemplo, em sistemas 32
   bits com mais de 8GB de memória, o memtester vai conseguir testar
   somente 4GB.

   Primeiro vamos validar quanto de memória que temos disponível em MB com
   o comando free:
$ free -m

   Como rodar um teste de memória com MEMTESTER no Linux Como rodar um
   teste de memória com MEMTESTER no Linux

   Neste caso, o melhor seria testar com 5414MB da coluna free.

   Para iniciar o teste, devemos rodar o comando memtester com a seguinte
   nomenclatura:

   [MEMTESTER] – [QUANTIDADE DE MEMÓRIA] – [NÚMERO DE VEZES QUE O TESTE
   VAI RODAR (DEFAULT INFINITO)]
$ memtester 5414 1

   Neste caso ele irá testar 5414MB, e apenas uma vez.

   Obs.: Na foto abaixo estou executando com 6005MB.
   Como rodar um teste de memória com MEMTESTER no Linux Como rodar um
   teste de memória com MEMTESTER no Linux

   É interessante que o memtester utiliza o mlock. Este recurso bloqueia o
   quantidade de memória que passamos como parâmetro, prevenindo que o
   Linux use como swap, ficando assim isolada somente para o teste de
   memória, sendo muito mais efetivo.

   Se você quiser testar o máximo que você tem disponível, passe como
   parâmetro o máximo de memória que você tem.

   Por exemplo, eu possuo um módulo de memória de 8GB:
$ memtester 8G 1

   ou
$ memtester 8192 1

   Se você informar o máximo de memória, ele vai pegar o máximo que você
   tem disponível e testar. Entretanto, você vai ver que o equipamento vai
   congelar e retornar possívelmente quando finalizar o teste.

   Seu processador também vai começar a esquentar e o fan a rotacionar de
   uma forma mais intensa. Por que? Pois quem envia os comandos para a
   memória ser stressada é o processador, visto que a northbridge é
   integrada à ele.

   É possível verificar o uso do processador e memória com o comando top
   em outra aba ou outro terminal:
$ top

   Como rodar um teste de memória com MEMTESTER no Linux Como rodar um
   teste de memória com MEMTESTER no Linux

Pessoal, a dica de hoje foi essa. Abraço!


----------------------------------
impressora ricoh 2000
imprimir preto ou colorido
restringir funcoes de aplicativos
desabilitar 4 cores
-----------------------------------

bosontreinamentos
samba pacotes:
1.apt-get install libcups samba samba-common
2.vi /etc/samba/smb.conf
3.descomentar security = user (para habilitar os ususarios linux a se logar no servidor samba)
4. systemctl restart smbd (reinicar o samba)
5. mkdir /home/publico (criar uma pasta publica)
6. chgrp /home/publico (torna a pasta publica acessivel aos usuarios que fazem parte do grupo users)
7. chmod 775 /home/publico (permitir que usuarios do grupo users gravem na pasta)

samba: checar com testparm uma especie de debug para verificar erros grosseiros nas configuracoes
rode testparm
testparm
---------------------------------------
acertar fuso horario data hora
dpkg-reconfigure tzdata
Run 'dpkg-reconfigure tzdata' if you wish to change it.
----------------------------------------

26/10/2021

Criar novo initramfs
/boot/mv initrd.img-5.10.0-8-amd64 initrd.img-5.10.0-8.old
/boot/update initramfs -c -k
update-grub
-------------------------------------------------------------
Comparar diferenças entre 2 (dois) arquivos

diff -Naur arquivo1.txt arquivo2.txt
-------------------------------
Copiar chaves

1.Criar um par de chaves
2.Copiar a chave para o servidor
3.Acessar o servidor
4.Copiar a chave para o root
5.Acessar como root

1.Criar um par de chaves
ssh-keygen
---------------------------------------------------------------
ativacao windows 10
registro windows
regedit
hkeylocal machine
system
current_control_set


windows original mensagem software ilegal ativacao windows 7 voce pode ter sido vitima de software ilegal

1. Prompt comando como adm
2. SLMGR -REARM
3. boot
--------------------------------------------------------------------------------
Problemas samba

algumas estacoes windows 7 davam: 
subi um servidor samba mas ha clientes win7 que apresenta a msg ao tentar conectar:
“A senha de rede especificada não está correta.”

win10 se conecta e outro cliente q win7 tb. Alquem passou por isso?
Resolvido adicionando o parâmetro no smb.conf
ntlm auth = yes
---------------------------------------------------------------------
initramfs

grub (tecla e)

final da linha linux
adiciona comando: break
f10

ls /root/
mount -t ext4 -o noatime,nodiratime /dev/vda1 /root
blkid
mount
ls /
ls /root
chroot /root/
lsblk
passwd


-------------------------------------------------------
14/10/2021
Situação problema:

Resultado do comando systemctl status seguido de systemctl --fail:
networking.service failed

Mensagem de erro no log que me levou a solução:

journalctl -xe

A unidade networking.service está sendo iniciada.
out 14 16:31:01 stem dhclient[2115]: Internet Systems Consortium DHCP Client 4.4.1
out 14 16:31:01 stem ifup[2115]: Internet Systems Consortium DHCP Client 4.4.1
out 14 16:31:01 stem ifup[2115]: Copyright 2004-2018 Internet Systems Consortium.
out 14 16:31:01 stem ifup[2115]: All rights reserved.
out 14 16:31:01 stem ifup[2115]: For info, please visit https://www.isc.org/software/dhcp/
out 14 16:31:01 stem dhclient[2115]: Copyright 2004-2018 Internet Systems Consortium.
out 14 16:31:01 stem dhclient[2115]: All rights reserved.
out 14 16:31:01 stem dhclient[2115]: For info, please visit https://www.isc.org/software/dhcp/
out 14 16:31:01 stem dhclient[2115]: 
out 14 16:31:01 stem ifup[2122]: Cannot find device "eth0"
out 14 16:31:01 stem dhclient[2115]: Failed to get interface index: No such device

Solução: (Depois de muitas aulas do kretcheu e muito garimpo de estudos)
erro raise network
Passo 1.vi /etc/network/interfaces.d/setup

Antes:

auto eth0
iface eth0 inet dhcp

Depois:

auto enp2s0
iface enp2s0 inet dhcp

Passo 2.vi /etc/network/interfaces

Antes:
auto lo
iface lo inet loopback

Depois:
auto lo
iface lo inet loopback
iface enp2s0 inet dhcp

Então reiniciando serviço:
systemctl restart networking
systemctl status networking

● networking.service - Raise network interfaces
     Loaded: loaded (/lib/systemd/system/networking.service; enabled; vendor preset: enabled)
     Active: active (exited) since Thu 2021-10-14 17:09:41 -03; 1min 26s ago
       Docs: man:interfaces(5)
    Process: 1443 ExecStart=/sbin/ifup -a --read-environment (code=exited, status=0/SUCCESS)
   Main PID: 1443 (code=exited, status=0/SUCCESS)
      Tasks: 8 (limit: 6943)
     Memory: 3.1M
        CPU: 115ms
     CGroup: /system.slice/networking.service
             ├─1468 /sbin/dhclient -4 -v -i -pf /run/dhclient.enp2s0.pid -lf /var/lib/dhcp/dhclient.enp2s0.leases -I -df /var/lib/dhcp/dhclient6.enp2s0.leases enp2s0
             └─1542 /sbin/dhclient -4 -v -i -pf /run/dhclient.enp2s0.pid -lf /var/lib/dhcp/dhclient.enp2s0.leases -I -df /var/lib/dhcp/dhclient6.enp2s0.leases enp2s0

out 14 17:09:41 stem ifup[1542]: DHCPREQUEST for 192.168.15.6 on enp2s0 to 255.255.255.255 port 67
out 14 17:09:41 stem dhclient[1542]: Sending on   LPF/enp2s0/1c:1b:0d:f1:c0:5b
out 14 17:09:41 stem dhclient[1542]: Sending on   Socket/fallback
out 14 17:09:41 stem dhclient[1542]: DHCPREQUEST for 192.168.15.6 on enp2s0 to 255.255.255.255 port 67
out 14 17:09:41 stem dhclient[1542]: DHCPACK of 192.168.15.6 from 192.168.15.1
out 14 17:09:41 stem ifup[1542]: DHCPACK of 192.168.15.6 from 192.168.15.1
out 14 17:09:41 stem ifup[1554]: RTNETLINK answers: File exists
out 14 17:09:41 stem dhclient[1542]: bound to 192.168.15.6 -- renewal in 7121 seconds.
out 14 17:09:41 stem ifup[1542]: bound to 192.168.15.6 -- renewal in 7121 seconds.
out 14 17:09:41 stem systemd[1]: Finished Raise network interfaces.

Conferindo:

systemctl start

State: running
      Jobs: 0 queued
      Failed: 0 units
      Since: Thu 2021-10-14 11:54:55 -03; 4h 58min ago
      
      Gratidão pelo seu trabalho kretcheu!
-------------------------------------------------------
 



idiomas
dpkg-reconfigure locales
377
--------------------------------------------
teclado layout keyboard
apt-install console-setup
sudo dpkg-reconfigure console-setup
sudo dpkg-reconfigure keyboard-configuration
sudo dpkg-reconfigure console-configuration
-------------------------------------------------------------------------
Use um -s no full-upgrade para simular. Pode ser sem sudo mesmo.
Leandro Ramos
Ótima política.
-------------------------------------
traceroute -I -T -p 10000 138.219.197.214

mtr alternativa ao traceroute
apt install mtr

não muito a ver com o seu prob, mas só uma dica: tem uma alternativa ao traceroute que é o mtr - pra uma saída parecida com o traceroute eu uso mtr -4b <dominio>- a opção 4 é pra IPv4 e o b é pra mostrar o hostname e o IP juntos.

-----------------------------------
Testar placa de rede
lspci
apt-get install memtester -y
free -m
memoria livre: 5414

memtester 5414 1
--------------------------------
reiniciar interface de rede

ifdown eth0
ifup eth0

------------------------------------------------------------------------------
   Pessoal, segue uma dica útil para quem trabalha com S.O. Linux, que se
   trata de forçar o usuário a trocar a senha no primeiro login.
   Esse comando é muito útil, pois pode ser utilizado via script para
   criação de usuários em massa. Uma senha padrão é definida e forçado a
   troca no primeiro login, para maior segurança do ambiente.
   O comando descrito abaixo é o “chage”.
   Detalhando:
   Esse comando irá forçar a expiração da senha do usuário,  logo que o
   login for executado, o S.O. irá solicitar que altere a senha.
   # chage -d 0 USER
   Expirando a senha em períodos pré-determinados:
   Para isso iremos utilizar o comando passwd + opções
   Detalhamento:
   -x 30 => Expira em 30 dias
   -w 10 => Irá avisar o usuário quando faltar 10 dias para a senha
   expirar
   -i 0    => Quantos dias a conta ainda ficará ativa após a expiração da
   senha.
   # passwd -x 30 -w 10 -i 0 USER
   Através do comendo chage, também é possível visualizar as definições de
   cada usuário:
   # chage -l USER
   Minimum: 0 Maximum: 30
   Warning: 10 Inactive: 0
   Last Change: Out 06, 2014
   Password Expires: Nov 06, 2014
   Password Inactive: Nov 06, 2014
   Account Expires: Never
   Abraços
   André Francisco Gotardo

   O que você achou disso?



-----------------------------------------------------------------------------------------
Criar um banner customizado para o SSH
Se você quiser que qualquer usuário que se conecte através de seu serviço SSH veja uma mensagem específica, você pode criar um banner SSH customizado. Basta criar um arquivo de texto (em meu exemplo este arquivo se chama /etc/ssh-banner.txt) e escrever dentro dele qualquer mensagem que desejar; por exemplo:

  *****************************************************************
  * Este é um serviço SSH privado. Não é para você estar aqui     *
  * Por favor, saia imediatamente.                                *
  *****************************************************************
Ao terminar a edição, salve o arquivo. No arquivo sshd_conf, procure por uma linha que diz:

  #Banner /etc/issue.net
Descomente a linha e coloque o caminho para o seu banner SSH customizado.



Read more: http://www.linhadecodigo.com.br/artigo/2974/dicas-avancadas-de-seguranca-para-ssh.aspx#ixzz77xQeAs3r

-----------------------------------------------------
redes com ips de range diferente na mesma interface de rede

/etc/network/interfaces

# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback

#auto eno1:1
iface eno1:1 inet static
address 192.168.22.29
netmask 255.255.255.255

-------------------------------------------------------------------------
samba

Editar smb.conf

sudo vi /etc/samba/smb.conf

ti@fbrec-bkp:~$ cat /etc/samba/smb.conf
#
# Sample configuration file for the Samba suite for Debian GNU/Linux.
#
#
# This is the main Samba configuration file. You should read the
# smb.conf(5) manual page in order to understand the options listed
# here. Samba has a huge number of configurable options most of which 
# are not shown in this example
#
# Some options that are often worth tuning have been included as
# commented-out examples in this file.
#  - When such options are commented with ";", the proposed setting
#    differs from the default Samba behaviour
#  - When commented with "#", the proposed setting is the default
#    behaviour of Samba but the option is considered important
#    enough to be mentioned here
#
# NOTE: Whenever you modify this file you should run the command
# "testparm" to check that you have not made any basic syntactic 
# errors. 

#======================= Global Settings =======================

[global]

## Browsing/Identification ###

# Change this to the workgroup/NT-domain name your Samba server will part of
   workgroup = WORKGROUP

#### Networking ####

# The specific set of interfaces / networks to bind to
# This can be either the interface name or an IP address/netmask;
# interface names are normally preferred
;   interfaces = 127.0.0.0/8 eth0

# Only bind to the named interfaces and/or networks; you must use the
# 'interfaces' option above to use this.
# It is recommended that you enable this feature if your Samba machine is
# not protected by a firewall or is a firewall itself.  However, this
# option cannot handle dynamic or non-broadcast interfaces correctly.
;   bind interfaces only = yes

#client min protocol = SMB1

#### Debugging/Accounting ####

# This tells Samba to use a separate log file for each machine
# that connects
   log file = /var/log/samba/log.%m

# Cap the size of the individual log files (in KiB).
   max log size = 1000

# We want Samba to only log to /var/log/samba/log.{smbd,nmbd}.
# Append syslog@1 if you want important messages to be sent to syslog too.
   logging = file

# Do something sensible when Samba crashes: mail the admin a backtrace
   panic action = /usr/share/samba/panic-action %d


####### Authentication #######

# Server role. Defines in which mode Samba will operate. Possible
# values are "standalone server", "member server", "classic primary
# domain controller", "classic backup domain controller", "active
# directory domain controller". 
#
# Most people will want "standalone server" or "member server".
# Running as "active directory domain controller" will require first
# running "samba-tool domain provision" to wipe databases and create a
# new domain.
   server role = standalone server

   obey pam restrictions = yes

# This boolean parameter controls whether Samba attempts to sync the Unix
# password with the SMB password when the encrypted SMB password in the
# passdb is changed.
   unix password sync = yes

# For Unix password sync to work on a Debian GNU/Linux system, the following
# parameters must be set (thanks to Ian Kahan <<kahan@informatik.tu-muenchen.de> for
# sending the correct chat script for the passwd program in Debian Sarge).
   passwd program = /usr/bin/passwd %u
   passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .

# This boolean controls whether PAM will be used for password changes
# when requested by an SMB client instead of the program listed in
# 'passwd program'. The default is 'no'.
   pam password change = yes

# This option controls how unsuccessful authentication attempts are mapped
# to anonymous connections
   map to guest = bad user

########## Domains ###########

#
# The following settings only takes effect if 'server role = classic
# primary domain controller', 'server role = classic backup domain controller'
# or 'domain logons' is set 
#

# It specifies the location of the user's
# profile directory from the client point of view) The following
# required a [profiles] share to be setup on the samba server (see
# below)
;   logon path = \\%N\profiles\%U
# Another common choice is storing the profile in the user's home directory
# (this is Samba's default)
#   logon path = \\%N\%U\profile

# The following setting only takes effect if 'domain logons' is set
# It specifies the location of a user's home directory (from the client
# point of view)
;   logon drive = H:
#   logon home = \\%N\%U

# The following setting only takes effect if 'domain logons' is set
# It specifies the script to run during logon. The script must be stored
# in the [netlogon] share
# NOTE: Must be store in 'DOS' file format convention
;   logon script = logon.cmd

# This allows Unix users to be created on the domain controller via the SAMR
# RPC pipe.  The example command creates a user account with a disabled Unix
# password; please adapt to your needs
; add user script = /usr/sbin/adduser --quiet --disabled-password --gecos "" %u

# This allows machine accounts to be created on the domain controller via the 
# SAMR RPC pipe.  
# The following assumes a "machines" group exists on the system
; add machine script  = /usr/sbin/useradd -g machines -c "%u machine account" -d /var/lib/samba -s /bin/false %u

# This allows Unix groups to be created on the domain controller via the SAMR
# RPC pipe.  
; add group script = /usr/sbin/addgroup --force-badname %g

############ Misc ############

# Using the following line enables you to customise your configuration
# on a per machine basis. The %m gets replaced with the netbios name
# of the machine that is connecting
;   include = /home/samba/etc/smb.conf.%m

# Some defaults for winbind (make sure you're not using the ranges
# for something else.)
;   idmap config * :              backend = tdb
;   idmap config * :              range   = 3000-7999
;   idmap config YOURDOMAINHERE : backend = tdb
;   idmap config YOURDOMAINHERE : range   = 100000-999999
;   template shell = /bin/bash

# Setup usershare options to enable non-root users to share folders
# with the net usershare command.

# Maximum number of usershare. 0 means that usershare is disabled.
#   usershare max shares = 100

# Allow users who've been granted usershare privileges to create
# public shares, not just authenticated ones
   usershare allow guests = yes

#======================= Share Definitions =======================

[servidor fbrec-bkp]

path = /fariabrito
valid users = ti
admin users = ti
public = no
writable = yes
printable = no

[homes]
   comment = Home Directories
   browseable = no

# By default, the home directories are exported read-only. Change the
# next parameter to 'no' if you want to be able to write to them.
   read only = yes

# File creation mask is set to 0700 for security reasons. If you want to
# create files with group=rw permissions, set next parameter to 0775.
   create mask = 0700

# Directory creation mask is set to 0700 for security reasons. If you want to
# create dirs. with group=rw permissions, set next parameter to 0775.
   directory mask = 0700

# By default, \\server\username shares can be connected to by anyone
# with access to the samba server.
# The following parameter makes sure that only "username" can connect
# to \\server\username
# This might need tweaking when using external authentication schemes
   valid users = %S

# Un-comment the following and create the netlogon directory for Domain Logons
# (you need to configure Samba to act as a domain controller too.)
;[netlogon]
;   comment = Network Logon Service
;   path = /home/samba/netlogon
;   guest ok = yes
;   read only = yes

# Un-comment the following and create the profiles directory to store
# users profiles (see the "logon path" option above)
# (you need to configure Samba to act as a domain controller too.)
# The path below should be writable by all users so that their
# profile directory may be created the first time they log on
;[profiles]
;   comment = Users profiles
;   path = /home/samba/profiles
;   guest ok = no
;   browseable = no
;   create mask = 0600
;   directory mask = 0700

 [arquivos grh joana]
            path = /fariabrito/recreio/joana
            available = yes 
            writable = yes
 valid users = grh,ti,joana,andre

[printers]
   comment = All Printers
   browseable = no
   path = /var/spool/samba
   printable = yes
   guest ok = no
   read only = yes
   create mask = 0700

# Windows clients look for this share name as a source of downloadable
# printer drivers
[print$]
   comment = Printer Drivers
   path = /var/lib/samba/printers
   browseable = yes
   read only = yes
   guest ok = no
# Uncomment to allow remote administration of Windows print drivers.
# You may need to replace 'lpadmin' with the name of the group your
# admin users are members of.
# Please note that you also need to set appropriate Unix permissions
# to the drivers directory for these users to have write rights in it
;   write list = root, @lpadmin


1.criar usuarios
  sudo adduser grh
  sudo adduser andre
  sudo adduser joana
  sudo adduser sandra

2.adicionar usuarios do grh ao grupo grh
  sudo adduser andre joana sandra grh

3.permissoes pastas:
  sudo chown -R grh:grh /fariabrito/recreio/grh
  sudo chmod -R 755 /fariabrito/recreio/grh
--------------------------------------------


Conhecer as dependencias de um pacote:
apt depends vim
----------------------------------------------------------
Recuperar grub perdido pela instalacao do windows - UEFI

livecd ou liveusb
1.c (console do grub)
2.ls
3.Achar a partição do sistema Linux - ls (hd0,gpt1)/
Quando achar:
4.configfile (hd0,gpt1)/boot/grub/grub.cfg
5.Aparecendo o menu do grub, escolha o boot.
6.terminal-lsblk
7.grub-install /dev/xxx
8.update-grub 


Recuperar grub perdido pela instalacao do windows - bios 

1. livecd ou liveusb
2. lsblk
3. montar a particao linux sistema em /mnt - mount /dev/sda2 /mnt
4. mount --bind /dev /mnt/dev
5. mount --bind /proc /mnt/proc
6. mount --bind /sys /mnt/sys
7. grub-install
8. update-grub
9. reboot
--------------------------------------------------------------------------------
Se tornar root no livecd liveusb
root livecd
sudo -s
--------------------------------------------------------------------------------
gravar usb debian
sudo dd if=kali-linux-2021.3-live-amd64.iso of=/dev/sdc bs=4M status=progress


27/09/2021
teclado keyboard
vi /etc/default/keyboard
Outro:
setxkbmap br
Outro:
keyboard-configuration

------------------------------------------------
27/09/2021
tabela ascii
man acii
------------------------------------------------
25/09/2021
Como parar ou reiniciar o serviço de rede:
systemctl stop networking.service
---------------------------------------------

25/09/2021
conectar wifi terminal
nmcli d wifi connect nome_da_rede password minha_senha
nmtui (network manager terminal user interface)
---------------------------------------------------------
24/09/2021

XDMCPserver
/etc/lighdm/lightdm.conf
descomentar

XDMCPserver
enabled=true

ss -lunpt
acessando:
apt install xnest
apt install xephyr

-----------------------------------
24/09/2021

Rodar um segundo servidor grafico:

startx -- :1


------------------------------------
Comandos vi
replace vi
For example, to search for the first occurrence of the string ‘foo’ in the current line and replace it with ‘bar’, you would use:

:s/foo/bar/
Copy
To replace all occurrences of the search pattern in the current line, add the g flag:

:s/foo/bar/g

If you want to search and replace the pattern in the entire file, use the percentage character % as a range. This character indicates a range from the first to the last line of the file:

:%s/foo/bar/g
------------------------------------------------------------
23/09/2021
nmap
nmap sem opções mostra a situação das portas:
nmap
nmap -sL: List Scan - simply list targets to scan
nmap -sP: Ping Scan - go no further than determining if host is online
----------------------------
Verificar redes wifi
iw dev interface scan
iw dev wlps5 scan
-------------------------------------
Se falta firmware, veja assim:
# grep firm /var/log/syslog | grep fail

-----------------------------------
Codigos lspci
nnkd 0200 ethernet placa rede

Listar dispositivos wifi
lspci -nnkd::0280

------------------------
setup bios grub

grub
e
fwsetup
----------------------------------

20/09/2021
ping com porta
nping -p 5060 ip_destino
nping 192.168.10.210
nping --tcp 177.xxx.xx.xx

paping

executa-se assim: ./paping ip_servidor -p porta
-----------------------------
20/09/2021
verificar ip placa rede
lspci -nnkd::0200
----------------------
20/09/2021
Verificar rede - ferramentas:
mii-tool
------------------------------------------------------------------
20/09/2021
Cria uma trava para mais ninguem mexer no arquivo passwd que está sendo editado.
vipw
--------------------------------------------------------------------------
20/09/2021

shutdown -r ou reboot

     Tecnologia Digital

     Como reiniciar ou desligar o Linux usando a linha de comando
     Tecnologia Digital
 
Como reiniciar ou desligar o Linux usando a linha de comando

   Leonardo Suassuna
   by Leonardo Suassuna 2 years ago2 years ago

   Fatmawati Achmad Zaenuri / Shutterstock.com

   Está com vontade de começar de novo? Este tutorial mostrará como
   reiniciar de forma limpa e segura ou desligar o computador Linux ou
   macOS na linha de comando.

Estamos indo para baixo

   Às vezes, você apenas precisa reiniciar ou desligar totalmente. Se você
   estiver trabalhando em um servidor sem GUI ou em uma sessão SSH em um
   computador remoto, a linha de comando é sua única opção. Sistemas Linux
   e Unix, como o macOS, fornecem vários comandos para desligar ou
   reiniciar o sistema diretamente da linha de comando.

   Os comandos que você pode usar são:
     * desligar
     * reiniciar
     * parar
     * desligar

   Olhar através das páginas de manual para esses comandos pode ser
   confuso. Dependendo de quais opções de linha de comando você escolher,
   todos esses comandos poderão executar desligamentos, reinicializações e
   interrupções do sistema. De fato, as páginas de manual para reboot,
   halte poweroff contêm exatamente a mesma informação.

   página de manual para o comando halt

O que há por trás disso?

   A resposta está no sistema de inicialização do systemd, que substituiu
   o venerável System V init sistema. No mundo Linux, o Fedora começou a
   usar systemd em 2011. Desde então, tem sido adotado por muitas
   distribuições. Debian e Ubuntu trocaram para systemd em 2015.

   Em systemddistribuições baseadas em shutdown, reboot, halte poweroff
   comandos são efetivamente atalhos que apontam para o systemctl comando.

   A manutenção desses comandos fornece um grau de compatibilidade com
   System V initdistribuições baseadas em Isso significa que os scripts de
   shell (e os administradores de sistema do System V de núcleo duro) não
   decaem se forem movidos para um computador com um systemd distribuição
   rodando nele.

Usando o desligamento

   Desligar ou reiniciar um sistema multiusuário significa que você
   precisa planejar com antecedência. Você precisa decidir quando irá
   encerrar ou reinicializar e avisar aos outros usuários do sistema que o
   encerramento está chegando e quando. Se é o seu próprio computador e
   você é o único que o utiliza, a vida é muito mais simples.

   Para executar qualquer um desses comandos, você deve estar no diretório
   sudo grupo. Ou seja, você deve ter permissões de superusuário e poder
   usar o sudo comando. Se o comando emitido entrar em vigor imediatamente
   e não afetar outros usuários conectados, não será necessário usar sudo.
   Se você tentar usar um desses comandos e o comando for recusado, tente
   novamente com sudo .

   Por padrão, o shutdown O comando garante que todos os processos sejam
   interrompidos de maneira limpa, todos os sistemas de arquivos sejam
   sincronizados e todas as atividades da CPU tenham cessado. Este é o
   estado de “parada”. Em seguida, envia uma mensagem ao hardware para
   cortar a energia. É claro que esse é o estado de desligamento ou
   “desligamento”.

   É comum passar shutdown alguns parâmetros, como uma sequência de tempo
   e uma mensagem que será enviada aos usuários conectados para avisá-los
   sobre o desligamento. Vamos agendar um desligamento daqui a 15 minutos.
   Tipo shutdown , um espaço, +15, um espaço e a mensagem a ser enviada
   aos usuários.
shutdown +15 Shutting down in 15 minutes!

   mensagem de comando de desligamento +15

   A seqüência de tempo que usamos foi +15 , representando daqui a 15
   minutos. o + é opcional. Nós poderíamos ter digitado 15.

   Recebemos uma resposta que confirma que um desligamento está agendado e
   quando ocorrerá. Os usuários conectados receberão a mensagem que
   fornecemos.

   notificação de desligamento

   Para cancelar um desligamento, use o -c (cancelar).
shutdown -c

   Comando Shutdown -c cancel

   Embora você não receba nenhuma notificação de que seu desligamento foi
   cancelado, seus usuários conectados são notificados.

   Aviso de cancelamento

   Se você não fornecer uma sequência de horário, um desligamento será
   agendado para um minuto a partir de agora. Observe que você não pode
   fornecer uma mensagem aos usuários conectados se não especificar uma
   sequência de tempo.
shutdown

   comando shutdown sem parâmetros

   Se você não pode esperar nem um minuto, pode usar now como a seqüência
   de tempo e o desligamento leva imediato efeito. Usando now é como usar
   +0.

   desligamento agora

   A sequência de horas pode ser uma hora definida, como 23:00. Deve
   seguir o formato de HH:MM e deve estar no relógio de 24 horas. Cinco
   minutos antes do sistema cair, novos logins são impedidos.

   encerramento 23:00 com mensagem

   Sabemos a ação padrão de shutdown faz o computador descer para o estado
   de parada e depois para o estado desligado. Podemos substituir esse
   comportamento passando outras opções de linha de comando para ele.
     * o -H A opção (parada) levará o computador ao estado de parada, mas
       não solicitará que o hardware seja desligado.
     * o -P (desligamento) é a ação padrão. O computador é reduzido ao
       estado de parada e, em seguida, é desligado.
     * o -r A opção (reinicialização) levará o computador ao estado de
       parada e, em seguida, reiniciará.
     * o -h (parada e desligamento) é a mesma que -P. Se você usar -h e -H
       juntos, o -H opção tem prioridade.
     * o -c A opção (cancelar) cancelará qualquer desligamento programado,
       parada ou reinicialização.

   Aqui está um exemplo em que agendamos uma reinicialização.
shutdown -r 08:20 System rebooting at 08:20

   desligamento agendando uma reinicialização

Comandos de reinicialização, parada e desligamento

   Esses comandos executam a ação que o nome sugere. No entanto, cada um
   deles aceitará opções de linha de comando para fazer com que qualquer
   um deles execute uma reinicialização, uma parada ou um desligamento.
   Mas por que confundir as coisas? Esses comandos são melhor utilizados
   pelo valor nominal.

   Se você deseja reiniciar agora, use reboot . Se você deseja desligar
   agora, use poweroffe se você deseja interromper o sistema agora, use
   halt.
reboot

   comando reboot em uma janela de terminal
halt

   comando de parada em uma janela de terminal
poweroff

   comando poweroff em uma janela de terminal

   Esses comandos entram em vigor imediatamente. Se algum desses comandos
   for recusado, preceda-os com sudo. Mas lembre-se de que uma recusa
   geralmente ocorre porque existem outros usuários conectados ao sistema
   que você está prestes a colocar offline.

Qual comando é adequado para mim?

   Em ambientes multiusuário, usando shutdown para executar essas ações,
   você terá mais controle. A facilidade de agendar desligamentos e
   reinicializações e alertar os usuários com uma mensagem de difusão será
   inestimável nesses casos. Para um computador de usuário único, reboot e
   poweroff provavelmente atenderá às suas necessidades.
--------------------------------------------------------------------------

20/09/2021
Será que foi removido um pacote e ficaram os arquivos de configuração dele?
dpkg -l | grep ^rc
----------------------------------------------------------------------------
20/09/2021
apt - Fazer com que os pacotes sejam apenas baixados mas não instalados:

apt upgrade -d

Para instalar basta rodar:
apt upgrade
----------------------------------------------------------------------
20/09/202

Listar ips da rede: ip scan scannear rede rapido
arp -a
----------------------------------------------------------------------
17/09/2021

Códigos ASCII
Decimal	Octal	Hexadecimal	Binário	Caractere

0	000	00	00000000	NUL
1	001	01	00000001	SOH
2	002	02	00000010	STX
3	003	03	00000011	ETX
4	004	04	00000100	EOT
5	005	05	00000101	ENQ
6	006	06	00000110	ACK
7	007	07	00000111	BEL
8   010	08	00001000	BS
9	011	09  00001001	TAB
10	012	0A	00001010	LF
11	013	0B	00001011	VT
12	014	0C  00001100	FF
13	015	0D	00001101	CR
14	016	0E	00001110	SO
15	017	0F	00001111	SI
16	020	10  00010000	DLE
17	021	11	00010001	DC1
18	022	12	00010010	DC2
19	023	13	00010011	DC3
20	024	14	00010100	DC4
21	025	15	00010101	NAK
22	026	16	00010110	SYN
23	027	17	00010111	ETB
24	030	18	00011000	CAN
25	031	19	00011001	EM
26	032	1A	00011010	SUB
27	033	1B	00011011	ESC
28	034	1C	00011100	FS
29	035	1D	00011101	GS
30	036	1E	00011110	RS
31	037	1F	00011111	US
32	040	20  00100000	Espaço
33	041	21	00100001	!
34	042	22	00100010	“
35	043	23  00100011	#
36	044	24	00100100	$
37	045	25	00100101	%
38	046	26	00100110	&
39	047	27	00100111	‘
40	050	28	00101000	(
41  051	29	00101001	)
42	052	2A	00101010	*
43	053	2B	00101011	+
44	054	2C	00101100	,
45	055	2D	00101101	–
46	056	2E	00101110	.
47	057	2F	00101111	/
48	060	30	00110000	0
49	061	31	00110001	1
50	062	32	00110010	2
51	063	33	00110011	3
52	064	34	00110100	4
53	065	35	00110101	5
54	066	36	00110110	6
55	067 37	00110111	7
56	070	38	00111000	8
57	071	39	00111001	9
58	072	3A	00111010	:
59	073	3B	00111011	;
60	074	3C	00111100	<
61	075	3D	00111101	=
62	076	3E	00111110	>
63	077	3F	00111111	?
64  100	40	01000000	@
65	101	41	01000001	A
66	102	42	01000010	B
67	103	43	01000011	C
68	104	44	01000100	D
69	105	45	01000101	E
70	106	46	01000110	F
71	107	47	01000111	G
72	110	48	01001000	H
73	111	49	 01001001	I
74	112	4A	01001010	J
75	113	4B	01001011	K
76	114	4C	01001100	L
77	115	4D	01001101	M
78	116	4E	 01001110	N
79	117	4F	01001111	O
80	120	50	01010000	P
81	121	51	01010001	Q
82	122	52	01010010	R
83	123	53	01010011	S
84	124	54	01010100	T
85	125	55	01010101	U
86	126	56	01010110	V
87	127	57	01010111	W
88	130	58  01011000	X
89	131	59	01011001	Y
90	132	5A  010110010	Z
91	133	5B	01011011	[
92	134	5C	01011100	\
93	135	5D	01011101	]
94	136	5E	01011110	^
95	137	5F	01011111	_
96	140	60	01100000	`
97	141	61  01100001	a
98	142	62	01100010	b
99	143	63	01100011	c
100	144	64	01100100	d
101 145	65	01100101	e
102	146	66	01100110	f
103	147	67	01100111	g
104	150	68	01101000	h
105	151	69	01101001	i
106	152	6A	01101010	j
107	153	6B	01101011	k
108	154	6C	01101100	l
109	155	6D	01101101	m
110	156	6E	01101110	n
111	157	6F	01101111	o
112	160	70	01110000	p
113	161	71	01110001	q
114	162	72	01110010	r
115	163	73	01110011	s
116	164	74	01110100	t
117	165	75	01110101	u
118	166	76	01110110	v
119	167	77	01110111	w
120	170	78	01111000	x
121	171	79	01111001	y
122	172	7A	01111010	z
123	173	7B	01111011	{
124	174	7C	01111100	|
125	175	7D	01111101	}
126	176	7E	01111110	~
127	177	7F	01111111	DEL

A seguir temos a tabela de códigos ASCII estendidos, que utiliza oito bits para representar os caracteres e contém mais 127 caracteres que incluem caracteres especiais, símbolos e letras acentuadas em vários alfabetos distintos.

Note que os códigos ASCII estendidos de seu computador podem diferir da tabela a seguir, pois eles dependem do conjunto de caracteres empregado pelo sistema operacional. O conjunto mais popular é um conjunto de caracteres denominado ISO 8859-1, também conhecido como ISO Latin 1, que contém caracteres presentes na maioria dos idiomas europeus ocidentais (incluindo o português).

Códigos ASCII estendidos
Decimal	Octal	Hexadecimal	Binário	Caractere
128 200 80  10000000    Ç
129	201	81  10000001	ü
130	202	82	10000010	é
131	203	83	10000011	â
132	204	84  10000100	ä
133	205	85	10000101	à
134	206	86	10000110	å
135	207	87	10000111	ç
136	210	88	10001000	ê
137 211	89	10001001	ë
138	212	8A	10001010	è
139	213	8B	10001011	ï
140	214	8C  10001100	î
141	215	8D	10001101	ì
142	216	8E	10001110	Ä
143	217	8F	10001111	Å
144 220	90	10010000	É
145 221 91	10010001	æ
146	222	92	10010010	 Æ
147	223	93	10010011	ô
148	224	94  10010100	ö
149	225	95	10010101	ò
150	226	96	10010110	û
151	227	97	10010111	ù
152	230	98	10011000	ÿ
153	231	99  10011001	Ö
154	232 9A  10011010	Ü
155	233	9B	10011011	ø
156	234	9C	10011100	£
157	235	9D	10011101	Ø
158	236	9E	10011110	×
159	237	9F	10011111	ƒ
160	240 A0	10100000	á
161	241	A1	10100001	 í
162	242	A2	10100010	ó
163	243	A3	10100011	ú
164	244	A4	10100100	ñ
165	245	A5	10100101	Ñ
166	246	A6	10100110	ª
167 247	A7	10100111	º
168	250	A8	10101000	¿
169 251	A9  10101001	®
170 252	AA  10101010	¬
171 253	AB	10101011	½
172	254	AC	10101100	¼
173	255	AD	10101101	¡
174	256	AE	10101110	«
175	257	AF	10101111	»
176	260	B0	10110000	░
177	261	B1  10110001	▒
178	262	B2	10110010	▓
179	263	B3	10110011	│
180	264	B4	10110100	┤
181	265	B5	10110101	Á
182	266	B6	10110110	Â
183	267	B7	10110111	À
184	270	B8	10111000	©
185	271	B9	10111001	╣
186	272	BA	10111010	║
187	273	BB	10111011	╗
188	274	BC	10111100	╝
189	275	BD	10111101	¢
190	276	BE	10111110	¥
191	277	BF	10111111	┐
192	300	C0  11000000	└
193 301	C1	11000001	┴
194	302	C2	11000010	┬
195	303	C3	11000011	├
196	304	C4	11000100	─
197	305	C5	11000101	┼
198	306	C6	11000110	ã
199	307	C7	11000111	Ã
200	310	C8	11001000	╚
201	311	C9  11001001	╔
202	312	CA	11001010	╩
203	313	CB	11001011	╦
204	314	CC	11001100	╠
205	315	CD	11001101	═
206	316	CE	11001110	╬
207	317	CF	11001111	¤
208	320	D0	11010000	ð
209	321	D1	11010001	Ð
210	322	D2	11010010	Ê
211	323	D3	11010011	Ë
212	324	D4	11010100	È
213	325	D5	11010101	ı
214	326	D6	11010110	Í
215	327	D7	11010111	Î
216 330	D8	11011000	Ï
217	331 D9  11011001	┘
218	332	DA	11011010	┌
219	333	DB	11011011	█
220	334	DC	11011100	▄
221	335	DD	11011101	¦
222	336	DE	11011110	Ì
223	337	DF	11011111	▀
224	340	E0	11100000	Ó
225 341	E1	11100001	ß
226	342	E2	11100010	Ô
227	343	E3	11100011	Ò
228	344	E4	11100100	õ
229	345	E5	11100101	Õ
230	346	E6	11100110	µ
231	347	E7	11100111	þ
232 350	E8	11101000	Þ
233	351 E9	 11101001	Ú
234	352	EA	11101010	Û
235	353	EB	 11101011	Ù
236	354	EC	11101100	ý
237	355	ED	11101101	Ý
238	356	EE	11101110	¯
239	357	EF	11101111	´
240	360	F0	11110000	­
241	361	F1	11110001	±
242	362	F2	11110010	‗
243	363	F3	11110011	¾
244	364	F4	11110100	¶
245	365	F5	11110101	§
246	366	F6	11110110	÷
247	367	F7	11110111	¸
248	370	F8	11111000	°
249	371	F9	11111001	¨
250	372	FA	11111010	·
251	373	FB	11111011	¹
252	374	FC	11111100	³
253	375	FD	11111101	²
254	376	FE	11111110	 ▀
255	377	FF	11111111	 

Para inserir um desses caracteres especiais em um texto, basta segurar a tecla Alt em seu teclado, e digitar a sequência numérica correspondente ao caractere desejado, em decimal. Assim, se digitarmos Alt + 225 em um editor de textos veremos o caractere alemão ß.

Por exemplo, a sequência de bits

0100001010100010011100110110111101101110010101000111001001100101011010
010110111001100001011011010110010101101110011101000110111101110011
representa em ASCII a frase “Bóson Treinamentos”.

Link interessante: Arte usando ASCII

-----------------------------------------------------------------------


17/09/2021

kali virt-manager
remover iso da subpasta e passar ela para a pasta home/usuario
erro format directory storage
-----------------------------------------------------------
Como saber se bootei via UEFI

Metodo 1
ls /sys/firmware/efi/efivars/

Metodo 2
efibootmgr

--------------------------------------------------
16/09/2021
Ordem de boot grub

Mudar a ordem em que rodam os scripts do update-grub:

/etc/grub.d

renomear 30_os-prober para 07_os-prober
executar update-grub
----------------------------------------------------------

15/09/2021
Utilizando porta ssh diferente em scp
scp -P 8000 Downloads/acao*.pdf ti@187.113.69.244:/home/ti
-------------------------------------------------------
15/09/2021
dedsums -a 1>log 2>erros

15/09/2021
Contar arquivos em um diretorio:
ls -ltra /mnt/hdextbarra/backup2021/academia/'COMPROVANTE DE VACINAÇÃO NAT.ADULTO' | grep -e "^-" | wc -l
------------------------------------------------------------------------------------------------------------
14/09/2021

Comando repete ultima digitacao completando um comando:
alt.
-----------------------------------------------------------
13/09/2021
Utilizando porta ssh diferente em rsync
Para aqueles que usam porta diferente da 22(ssh) e querem acesso via rsync, abaixo como fazer esta configuração:
# rsync -avP -e "ssh -p <numero_da_porta>" <usuario>@<ip_do_servidor>:/caminho/desejado/ /local/caminho/desejado
---------------------------------------------------------------------------------------------------------

13/09/2021

Instalar zabbix 5.0

1.Step 1: Install Zabbix server, frontend, and agent

sudo apt install zabbix-agent zabbix-frontend-php apache2 zabbix-server-mysql 
sudo apt -y install mariadb-server
sudo apt install phpmyadmin

sudo systemctl start mariadb
sudo systemctl enable mariadb


mysql_secure_installation

Obs:

The command is indeed wrong.

I found that the files are not in the location described in the tutorial. They are stored here:
/usr/share/zabbix-server-mysql/

So the command should be:
zcat /usr/share/zabbix-server-mysql/schema.sql.gz | mysql -uzabbix -p zabbix

zcat /usr/share/zabbix-server-mysql/schema.sql.gz | mysql -uzabbix -p zabbix

Configurar PHP:

ls -ltr /etc/apache2/
total 80
-rw-r--r-- 1 root root   320 ago  8  2020 ports.conf
-rw-r--r-- 1 root root 31063 ago  8  2020 magic
-rw-r--r-- 1 root root  1782 ago  8  2020 envvars
-rw-r--r-- 1 root root  7224 ago 12 08:51 apache2.conf
drwxr-xr-x 2 root root  4096 set 13 09:09 sites-available
drwxr-xr-x 2 root root  4096 set 13 09:09 conf-enabled
drwxr-xr-x 2 root root  4096 set 13 09:09 sites-enabled
drwxr-xr-x 2 root root 12288 set 13 09:12 mods-available
drwxr-xr-x 2 root root  4096 set 13 09:12 mods-enabled
drwxr-xr-x 2 root root  4096 set 13 09:12 conf-available

ti@virtual-debian11:~$ ls -ltr /etc/apache2/conf-available
total 28
-rw-r--r-- 1 root root  455 ago  8  2020 serve-cgi-bin.conf
-rw-r--r-- 1 root root 2174 ago  8  2020 security.conf
-rw-r--r-- 1 root root  189 ago  8  2020 other-vhosts-access-log.conf
-rw-r--r-- 1 root root 3224 ago  8  2020 localized-error-pages.conf
-rw-r--r-- 1 root root  315 ago  8  2020 charset.conf
-rw-r--r-- 1 root root  127 dez 18  2020 javascript-common.conf
-rw-r--r-- 1 root root  970 jan 31  2021 zabbix-frontend-php.conf




----------------------------------------------------------------------

Forma rapida de colocar um servidor web para funcionar: usando python



12/09/2021

Verificar ver serviços que estão rodando na máquina:
comando: ss -ntplu
-------------------------------------------------

12/09/2021
configuração fail2ban

0.apt install iptables

1.sudo cp /etc/fail2ban/jail.{conf,local}

2.ignoreip :: você usará este parâmetro caso deseja ignorar as falhas de uma determinada faixa de IP, ou seja, a faixa de IP ou o IP que definir nestes parâmetros serão ignorados para bloqueio. Você pode usar os seguintes parâmetros: 192.168.1.10 para indicar um Host, 192.168.1.0/255.255.255.0 para indicar uma sub-rede ou 192.168.1.0/24, para indicar uma sub-rede em CIDR.

3.bantime :: aqui você define quanto tempo (em segundos) um Host ficará bloqueado caso ele seja banido.
q

Verificar ips bloqueados:
sudo iptables -L

----------------------------------------------



10/09/2021
Tutorial GNU Linux 03 - Swap em arquivo criptografado



---------------------------------------------------------
10/09/2021
Curso GNU Linux - Aula 20 - Guia de solução de problemas

Palavras "proibidas":

1.Reconheceu
2.Permitiu
3.Vem com
4.Aceita
5.Ele
6.O Windows
7.O Linux
8.O Debian


08/09/2021

Procura Pesquisa grep:

grep Ookla *
------------------------------------------------------------

08/09/2021.
Lab GNU #35 - Removendo Senha windows10, Instalando mini máquina.
C:\windows\system32\config

Ex. chntpw -u usuario SAM

Ferramenta: apt install chntpw (sam password recovery utility)

-----------------------------------------------------------------

06/09/2021

Parametro: ssh -X
Pode rodar programas graficos que nao necessitem root.

--------------------------------------------------------------------
06/09/2021
Grub parou e agora?

1.shell do grub
2.digitar "help"
3.digite "set pager=1" Tipo um less
4.digitar ls (enter) Tipo um lsblk
5.digitar ls (hd0) ou ls (hd0,gpt1) A intenção é achar a partição onde está o kernel.Onde aparecer os diretorios do linux será onde está o kernel. O kernel fica no diretorio "/boot".
6. ls (hd0,gpt2)/boot - Mudar para a particao que aparecer para voce. Isso é para listar o diretorio do kernel.
7.Localizar os arquivos que contem "vmlinuz"
8.Proximo passo é fazer o grub carregar o kernel
9.Comando: "linux (hd0,gpt2)/boot/vmlinuz-5.6.13-gnu root=/dev/sda2 ou qual particao for no seu caso.
10. Como descobrir o nome dos discos: "cat /etc/fstab"
11. Dizer para o grub carregar o initrd: initrd (hd0,gpt2)/boot/initrd.img-5.6.13-gnu
12. Mandar o grub dar o boot: comando: "boot"
13. Depois de ressetar. logar e rodar o comando:"update-grub"

----------------------------------
06/09/2021

Perdi a senha de root e agora!?

1. grub
2. teclo e (editar)
3. Procurar a linha "Linux" que carrega o kernel. root=...
4. apagar quiet e ro.
5. mudar ro para rw
6. digitar "init=/bin/bash" ao lado de rw
7. Teclar F10 para bootar
8. ao bootar como root, digito "passwd" e crio uma nova senha de root
9. reboot a maquina de novo
10. Vai entrar o grub normal de novo


------------------------------------
Curso GNU Linux - Aula 36
Rio 29/08/2021

o que é pam?

Linux Pluggable Authentication Modules (PAM) is a suite of libraries that allows a Linux system administrator to configure methods to authenticate users. It provides a flexible and centralized way to switch authentication methods for secured applications by using configuration files instead of changing application code.[1] There are Linux PAM libraries allowing authentication using methods such as local passwords, LDAP, or fingerprint readers.[2] Linux PAM is evolved from the Unix Pluggable Authentication Modules architecture.[3]

PAM

O PAM (Pluggable Authentication Modules) é o serviço responsável por realizar a autenticação de usuários nos ambientes Linux/Unix. Através do PAM e de suas bibliotecas, é possível configurar um esquema de autenticação segura para qualquer aplicação de forma transparente.

O pacote libpam-ldap é o plugin do LDAP para o PAM, ou seja, ele é que permitirá ao PAM autenticar usuários armazenados no diretório LDAP. O PAM apenas realiza a autenticação dos usuários que foram reconhecidos durante a pesquisa do NSS, ou seja, é necessário instalar e configurar o módulo libnss-ldap antes do libpam-ldap para que a autenticação dos usuários do diretório LDAP seja efetuada.


Serviço: autenticaçao
ssh,gdm,lightdm

Autenticador - autentico 

jdap,unix,ad,radius



---------------------
Rio 29/08/2021

Curso GNU Linux - Aula 35 - VPN - Introdução

VPN
Virtual Private Network

- Tipos / Classificaçoes
- P->P
- P->Rede
- Rede->Rede
- Camadas
- Segurança
- Privacidade

rede 568

----------------------
Rio 27/08/2021

Curso GNU Linux - Aula 34 - O temido boot BIOS/UEFI MBR/GPT

Firmware
-> BIOS -> Legacy
-> UEFI -> 2007
 
Particionamento
-> DOS/MBR
-> GPT

***Partição é apenas uma tabela.***

MBR-> Boot loader
Entradas UEFI <- NVRAM -> boot menu->fallback














------------------------------------------------------------------

1. Verifique no prompt do boot, qual a ordem do S.O. que você quer.

Por exemplo: a primeira linha no prompt tem a ordem zero, a segunda 1 e assim por diante. Suponha que o S.O. selecionado esteja na ordem 5 (cinco).

2. Abra o arquivo, em /etc/default/grub:

$ sudo gedit /etc/default/grub

3. Procure a linha:
GRUB_DEFAULT=0
E mude para:

GRUB_DEFAULT=5

Salve e feche o arquivo.

4. Depois, rode o comando:

 sudo update-grub


No próximo boot, a quinta linha do prompt será executada por padrão, abrindo o S.O. selecionado.

--------------------------------------------------------------------------
boot lento
analisar

systemd-analyze
systemd-analyze blame

systemctl status
systemctl --failed
--------------------------------------
entrar modo terminal
modo terminal sem gerenciador janelas
Nivel -> run-levels
systemctl get-default
exemplos:
systemctl set-default graphical.target
systemctl isolate multi-user.target
systemctl set-default multi-user.target

**systemctl isolate graphical.target

----------------------------------------
Examinando erros nos logs

sudo journalctl -b -u nfs-server.service
journalctl -xe

Excelente comando: 
journalctl -p 3 -b
Fonte: https://forums.debian.net/viewtopic.php?t=150193
-----------------------------------------------------------------------------------------------
O firmware é um pedaco de programa que roda nao no processador principal da maquina aquele em que roda o kernel, mas no processador do proprio dispositivo.

comandos cli para saber quais são nossos barramentos pci:
lspci

comandos cli para saber quais são nossos dispositivos de rede:
lspci -nnkd::0200
lspci -nnkd::0280

comandos cli para saber quais são nossos barramentos usb:
lsusb -tv


ip link    -> ip l
ip address -> ip a
ip route   -> ip r

ping -c 3 1.1.1.1


the it crowd
quarto epsodio da 3 temporada







-----------------------------------------------------------------------------
palavra dificeis

alfarrabo

-------------------------------------------------------------------------------------
sudo root

Senha de configuração da senha de root:

Se não criar a senha de root durante a instalação, o usuário principal sereá um sudoer.

su -
O tracinho do su serve para carregar as variáveis de ambiente do root.

O arquivo sudoers

Serve para configurações personalizadas de sudo, um sudo limitado.

Você quer que um determinado grupo ou um determinado usuário tenham acesso a apenas alguns comandos usando o sudo.
Um usuário que não tem conta de root mas precisa relizar determinada tarefa que necessita de tais poderes.

--------------------------------------------------------------------------------------------------------------------------
Aquele velho problema de ter que sair do terminal e se logar de novo para que o ususario comum seja reconhecido fazendo parte do grupo sudo: solução: 
newgrp sudo
---------------------------------------------------------------------------------------

Virtual Box CLI CMD

Listar as vms:
VBoxManage list vms
Listar as vms que estão rodando:
VBoxManage list runningvms

Habilitar conexão da área de trabalho remota (Protocolo RDP):
VBoxManage modifyvm "Delli3" --vrde on vrde property TCP/Ports=5000

Ligar a vm:
VBoxManage startvm "Delli3" --type headless


----------------------------------------------------------------------------------------------------------------------------------
Digamos que você tenha acesso ssh a uma máquina com debian, a mesma tem anydesk instalado e rodando, mas por algum motivo desconhecido você precise acessa-la via anydesk e pelo terminal à princípio não consegue ver o seu id do anydesk.

No terminal digite:
anydesk --get-id

Fazer senha para acesso sem monitoramento:
echo senhaescolhida | sudo anydesk --set-password


iniciar serviço anydesk:
systemctl status anydesk
systemctl restart anydesk

anydesk Linux cli terminal

Installation

AnyDesk for Linux can be downloaded and updated via the command-line interface using the AnyDesk repositiories. Instructions on how to set up and use the repositories can be found below: http://deb.anydesk.com/howto.html http://rpm.anydesk.com/howto.html

Initialization Parameters

Parameter	Description
--service	Start the AnyDesk service, if not already running.
--stop-service	Stop the AnyDesk service.
--restart-service	Restart the AnyDesk service.
--silent	AnyDesk will not display message boxes when this parameter is specified. Recommended for scripts.
--remove	Silently uninstall AnyDesk with no notice.
Get Alias, ID, Status or Version

Get AnyDesk-ID:

anydesk --get-id
Get AnyDesk-Alias:

anydesk --get-alias
Get online status of AnyDesk client:

anydesk --get-status
Get AnyDesk version:

anydesk --version
Setting an Unattended Access Password

For security reasons, a password for unattended access can not be set from the command line directly as this would enable malicious users to spy the password from the command line in Task Manager. Instead, a pipe is used to set the password.

echo password | sudo anydesk --set-password

Note: This requires administrator privileges.
Registering the License Key

You can register a license with the current AnyDesk installation using the command line. The service must be running.

echo license_keyABC | anydesk --register-license

Almost every scripting language has a pipe interface for stdin and stdout. See the programming language documentation for more information.

Connecting to an AnyDesk Client

To connect to a remote AnyDesk ID or Alias, the syntax is: anydesk alias@ad

The following commands can be added after the destination address:

--file-transfer	﻿Start the file transfer session.
--fullscreen	Start a session with fullscreen mode.
--plain	Start a plain session, without window title and toolbar.

documento anydesk command line:

  The command line provides a tool to automate AnyDesk using scripts. For some cases, AnyDesk uses the pipe
   mechanism of the operating system instead of parameters for higher security.

   See also: Exit Codes, Automatic Deployment

   Show/hide all answers

Windows

   Installation

   AnyDesk can be installed by script with the following command:

   anydesk.exe --install <location> --start-with-win

   Important:

   <location> must be a valid installation path, e.g. C:\anydesk. Currently, AnyDesk must be started with
   Windows if installed.

   For more installation parameters, see Automatic Deployment.

   Initialization Parameters
   Parameter Description
   --control Start the process which creates the tray icon. During installation, AnyDesk creates a link with
   this parameter in the autostart Start Menu entry.
   --tray ﻿Start the process which creates the tray icon.
   --start-service Start the AnyDesk service, if not already running (Administrator privileges required).
   --stop-service Stop the AnyDesk service.
   --restart-service Restart the AnyDesk service.
   --silent AnyDesk will not display message boxes when this parameter is specified. Recommended for
   scripts.
   --remove Silently uninstall AnyDesk with no notice.

   Get Alias, ID, Status or Version

   Get AnyDesk-ID:
@echo off
for /f "delims=" %%i in ('"C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --get-id') do set CID=%%i
echo AnyDesk ID is: %CID%
pause

   Get AnyDesk-Alias:
@echo off
for /f "delims=" %%i in ('"C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --get-alias') do set CID=%%i
echo AnyDesk Alias is: %CID%
pause

   Get online status of AnyDesk client:
@echo off
for /f "delims=" %%i in ('"C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --get-status') do set CID=%%i
echo AnyDesk status is: %CID%
pause

   Get AnyDesk version:
@echo off
for /f "delims=" %%i in ('"C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --version') do set CID=%%i
echo AnyDesk version is: %CID%
pause

   Setting an Unattended Access Password

   For security reasons, a password for unattended access can not be set from the command line directly as
   this would enable malicious users to spy the password from the command line in Task Manager. Instead, a
   pipe is used to set the password.

   echo password | "C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --set-password

   Examples:

   Standard client: echo my_new_password | "C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --set-password

   Custom client: echo my_new_password | "C:\Program Files (x86)\AnyDesk-123abc456\AnyDesk-123abc456.exe"
   --set-password
   Note: This requires administrator privileges.

   Removing the Unattended Access Password

   A non-preset unattended access password can also be removed from the AnyDesk client using the command
   line.

   Examples:

   Standard client: "C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --remove-password

   Custom client: "C:\Program Files (x86)\AnyDesk-123abc456\AnyDesk-123abc456.exe" --remove-password
   Note: This requires administrator privileges.

   Registering the License Key

   You can register a license with the current AnyDesk installation using the command line. The service must
   be running.

   echo license_keyABC | "C:\Program Files (x86)\AnyDesk\AnyDesk.exe" --register-license

   Almost every scripting language has a pipe interface for stdin and stdout. See the programming language
   documentation for more information.

   Connecting to an AnyDesk Client

   To connect to a remote AnyDesk ID or Alias, the syntax is: "C:\Program Files (x86)\AnyDesk\AnyDesk.exe"
   alias@ad

   The following commands can be added after the destination address:
   --file-transfer ﻿Start the file transfer session.
   --fullscreen    Start a session with fullscreen mode.
   --plain         Start a plain session, without window title and toolbar.

   Connecting With the Unattended Access Password Example script that connects to alias@ad with password.
   Use command line or batch script:

   echo password | "C:\Program Files (x86)\AnyDesk\AnyDesk.exe" alias@ad --with-password

   Opening Settings

   Open the Settings window:
   --settings       or
   --admin-settings (for global settings)

   To go to the specific setting page, the syntax is:
   --settings: ui (User Interface)
               security
               alias (Setup Alias panel)
               privacy
               video (Display)
               capture (Windows 7 only)
               audio
               connection
               file_transfer
               recording
               printer
               wol (Wake-On-LAN)
               license (License Key)
               about (About AnyDesk)

   To open global settings:
   --admin-settings: capture (Windows 7 only)
                     security
                     connection
                     recording
   --plain       Open a plain AnyDesk window. Can be used with AnyDesk connection command.
   --disclaimer  Show your customized disclaimer
   --show-advert Show the advertisement page of AnyDesk. Thank you for sharing! :)
     ____________________________________________________________________________________________________

macOS

   Get Alias, ID, Status or Version

   Get AnyDesk-ID:
/Applications/AnyDesk.app/Contents/MacOS/AnyDesk --get-id

   Get AnyDesk-Alias:
/Applications/AnyDesk.app/Contents/MacOS/AnyDesk --get-alias

   Get online status of AnyDesk client:
/Applications/AnyDesk.app/Contents/MacOS/AnyDesk --get-status

   Get AnyDesk version:
/Applications/AnyDesk.app/Contents/MacOS/AnyDesk --version

   Setting an Unattended Access Password

   For security reasons, a password for unattended access can not be set from the command line directly as
   this would enable malicious users to spy the password from the command line in Task Manager. Instead, a
   pipe is used to set the password.

   echo password | sudo /Applications/AnyDesk.app/Contents/MacOS/AnyDesk --set-password
   Note: This requires administrator privileges.

   Registering the License Key

   You can register a license with the current AnyDesk installation using the command line. The service must
   be running.

   echo license_keyABC | /Applications/AnyDesk.app/Contents/MacOS/AnyDesk --register-license

   Almost every scripting language has a pipe interface for stdin and stdout. See the programming language
   documentation for more information.

   Connecting to an AnyDesk Client

   To connect to a remote AnyDesk ID or Alias, the syntax is:
   /Applications/AnyDesk.app/Contents/MacOS/AnyDesk alias@ad

   The following commands can be added after the destination address:
   --file-transfer ﻿Start the file transfer session.
   --fullscreen    Start a session with fullscreen mode.
   --plain         Start a plain session, without window title and toolbar.
     ____________________________________________________________________________________________________

Linux

   Installation

   AnyDesk for Linux can be downloaded and updated via the command-line interface using the AnyDesk
   repositiories. Instructions on how to set up and use the repositories can be found below:
   http://deb.anydesk.com/howto.html http://rpm.anydesk.com/howto.html

   Initialization Parameters
   Parameter Description
   --service Start the AnyDesk service, if not already running.
   --stop-service Stop the AnyDesk service.
   --restart-service Restart the AnyDesk service.
   --silent AnyDesk will not display message boxes when this parameter is specified. Recommended for
   scripts.
   --remove Silently uninstall AnyDesk with no notice.

   Get Alias, ID, Status or Version

   Get AnyDesk-ID:
anydesk --get-id

   Get AnyDesk-Alias:
anydesk --get-alias

   Get online status of AnyDesk client:
anydesk --get-status

   Get AnyDesk version:
anydesk --version

   Setting an Unattended Access Password

   For security reasons, a password for unattended access can not be set from the command line directly as
   this would enable malicious users to spy the password from the command line in Task Manager. Instead, a
   pipe is used to set the password.

   echo password | sudo anydesk --set-password
   Note: This requires administrator privileges.

   Registering the License Key

   You can register a license with the current AnyDesk installation using the command line. The service must
   be running.

   echo license_keyABC | anydesk --register-license

   Almost every scripting language has a pipe interface for stdin and stdout. See the programming language
   documentation for more information.

   Connecting to an AnyDesk Client

   To connect to a remote AnyDesk ID or Alias, the syntax is: anydesk alias@ad

   The following commands can be added after the destination address:
   --file-transfer ﻿Start the file transfer session.
   --fullscreen    Start a session with fullscreen mode.
   --plain         Start a plain session, without window title and toolbar.

   © 2020 AnyDesk Software GmbH — Made with passion in Stuttgart, Germany
   This page is powered by MediaWiki
   Imprint

Fonte: https://support.anydesk.com/Command_Line_Interface
------------------------------------------------------------------------------------------------------------------------------------
Como excluir arquivos cujo nome começa com "-" 
Nome do arquivo: -f1
rm -- -f1
-----------------------------------------------------

Aula 31 - virtualização 02
apt install virsh (somente CLI)
apt install virt-manager

Verificar se o processador suporta virtualização tipo 1:

grep vmx /proc/cpuinfo (intel)
grep svm /proc/cpuinfo (amd)

Gostei desse comando para verificar se o processador tem suporte para virtualização tipo1:
cat /proc/cpuinfo | egrep --color '(vmx|svm)'

kvm -> modulo kernel (Kernel-based Virtual Machine)
QEMU -> hardware
libvirt -> API

Trata-se de um sistema de virtualização completa com opções limitadas para paravirtualização.
Funciona em hardware que possua extensões de virtualização habilitadas (Intel VT ou AMD-V).
Foi originalmente caseado em arquitetura intel e foi incluído no Kernel Linux 2.6.20 (ano 2007).
É ativado pelo módulo de kernel kvm.ko , auxiliado pelos módulos kvm-intel.ko e kvm-amd.ko.
Além de Intel 32/64 bits, tambpem suport ARM, PowerPC, S/390x e IA-64.

Iniciar maquina virtual pela CLI:
virsh start --domain nome_da_maquina
Resetar: reset
Desligar: shutdown

Listar as maquinas existentes:
virsh list --all

Ver ip delas:
virsh net-dhcp-leases default(nome placa de rede) 

----------------------------------------
Significado CLI

CLI -> command line interface
-----------------------------------------
Verificar software nao livre na maquina:
vrms - verificador Richard Matthew Stallman
-----------------------------------------
ti@rangel:~$ lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda      8:0    0 465,8G  0 disk 
├─sda1   8:1    0   100M  0 part 
├─sda2   8:2    0 195,2G  0 part 
└─sda3   8:3    0 270,4G  0 part /mnt/hd1
sdb      8:16   0 223,6G  0 disk 
├─sdb1   8:17   0   529M  0 part 
├─sdb2   8:18   0   100M  0 part 
├─sdb3   8:19   0    16M  0 part 
└─sdb4   8:20   0 222,9G  0 part 
sdc      8:32   0 223,6G  0 disk 
├─sdc1   8:33   0 217,7G  0 part /
├─sdc2   8:34   0     1K  0 part 
└─sdc5   8:37   0   5,9G  0 part [SWAP]
sdd      8:48   0   1,8T  0 disk 
└─sdd1   8:49   0   1,8T  0 part /mnt/hdextseagate

ti@rangel:~$ sudo fdisk -l
[sudo] senha para ti: 
Disco /dev/sdb: 223,57 GiB, 240057409536 bytes, 468862128 setores
Modelo de disco: KINGSTON SA400S3
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 512 bytes
Tamanho E/S (mínimo/ótimo): 512 bytes / 512 bytes
Tipo de rótulo do disco: gpt
Identificador do disco: 99151EC3-C046-40D4-8DD5-CF3E3BFCDC1E

Dispositivo  Início       Fim   Setores Tamanho Tipo
/dev/sdb1      2048   1085439   1083392    529M Windows ambiente de recuperação
/dev/sdb2   1085440   1290239    204800    100M Sistema EFI
/dev/sdb3   1290240   1323007     32768     16M Microsoft reservado
/dev/sdb4   1323008 468860927 467537920  222,9G Microsoft dados básico


Disco /dev/sda: 465,76 GiB, 500107862016 bytes, 976773168 setores
Modelo de disco: ST500LM012 HN-M5
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 4096 bytes
Tamanho E/S (mínimo/ótimo): 4096 bytes / 4096 bytes
Tipo de rótulo do disco: dos
Identificador do disco: 0x4e47f509

Dispositivo Inicializar    Início       Fim   Setores Tamanho Id Tipo
/dev/sda1   *                2048    206847    204800    100M  7 HPFS/NTFS/exFAT
/dev/sda2                  206848 409602047 409395200  195,2G  7 HPFS/NTFS/exFAT
/dev/sda3               409602048 976769023 567166976  270,4G  7 HPFS/NTFS/exFAT


Disco /dev/sdc: 223,57 GiB, 240057409536 bytes, 468862128 setores
Modelo de disco: KINGSTON SA400S3
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 512 bytes
Tamanho E/S (mínimo/ótimo): 512 bytes / 512 bytes
Tipo de rótulo do disco: dos
Identificador do disco: 0x2c840be8

Dispositivo Inicializar    Início       Fim   Setores Tamanho Id Tipo
/dev/sdc1   *                2048 456484863 456482816  217,7G 83 Linux
/dev/sdc2               456486910 468860927  12374018    5,9G  5 Estendida
/dev/sdc5               456486912 468860927  12374016    5,9G 82 Linux swap / Solaris


Disco /dev/sdd: 1,82 TiB, 2000398933504 bytes, 3907029167 setores
Modelo de disco: Expansion Desk  
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 4096 bytes
Tamanho E/S (mínimo/ótimo): 4096 bytes / 4096 bytes
Tipo de rótulo do disco: dos
Identificador do disco: 0x68e366af

Dispositivo Inicializar Início        Fim    Setores Tamanho Id Tipo
/dev/sdd1                 2048 3907029166 3907027119    1,8T  7 HPFS/NTFS/exFAT



Bem-vindo ao fdisk (util-linux 2.36.1).
As alterações permanecerão apenas na memória, até que você decida gravá-las.
Tenha cuidado antes de usar o comando de gravação.

O dispositivo já contém uma assinatura "ext4" e ela será removida por um comando de escrita. Veja a página man fdisk(8) e a opção --wipe para mais detalhes.

A unidade não contém uma tabela de partição conhecida.
Criado um novo rótulo de disco DOS com o identificador de disco 0x9b0c568e.

Comando (m para ajuda): ^C
Todas as alterações não escritas serão perdidas. Deseja realmente sair? y 

Comando (m para ajuda): p
Disco /dev/sdc1: 217,67 GiB, 233719201792 bytes, 456482816 setores
Unidades: setor de 1 * 512 = 512 bytes
Tamanho de setor (lógico/físico): 512 bytes / 512 bytes
Tamanho E/S (mínimo/ótimo): 512 bytes / 512 bytes
Tipo de rótulo do disco: dos
Identificador do disco: 0x9ebaa9a0


Lab#01-chroot
Criar uma partição para o boot efi:



mount --bind /proc /debian/proc
mount --bind /dev /debian/dev
mount --bind /sys /debian/sys
chroot /debian

purgar todos os pacotes grub
pacote instalar: grub-efi-amd64

grub install /dev/sda

update-grub

efibootmgr

configurar o fstab:
blkid para saber o UUID

UUID=XXXX-XXXX               /boot/efi            vfat         defaults  2  2 

umount /debian/proc
umount /debian/dev
umount /debian/sys
umount /debian/boot/efi
umount /debian





Anotações:
kvm com qemu
libvirt


Verificar binario
md5sum /usr/bin/ls

Verificar versao do arquivo
ls --version
-----------------------------------------------

Criar sistema de arquivos(formatar) na partição:
mkfs.ext4 /dev/sda1
------------------------------------------------
Desligar o swap
swapoff -a
---------------------------------------
Verificar se precisa de firmware wifi
journalctl -b | grep firmware
----------------------------------------
obs
apt install obs-studio
----------------------------------------
Pacote pst-utils 0 converte o pst em mbx 
readpst
read pst arquivo.pst
-----------------------------------------
Linux - Tentar sair do modo de emergencia 
systemctl isolate multi-user.target
--------------------------
log do boot
journalctl -b
------------------------------------
Verificar rede wifi sem fio terminal
iw dev wlp7s0
-------------------------------------------
fsck /dev/…
fsck -y /dev/… yes automatico
--------------------------
Status dos serviços
systemctl status
---------------------------
Pega conectividade placa de rede cabeada
dhclient
--------------------------
Verificar ip
ip -c a
------------------------------------
diff -Naur
---------------------------------------------
apt novo do bullseye que purga tudo de uma tacada só.

apt purge ~c
-----------------------------------------------
deborphan
deborphan 
sudo apt purge $(deborphan )
deborphan -a
------------------------------
Verificar a versão versao debian

cat /etc/*-release
lsb_release -a
cat /etc/debian_version
cat /etc/issue

-----------------------------
masked mascarado

Saber o que está mascarado(masked):

systemctl list-unit-files

Depois se quiser desmascarar:

sudo systemctl unmask samba-ad-dc.service
 
-------------------------------------------------
Criar pendrive instalacao linux no debian dd:

dd if=arquivo.iso of=/dev/sd(do seu pendrive) bs=8M status=progress 
&& sleep 3 && sydd if=arquivo.iso of=/dev/sd(do seup pendriver) bs=8M status=progress && sleep 3 && sync
19:39
 
nc -t s

dd if=debian-11.0.0-amd64-netinst.iso of=/dev/sde bs=4M; sync
----------------------------------------------
Listar pacotes removidos que nao foram purgados
dpkg -l | grep ^rc
------------------------
 
Listar pacotes instalados:
dpkg -l
dpkg -l | grep ????
--------------------------------------------------------------------
 
Minha instalação do grub é BIOS OU UEFI ?
 
[ -d /sys/firmware/efi/efivars ] && echo UEFI || echo BIOS
------------------------------------------------
Verificar pacotes que não são do debian
apt list '~i!~Odebian'
alias lnd="apt list '~i!~Odebian'"
------------------------------------------------
Fazer pendrive boot debian
dd if=arquivo.iso of=/dev/sd(do seu pendriver) bs=8M status=progress && sleep 3 && sync
------------------------------------------------
Instalar debian paralelo:
sudo apt install debootstrap
debootstrap bullseye /debian (diretorio que será instalado) http://deb.debian.org/debian

grml-debootstrap (Esse tem mais ferramentas - ssh, etc...)

Instalar kernel:
apt install linux-image-amd64
-------------------------------------------------
Testar HD
sudo apt install smartmontools
sudo smartctl -t short /dev/sda
sudo smartctl -l selftest /dev/sda
Fonte: https://www.bfnetworks.com.br/smartmon-verificando-saude-hd-linux/
-----------------------------------------------------------------------------
Comando Verificar hardware placa de video Linux
lspci -nnkd::0300
lspci -nn
-----------------------------------------------------------------------------
Entrada fail back ou fallback grub somente nas UEFI EFI
grub-install /dev/nvme0n1 --removable
cria uma entrada extra em caso de pane no grub
------------------------------------------------------------------------------
ssh
apt install ssh 
Já instala o server e o client
------------------------------------------------------------------------------
Listar pacotes que estão instalados aqui e não são da origem debian
apt list ‘~i!~Odebian’
--------------------------------------------
gerador de fstab
apt install arch-install-scripts

genfstab -U /

arch-chroot /debian/
--------------------------------------------------
Lab #30 - LAb GNU ao vivo
apt clean
dpkg -l | grep texlive
dpkg -l | awk ‘/texlive/ {print $2}’
apt purge $(dpkg -l | awk ‘/texlive/ {print $2}’)
 ----------------------------------------------------------------
Arquitetura 32 ou 64 
dpkg --print-architecture
dpkg --print-foreign-architectures
----------------------------------------------------------------------------------
Problemas apt-get
apt purge $(<remover)
 
--------------------------------------------------------------------------------------------------
Quando queremos saber todos os repositorios que temos configurados apt
apt policy
--------------------------------------------------------------------------
historico notebook lg wifi rede
apt install firmware-linux
apt install firmware-realtek

1  ls -ltr
    2  cd Downloads
    3  ls -ltr
    4  sudo unzip TL-*
    5  su -
    6  sudo aot update
    7  reset
    8  sudo apt update
    9  exit
   10  sudo apt update
   11  exit
   12  su -
   13  exit
   14  sudo apt update
   15  exit
   16  sudo apt update
   17  cd Downloads
   18  ls -ltr
   19  unzip TL-
   20  unzip TL-*
   21  ls -ltr
   22  cd TL-WN723N_V3_150909
   23  ls
   24  cd Driver
   25  ls
   26  ls -ltr
   27  vi Driver
   28  ls -ltr
   29  sudo ./Driver
   30  ls -ltr
   31  sudo make
   32  sudo make install Driver
   33  sudo apt install gcc
   34  cat /proc/version
   35  sudo apt-get install git linux-headers-generic build-essential dkms
   36  sudo vi /etc/apt/sources.list
   37  sudo apt install vim
   38  sudo vi /etc/apt/sources.list
   39  sudo apt update
   40  sudo apt-get install git linux-headers-generic build-essential dkms
   41  git clone https://github.com/pvaret/rtl8192cu-fixes.git
   42  sudo apt install github
   43  cd ..
   44  ls -ltr
   45  sudo dpkg -i goog*
   46  sudo apt install rtl8192cu
   47  sudo apt install dkms
   48  sudo apt install dkm
   49  sudo apt install wicd
   50  sudo apt install rtlwifi
   51  sudo add-apt-repository ppa:linuxmint-tr/wireless-ppa
   52  git clone https://github.com/pvaret/rtl8192cu-fixes.git
   53  sudo apt install git
   54  git clone https://github.com/pvaret/rtl8192cu-fixes.git
   55  sudo dkms add ./rtl8192cu-fixes
   56  sudo dkms install 8192cu/1.11
   57  sudo depmod -a
   58  sudo cp ./rtl8192cu-fixes/blacklist-native-rtl8192.conf /etc/modprobe.d/
   59  sudo dkms add ./rtl8192cu
   60  sudo dkms install 8192cu
   61  CODE: SELECT ALL
   62  apt install rfkill
   63  sudo apt install rfkill
   64  rfkill list
   65  sudo rfkill list
   66  ls -ltr
   67  sudo dpkg -i firmw*
   68  gksudo gedit /usr/share/applications/gstreamer-properties.desktop
   69  lsusb
   70  lsusb | grep Camera
   71  sudo apt update
   72  sudo apt upgrade
   73  sudo apt install vim
   74  sudo vi /etc/apt/sources.list
   75  sudo apt install firmware-linux
   76  çs
   77  ls
   78  ip a
   79  exit
   80  ssh ti@138.219.214.197
   81  ssh ti@138.219.197.214
   82  ls
   83  sudo apt install samba
   84  ls -ltr
   85  sudo apt update
   86  ssh ti@138.219.197.214
   87  sudo apt update
   88  ip a
   89  reset
   90  ip a
   91  ssh ti@138.219.197.214
   92  ls -ltr
   93  exit
   94  sudo apt upgrade
   95  sudo apt update
   96  sudo apt install fdupes
   97  sudo apt install rsync
   98  sudo apt install samba
   99  sudo apt install cips-utils
  100  ssh ti@138.219.197.214
  101  sudo apt install cifs-utils
  102  ssh ti@138.219.197.214
  103  tree
  104  sudo apt install tree
  105  tree
  106  df /
  107  mkdir /backup
  108  sudo mkdir /backup
  109  sudo chmod 770 /backup
  110  sudo chown ti:ti /backup
  111  sudo apt install samba
  112  sudo smbpasswd -a ti
  113  sudo systemctl restart smdb
  114  sudo systemctl restart smbd
  115  man rsync
  116  sudo apt install tmux
  117  tmux
  118  gpg --keyserver-options auto-key-retrieve --verify archlinux-version-x86_64.iso.sig
  119  rfkill list
  120  sudo apt install rfkill
  121  rfkill
  122  sudp rfkill list
  123  sudo rfkill list
  124  ls -la
  125  ls -la .history
  126  ls /etc
  127  ls /etc/bashrc
  128  cd ./bashrc
  129  cd /.bashrc
  130  vi /.bashrc
  131  vi .bashrc
  132  history >> historico.txt
 
 
 
Contar ou achar arquivos por extensão:
ls -l /mnt/barra/fundamental2/*.jpg | wc -l
wc -l /fariabrito/barra/fundamental2/*.jpg
 
cifs
apt install cifs-utils
 
Pastas com espaço e acentuadas fstab montar 
Pasta com espaço, o espaço é representado pelo código “/040”
Pasta “fundamental 1”
//192.168.0.48/fundamental\0401 /mnt/barra/fundamental1 cifs credentials=/.smbcredentials,x-systemd.automount 1 1
Pasta “educ inf”
//192.168.0.48/educ\040inf /mnt/barra/infantil cifs credentials=/.smbcredentials,iocharset=utf8,x-systemd.automount 1 1
#montar pasta personal servidor barra
Nome de pasta acentuada: Usar o código: iocharset=utf8
Pasta “nutrição”
//192.168.0.48/nutrição /mnt/barra/nutricao cifs credentials=/.smbcredentials,iocharset=utf8,x-systemd.automount 1 1
----------------------------------------------------------------------------------------------------------
apt sources list problema recuperar
/usr/share/doc/apt/examples/sources.list
 
IP alternativo
apt install net-tools
alias linux rede
atribuir ip de outra classe a mesma interface de rede:

ifconfig ens3:1 192.168.15.2 (ip que você queira)
ifconfig ens3:1 down (desligar)

------------------------------------------------------------------------------------------------------------------------------------- 
Quando se tenta utilizar o Thunar (que é o gerenciador de arquivos nativo do XFCE) para navegar numa rede windows via protocolo “smb://”, no primeiro momento não se tem sucesso. Quando se clica em “Procurar rede”, recebe-se a seguinte mensagem de erro:
 
Failed to open "/ on".
Operation not supported.

Para habilitar os protocolos FTP e SMB através do aplicativo Thunar, experimentei duas formas:
rede thunar smb://
 
a) Através dos pacotes “fusesmb” e “gvfs-backends”
Estes pacotes devem ser instalados. Consequentemente, o Thunar passará a abrir endereços “ftp://” e “smb://” normalmente. Para instalá-los:
 
# apt-get install fusesmb gvfs-backends
---------------------------------------------------------------------------------------------
Identificando arquivos duplicados no Linux

1- Opção por linha de comando
O fdupes já esta nos repositórios, de forma que a sua instalação é muito simples:
sudo apt-get install fdupes   ( e forneça a sua senha quando solicitado).

Vamos considerar que iremos procurar os arquivos duplicados a partir do nosso diretório home:

1- Listando os arquivos duplicados no console:
fdupes -r ~   Este comando irá mostrar no console a lista de arquivos duplicados.  o “~”  corresponde ao diretório home. Substitua  pelo diretório que você deseja verificar. O parâmetro “-r” faz com que o fdupes procure em todos os subdiretórios dentro do diretório inicial.

Quando o programa retornar você irá observar que muitos arquivos foram identificados na lixeira. É uma ótima hora de você apagar a lixeira antes de continuar
Bem, listar pode ser interessante para você ver o tamanho do problema, mas  se tivermos esta lista em um arquivo, vai ser bem melhor. Você poderá visualizar a 
lista com qualquer editor de textos.

2- Enviando a lista de arquivos  duplicados para um arquivo texto.
fdupes -r  ~ |   tee  listaDuplicados.txt  obs: o arquivo será criado no diretório corrente

3-  Que tal apagar todos os arquivos duplicados?
fdupes -rd  ~ (substitua “~” pelo diretório que você deseja atuar).
Atenção. O programa irá te perguntar sobre o arquivo que você deseja manter. Use com cuidado.

4- Na listagem  abaixo mostramos as opções  do fdupes
-r    	–recurse   	para procurar dentro dos subdiretórios
-s  -symlinks        segue os links simbólicos
  -H –hardlinks   	quando dois ou mais arquivos apontam para a msa área de disco, eles são tratados como não duplicados. Esta opção altera este comportamento.
-n –noempty    	 exclui arquivos de comprimento zero do processamento
-A –nohidden   	 exclui arquivos escondidos do processamento
-f –omitfirst  	 omite o primeiro arquivo de cada conjunto de iguais.
-1 –sameline   	 lista cada conjunto de iguais numa única linha
-S –size   	 	mostra o tamanho dos arquivos duplicados
-m –summarize  	 sumariza a informação do fdupe
-q –quiet  	 	esconde o indicador de progresso
-d –delete 	 	pergunta ao usuário se quer manter ou apagar  os arquivos iguais. Veja no man os problema de uso desta opção juntamente com a opção -s ou –symliks.
-N –noprompt    	juntamente com o –delete, preserva o primeiro arquivo no conjunto de duplicados  e apaga o resto, sem perguntar ao usuário.
-v –version     	mostra a versão do fdupes
-h –help   	 	mostra a ajuda (em inglês)
--------------------------------------------------------------------------------------------------------------------

 
UTILIZANDO O FIND PARA EXCLUIR DETERMINADOS ARQUIVOS
Para excluir arquivos com um determinado nome ou extensão a partir de um diretório recursivamente, utilize o comando:
 
# find /teste -name '*.log' -exec rm {} \;
 
Feito isso todos os arquivos com extensão .log a partir do diretório teste serão excluídos.
 
A dica serve também para nome de arquivos, basta utilizar metacaracteres.
 
Até a próxima dica.


pasta acentuada acentos rede acento
//192.168.0.48/nutrição /mnt/nutricao cifs credentials=/home/ti/.smbcredentials,iocharset=utf8,x-systemd.automount 1  1
 
 


criar pendrive boot debian
sudo dd if=debian-10.9.0-amd64-netinst.iso of=/dev/sdb1 status=progress && sync



Resetar configurações de painel do Xfce
Dica testada no Fedora 29 Xfce Spin.
 
Após "bagunçar" seu ambiente Xfce, mudando o painel de todo jeito e todo lugar, adicionando e removendo coisas... talvez fique estranho e você queira voltar ao padrão.
 
Para isso execute:
 
 xfce4-panel --quit
$ pkill xfconfd
$ rm -rf ~/.config/xfce4/panel
$ rm -rf ~/.config/xfce4/xfconf/xfce-perchannel-xml/xfce4-panel.xml
$ xfce4-panel
Instalar ssh windows 10
Botão direito mouse iniciar -> Configurações -> Aplicativos -> Aplicativos e Recursos
-> Recursos Opcionais -> Adicionar um Recurso -> Pesquisar: Servidor OpenSSH e Cliente OpenSSH

Installing OpenSSH Server on Windows 10
Leave a reply
So in yesterday’s post we learned that the OpenSSH client is included with the Windows 10, Update 1803!  Guess, what else is included in this server, an OpenSSH Server! Yes, that’s right…you can now run an OpenSSH server on your Windows 10 system and get a remote terminal! So in this post, let’s check out what we need to do to get OpenSSH Server up and running.
First, we’ll need to ensure we update the system to Windows 10, Update 1803. Do that using your normal update mechanisms.
With that installed, let’s check out the new Windows Capabilities (Features) available in this Update, we can use PowerShell to search through them.
PS C:\> Get-WindowsCapability -Online | Where-Object -Property Name -Like "OpenSSH*"

Name : OpenSSH.Client~~~~0.0.1.0
State : Installed

Name : OpenSSH.Server~~~~0.0.1.0
State : NotPresent
Now to install OpenSSH server, we can use the Add-WindowsCapability cmdlet
PS C:\WINDOWS\system32> Add-WindowsCapability -Online -Name  OpenSSH.Server~~~~0.0.1.0
To confirm it’s installation we can use the Get-WindowsCapability cmdlet again, and this time it’s state is “Installed”
PS C:\WINDOWS\system32> Get-WindowsCapability -Online | Where-Object -Property Name -Like "OpenSSH.Server*"

Name  : OpenSSH.Server~~~~0.0.1.0
State : Installed

With that installed, let’s take a look at where sshd lives on our Windows system and that’s in C:\Windows\System32\OpenSSH\
PS C:\> Get-ChildItem C:\Windows\System32\OpenSSH\

Directory: C:\Windows\System32\OpenSSH

Mode LastWriteTime Length Name
---- ------------- ------ ----
-a---- 3/10/2018 12:20 PM 343552 scp.exe
-a---- 3/10/2018 8:20  PM 355840 sftp-server.exe
-a---- 3/10/2018 12:20 PM 408064 sftp.exe
-a---- 3/10/2018 12:20 PM 531968 ssh-add.exe
-a---- 3/10/2018 12:20 PM 495616 ssh-agent.exe
-a---- 3/10/2018 12:20 PM 657920 ssh-keygen.exe
-a---- 3/10/2018 12:20 PM 594944 ssh-keyscan.exe
-a---- 3/10/2018 8:20  PM 154624 ssh-shellhost.exe
-a---- 3/10/2018 12:20 PM 894464 ssh.exe
-a---- 3/10/2018 8:20  PM 970752 sshd.exe
-a---- 1/30/2018 7:55  PM 2143   sshd_config_default
On Windows systems, network daemons run as “Services”. We can see with the Get-Service cmdlet, the installer added ssd and also ssh-agent!
PS C:\Users\aen> Get-Service -Name *ssh*

Status   Name               DisplayName
------   ----               -----------
Stopped  ssh-agent          OpenSSH Authentication Agent
Stopped  sshd               OpenSSH SSH Server
As you can see the state is stopped, so let’s start the Services and also set them to start on boot
PS C:\WINDOWS\system32> Get-Service -Name *ssh* | Set-Service -StartupType Automatic
PS C:\WINDOWS\system32> Get-Service -Name *ssh* | Start-Service
We can use netstat to see if we’re up and running
PS C:\WINDOWS\system32> netstat -bano | more

Active Connections

  Proto  Local Address          Foreign Address        State           PID
  TCP    0.0.0.0:22             0.0.0.0:0              LISTENING       12764
 [sshd.exe]
So now that it’s up and running, you should know that the configuration files and host keys live in ProgramData\ssh\ so if you need to change the behavior of SSH you’ll head for the sshd_config file and when finished, restart your service with Restart-Service -Name sshd 
PS C:\Users\aen> Get-ChildItem -Path 'C:\ProgramData\ssh\'

    Directory: C:\ProgramData\ssh

Mode                LastWriteTime         Length Name
----                -------------         ------ ----
d-----        5/17/2018   8:35 AM                logs
-a----        5/17/2018   8:35 AM              7 sshd.pid
-a----        1/30/2018   4:55 PM           2143 sshd_config
-a----        5/17/2018   8:35 AM            668 ssh_host_dsa_key
-a----        5/17/2018   8:35 AM            613 ssh_host_dsa_key.pub
-a----        5/17/2018   8:35 AM            227 ssh_host_ecdsa_key
-a----        5/17/2018   8:35 AM            185 ssh_host_ecdsa_key.pub
-a----        5/17/2018   8:35 AM            419 ssh_host_ed25519_key
-a----        5/17/2018   8:35 AM            105 ssh_host_ed25519_key.pub
-a----        5/17/2018   8:35 AM           1675 ssh_host_rsa_key
-a----        5/17/2018   8:35 AM            405 ssh_host_rsa_key.pub
You’ll likely need to open your Windows firewall, which can be done with the following cmdlet on PowerShell 5.1
New-NetFirewallRule -Name sshd -DisplayName 'OpenSSH Server (sshd)' -Enabled True -Direction Inbound -Protocol TCP -Action Allow -LocalPort 22

So let’s test it out, I’m going to ssh from my Mac into my Windows 10 laptop
My-MacBook-Pro:~ aen$ ssh demo@192.168.0.111
The authenticity of host '192.168.0.111 (192.168.0.111)' can't be established.
ECDSA key fingerprint is SHA256:eQti/VKAXhTgbLGTqD3n/QOxcPvfdIT6rwuIK+8F5Vs.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.0.111' (ECDSA) to the list of known hosts.
demo@192.168.0.111's password:

Microsoft Windows [Version 10.0.17134.48]
(c) 2018 Microsoft Corporation. All rights reserved.

demo@W10LAPPY C:\Users\demo>

And that’s it, you can now install OpenSSH server on your Windows 10 system. I can only imagine it’s a matter of time before this hits the server side of things! Bravo PowerShell Team, bravo!
------------------------------------------------------------------------------------------------------------------
compartilhamento nfs 

Compartilhar arquivos entre Linux com o NFS

   00 Cliente Servidor Nfs
   3/5 - (1 vote)

   Nesse tutorial, veja como compartilhar arquivos entre linux com o NFS (Network File System) que é um
   protocolo (serviço de rede) que permite acesso remoto a um sistema de arquivos através da rede. Todos
   os sistemas Unix podem trabalhar com esse protocolo, mas quando os sistemas Windows estão envolvidos,
   o protocolo SMB (Samba, também conhecido como “CIFS”) tem que ser usado. O cliente NFS tem por
   finalidade tornar o acesso remoto transparente para o usuário do computador. Assim, esta interface
   cliente e servidor, executada pelo NFS através dos protocolos Cliente-Servidor, fica bem definida
   quando o usuário, ao chamar um arquivo/diretório no servidor, lhe parece estar acessando localmente,
   sendo que está trabalhando com arquivos remotamente. No nosso tutorial, executaremos o
   compartilhamento entre 2 sistemas Debian.

Compartilhar arquivos entre Linux com o NFS

   Nota: todos os comandos deverão ser executados com privilégio de root.

Máquina Cliente-Servidor

   O servidor NFS  é atualmente recomendado para uso com o Linux, contendo recursos como NFSv3 e NFSv4,
   suporte Kerberos via GSS, e muito mais. Ele é também significativamente mais rápido e usualmente mais
   confiável do que os servidores NFS em espaço de usuário (dos pacotes unfs3 e nfs-user-server).
   Entretanto, ele é mais difícil de depurar do que os servidores em espaço de usuário, e tem um
   conjunto de recursos ligeiramente diferente.

   Vamos instalar o cliente-servidor (nfs-kernel-server) na máquina onde será o servidor. Assim, pode-se
   também instalar tanto o Cliente-servidor como o Cliente em ambas as máquinas para que assim possam
   ter acessos entre elas. Para isto, basta fazer as devidas configurações nas máquinas, tanto cliente
   como servidor.

Comando:

apt-get install nfs-kernel-server

   Assim, após a instalação do cliente-servidor (nfs-kernel-server), vamos no arquivo exports adicionar
   a entrada do cliente. É preciso dar as devidas permissões para o compartilhamento.

   Então, abra o arquivo exports que fica dentro do diretório /etc com o editor de texto de sua
   preferência. No nosso caso, vamos executar o editor de texto nano no terminal.

Comando:

nano /etc/exports

   O arquivo exports para configuração do servidor NFS lista os diretórios que estão disponíveis através
   da rede (exported). Assim, para cada compartilhamento NFS, apenas uma determinada lista de máquinas
   tem acesso permitido. Portanto, um controle mais refinado de acesso pode ser obtido com algumas
   opções.

   Agora, vamos adicionar a linha abaixo dentro do arquivo exports.
/media/mcnd2/Backup_GPT_1TB_NTFS/ 192.168.0.145(rw,async,no_subtree_check)

   A identificação da sintaxe da linha acima:
     * /media/mcnd2/Backup_GPT-1TB_NTFS/ ? Diretório que será compartilhado pelo servidor;
     * 192.168.0.145 ? IP da máquina cliente com qual o servidor será compartilhado; e
     * (rw,async,no_subtree_check) ? Opções que o diretório compartilhado terá.

   Então, para algumas opções para o compartilhamento temos:
     * ro ? exporta sistema de arquivos como read-only (somente leitura);
     * rw ? exporta sistema de arquivos como read-write (leitura e escrita);
     * secure ? usa um protocolo mais seguro para transações NFS;
     * soft ? retorna um erro se o servidor não responder;
     * hard ? tenta montar ate que o servidor responda;
     * no_subtree_check ? desabilita a verificação da sub-árvore assim pode aumentar a taxa de
       transferência;
     * sync ? o servidor apenas responde a uma consulta NFS quando a operação de disco corrente é
       concluída, isso pode ser desabilitado com a opção async. Assim, a escrita assíncrona aumenta um
       pouco a performance, mas ela diminui a confiança já que existe o risco de perda de dados no caso
       do servidor falhar entre comunicar a escrita e realmente escrever no disco;
     * root_squash ? para que não seja dado acesso de root no sistema de arquivos a nenhum cliente NFS,
       todas as consultas que parecem vir do usuário root são consideradas pelo servidor como vindo do
       usuário nobody. A opção no_root_squash, desabilita esse comportamento, é arriscada e só deverá
       ser usado em ambientes controlados.

   Para saber mais opções, veja o manual do NFS com o comando man nfs.

   Depois de termos editado o arquivo exports, vamos reiniciar o servidor NFS.

Comando:

service nfs-kernel-server restart


   Logo em seguida, exportamos todo os sistemas de arquivos listados no arquivo exports.

Comando:

exportfs -a

Máquina Cliente

   Na máquina cliente onde queremos acessar o servidor, vamos instalar o Cliente (nfs-commom).

Comando:

apt-get install nfs-common

   Após a instalação do cliente (nfs-common), vamos criar o diretório Backup_desk com o comando mkdir
   seguido do caminho absoluto onde será montado o compartilhamento, no nosso caso /media/Backup_desk.

Comando:

mkdir /media/Backup_desk

   Em seguida vamos verificar se o compartilhamento está sendo executado corretamente.

Comando:

mount -t nfs 192.168.0.185:/media/mcnd2/Backup_GPT_1TB_NTFS/ /media/Backup_desk

   Caso o compartilhamento NFS não esteja sendo montando, veja o que retorna ao tentar iniciar o serviço
   nfs-common.

Comando:

systemctl start nfs-common.service

Saída do comando:

Failed to start nfs-common.service: Unit nfs-common.service is masked.

   Se caso retornar que o serviço está mascarado, vamos seguir as etapas abaixo para resolvermos esse
   problema.

   Verificar o serviço nfs-common.

Comando:

systemctl enable nfs-common

Saída do comando:

Synchronizing state of nfs-common.service with SysV service script with /lib/systemd/systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable nfs-common
Failed to enable unit: Unit file /lib/systemd/system/nfs-common.service is masked.

   Verificar o caminho listado.

Comando:

file /lib/systemd/system/nfs-common.service

Saída do comando:

/lib/systemd/system/nfs-common.service: symbolic link to /dev/null

   A saída do comando retornou que o arquivo da unidade tem um link simbólico para /dev/null.
     *
     *

   Desmascarar o serviço nfs-common removendo o arquivo.

Comando:

rm /lib/systemd/system/nfs-common.service

   Recarregar o daemon.

Comando:

systemctl daemon-reload

   Verificar o status do serviço nfs-common.

Comando:

systemctl status nfs-common

Saída do comando:

? nfs-common.service - LSB: NFS support files common to client and server
    Loaded: loaded (/etc/init.d/nfs-common; generated; vendor preset: enabled)
    Active: inactive (dead)
      Docs: man:systemd-sysv-generator(8)

   Iniciar o serviço nfs-common e verificar novamente o status.

Comando:

systemctl start nfs-common
systemctl status nfs-common

Saída do comando:

? nfs-common.service - LSB: NFS support files common to client and server
    Loaded: loaded (/etc/init.d/nfs-common; generated)
    Active: active (running) since Sun 2018-04-29 22:57:03 -03; 4s ago
      Docs: man:systemd-sysv-generator(8)
   Process: 8911 ExecStart=/etc/init.d/nfs-common start (code=exited, status=0/SUCCESS)
     Tasks: 2 (limit: 4915)    CGroup: /system.slice/nfs-common.service
            ??8918 /sbin/rpc.statd
            ??8937 /usr/sbin/rpc.idmapd

   Então, verificar se o serviço foi desmascarado e iniciado, lembrando que deverá ativar o serviço na
   inicialização.

Comando:

systemctl is-enabled nfs-common

Saída do comando:

nfs-common.service is not a native service, redirecting to systemd-sysv-install.
Executing: /lib/systemd/systemd-sysv-install enable nfs-common
enabled

Iniciando o compartilhamento

   Então, após termos desmascarado o serviço nfs-common, vamos iniciar o compartilhamento entre as
   máquinas e verificar se problema foi resolvido.

   Listamos os arquivos no diretório onde será montado o compartilhamento.

Comando:

ls -l /media/Backup_desk/

Saída do comando:

total 0

   Assim, vemos que não temos nenhum arquivo dentro do diretório.

   Agora, montamos o compartilhamento.

Comando:

mount -t nfs 192.168.0.185:/media/Backup_GPT_1TB_NTFS/ /media/Backup_desk

   Se o retorno do comando voltar para o cursor a espera de um novo comando é porque o compartilhamento
   iniciou sem problema.

   Então, listamos novamente os arquivos dentro do diretório /media/Backup_desk que está sendo
   compartilhado o diretório do servidor /media/Backup_GPT_1TB_NTFS/.

Comando:

ls -l /media/Backup_desk/

Saída do comando:

total 2848
drwxrwxrwx 1 root root 4096 abr 29 15:00 Autoria
drwxrwxrwx 1 root root 4096 fev 10 01:09 Backup_Geral
drwxrwxrwx 1 root root 432 abr 30 01:10 cliente1_Debian
-rwxrwxrwx 1 root root 118617 fev 4 20:24 Corrigindo problema de rede no openSUSE.pdf
-rwxrwxrwx 1 root root 186296 fev 6 22:41 Guia_de_pós-instalação_do_openSUSE_Leap_42.3.pdf
-rwxrwxrwx 2 root root 604863 nov 20 11:24 Iniciar a numeração de página depois no documento.pdf
-rwxrwxrwx 1 root root 30096 fev 6 22:04 Install_snapd_on_openSUSE.pdf
-rwxrwxrwx 2 root root 456902 jun 29 2017 Nota_Compra_Peças_Desktop.pdf
-rwxrwxrwx 2 root root 416551 jan 30 19:40 Notas_Fiscais_HD_PLACA_DE_VIDEO_CONTROLE_COOLER.pdf
-rwxrwxrwx 2 root root 78087 mar 30 21:55 Recibo do Jogo Spec Ops - The Line.pdf
-rwxrwxrwx 2 root root 74923 set 8 2017 Recibo do jogo The Walking Dead.pdf
-rwxrwxrwx 2 root root 920180 set 2 2014 RemoverVirusQueTransformaPastasEmAtalhos.pdf
drwxrwxrwx 1 root root 4096 abr 29 23:59 servidor_Debian

Comando:

ls /media/Backup_desk/

Saída do comando:

Autoria/
Backup_Geral/
cliente1_Debian/
Corrigindo problema de rede no openSUSE.pdf Guia_de_pós-instalação_do_openSUSE_Leap_42.3.pdf
Iniciar a numeração de página depois no documento.pdf
Install_snapd_on_openSUSE.pdf
Nota_Compra_Peças_Desktop.pdf
Notas_Fiscais_HD_PLACA_DE_VIDEO_CONTROLE_COOLER.pdf
Recibo do Jogo Spec Ops - The Line.pdf
Recibo do jogo The Walking Dead.pdf RemoverVirusQueTransformaPastasEmAtalhos.pdf
servidor_Debian/

   Então, se houver necessidade de montar o compartilhamento frequentemente, basta adicionar a linha
   abaixo no arquivo fstab dentro de /etc.
192.168.0.185:/media/Backup_GPT_1TB_NTFS /media/Backup_desk nfs auto,exec 0 0

   A identificação da sintaxe da linha acima:
     * 192.168.0.185:/media/Backup_GPT_1TB_NTFS  ?  endereço do servidor NFS;
     * /media/Backup_desk ?  diretório local do cliente;
     * nfs  ?  especifica o sistema de arquivo;
     * auto  ?  o compartilhamento é montando durante o boot do sistema;
     * exec  ?  permite executar programas dentro do diretório compartilhado.

   Assim, nas imagens abaixo, vemos primeiro o desktop Servidor e depois o notebook Cliente.
   Debian - servidor desktop

   Debian – servidor desktop
   Debian - cliente notebook

   Debian – cliente notebook
   Debian - cliente notebook

   Debian – cliente notebook

   Então, ficamos por aqui e esperamos que esse tutorial seja um guia para que você consiga compartilhar
   arquivos entre sistemas GNU/Linux.
   
mount -t nfs 192.168.15.57:/home/ti/Downloads/filmes /mnt/filmes

------------------------------------------------------------------
atualiza windows 7

O windows update não pode procurar atualizacoes

https://www.youtube.com/watch?v=G45RtfUkEGQ

windows update nao funciona nao atualiza mais 

net stop WuAuServ

procurar na pasta windows:
pasta software distribuition
renomear essa pasta para SD.OLD

net start WuAuServ

Como corrigir o erro 80072EFE no Windows Update windows 7:
Instalar service pack sp1

Acessar: https://www.catalog.update.microsoft.com/Home.aspx
Baixar: KB3138612 e instalar.
--------------------------------------------------- 
Instalar nfs servidor e cliente

servidor:
sudo apt install nfs-kernel-server
cliente:
sudo apt install nfs-common

cliente:
sudo vi /etc/fstab

192.168.15.57:/mnt/shared /mnt/shared nfs4 rw,nosuid 0 0
192.168.15.57:/home/ti/Downloads/filmes /mnt/filmes nfs4 rw,nosuid 0 0

servidor 192.168.15.57:
sudo vi /etc/exports

/home/ti/Downloads/filmes 192.168.15.14(rw,sync,no_subtree_check)
ou
/home/ti/Downloads/filmes *(rw,sync,no_subtree_check)





Area de trabalho remota windows
mstsc
 
Escanear rede linux - excelente comando
sudo apt install arp-scan
sudo arp-scan --localnet



Não Consegue Instalar a Versão Pro Do Windows 10 Apenas a Versão Home? Solução Aqui
https://www.youtube.com/watch?v=sul8sKpYtJY&list=PLpe8AVNfBzALID6WHtjlkazayPsFqBS8w&index=9&t=2s

Esse caso é muito técnico, pois envolve como originou seu PC com Windows. Exemplo; você comprou um notebook e o mesmo (original, visto que ele está ativado) veio com Windows 10 Home Single Language, tecnicamente o serial (key) de forma digital vai estar gravada na sua BIOS, também é possível (talvez) ter acesso a essa chave pela nota fiscal. Agora em algum momento no futuro você tentar instalar a versão Pro, (logo a tela onde mostra as versões não é mostrada) e quando termina a instalação você nota que a versão ainda é a Home Single Language.
A reposta está bem obvia né? O Windows consultou a BIOS para ver qual serial está liberado e viu que a versão Home Single Language pode ser instalada. Mais ainda não terminamos por aqui. Dentro da ISO ou imagem do Windows que você está usando para formatar o computador pode ter uma solução (jeitinho brasileiro) acesse as pastas da ISO/DVD e faça uma pesquisa com esse termo (arquivo) “EI.CFG” sem aspas. Supostamente você não vai encontrar, esse arquivo tem a função de burlar essa comunicação entre a instalação e sua BIOS, liberando as versões para uso. Nota; as ISOs baixada por canais Microsoft não possuem esse arquivo, nesse caso você vai ter que adicionar manualmente. Vejo vídeo abaixo para ver como adicionar manualmente, antes baixe o arquivo do link abaixo.
Links
https://sayrodigital.com/instalacoes/...
https://sayrodigital.com/download/dis...
Não consigo instalar a versão Pro, apenas a Home!
Esse caso é muito técnico, pois envolve como originou seu PC com Windows. Exemplo; você comprou um notebook e o mesmo (original, visto que ele está ativado) veio com Windows 10 Home Single Language, tecnicamente o serial (key) de forma digital vai estar gravada na sua BIOS, também é possível (talvez) ter acesso a essa chave pela nota fiscal. Agora em algum momento no futuro você tentar instalar a versão Pro, (logo a tela onde mostra as versões não é mostrada) e quando termina a instalação você nota que a versão ainda é a Home Single Language.

A reposta está bem obvia né? O Windows consultou a BIOS para ver qual serial está liberado e viu que a versão Home Single Language pode ser instalada. Mais ainda não terminamos por aqui. Dentro da ISO ou imagem do Windows que você está usando para formatar o computador pode ter uma solução (jeitinho brasileiro) acesse as pastas da ISO/DVD e faça uma pesquisa com esse termo (arquivo) “EI.CFG” sem aspas. Supostamente você não vai encontrar, esse arquivo tem a função de burlar essa comunicação entre a instalação e sua BIOS, liberando as versões para uso. Nota; as ISOs baixada por canais Microsoft não possuem esse arquivo, nesse caso você vai ter que adicionar manualmente. Vejo vídeo abaixo para ver como adicionar manualmente, antes baixe o arquivo do link abaixo.
Download G-Drive
 

-------------------------------------------------
Formatar pendrive debian
1- Verificar onde está o pendrive: mount

2- Desmontar o pendrive: umount /dev/sdb1

3- Formatar o pendrive: mkfs.fat /dev/sdb1

Fim
--------------------------------------------------------
espaços em branco pasta rede
Substitua os espaços em branco pelos seus respectivos códigos em ASCII "\040".
mount -t cifs //ip/pasta\040de\040rede/ /mnt/floppy/ -o username=Administrador,password=senha
 
 
//192.168.0.48/nutrição cifs credentials=/home/ti/.smbcredentials,iocharset=utf8,x-systemd.automount 1 1
--------------------------------------------
ip publico
IP PUBLICO TERMINAL LINHA DE COMANDO
curl ifconfig.me
------------------------------------------------ 
Listar usuarios samba
sudo pdbedit -L -v | grep username
------------------------------------------
DESCOBRIR O SISTEMA DE ARQUIVOS EXISTENTE nas partições? [RESOLVIDO]

Foxbit achei ótima essa do :

df -hT

--------------------------------------------------------------
Montar pendrive hdexterno em ntfs
sudo mount -t ntfs-3g /dev/sdc1 /mnt/hdext2
--------------------------------------------------------------
rsync
rsync -avP /mnt/financeiro ti@138.219.197.214:/mnt/hdext2
--------------------------------------------------------------
Achar e copiar
sudo find /mnt/fundamental2bkp -iname "*.avi" -exec cp -vf {} /home/ti/videosfund2 \;

grub rescue

ls
set prefix=(hd,msdos1)/boot/grub
insmod normal
normal

sudo update-grub
sudo grub-install /dev/sda


Python

O operador == é um dos operadores de comparação; outros operadores desse tipo são: 

x != y # x é diferente de y
 
x > y # x é maior do que y 

x < y # x é menor do que y 

x >= y # x é maior ou igual a y 

x <= y # x é menor ou igual a y 

x is y # x é o mesmo que y 

x is not y # x não é o mesmo que y



Amigo se vocÊ vai fazer um compartilhamento entre duas máquinas com Debian, então você faz isso por NFS.

Ex. na maquina que vai ser compartilhado algo você ativa NFS. Antes verifique se ele esta instalado, entra no terminal e digita sudo nfs status.

Se mostrar o status blz, agora se disser que não tem instalado basta você instalar: sudo apt-get nfs-server nfs-utilits.

Agora vc edita o arquivo /etc/exports e adiciona a linha com o diretório que vc quer compartilhar, vamos supor que é o diretório /home/mp3 vai ficar assim /home/mp3 *(rw) (permissão para leitura e escrita) salva e reinicia o serviço do NFS sudo service NFS restart.

Se der tudo certo o diretório vai estar compartilhado, agora falta vc mapear o mesmo na outra máquina.

Mapear:

vi /etc/fstab

192.168.15.40:/mnt/arquivos /mnt/arquivos_deb10_server nfs rw,sync,auto  0. 0

Aqui vai uma dica simples, mas bem útil. Para listar somente os diretórios no Linux, use o comando:

$ ls -al | grep "^d"

Pasta inicializar windows 10:

%AppData%\Microsoft\Windows\Start Menu\Programs\Startup

Varrer rede 
nbtscan

procurando arquivos find
find . | grep "DETRAN"

scp
scp /home/ti/teste.txt ti@192.168.15.39:/home/ti

Transferir pasta inteira -r

Examinar a rede Linux
nbtscan 192.168.0.1/24

Gerar senha ssh
ssh-keygen
ssh-copy-id
deixar senha da chave em branco
--------------------------------------------------------------------------------------------------------------------------------------
Comando du - muito util para verificar tamanho de diretorios e arquivos, essa opção --time também é muito interessante, parece que ela mostra a última vez que o arquivo foi mexido.

du -ha --time /mnt/debrec/repbarra/ | sort -h >> ordenados.txt

du -hsc /mnt/debrec/*

Ferramenta aprimorada do comando du: apt install ncdu
-------------------------------------------------------------------------------------------------------
Instalando o sendEmail
 
sudo apt install sendemail
sudo apt install libnet-ssleay-perl
sudo apt install libio-socket-ssl-perl
sudo apt install lynx

arquivos necessarios:
iplocal.txt
-rw-r--r-- 1 ti ti   529 jun 25 15:15 enviar_loggrumari.sh
-rw-r--r-- 1 ti ti    15 jun 25 15:18 ip.txt
-rw-r--r-- 1 ti ti   889 jun 25 15:18 enviar.txt
-rwxr-xr-x 1 ti ti   922 jun 25 15:21 enviar_ip.sh














Verificar hardware minuciosamente

sudo  

Verificar marca HD
Verificar hardware linha comando
 
apt install lshw
 
sudo lshw -C disk
 
Scanear rede
 
nbtscan 192.168.0.1/24
 
nmap
 
Tamanho pastas: ordenado por tamanho
 
du -ha --time /home/ti/financeiro_scanner | sort -h


formulario1.php:
<form action="action.php" method="post">
 <p>Seu nome: <input type="text" name="name" /></p>
 <p>Sua Idade: <input type="text" name="age" /></p>
 <p>Sua altura: <input type="number" step="0.001" name="alt" /></p> 
 <p><input type="submit" /></p>
</form>

action.php:
Oi <?php echo htmlspecialchars($_POST['name']); ?>.
Você tem <?php echo (int)$_POST['age']; ?> anos de idade.
Você mede <?php echo floatval($_POST['alt']); ?> m.


Linux: compactando e descompactando arquivos com o tar
lucas.felix
lucas.felix
16/05/2017



Formação Certificação LPI Linux Essentials
Se você é usuário Linux, quais tipos de extensão, para arquivos compactados, você costuma lidar? Será que é zip? Provavelmente não. Geralmente, encontramos arquivos com a extensão .tar.gz.

Mas por que .tar.gz? O que isso significa? Quando nos deparamos com arquivos do tipo .tar.gz, significa que dois processos ocorreram. O primeiro é o empacotamento dos arquivos no formato .tar. O segundo processo é a compactação no formato gzip.

O tar apenas une todos os arquivos em um só. Mas o tar não aplica algoritmos de compactação para que o arquivo resultante fique menor. Para isso utilizamos um outro formato, como o gzip.

A vantagem é que o tar consegue manter as permissões dos arquivos, bem como links diretos e simbólicos, sendo interessante por exemplo para realizar backups.

Utilizamos o comando tar para realizar as compactações. A compactação do diretório Projetos/ ficaria da seguinte forma.


$ tar -czf projetos.tar.gz Projetos/

A primera coisa que você deve ter notado é que, diferente do zip, o comando tar não necessita do -r. Ele age de forma recursiva por padrão. O -c é de create, ou seja, para indicar que desejamos criar um arquivo. O -z indica que queremos compactar com gzip. Utilizamos o -f (file), para que o comando crie o arquivo compactado.

Para descompactar, basta utilizar o -x de extract no lugar do -c.


$ tar -xzf projetos.tar.gz

xvzf

O comando tar, ao contrário do zip, é silencioso (quiet) por padrão. Se quisermos que ele imprima os detalhes do que está fazendo, basta utilizar o argumento -v (verbose)**.

Se compararmos os tamanhos do arquivo .zip e do .tar.gz vamos perceber que nesse caso o .tar.gz ficou menor, mas isso não necessariamente irá sempre ocorrer.

Como executar dois ou mais comandos do Linux ao mesmo tempo
Edivaldo Britopor EDIVALDO BRITO
Para o TechTudo
FACEBOOK
TWITTER

Se você usa Linux, provavelmente já sabe o quão útil a linha de comando pode ser para trabalhar com arquivos, instalação de software e execução de programas. Mas o recurso pode ser ainda mais eficiente caso queira executar vários comandos ao mesmo tempo. A combinação de dois ou mais comandos no terminal também é conhecido como “encadeamento de comandos”. Confira, no tutorial abaixo, quatro maneiras de combinar comandos.

Linux no macOS: como instalar XQuartz e rodar programas no Mac OS X

1) O operador ponto e vírgula (;)

O operador ponto e vírgula (;) permite executar vários comandos em sucessão. Para entender melhor, abra uma janela de terminal (no Ubuntu e Linux Mint, pressione as teclas Ctrl + Alt + T).

Em seguida, digite os seguintes três comandos em uma linha, separados por ponto e vírgula, e pressione Enter.

Executando três comandos em sequência no terminal do Linux (Foto: Reprodução/Edivaldo Brito)
Executando três comandos em sequência no terminal do Linux (Foto: Reprodução/Edivaldo Brito)
Essa sequencia lhe dará uma listagem do diretório atual (ls), mostrará qual diretório você está atualmente (pwd), e exibirá seu nome de login (whoami), tudo de uma só vez. Nesse combinação, você não precisa colocar espaços entre as vírgulas e os comandos, pois é possível inserir os três comandos juntos: ls;pwd;whoami.

2) O operador lógico E (&&)

Se você precisa que o segundo comando seja executado depois do primeiro, separe-os com o operador lógico E, que é representado por um duplo e comercial (&&). Por exemplo, se quiser criar um diretório chamado MyFolder e depois “entrar nesta pasta", digite a seguinte sequencia e pressione Enter:

mkdir MyFolder && cd MyFolder

Executando dois comandos com o operador E ( && ) (Foto: Reprodução/Edivaldo Brito)
Executando dois comandos com o operador E ( && ) (Foto: Reprodução/Edivaldo Brito)
Observe que ao executar a sequência, a pasta foi criada com sucesso. Como resultado, percebe-se que, na maioria das vezes, é mais seguro usar o operador lógico E, em vez do operador ponto e vírgula (;), pois isso garante que você não fará nada desastroso.

Download grátis do app do TechTudo: receba dicas e notícias de tecnologia no Android ou iPhone

3) O operador lógico OR (||)

| pipe

Caso precise executar um segundo comando, apenas se o primeiro comando não for executado com sucesso, use o operador lógico OU, que é representado por duas barras verticais (||).

Por exemplo: se quiser verificar se existe uma pasta MyFolder ( [ -d ~/MyFolder ] ) e não existir, basta criá-la usando o comando mkdir ~/MyFolder. Em seguida, digite o seguinte comando no terminal do Linux e pressione Enter:

[ -d ~/MyFolder ] || mkdir ~/MyFolder

Executando dois comandos com o operador OU ( || ) (Foto: Reprodução/Edivaldo Brito)
Executando dois comandos com o operador OU ( || ) (Foto: Reprodução/Edivaldo Brito)
No exemplo, para que tudo funcione corretamente, certifique-se que exista um espaço após o primeiro colchete e antes do segundo. Caso não esteja assim, o primeiro comando que verifica se o diretório existe não irá funcionar. 

Se estiver tudo certo, como o diretório MyFolder não existe, o segundo comando criará o diretório.

4) Combinando vários operadores

Você também pode combinar vários operadores em uma mesma sequência. Por exemplo, para verificar se existe um arquivo ( [ -f ~/exemplo.txt ] ). Se isso acontecer, o sistema irá exibir uma mensagem na tela dizendo confirmando ( echo “Arquivo existe.” ). Se não, um comando criará o arquivo ( touch ~/exemplo.txt ). Então, digite o comando abaixo no prompt de comando e pressione Enter:

[ -f ~/exemplo.txt ] && echo “Arquivo existe.” || touch ~/exemplo.txt

Executando três comandos com operadores diferentes (Foto: Reprodução/Edivaldo Brito)

-----------------------------------------------------------------------------------------------------------------------------------------------------

Agendador tarefas windows 10 - virtual box - iniciar aut sem precisar logar no win10 - mais em anexo tarefa exportada
 
"C:\Program Files\Oracle\VirtualBox\VirtualBoxVM.exe"
argumentos: --startvm "{22e96742-4c54-4cd5-8559-15d2197b8002}" --type headless;
Executar estando o usuario conectado ou não
Executar com privilegios mais altos
Configurar para windows 10
 
-----------------------------------------------------------------------------------------------------------------------------------------------------
						Tópico: Agendamento de desligamento pelo Cron  (Lida 1517 vezes) 					
								 								rafaelss 							
							
Usuário Ubuntu

Mensagens: 2
									
										Agendamento de desligamento pelo Cron 									
									
« Online: 10 de Outubro de 2016, 12:41 »
									 								
							
							
								
Olá galera do pinguim.

Trabalho com Tecnologia da Informação e sempre flertei com o Linux, mas na condição de usuário.
Trabalho em um museu com conteúdos de áudio e vídeo para exposições.
Recentemente, tomei a iniciativa de usar exclusivamente Linux nas exposições temporárias. Adotei a distro Xubuntu, que é uma variação do Ubuntu com xfce como interface gráfica.

Resumindo: Consigo configurar o horário de ligar pela Bios, consigo manter o vnc x11 funcionando na inicialização para que eu tenha acesso remoto as estações, consigo manter o vlc exibindo o conteúdo em loop e tela cheia, porém não consigo usar o cron pra programar os desligamentos.

Atualmente venho fazendo um paliativo com o comando shutdown -h 18:10 porém o adequado seria que as segundas-feiras o equipamento desligasse as 09:20. Segunda é um dia de manutenção e não precisa funcionar a exposição.

Tentei os comandos "crontab -e" e "sudo crontab -e" criando as seguintes linhas:

10 18 * * 0,2-6 shutdown -h 0
20 09 * * 1 shutdown -h 0

Não deu certo.

Tem algum meio de fazer isso funcionar? Onde estou errando?

Conto com a ajuda do pessoal que já trabalha com o Cron pra fazer acontecer

Abraços
							
						
						
							
							
							
								 								Registrado 							
						
					
					 				
				 				 				
					 					
						
							
								 								rafaelss 							
							
Usuário Ubuntu

Mensagens: 2
									

								
						
						
							
								
									
										 									
									
										Re:Agendamento de desligamento pelo Cron 									
									
« Resposta #1 Online: 10 de Outubro de 2016, 15:42 »
									 								
							
							
gerar senhas fortes:								
gpg --gen-random --armor 1 12
------------------------------------
Copiar e colar no nano

Copiar: Shift + clique com o botão direito do mouse
Colar : ctrl+U

Meu metodo:
copiar crtl k e ctrl u
colar ctrl u

---------------------------------------------------

Deixo aqui o meu registro de solução.

Editei o arquivo de agendamento do cron com o comando "sudo crontab -e"
Editei as linhas que eu precisava da seguinte forma:
10 18 * * 0,2-6 /sbin/shutdown -h now
20 09 * * 1 /sbin/shutdown -h now
Salvei o arquivo pressionando "Ctrl + O", confirmando as alterações e finalizei o editor com o comando "Ctrl + X" (Comandos do editor nano)

Não se preocupe com o destino do salvamento, pois o cron coloca mesmo sua edição num arquivo temporário de forma a checar os comandos digitados antes de processar sua alteração.

Confira o conteúdo dos agendamentos com o comando "sudo crontab -l"

Como se trata de uma operação de desligamento achei adequado utilizar o super usuário.

Vi a dica do caminho do shutdown (/sbin/shutdown) no fórum adkubuntu em inglês

Mais uma vez obrigado a todos.
Estou inclinado a ajudar que seja da área cultural e queira mudar parte do seu pátio tecnológico pra Linux.
Sinta-se a vontade para entrar em contato.

Abraços.

Rafael Souza


nmap - varrer rede igual advanced ip scanner
nmap -sP 192.168.10.1/24

nmap -A -v -v 192.168.1.0/24 gives a lot of information, even SO in some cases
nmap -sn 192.168.1.0/24 gives the MAC and IP addresses. Very Useful too
sudo nmap -PU 192.168.1.0/24 explains every IP address


Microfone google chrome
O Meet exibe a mensagem "o som do microfone foi desativado pelas configurações do sistema"

Consegui entrando no "Painel de Controle", em seguida "Hardware e Sons", depois "Alterar sons do sistema", nas barras superiores vai em "Gravação", clica no "Microfone" e depois "Propriedades", E configura o microfone. Tem que deixar ele ativado, quando acessei ele estava com com símbolo do som com um X, depois de ativado só clicar em "OK" e novamente "OK".

incluir usuario no grupo sudo
sudo usermod -aG sudo nomedousuario



cut -c11-15 speedbarra2.high.download.txt > speedbarra2.high.download.num.txt
grep "Download" speedbarra2.high.txt > speedbarra2.high.download.txt
grep "Download" speedbarra2.high.txt
grep -B 2 -A 5 "High" speedbarra2.txt > speedbarra2.high.txt
grep "2020" speedbarra2.txt > speedbarra2.data.hora.txt
cut -c12-16 speedbarra2.high.data.hora.txt > speedbarra2.high.hora.txt
grep "2020" speedbarra2.high.txt > speedbarra2.data.hora.txt
grep "2020" speedbarra2.high.txt > speedbarra2.high.data.hora.txt
cut -c12-16 speedbarra2.high.data.hora.txt > speedbarra2.high.data.txt
cut -c1-10 speedbarra2.high.data.hora.txt > speedbarra2.high.data.txt

Saber a ultima inicializacao linux
who -b 
 
 
 
SUBSTITUINDO PALAVRAS NO EDITOR VI
 
 
Entre em modo de comando teclando [Esc].
 
Use o ":" no começo em seguida %s/TextoAntigo/TextoNovo/g.
 
Exemplo:
 
:%s/dani/Daniela/g



Dica rápida de como descobrir a velocidade de sua placa de rede.

Instale o pacote ethtool:

 sudo apt install ethtool

(ou use o gerenciador de pacotes de sua distribuição caso não seja Debian-like)

E finalmente o comandinho mágico:

 sudo ethtool eth0 | grep Speed

cat /sys/class/net/enp1s0/speed

lshw mostra real verdadeira capacidade placa rede

Lembre-se de substituir "eth0" pela interface de rede desejada.













"Este arquivo veio de outro computador…” - como posso desbloquear todos os arquivos em uma pasta sem precisar desbloqueá-los individualmente?

O PowerShell, disponível aqui , possui um Unblock-Filecmdlet que fará essa tarefa por você. Para desbloquear todos os arquivos em um diretório, você deve emitir o seguinte comando.
dir c:\mydir -Recurse | Unblock-File


Teclas de atalho do Windows Media Player disponíveis em:

 Teclas	 Função
 CTRL+1	Modo tela inteira
 CTRL+2	 modo capa para diminuir o tamanho da janela
 CTRL+M	 mostra ou esconde os menus clássicos quando o player está no modo completo
 CTRL+B	 Item ou capítulo anterior, pode ser de uma lista ou DVD
 CTRL+F	 Próximo item ou capítulo, também de uma lista ou DVD
 CTRL+H	 Ativa ou desativa reprodução em ordem aleatória
 CTRL+N	 Cria uma nova lista de execução dentro da biblioteca
 CTRL+P	 Pausa e recomeça a execução
 CTRL+S	 Para a execução
 CTRL+T	 Ativa ou desativa repetição
 CTRL+SHIFT+B	 Retroceder vídeo
 CTRL+SHIFT+C	 Ativa e desativa legendas
 CTRL+SHIFT+F	 Avança pelo vídeo (também funciona para músicas)
 CTRL+SHIFT+G	 Reproduz o vídeo em velocidade alta
 CTRL+SHIFT+N	 Reproduz o vídeo em velocidade normal
 CTRL+SHIFT+S	  Reproduz o vídeo em velocidade baixa
ALT+1	 Tamanho do vídeo em 50%
 ALT+2	 Tamanho do vídeo original
 ALT+3	 Tamanho do vídeo em 200%
 ALT+ENTER	 Ativa ou desativa a exibição em tela cheia
 F1	 Abre a "Ajuda e suporte"
 F2	 na biblioteca, edita informações sobre um item selecionado, que pode ser o nome de um artista, por exemplo.
 F3	 Também para a biblioteca, adiciona um arquivo de mídia
F4	 Também para a biblioteca, alterna o modo de exibição dos itens
 F5	 Atualiza informações nos painéis
 F6	 Aumenta o tamanho da arte do álbum
 SHIFT+F6	 Diminui o tamanho da arte do álbum
 F7	 Tira o áudio
 F8	 Diminui o volume
 F9	 Aumenta o volume
 F10	 Exibe os menus clássicos
 F11	 Muda para tela inteira
 ALT+SETA PARA A ESQUERDA	 Volta para o último item que você acessou no player.
 ALT+SETA PARA A DIREITA	 Refaz o caminho que você fez percorrendo as suas últimas exibições no player.
 CTRL+E	 Na biblioteca, coloca o cursor do mouse sobre a caixa de pesquisa
 CTRL+J	 Abre a bandeja de CD/DVD (Se somente 1 leitor)
 CTRL+O	 Abrir um arquivo
 CTRL+U	 Abrir uma localização da internet
 CTRL+W	 Fecha ou interrompe a execução de um arquivo

Comandos que o Plugin WMP Keyes permite editar.
https://downloads.sourceforge.net/project/wmpkeys/wmpkeys/1.2.0.0/wmpksetup.msi?r=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fwmpkeys%2Ffiles%2F&ts=1502583701&use_mirror=ufpr
 Teclas	 Função
 CTRL+ALT+HOME	 Tocar e pausar
 CTRL+ALT+SETAS PARA A DIREITA E ESQUERDA	 Próximo item e item anterior
 CTRL+ALT+SETAS PARA CIMA OU PARA BAIXO	 Aumentar e diminuir o volume
 CTRL+ALT+F ou B	 Avançar/voltar
 CTRL+ALT+1 a 5	 
Classificar item em execução

Inventário rede

sudo nmap -sS -O -T3 -oA invent 192.168.0.1/24 
-----------------------------
saber quem é o papa espaço
du -hsc /* | sort -h



